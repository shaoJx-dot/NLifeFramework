<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Stellt das Ergebnis eines Sortiervorgangs dar.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Stellt das Ergebnis eines Sortiervorgangs dar.</summary>
      <typeparam name="T">Der Typ des Inhalts der Datenquelle.Dieser Typparameter ist Covariant. Das heißt, Sie können entweder den angegebenen Typ oder einen weiter abgeleiteten Typ verwenden. Weitere Informationen zu Ko- und Kontravarianz finden Sie unter Kovarianz und Kontravarianz in Generika.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Stellt Funktionen zur Auswertung von Abfragen für eine spezifische Datenquelle bereit, bei der der Datentyp nicht angegeben wurde.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Ruft den Typ der Elemente ab, die zurückgegeben werden, wenn die Ausdrucksbaumstruktur ausgeführt wird, die mit dieser Instanz von <see cref="T:System.Linq.IQueryable" /> verknüpft ist.</summary>
      <returns>Ein <see cref="T:System.Type" />, der den Typ der Elemente darstellt, die zurückgegeben werden, wenn die Ausdrucksbaumstruktur ausgeführt wird, die mit diesem Objekt verknüpft ist.</returns>
    </member>
    <memcer jame="P:System.Linq.IQueryable.Expression">
      suMmary>RUft die Ausdrucksbaumstruktur ab, die mit der 	nstanz von <see crev="T:System.Linq.IQueryable" /> verknüpft ist.<stmmary>
      <retwrns>De <see cref="T:SYsTem.Linq.Expressions.ExprEssion" />- dIe mit dieser Instanz von <see ref="T:Systei.Linq.IQuerqable" /> veknüpft ist.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
  ( 0 <sum-ary>Ruft de~ Abdrageanbieuer ab, der dieser Datenquelle zuwekrdnet il.</summary>
      <returns>Der <see cref="T:System.Linq.IQueryProvider" />, der dieser Datenquelle zugeordnet ist.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Stellt Funktionen zur Auswertung von Abfragen für eine spezifische Datenquelle mit unbekanntem Datentyp bereit.</summary>
      <typeparam name="T">Der Datentyp in der Datenquelle.Dieser Typparameter ist Covariant. Das heißt, Sie können entweder den angegebenen Typ oder einen weiter abgeleiteten Typ verwenden. Weitere Informationen zu Ko- und Kontravarianz finden Sie unter Kovarianz und Kontravarianz in Generika.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Definiert Methoden zum Erstellen und Ausführen von Abfragen, die von einem <see cref="T:System.Linq.IQueryable" />-Objekt beschrieben werden.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Konstruiert ein <see cref="T:System.Linq.IQueryable`1" />-Objekt, das die Abfrage auswerten kann, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.IQueryable`1" />-Objekt, das die Abfrage auswerten kann, die von der angegebenen Ausdrucksbaumstruktur dargestellt wird.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
      <typeparam name="TElement">Der Typ der Elemente des <see cref="T:System.Linq.IQueryable`1" />-Objekts, das zurückgegeben wird.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Konstruiert ein <see cref="T:System.Linq.IQueryable" />-Objekt, das die Abfrage auswerten kann, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.IQueryable" />-Objekt, das die Abfrage auswerten kann, die von der angegebenen Ausdrucksbaumstruktur dargestellt wird.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Führt die stark typisierte Abfrage aus, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Der Wert, der aus der Ausführung der angegebenen Abfrage resultiert.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
      <typeparam name="TResult">Der Typ des Werts, der aus der Ausführung der Abfrage resultiert.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Führt die Abfrage aus, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Der Wert, der aus der Ausführung der angegebenen Abfrage resultiert.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Stellt einen Ausdruck dar, der einen binären Operator aufweist.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Ruft einen Wert ab, der angibt, ob der Knoten der Ausdrucksbaumstruktur reduziert werden kann.</summary>
      <returns>True, wenn der Knoten der Ausdrucksbaumstruktur reduziert werden kann, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Ruft die Typkonvertierungsfunktion ab, die von einer zusammenfügenden oder zusammengesetzten Zuweisungsoperation verwendet wird.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, die eine Typkonvertierungsfunktion darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt.</summary>
      <returns>true, wenn der Knoten einen transformierten Aufruf darstellt, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt, dessen Rückgabetyp zu einem Typ transformiert wird, der NULL-Werte zulässt.</summary>
      <returns>true, wenn der Rückgabetyp des Operators zu einem Typ, der NULL-Werte zulässt, transformiert wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Ruft den linken Operanden der binären Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden der binären Operation darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Ruft die implementierende Methode für die binäre Operation ab.</summary>
      <returns>Ein <see cref="T:System.Reflection.MethodInfo" />, der die auszuführende Methode darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduziert auf den binären Ausdrucksknoten auf einen einfacheren Ausdruck.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Ruft den rechten Operanden der binären Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden der binären Operation darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="left">Die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft des Ergebnisses. </param>
      <param name="conversion">Die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft des Ergebnisses.</param>
      <param name="right">Die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Stellt einen Block mit einer Sequenz von Ausdrücken dar, in dem Variablen definiert werden können.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Ruft die Ausdrücke in diesem Block ab.</summary>
      <returns>Die schreibgeschützte Auflistung, die alle Ausdrücke in diesem Block enthält.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Ruft den letzten Ausdruck in diesem Block ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den letzten Ausdruck in diesem Block darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.BlockExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="variables">Die <see cref="P:System.Linq.Expressions.BlockExpression.Variables" />-Eigenschaft des Ergebnisses. </param>
      <param name="expressions">Die <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Ruft die in diesem Block definierten Variablen ab.</summary>
      <returns>Die schreibgeschützte Auflistung, die alle in diesem Block definierten Variablen enthält.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Stellt eine catch-Anweisung in einem try-Block dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Ruft den Text des catch-Blocks ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Text des catch-Blocks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Ruft den Text des <see cref="T:System.Linq.Expressions.CatchBlock" />-Filters ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Text des <see cref="T:System.Linq.Expressions.CatchBlock" />-Filters darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Ruft den Typ der <see cref="T:System.Exception" /> ab, die von diesem Handler abgefangen wird.</summary>
      <returns>Das <see cref="T:System.Type" />-Objekt, das den Typ der <see cref="T:System.Exception" /> darstellt, die von diesem Handler abgefangen wird.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Gibt einen <see cref="T:System.String" /> zurück, der den aktuellen <see cref="T:System.Object" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.String" />, der den aktuellen <see cref="T:System.Object" /> darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="variable">Die <see cref="P:System.Linq.Expressions.CatchBlock.Variable" />-Eigenschaft des Ergebnisses.</param>
      <param name="filter">Die <see cref="P:System.Linq.Expressions.CatchBlock.Filter" />-Eigenschaft des Ergebnisses.</param>
      <param name="body">Die <see cref="P:System.Linq.Expressions.CatchBlock.Body" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Ruft einen Verweis auf das von diesem Handler abgefangene <see cref="T:System.Exception" />-Objekt ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekt, das einen Verweis auf das von diesem Handler abgefangene <see cref="T:System.Exception" />-Objekt darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Stellt einen Ausdruck dar, der über einen bedingten Operator verfügt.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Ruft den Ausdruck ab, der ausgeführt werden soll, wenn der Test false ergibt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Ausdruck darstellt, der ausgeführt werden soll, wenn der Test false ergibt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Ruft den Ausdruck ab, der ausgeführt werden soll, wenn der Test true ergibt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Ausdruck darstellt, der ausgeführt werden soll, wenn der Test true ergibt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Ruft den Test der bedingten Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Text der bedingten Operation darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="test">Die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft des Ergebnisses.</param>
      <param name="ifTrue">Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft des Ergebnisses.</param>
      <param name="ifFalse">Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Stellt einen Ausdruck dar, der über einen konstanten Wert verfügt.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ConstantExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Ruft den Wert des konstanten Ausdrucks ab.</summary>
      <returns>Ein <see cref="T:System.Object" /> gleich dem Wert des dargestellten Ausdrucks.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Gibt einen Sequenzpunkt für Debuginformationen aus oder löscht ihn.Dadurch kann der Debugger beim Debuggen den richtigen Quellcode hervorheben.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> ab, die die Quelldatei darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, die die Quelldatei darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Ruft die Endspalte dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Endspalte des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Ruft die Endzeile dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Endzeile des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Ruft den Wert ab, mit dem angegeben wird, ob <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts verwendet wird.</summary>
      <returns>True, wenn die <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts verwendet wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Ruft die Startspalte dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Anfangsspalte des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Ruft die Startzeile dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Anfangszeile des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Stellt den Standardwert eines Typs oder eines leeren Ausdrucks dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.DefaultExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Stellt einen Initialisierer für ein einzelnes Element einer <see cref="T:System.Collections.IEnumerable" />-Auflistung dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Ruft die Instanzmethode ab, die zum Hinzufügen eines Elements zu einer <see cref="T:System.Collections.IEnumerable" />-Auflistung verwendet wird.</summary>
      <returns>Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Instanzmethode darstellt, die einer Auflistung ein Element hinzufügt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Ruft die Auflistung von Argumenten ab, die an eine Methode übergeben werden, die einer <see cref="T:System.Collections.IEnumerable" />-Auflistung ein Element hinzufügt.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente für eine Methode darstellen, die einer Auflistung ein Element hinzufügt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Gibt eine Textdarstellung eines <see cref="T:System.Linq.Expressions.ElementInit" />-Objekts zurück.</summary>
      <returns>Eine Textdarstellung des <see cref="T:System.Linq.Expressions.ElementInit" />-Objekts.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Stellt die Basisklasse bereit, aus der die Klassen abgeleitet werden, die die Knoten in der Ausdrucksbaumstruktur darstellen.Sie enthält auch static-Factorymethoden (Shared in Visual Basic), um die verschiedenen Knotentypen zu erstellen.Dies ist eine abstract Klasse.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Erstellt eine neue Instanz von <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise ruft <see cref="T:System.Linq.Expressions.MethodCallExpression" /> die Methode <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> auf.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition ohne Überlaufprüfung darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition mit Überlaufprüfung darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen AND-Vorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.And" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen AND-Vorgang darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.And" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten AND-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als true ausgewertet wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="left" />.Type und <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bedingte AND-Operation darstellt, bei der der zweite Operand nur ausgewertet wird, wenn der erste Operand zu true aufgelöst wird.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="method" /> ist null, und <paramref name="left" />.Type sowie <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, um auf ein mehrdimensionales Array zuzugreifen.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="array">Ein Ausdruck, der das mehrdimensionale Array darstellt.</param>
      <param name="indexes">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit Ausdrücken, die zum Indizieren des Arrays verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, um auf ein Array zuzugreifen.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="array">Ein Ausdruck, der das zu indizierende Array darstellt.</param>
      <param name="indexes">Ein Array mit Ausdrücken, die zum Indizieren des Arrays verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die das Anwenden eines Arrayindexoperators auf ein Array mit einem Rang größer als eins darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft festgelegt werden soll.</param>
      <param name="indexes">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> oder <paramref name="indexes" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type stellt keinen Arraytyp dar.- oder - Der Rang von <paramref name="array" />.Type entspricht nicht der Anzahl der Elemente in <paramref name="indexes" />.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines oder mehrerer Elemente von <paramref name="indexes" /> stellt nicht den <see cref="T:System.Int32" />-Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Anwenden eines Arrayindexoperators auf ein Array mit Rang eins darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="index">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> oder <paramref name="index" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type stellt keinen Arraytyp dar.- oder - <paramref name="array" />.Type stellt einen Arraytyp dar, dessen Rang nicht 1 ist.- oder - <paramref name="index" />.Type stellt nicht den <see cref="T:System.Int32" />.Type dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die das Anwenden eines Arrayindexoperators auf ein mehrdimensionales Array darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="array">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Instanzen - Indizes für den Arrayindizierungsvorgang.</param>
      <param name="indexes">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> oder <paramref name="indexes" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type stellt keinen Arraytyp dar.- oder - Der Rang von <paramref name="array" />.Type entspricht nicht der Anzahl der Elemente in <paramref name="indexes" />.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines oder mehrerer Elemente von <paramref name="indexes" /> stellt nicht den <see cref="T:System.Int32" />-Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen Ausdruck zum Abrufen der Länge eines eindimensionalen Arrays darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft gleich <paramref name="array" /> ist.</returns>
      <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type stellt keinen Arraytyp dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, das die Initialisierung eines Felds oder einer Eigenschaft darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, bei dem <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> gleich <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Ein <see cref="T:System.Reflection.MemberInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> oder <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Die durch <paramref name="member" /> dargestellte Eigenschaft verfügt über keinen set-Accessor.- oder - <paramref name="expression" />.Type kann nicht dem Typ des Felds oder der Eigenschaft zugeordnet werden, das bzw. die durch <paramref name="member" /> darstellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, das die Initialisierung eines Members durch Verwendung einer Eigenschaftenaccessormethode darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist.</returns>
      <param name="propertyAccessor">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> oder <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Die Eigenschaft, auf die von <paramref name="propertyAccessor" /> zugegriffen wird, verfügt über keinen set-Accessor.- oder - <paramref name="expression" />.Type kann nicht dem Typ des Felds oder der Eigenschaft zugeordnet werden, das bzw. die durch <paramref name="member" /> darstellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BlockExpression" />, die die angegebenen Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="variables">Die Variablen im Block.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="variables">Die Variablen im Block.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BlockExpression" />, die zwei Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="arg0">Der erste Ausdruck im Block.</param>
      <param name="arg1">Der zweite Ausdruck im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das drei Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="arg0">Der erste Ausdruck im Block.</param>
      <param name="arg1">Der zweite Ausdruck im Block.</param>
      <param name="arg2">Der dritte Ausdruck im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das vier Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="arg0">Der erste Ausdruck im Block.</param>
      <param name="arg1">Der zweite Ausdruck im Block.</param>
      <param name="arg2">Der dritte Ausdruck im Block.</param>
      <param name="arg3">Der vierte Ausdruck im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das fünf Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="arg0">Der erste Ausdruck im Block.</param>
      <param name="arg1">Der zweite Ausdruck im Block.</param>
      <param name="arg2">Der dritte Ausdruck im Block.</param>
      <param name="arg3">Der vierte Ausdruck im Block.</param>
      <param name="arg4">Der fünfte Ausdruck im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BlockExpression" />, die die angegebenen Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Ausdrücke enthält, nicht über Variablen verfügt und von einem bestimmten Ergebnistyp ist.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Blocks.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Blocks.</param>
      <param name="variables">Die Variablen im Block.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Blocks.</param>
      <param name="variables">Die Variablen im Block.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Ausdrücke enthält, nicht über Variablen verfügt und von einem bestimmten Ergebnistyp ist.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Blocks.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Break-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break", die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und ein NULL-Wert beim Springen an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Break-Anweisung darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine Break-Anweisung mit dem angegebenen Typ darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine Break-Anweisung mit dem angegebenen Typ darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die keine Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzmethodenaufruf angibt (übergeben Sie null für eine static-Methode bzw. in Visual Basic eine Shared-Methode).</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist null.- oder - <paramref name="instance" /> ist null, und <paramref name="method" /> stellt eine Instanzmethode dar.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type kann dem deklarierenden Typ der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> und <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft festgelegt werden soll. Übergeben Sie null für eine static-Methode (Shared in Visual Basic).</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist null.- oder - <paramref name="instance" /> ist null, und <paramref name="method" /> stellt eine Instanzmethode dar.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type kann dem deklarierenden Typ der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.- oder - Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die durch <paramref name="method" /> dargestellte Methode überein.- oder - Mindestens ein Element von <paramref name="arguments" /> kann nicht dem entsprechenden Parameter der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die zwei Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzaufruf angibt.(Übergeben Sie NULL für eine statische Methode bzw. eine Shared-Methode in Visual Basic.)</param>
      <param name="method">Das <see cref="T:System.Reflection.MethodInfo" />, das die Zielmethode darstellt.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die drei Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzaufruf angibt.(Übergeben Sie NULL für eine statische Methode bzw. eine Shared-Methode in Visual Basic.)</param>
      <param name="method">Das <see cref="T:System.Reflection.MethodInfo" />, das die Zielmethode darstellt.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> und <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzmethodenaufruf angibt (übergeben Sie null für eine static-Methode bzw. in Visual Basic eine Shared-Methode).</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist null.- oder - <paramref name="instance" /> ist null, und <paramref name="method" /> stellt eine Instanzmethode dar.- oder - <paramref name="arguments" /> ist nicht gleich null, und mindestens eines der darin enthaltenen Elemente ist gleich null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type kann dem deklarierenden Typ der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.- oder - Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die durch <paramref name="method" /> dargestellte Methode überein.- oder - Mindestens ein Element von <paramref name="arguments" /> kann nicht dem entsprechenden Parameter der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode durch das Aufrufen der entsprechenden Factorymethode darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist, die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft gleich <paramref name="instance" /> ist, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> auf die <see cref="T:System.Reflection.MethodInfo" /> festgelegt ist, die die angegebene Instanzmethode darstellt, und <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> auf die angegebenen Argumente festgelegt ist.</returns>
      <param name="instance">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaftswert nach einer bestimmten Methode durchsucht wird.</param>
      <param name="methodName">Der Name der Methode.</param>
      <param name="typeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typparameter der generischen Methode angeben.Dieses Argument muss NULL sein, wenn durch methodName eine nicht generische Methode angegeben wird.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, das die Argumente der Methode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> oder <paramref name="methodName" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Es wurde keine Methode, deren Namen gleich <paramref name="methodName" /> ist, deren Typparameter <paramref name="typeArguments" /> entsprechen und deren Parametertypen <paramref name="arguments" /> entsprechen, in <paramref name="instance" />.Type oder ihrer Basistypen gefunden.- oder - Es wurde mehr als eine Methode, deren Namen gleich <paramref name="methodName" /> ist, deren Typparameter <paramref name="typeArguments" /> entsprechen und deren Parametertypen <paramref name="arguments" /> entsprechen, in <paramref name="instance" />.Type oder ihrer Basistypen gefunden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode (Shared in Visual Basic) darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Das <see cref="T:System.Reflection.MethodInfo" />, das die Zielmethode darstellt.</param>
      <param name="arguments">Ein Auflistung von <see cref="T:System.Linq.Expressions.Expression" />, die die Aufrufargumente darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer static-Methode (Shared in Visual Basic) mit einem Argument darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die zwei Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die drei Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die vier Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
      <param name="arg3">Das <see cref="T:System.Linq.Expressions.Expression" />, das das vierte Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die fünf Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
      <param name="arg3">Das <see cref="T:System.Linq.Expressions.Expression" />, das das vierte Argument darstellt.</param>
      <param name="arg4">Das <see cref="T:System.Linq.Expressions.Expression" />, das das fünfte Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer static-Methode (Shared in Visual Basic) mit Argumenten darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine static-Methode (Shared in Visual Basic) darstellt, auf die die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die durch <paramref name="method" /> dargestellte Methode überein.- oder - Mindestens ein Element von <paramref name="arguments" /> kann nicht dem entsprechenden Parameter der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer static-Methode (Shared in Visual Basic) durch das Aufrufen der entsprechenden Factorymethode darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist, die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die <see cref="T:System.Reflection.MethodInfo" /> festgelegt ist, die die angegebene static-Methode (Shared in Visual Basic) darstellt, und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Argumente festgelegt ist.</returns>
      <param name="type">Der <see cref="T:System.Type" />, der den Typ angibt, der die angegebene static-Methode (Shared in Visual Basic) enthält.</param>
      <param name="methodName">Der Name der Methode.</param>
      <param name="typeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typparameter der generischen Methode angeben.Dieses Argument muss NULL sein, wenn durch methodName eine nicht generische Methode angegeben wird.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, das die Argumente der Methode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="methodName" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Es wurde keine Methode, deren Namen gleich <paramref name="methodName" /> ist, deren Typparameter <paramref name="typeArguments" /> entsprechen und deren Parametertypen <paramref name="arguments" /> entsprechen, in <paramref name="type" /> oder seinen Basistypen gefunden.- oder - Es wurde mehr als eine Methode, deren Namen gleich <paramref name="methodName" /> ist, deren Typparameter <paramref name="typeArguments" /> entsprechen und deren Parametertypen <paramref name="arguments" /> entsprechen, in <paramref name="type" /> oder seinen Basistypen gefunden.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Gibt an, dass der Knoten zu einem einfacheren Knoten reduziert werden kann.Wenn true zurückgegeben wird, kann Reduce() aufgerufen werden, um das reduzierte Formular zu erzeugen.</summary>
      <returns>True, wenn der Knoten reduziert werden kann, andernfalls False.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit einem Verweis auf das aufgefangene <see cref="T:System.Exception" />-Objekt zur Verwendung im Handlertext darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="variable">Eine <see cref="T:System.Linq.Expressions.ParameterExpression" />, die einen Verweis auf das von diesem Handler aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit einem <see cref="T:System.Exception" />-Filter und einem Verweis auf das aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="variable">Eine <see cref="T:System.Linq.Expressions.ParameterExpression" />, die einen Verweis auf das von diesem Handler aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
      <param name="filter">Der Text des <see cref="T:System.Exception" />-Filters.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> von <see cref="T:System.Exception" />, der von diesem <see cref="T:System.Linq.Expressions.CatchBlock" /> behandelt wird.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit einem <see cref="T:System.Exception" />-Filter, aber keinem Verweis auf das aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> von <see cref="T:System.Exception" />, der von diesem <see cref="T:System.Linq.Expressions.CatchBlock" /> behandelt wird.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
      <param name="filter">Der Text des <see cref="T:System.Exception" />-Filters.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts.</returns>
      <param name="document">Die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, die die Quelldatei darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine zusammenfügende Operation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von <paramref name="left" /> stellt keinen Referenztyp und keinen Typ dar, der NULL-Werte zulässt.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type und <paramref name="right" />.Type können nicht ineinander konvertiert werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die bei einer gegebenen Konvertierungsfunktion eine zusammenfügende Operation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type und <paramref name="right" />.Type können nicht ineinander konvertiert werden.- oder - <paramref name="conversion" /> ist nicht null, und <paramref name="conversion" />.Type ist ein Delegattyp, der nicht genau ein Argument akzeptiert.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von <paramref name="left" /> stellt keinen Referenztyp und keinen Typ dar, der NULL-Werte zulässt.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von <paramref name="left" /> stellt einen Typ dar, der nicht dem Parametertyp des Delegatentyps <paramref name="conversion" />.Type zugeordnet werden kann.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von <paramref name="right" /> ist nicht gleich dem Rückgabetyp des Delegattyps <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die eine bedingte Anweisung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> oder <paramref name="ifTrue" /> oder <paramref name="ifFalse" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type ist nicht <see cref="T:System.Boolean" />.- oder - <paramref name="ifTrue" />.Type ist ungleich <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die eine bedingte Anweisung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei der die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> und die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="value">Ein <see cref="T:System.Object" />, auf den die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei der die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> ist und die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="value">Ein <see cref="T:System.Object" />, auf den die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> ist null, und <paramref name="type" /> kann nicht auf der Basis des dynamischen Typs von <paramref name="value" /> zugeordnet werden.</exbeption>
    </member>
    <memrez name=#M:Systm.Linq.Expresshons.Expressiof.Continue(Systdm.Linq.hpr%rsiknr.LabelTaret)">
      <summavy.Erstellt einm see cref="T:System.Linq.E8pressions.Got/Expvessio~" />, tiE ei.e Conti~ue-nweisung d!rs4ellt.</summary>
 ""  <returns>Eine <see cref="T:System.Lioq.Expressions.GotoExpression* />, bei(der <see cref="P:System.Linq.Exprecsions.GotgExpressioo/Jind" /> gleich "Continue" die <see creF?"P:System.Linq.Expsessions.G/dgExprEssIon.Target" />-Emgensshaft a1f <par!mrf fame=&4arget" /> festgedEgt ist und"beim Springen ei^ nULL-Wert an die Zaebeeihnung übergefmn ird.<-eturns>
  `   <aram name="target">Das <re%`cref="t:System.Linq.Expressions.LabmlTargep" />, zu dem <ree cref="T:System.Lilq.Expressions.GOtoExpruSsion" /> Sprifgt.</piram.
  " </mmber>
  $ <m%mBer name="M2System.Linq.ExPrmssions.Expression.Continue(System.Linq.ExpRessio.s.LabelTarget,Sstem.Type)">
    ( ,summarq>Erstellt eine <see cref?"U:[ystem.Lmnq.Exxressions.GotoExprussinn" />, die eine Continue-Anweisung mit dem ajGegebenen ]p darsteLlt.</sqmmary
     0<retrns>Ein`<wee cref=":Systei.Linq.expressions.GotoExpresqion""/>, bgi dem <see cref="P:System.\inq.Expre{sions.GotoExprewsion.Kind" /< gleikh"Conti~ue" ist, dhe <see cref="P:SycdemnLinq.Expressions/GotoExprdssion.Target" ?>-Eigenschaft auf <paramref name= |arget" /> festgelegt hst, die <see sref="P:System.Dinq.Expressions.Ezpression.Tyye" />-Eigensgxaft auf <parambef name="t9pe" /> festgelegt ist un` beiM Sppigen ein NULL-Wert an die Zielbezeichnung!übergebn wird*</retwrnq>	
      <param namd="target">Das!<see0cref="T:Sys|gm.Linq.Expressiolq.LabelTarget# />, zu dmm <see cref="T:System.Linq.E(pressions.GmtmExPrdssom" /> s0ryngt.</param>
      <param name=2type">Ein <cea cref="\:System.Type2 />, auf ddn die <cee cref="P:Sxsem.Lan1.Ex0ressions.Ehpression.Type" />-EiEenschift fesuge,egt werdn soll./param>
   !</member>
    <member name="O:System.Linq.Expressinns.GxpressIon.Converd(Sy3tem.Linq.Expressiona.Expression,Systgm.Dype)">M
      <summary>Erstellt ein 4see #ref="T:Sy{tem.LInq.Expressions.UnaryExprusSion" ?>,$das ei~en Typkonvertiertngsvorgang darstellt.</rummary>
      <returns>Ein <see csEf="T:Sytem.Linq.Expr%ssions.UnaryExpression" />, bei dem die <see cref="P:SyStem.Linq.Txpressimns.ExprusSion.NoduType" />-Eigenschaft 'leich<se cref="F:System.Linq.Axpressions,ExpressionType.Cone2t" /> ist und die <see cref="p:System.inq.Express)ons.UNaryEpressi/n.Operand" />-Eige.cxaf4 souie die <see czef="p:System.Lilq.Expressions.Expvewsion.Type" />-E)genschaft a5v die angegebmnen Werte0festgelegt sind.|/returnq>
      <param Name="expressIon">Ein 8see cvef="T:System.Linq.Axpressions.Exprewwion" />, auf den die <see cref="P:System.inq.Expressions.UnaryE|pressioo.Opeband" '>-Eigenschaf4 feStgelegt we2den soll.</param>
      <param nAme="type">E)n <see crEf="T:System.Ty0e" />, auf dcs die |see czef="P:System.Lijq.Expressons.ExpressionType" />-Eigens#hef| festgelegt wePden!{oll.</param>
      <axcetion cbef="T>Sstem.ArgumentLullUhception">
"  0    <paramref jam%="exprEsson" /> oder <parcmpef name="type6 / ist nunl.</excepTion>
      <excgption cref="T:System.Inval)dOperationExceppiol">Zwisc(e. <paramref name="expression2 />.Typg und <xaramref name="type" /> ist kein KonvErdierungs/rerator definiert.=/excepion>
    </membez>
"   <mem"er name="M:S}tem.Linq.Expressions.ExPreqsion.Convert(Siste.Linq.ExpressionS.Exression,SYstem.Type,System.Reflection.MephodInfo)>
      <sum}ary>Erstellt eine <seE crdf="T:System.Linq.Expbessojq.UnaryExpression" />, die eine Konvertieru~gsoqeradion darstellt, füs die die mplementierendu Me4hode angefebn st.<-su-mary>
    <returns>Ein <se cRef9"T:Sysddm.Linq.Expressikns.UnaryExpressyoN" '>, bei dgi die(<see cref="P:System.hnq.Exprgssions.ExpressioN.NodeType" />-Eienschaft gleich <3ee gref=&F8Sstem.Nin1.ExpressionS.ExpRussionTypd.CoNvert" />(ist Und die Eigenschadtej(<see cref="P8System.Ly^q.ExprmsWins.UnarYExpressioj.Opepand" />, <seecref="P:System.Linq.Expressmons.Expressyon.Type /> und <sea cref|"P:System.Linq.E|preSsions.UlapyEpression.dthod" /> auf die angegebeNen Werte f'stgelegt sind.</returns>      |param name="expression>Ein <see cref= T:System.Linq/Expressions.Expsession" />, auf de. die <see cref9"P:Sysuem.Linq.Extressions.UnaryExpression.OpesiNd" />-DigenscHaft festgelegt webden rll.</taram>
   "  <param name="type">Ein =see cref="T:Cysuem.Type" />, au dqs dIe <sde cref="P:System.\inq.Expvession{.Expzession.Typ%" />%Eigeosshafu festgelegt werden soll.</pa2am>      <param name="method">il <see cref="t:System.Refmgction.MephodInfo" />, quf ds die <Sem cren}"P:System.Linq.ExpreSsion.UnaryExpression.Method" />-EigenschaFt festgelegt wevd%n soll.</pa2am>
      <excmqtion cref=2T:Systum.Argument^ullEXcption">
 !  `   <paralref nime="expression" /> oder <paamref namE="type" /> ist nUll|/exception>-
      <exception crdf=*T:Sxspem.ArgumentExcertion">
        <paramrmf name="method" /> ist nicht null, und die dadurc`(avgestellte(Methode wibt voiD z5rück, ist ficht statik (Share in Visqe, Basi#) oder akreptiert icht eenau ein Ergument.</exce`tion>
`     <epception cref="T:System.InvalidOperationExceptmon".ZwicLen <p!ramref name="expression" o..Type unD <paramref name="type" /> ist kgin Kon~ertierungsoperator defIniert.- oder m 8paramref name="gxpression" />.Type kann dem Argumenttyp der dtrkH0<pcramRef name="ethod" /> dargestellten Methnd nicht:ugeobdnet werden.- oer - Der Rüc	gabetyp der$Method, die d5rch <paramref name="method" /> dargestehlt wirdl kann <paramref name="type" /> nicht zugeosdnet werden.- oder - <paramref name="eXression" />.Type oder <pAramref name="ypu" /> ist ein Wurttyp, dev NULL-_este ZulƤsst, uld der entsprechen`e Wertt9x, ter ceine NTL\-Werte zulässt, entsprict$nicht dem0Argumenttyp bzw.(ddm RôckgAbetyp der durch <paramref!name="methoe" /> `areestEllten Methode.</excepvion>
      <exseption cren="T:System.Reflecvion.QibiguousMatchExCepion">Es wurde0leh3 als eine0Muthode"gefunden, dig mit der$<paramref na}e="mephod" />-beschreibung!üBereinstimmt.</exception>
    </membes>
"   <member naMe="MSystem.Linq.Express}ons.Expression.ConvertheckEd(Sqstem/DlnqExpressions.xressIon,Sywtem.Vip	">
$     <wummary>Erstellt Mine <see cref="T:System.Linq.Expressiols.UnaryExpressikn" />, dig eine Konvestierungsoperavin `aRstellt, $ie eine Ausnahme dusl÷st, wenn ein Ü"erliun im Zieltyp!auftritt.</wummary>
    ` <r%turns>Ain <se% cref="T:SsTem>Linq.E|pressions.UnaqExpression" />, b$i dem did <see cref}"P:Sytem.Linq.Expressions.Expres3ion.Nodetype"`/>Gigenschaft gleich <see cre&="F:Sxst%m.Linq.Expressins.ExressionType.CknvertCheaked /> istund die <see cref5"P:System.Linq.Expres{ioos/UnaryExpression.Operand" />-Eigenscjaft rowie die <see cref="P:Sy{tum.Li.q.Exprqsimns.Expression.Type" />-Eigenschaf$auf die angegebenen Werte festgelegt ind.</Returns>
      <param namd="exprussio">Ein <s%ecref="TSystem.Linq,Gxpressions.Expression" /> auf den`lie <sed cref5"P:ystem*Linq.Exqressions.UnaryExp2essign.Nperand" />-Ukgenschaf festw%legt werdmn soll.</param>      <param name=type".Ein <sEe cpef=#T:ystem.Type" />, auf das die 8see cref="P:System.Minq.Expressions.Expressiof*Type" />-Eigefschaft festgele't werden soll/</param>
     <exce`tioo cref="TSystem.A2gmentu,lExceptin">
        <paramref ncme="expression" /> oder <para-ref ncme="tqpe" /> hst null,</exception>
   0  <exception crf="T:System.IvalidO0eraUiolExce`tioN#>ZwIschen <parcmref0name="expRession" /~.Type$und <aramref naie="type" />$ist kein Konverterung3operator definiert.</axception>
  ` <'member>
    <member name5"M:System.Linq.ExprEssios.Expression.ConvertALgcked(System.Minq.Exppessiols.Expression,Syrtgm.Type(System.Reflgstion.MethodInfo)">   0` <summary>Erstellt eine <see cref="T:System.Minq,Expressions.UnasyExpression& />, die eine(onverpierungsoperat`on darstellt, fӼr die die ioplementierende Methode angegeben ist und$die eine$Ausnahme auslösv, wenn ein ÜberlauF im Zie}typ quftrmtt/</wummary>
      <returns>Ein <see cref="U:Sysem.Linq.ExtressionsUnaryExpresyon# />, bei dem die <see cref"P:S{tEm.Linq.Expressions.Expression.NodeType" />-Eigenschagt gleich <see cref}"F:System.Linq.Expressions.EXpressionDype.CoferteckeD" /> isd und die Eigenschaftgn <sem cref="P:System.Linq.Dxpressions.UnaryExp2ession.Operand" />,@<sue cref="P:Syste-.Linq.Expressions.Expression.Type" /> und"<see cref="P:System.Linq.Exprescions&UnaryEyprecsion.Method" /> auf dhe angegebnen Werte vestgelegt 3ind./returns>
      <para- name="expression">Ein"<see cref="T:System.EinqnEx0ress)ons.Expression" />, auf den die <see ref="P:System.Linq.Exprersions.UnaryExpressioo.Operand" />-Eigenschaft fesugelet ser$en soll.</pqram>
    $ <param name="tyre">Ein <see cref="T:Systee.Txpe" '>,$auf dcs diE <see aref="P:Sqstem.Lins.Expressions.ExpressioJ.ype" />-EIgenschaft festge$egt werden soll.</param>
      <0aram namu="mmthod">Ein <wee aref="T:Sqstem.Refdection.metholInfo" />, auf dcs die <see cref="P8System.Linq.AypressiOns.UnaryE8`ression.Method" />-Eigmnschabt festgelegt werden soll.</param>
      <exception cref="T:Sywtem.Argmen4NUllExceptmoj">
"    $  <paramref0name="expvession" /? oder |param2ef name="type" /> ist null.</exception.
      excdption cred="T:System.Argumentxception"<
        <PazamreG namE}"method# /> i{ nicht nul,, und die dadurch dar'es4ellte Metofm gibt void zurück, ist nicht static (Share$ in Visual Basic	 oder ak~eptiert nicht genqu eil AgumEnt/</excepTion>
      <ezcepuion cref="T:Sqstem.InvalidoqezationException":ZwmscheO <pAramref name="exprdssion  />.Type und <paramref name="type" /$)st kein KonvertIerungsoperator definieRt.- oder - <paramref name="expressIon" />.Type kann deo Arguoenttyp dgr duzch <paramre ncme="me4hod" /> dargectellten Metode nicht zugeobdnet werd%n.- gdmz - Der Rückgabetyp der MethoDe,!die durci <paramr%f ncme="method" /> darges|ell| wird, kann <pAram2ef(fame="typ" /> nihv zugeordnet werden.- oder - <pasamref name="exqresw)ol" />.Type oder <paramref nae="type" > iwt ein werttyp,$der NULL-_erte zulässt, und leR entsprechelde Wer|vyp, ler keine NULM-Werte zulässt, entspricht nicht dem Argumenttyp`bzw. dem Rckgabetyp de duzch <rAramreb name="mevhod" />`dargestellden Methode.</exception>
      <exceptioj cref="T:SystenReflection.AmbaguousMatchException">Es wtrte mehr els eine MethoDe0guunddl, die mit der <paramPef name="medhod" /-beschrEiBung bereinstimmt.</exception>
    </member>
    <eember naee="I:Sys5em&Linq.Mxpressions.Expression.DebugInfo(S}stem.Lknq.Expressio~s.Syo"olDocumen~Info,Sxstem.Int32,System.Int32,Sy3tem.Int32,SystemnInt32)*>
      <{ummA2y>Erste|lt eife <se cRef="T:System.Linq.Expres{ions.LebugInfoExpression" /> oit der angegebenen Spanne.</suMmary>
      <returns>Eine I~stanz von <sed cref="T:Syst%m.Linq.Expressions.DebugInfoExpression" />.8/returns>
      8param name="$ocument">Die cee(cref="T:System.Linq.Exprassikns.SyMbolDocumentInfO" >, die die Quelldatey darsellt*</param>
      <par`-0name=#sdartL)ne">Die Startzeile $ieser <see cref="T:System.Linq.Epressions.DejugIn&oExpression" />.Muss größer als 0 sein.</param>
      <pram neme9"startClumn">Dhe Star|spamte dieser <see cref="T:System.Linq.Expressions.DebugInfoExprgssioj" />.Musw größer als 0 sein.</param>
     `<paam name="endLine">Dia Endxeie daeser <see cre="T:SyStem.Linq.ExpressioNs.DebugInfoEppression" />.Muss grö×er mder gleich der StartzEile sein.</paraM>
      <param ame="endColuin">Die ENdspalte diese2 <see cref="u:Syspem.Linq.ExpRessions.@ebqwInfoEypression" />.Wenn die Endzele und de Startzeile identisch sind, muSs dig Eodzeile größer oder gleich der Startspalte sein.Muss in jede F`ll gRßer als`0 sein.</param>
    </member<
    <mdmber name="M:Systdm.Linq.Expressonq.Exprecsio~.FCrement(Sytem.Linq.Ezpressions.Expression">
     (<summary>Erstelt eine <see cref="T:System.LinQ.Expressionsn5naryExpression" /, die das Verringern des AusdrucKqwerus0um 0earstelht.</summary>
      <returnsEine <see cref="T:SystemnLinq.Exp2essions.UnaryExpression" />, die den verringerten Ausdruckswert $arstellt.</ret%ros>
    ` <param name="expression >Ein zu`verr)ngarldes <see cref="T:System.Linp.ExprEswons.ExpressioN" />.<'parim>
    </member>
    <member name="M:Systel.Linq.Expressaons.Expression,Decrement(System.Linq.Exxressions*xpression,Sycpem.refldction.Me4hodInfo)">
      <summary>Erstellt ehne <qee cref="T:System.Linq.Expressions.UnaryExqres3ion" />- dia das Verringern des Ausdruckswerts um 1 darsTelht.</suomary>	
      <returns>Eile <sde0cref="T>System.Linq.expressiknsUnaryExprEsion" />,"die den verri/gerten Ausdruckswert darstelld.>/retrns>
  $   <param name="expression">Ein zu verringErndms <see cref="T:Sys4em.Linq.Uxpressions.Expression" o.</param>
     "<pcram name="method >Ean <see crmf="T:Syst%m.Reflec|ion.MethodInfo" />, das die implementiere~de Methode dapwtellt.</param>
   </member>
    <oember name="M:System/Lina:Dxpressiofs.E8pression.Default(System.Type)"6
 $    <summary>ErsteL,!einE <see cref="T:Sqsteo.Linq.Expressions.DefaultExpbession" />, 0ei der die <see0cre&="P:C{s|em.inq.Exprdswions.Expression.Txpe" />-Eiggnsshaft auN fen angegebenen Typ festgenegt ist.</summary>
      <returns>En ,see cref="TSystem.linq.ExpressioN{.DefaultExpression" />- bei dem dia <see cref="RSystem.Linq,Exprussions.Expression.NodeType" />-E)genschaf| gleich <see cref="F:yctem.Linq.Expression{.xpres3ionTipe.Default" /> und die <se cref="P:Syrtem.Linq.Expreqcions.EXpression.Type" />-Gigenqchafv auf den angegebe~en Typ festgelegt is4.<returns>
      <param name="tYpe">Ein <seE"cref="T*Systum.TYpe" +>, auf Das die =sea cref="T:Sy3tum.LinqExpressionS.E|pressionType" />-Eigensc,aft festgelegt0werden nll.</param>
    </member<
 0 <member nime<"M:System.Linq.Expressions.Exqressio*Divide(System.Hinq.ExpressionsExpression,SyrtemlLinq.Expressos.Expression)b.
`     <summary>Erstell e)ne <see cref="T;System.Linq.Expre3sions.@inaryEypresskon" />, die eing arithmetiSche EIvision darsteLlt.</summAry>
      <rgturnq>Ein <see cref=2T:Syqtem.Hinq.Expressions.BinaryExpressiol""/,bei dem die <see cref="P:System.Lin.Gxbresskons.Mppresign.NodeType" />-Eigenschaft Gleich <see cref="F:System.Linq.Ex`ressions.xre3sIonType.Divide" /> ist unD die <see crf="P:System.Lnq.Expressions.BinaryEzpression.Left" />-Eigenschaft sowie die <see cref="P:Systee.Linq.Exprewsions.BinaryExpreswion.Right" />-Eigens#anT uf die angegubenen Wgrte festgelegt sind.</revwros>
      <param name}"eft">Eine <See cref="T:System.Lin1.Expressions.Ezpression" />, auf die die <see0cre&="P:System.Linq.Exprassi/ns.BinaryExpression/\eft" />EigEnschaft festgelegt werden soll.<-param>
$    $<param namd="r)ght">Eine ,see cref="T:System.Linq.expressions.Expres3ion" />,$auf die die <see cref}"P:System.Hynq.ExpressiOns.BinryExpre3sion.Rkght" />-EIgenschaft vestgelgt werden so,l.</param>
      <exception(cref="T:System.AzBumen4NullExcettion#>
 !  "   <paramrcf name="l%ft" /> ohe2 ,paramref jame="zight" /> is nUll.</exception>
      >except)on cref="T:System.InvalidOperctyonException">der Divisionsmperator(ist für <paramref name="left" />.Type und <parambgf name="right" />.Dypg nicht definiert.</exception>
`   </member~
    <member name="M:Systel.Linq.Expressyons/Exprewsioj.Ditide(Sysvem.Linq.Expressios.Expres3ion,System.Linq.Expbessions.ExpzesSionSyseem.Reblection.MethodYnfo)">
    $ <qummar{>Erstelt eie 4see cref="P:System.Linq.Express)/~s.BinaryExpression" />,"die eine arithmEtische Divirion"darstellt.Die impldm%ntierende Method kann clgegeben werden.</summe2y>      <returjs>Ein <see cref="T:System.Linq.Expressions/BinaryExpression" />< bei dgm die <see cref="P:System.Niq.Expressions&Expreswioj.JodmType" />-EigenschafT gleich"<see cref=F:System.Linq.E|pressions.ExprmssionType.Divide" /> isT und die Eigenschaften <see Cref=":System.Linq.Expessions.BinarYExpression.Lft" /6, <3ee cref="P:System.Linq.expbessions.BinaryExpression.Right" /> und <see cref"R:Sytem.Linq.EhPression3.BinaryExpresskon.]%thod" /> auf de angege`enen Werte festgelegt 3ind.</returns>
      <param name="lefp">E)n!<see gref="P:System.Linq.Expressions.Expression" /6, `}f den die }seE cref="P:System.Linq.ExpressIons.BnaryExprecsion.Left" />-Eigenschaft festgelegt weRdn sll.</param>
    0 <param name="right">Ein <See cref="\:QysTem.Linq.Exprmssios.Exprmssion" />, auf den"die <ce Crf="P:Sy{tem.Li~q.Epressions.BilaryEpprgssion.Right"(/>-Eigen{chaftfestgelegt werden sglh</paraM>
 $    <param fame="method">Ein <seecref="T:system.RefleCvion.MethodI.fo* >, auf $as die <sEd crdf=&P:Systee.Linq.E}pressinns.BinaryE8pressimn.Method"/>-Eigenschaft fdstgelegt werden snll.</paRam>
(     <excptign crmf="T:Systam.ArgumentNullExcEptin">
      " 4paramref nime="lefu" />0gder <parairef name?"riglt" /> is| n5ll.</exception>
      <exception cref="T:System.vgumentExc%ption#>
        <paramref name="mmThod" o> ist nicht nulm, und die talurch dargestellte Methodg gibt poid`zurüsk, ist nicht static (Shared in Visual Bashc) oder aczextiert nicht genau ~wei argumente.</dyaaptIon>
     <exception crdf="T:System.InvalidOperationException">  "     <paramref name="method" /> ist nul,, und deR DivisiOnsoperator ist dür 8paramre nime9"lef" />.Type und <paramref name="right" +>.Type nict definiurt.</eception>    </member>
    <member name=M:S9stem.Linq.Expressions.Expression/DiviDeAssign(System.Minq.ExPressions.E8pressiOn,System.L)nq.Expressi/ns.Expression)">
    ( <summavy>rstellt Eine <se crdf=#T:Sytem.Linq.Epresi/ns.BifaryAxxressmo~" />, die eine Divisionszuweistngsoperation ohnm Überlaufprüfung darstellu.</summary>
$     <rerurnq?Min <see cref="T:SystemjLin.Expessions.binaryExpression" />,bei dem diu <see cref="P:System.Lilq.Expzussion.Expessioj.odeType" /-Eigenschaft gleich <see cref="F8System.Hijq*Expressions+ExppessionType.Di~iDeASsign"0/. irt uld"die <see bref"P:System.Linq.Expressions.BinaryExpression.Lebt" />-Migensshaft sowie die <sge cref="P:Sstmm.Linq.ExPressions.BinaryExprEss)on.Right"/?-E)gelsc`aft auf die!ungegebenen Werte festgel%gt siNd.</rdterns>
    ! <param name="lefu">Ei <see cref="T>SysteM.Lmnq.Exprgssions.Exppess)o." o>, auf dEn Die <qee crev="P:SystemLinqExprssions.BkniryExpressign.LeFt" />-EgensChaft festgelegt werden soll.8/p!raM>
    ! <param naee="right">Ein <sed cref="T:QystemLinq.Expressmofs.Expression# >, aun de~ die <see cref="P2System.LiNq.Expressions.BinaryExpreSsimn,Riglt"`/>-Eigenschaft0festgelegt werden!skll.</pqram~
 $  <Omgmber>
    <memBe name="M:Ryrtem*Linq.Expressions&Expression/DivideAssicf(System.Linq.Expresskon{.Expression,Qystem/Lina.Expressions.E8pressio.,System.REflection.MethoDInfo-">      >sumMary>Grstullt einE <see cref="T:System.Lilq.Expre3sions.Jk~aryExpression" />, die eineDivisionsjuwuisungsop%ra4ion ohne Überlaufxrüfung farstellt.</summ`ry>
      <returNs>Ein 8see cref="T:System.LinuNExprusshmns.Bin`RyExpressioj" />, bei dem dig <see cref="P:System.Lynq.Exprgssyns.Expression.JodeTypd" />-Uigenrchagt gleish <see creF="F:System>Lnq.xpressyonr.ExprmssionType.DivideAssign" /> )st(und di Eigenschaften <sde cref="P:ystem.Linq.Expressions.BinaryExpression.Left" />, <see cr%f=P:Sys4e}.Linq.ExrressionsnBinariExPbession/Richt" /> und ,see cref="P:SYStem.Mina.Exprdssiojs.Bi~aryEXprcssio.Method" /> auf die angegebenen WertE fest7elegt sifd.>/returns>
      <pa2am ~ame="lnt">Eif <see cref="T:Systee.Linq.Expressions.Expression""/>, auf dej Die 8s% cref="Pzystem.Lin1.Extrersions.Binar}E|dression.Left" />-eigenschqft festgelegT werden soll.</param>
      <param name="right".Ein <3ee cvef="T:System.LiNq.E8pressions.Expression" />, aud Den die <see cref="P:SyStmm.Lin1.Expressions.B)naryDxpressIon.Right#$/>-Ehgenschaft festgelegt verden sol,.</piram>
      8param name="method">Ein <sae cref="T:System.Rmflection.Metho$I~fo" />, atf das die0<see`c2gf="@:System.Lin.EXpressaonsBinarYExpressaon.Method" />-Eigenschaft usTgelegt wdrden soll.</Param~
  ! </member>
    <member namm="M>System.Linq.Expressions.Exprerciol.DyvideAscignSystem.Linq.Expressiofs.ExpsessionSystem.Linq.Expressio.s.Expressioj,System.Reflect)on.MEthodInfo.System.Linq.Expressigns.LambdaExpression)b>
      <semmary>Arstellt eine <see(cref="T:System.Linq.Eypsessions.BineyExpression" />, f)e`eine Divisionszuweisungropertion oine Überleufprüfung dcrstElLt.4/qummary>
     !<ret5rns>EiNe <see cref-"T:Systgm.Dinq.Expressions.BinaryExpression" />, bdi ter d)d <see cref="Q:Wystem.Linq.Expressions.Expresikn/NodeType" />-Eigenschaf4 gleich <see cref="F:System.Linq.ExprEssions.ExpressionType.DivideAssign" /> ist und Die Eigenschaften sem cref5"P:System.Ln1.Exp2essions.BinaryE8rression.Left" />, <see cref="@:System.Lin.Expressions.BinarYExpressioj.Right" />, <see csef="P:System.Linq.ExpressIons.BinaryExpressinn.Medhod" /> und <see kref="P:Syst%m.Linq.Expressions.BinaryExpr%ssimn.Covmrsion(/< a}f!die angegebgnenWerte festgelegt sind.</peturns>
      <param nae="left2>Ein <cee kref="T:Cyctem.linq.Expressiojs.Exression" />, aun`den die ,see cref=":ystem.Linq,Expressions.BinaryExpression.LEft" />-Eigenschaft festgelagt WerdDn 3o,|.</param>
     8param name="rig(t">Ei. <sme creg="T:System.Linq.ExpbeSsions.Expression" />,)aqf den die 8sae cref="P:S9stdm.Linq.xpessions.BinarqExpresion.Sicht" /~=Eigenschaft festglegt wer$gn s/ll.</param?
      <pa`m name="lethod">Ekn <see cref="T:System.Reflection.MethodInfo& />, !uf das die <see0cref"pzSystem.DinqExPressiOns&BknaryExpression.Iethnd" />/Eigenschafd festgeleGt wesden soll.</``ram>      <param n`ma="con6er{ion">Fin <cee$cbef="T:S{stem.Lyn1.ExpressioNs.LambdaEhpressio" />, auf"dar die <see cref="P:Syste-.LinqExpressions.BinaryExprersin.Conversign" />-Eicenschaft festgelegt wdrden soll.</pazam>
`   </lember>
    <member name="L:SysTem.Lhnq.ExpressiolS.ExprecsioN.ElmmentIfit(System.ReflEction.OethodInfo,System.Colectyonq.Gengric.CEnumerable{Syktem.Linq.Ex`ressions.Ex0ression})">
      <summcry>ErStellt `in <sce cref="T:Sistem.Liny.Exprersions/MlementInit" />, dessen zWeitEs Argu-ent ein <see cref=#T:Sysdem.Collections.Generic.iEnumerable`1"/> ist<)suimary>
      <returns:Ein <see cref="T:Rystem.Linq.Expressiony.ElementIoiv" />,"bei dee die <see cref="P:System.Linq.ExpvessioNs.ElementInaT.Ad`Method" />-Eigenschabt uNe die <see crf<"P:Syqtel*L)nu.Ex`resshons.ElementH~it.Arguments "/>,Eigen{chafd auf die$angefebenen Werte fe3tgeoegt 3ind.</reuurnc:
 (  ` <param name9"addMethod">Ey~ <see cref="T:Systel.Reflection/Methodinfo" />, auf as die <see cref="P:System.Linq.Exprebsions.ElaMEnt	n)t.ADdMethgd" />-Eigenschaft festgelegt erden soll.</param>
      <paraM name="arguments">EIn <ee kref="T:Sytem*CollectionsGnevic.I@nuerable`1" /> mit <see cRef5T:System.Linq.Expressins.ExPressyon" />-Ojekten, awf das die <see cref=P:System.Llnq,Expressions.Elemen|Ijit.Argtments" >-Eigenschaft festgeleet werden soll.4/param>
     "<exseptiOn cref="T:System.ArgumentNullExce0tign*> `    $ p`R`mref name="addMethmd" /> odera<paramref naeE="ar'uments" /> ist nwll*</Excepuion>
      <%xception`sref-"T:Sy3pem.ArGueuntException">Die durch <P!ramrefnaee="addMuthod# /> darges|ellte Methode weis nicht den Famn "Add" (Croß-/Kleinwchreibung wird nicht berücksichtigt)auf>- oder¡- Die durc( <paamref nalg="aDdMet(od" /< dargesdellte!ME(ode ist keine Instanzmethoden- mder - <piram2ef name="argtmeFts" />`entiält nicht dieselbe Anza`l an Elementen wie die Anzehlhder`Pavaggter für die0durch <parcMref name="addMethod" /> dargestellte Methode.- oder- Die <see crmd="P:System.Lhnq.Expressions.Expression/Type" />-Emgelsch!Ft einer der iehrerev Elemente won <para%ref name*arg}ments" /> kann nicht dem Typ de{ eftsprmciendE. Parametezs dep durch"<Teramref name}"add]ethkd" /> dapgestellten Metkode zugeordnEt werden.<'exaeption>
    </mEmber>
    <member name="M:Syspem*\inq.Expressaons,Exp2essio~.ElementInit(Rqstem.Reflection.]ethodInfo,System.Linq.Expressions.xpression[])">
      <summary>Erstellt gin >ste cref="T:System.Linq.Ex0r%ssions.ElementHnit" >, dess%n zweitesArgumgnt ein Wertearray is|.|+suoearx>
 0    <returns:Ein <seucrEf="T:System.Linq.expressyons.ElementInit" /> bei dem die >see #ref="P:System.Linp.Expressions.ElementInit.AddMethod" />-Eio%nschaft qnd die <see cref="P:System.Linq.Exqressions.ElemdntInitArguments" />-EiEenschaft au& diu angegebendn Werte ustgelegt sind.</returns>
   0 $<par`m name="addMethod"Ein <see cref="T:System"Reflection.MethodInfo" />, auf dqs die <see cref="P*System.Linq.Expression.ElemeotIniu.AdlMethod" />-Eigenschaft festgUlegt w%rden soll.</param>
 !    <param namd="aRgumGnts >En Array Vmn 8see bref="\:Systum.LinqExpvEssions>Expression" />-Objekten, auf daS die <se cref="P:System.Linq.E8pressions.DlemenuInit.Argumets" />-Eigenschft festgelegt wdrden soll.</paRam>
     <exception cref<"T:System.Arg}menuNullExcmptio">
        <paramreg name="addMevhod" / oder <paramref name="arumentsb /> ist null.</exception>	
   !  <exception cref="P:Wystem.ArgumentException">Die dwvch addMethod dargustellte ethode weist nicht den Namen "Cdd" (Wroß-/KlensbhreiBung wyrd nicht berücksichtkgt) auf&- oder- Die urah addMethod d!rgestellte Medhode ist kioe Insvanzeethode.- kder - arguments enthält nicht dieselbg Anzahl von Elementen wie die Anzahl der Parameter für die dursh ddMedhod dasgestelle MethOde.- oder= Die <see gsn="P:Rystem.LinqExpressmons.Expression.Type" />-Eigenschaft einer oder mehrerer Elemente von <paramref name="arguments" /> kann nicht lem Typ des entsprechenden Parameters der durch paramref name="addMeThod"0/> daRgesellten`Methode zugeorfnet werden.</exception>    </mgmbdr>
   <}embev name="M:SystemnLina.Expre{ions.Expression.Eopty"~
     <suemary>ErstelLt einen leeren Ausdr5k vkm yp <se% cref="T:System.Foi" />.<-summary>
      <returns>Eine <see cref"T:Systmm.Linq.Expressions.DefaultExpres{ion" />, be) dmr die <sEe cref="P:System.Linq&ExpressionS.Expvession.NodeUype" o>=EigensChact gleah <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> und die <see cref="P:System.Linq.Expressions.Ezpression.Type" />-EygeNsbhaft auf <see$cred="T:SycpemVoid" /> fEstgelegt ist.<.retrns>
    ,/membg2>
    <member name="M:Syste}.Linq.Exp2essions.Ex0ressiol.EquIl(SystMm.Linq.ExpressionsExpression,System.Linq.Exprmssions.Expression)">
      summaryEbstellv eije =ree craF="T:System.Lmnu>Expressions.BinazyUxpreqsion" />$ die uinen Gleichheitsvergleich darstel,t.</qummary>
      <returns>Ein <sAe cref="T:System.Linu.EXpressions.BinaryExpressioN" />, bem dmm die <see"cref="P:Sysl%m.Linq.Uxpressions.Expres{ikn*NodeType" />-Eigenscjaft*gleich <see cref="F:CyStem.Linp.Expression{.ExprecsionTypE.Equal" /> Ist und die <seE cref="P:System.Linq.Expressions.BinaryDxpression.left" />-Eigenschaft sowye dye <see cref="P:System.Linq.Expressions.BinasyExpression.Ryght" o>-Ei%schaft auf dim angegubnen WErte fesTgelegt sind.</returns>
      <pcRam name="left">Ein <sge cref="T:Syctem.Linq.DxpresSions.Mxprssion" />, aUf den die 4see cref="P:Systeo.Linq,Expressions.Bi.aryExpressioN.Left" />)Eigenschaft festgenegt werden soll.</taram>
     !<param name="rigit>Ein <see cref="T:SysTem.Linq.ExprEqsiojs.Ex0ression" />, !f den die <see crdf="P2System.Linq.Express)ons.BinaryExpressioj.Right" />-Eigenschaft festgelegt werden$soll.</qaram>
      <exceptmon crEf="T:Sysdem.ArgumentNullExceptiof">
        <paramvgf name="left" /> oder <paramref name="right" /> ist!null.</exceptin>
     <eyaeption cref="R;System.InvalidOperationException">Der GleichheitsopErator ist fr =paramref naee="left" /:.Type un` <paralref lame="right" />.TYpe nicht dmfiniert.</exception>
    </mEmber>
    <memBer name="M:System.Linq.Expreswions.Expression.Equal(System.Linq.Expre3sio.s.Gxpression.System*LIlp.Expressions.Expression,System.Boolean,S9stem&Reflection,MethodInfo	">
      >summery>ErStallt e)ne <see cref="T:Syspem.Linq.Expressions.BinaryExpression" />, dieeinen Glaic`heitq6ergLeibh darstellt.Die$imp|ementierende Methode kann ngegebEn werden.</summary>
      <Returns6Eine <see cref="T:System.LInq.Expressions.BinaryExpresshon" />, cei der dIe <3ee cref=#P:Sytem.Lmnq.Expresshons.EXpressi/n.NmdeType" />=EigenschafT gleich <see cref-"F:System.Linq.Expr%ssionS.ExpressionType.Equam"`> ist und die Eigunsch`fTen =sem cref5"P:System.Lhnq.expressyons.Bi.aryExp6es{n&LEft" />, <see cref="@:system.Lioq.Expressionr.BinaryE|pression.Right" />, <see #ref="P:System.Linq.Expressions.BinaryExPressiof.IsLiftedToNull" /> ujd <see cref="P:Wy3tem.Lijq.Expressions.BinaryExpreusion.Method" /> iuf d)e angegebenen wEpte festgelegt sid.</peturns:     (<param .cme="lEft&?Eij 4see cref="T:System.inq.Expressions.xpression" '>, auf dfn die <see cref="T:System.inq.Expressionq.BinaryExprersion.Laft" />-Eioenschagt!vestgelegt wrden sO|l.</param>
      <parim name="right">Ein <see cse="T{Syspem.Linq.Extressions.Ex`ression" /., auf dgn die <see cref?"P:Qystem.Lin.Expressikns.BinaryExpr%ssion.Right" ?>-Eigenschaft festgulggt weren soll.</raram>
      <param name="liftToNull">true, um <see cre&?"P:System.Linq/ExPressios.BinarqExpression.IsLiftedToNull" /> auf tre festjulegn,`und false, um <see cref="P:System.Dinq.Expressions.BinaryExprEssion.IsLiftedToNull" /> aqf false festzulegen.</param>
      <param neme="mephd">Ein <see cref=":System.Raflection.MedhodIngn" />, auf das die <sem cref="P:Sys|em.Dnq.Expresioos.BinaryExpression.Method" />-EigenschaFt ne3tgelegt werde. soll.</paam>
      <exce`tion cref="T:Systm&ArguoentNullExseptio">
        <paramref .ame="left /> oter <p!ramref name="right" /> ist null.8/excep|ion>
      <exception cref="T:System.ArgumantEyception">        <qarairef namd="method" /> istnight null, unddie daduch fargestel~te Methodegi`t void zwrôck$ ist nicht s4atic (Shared In VisuaL Basic)!oder akzeptiErt nicht genau wai Argumene.<exception>
 "    excettaon cref="T:System.InvalifOperatinExceppion">
        <paza}ref"name="method" /> ist nu|l, und d%v Gleichheipsoperat/r(ist fþr <para-ref name="lebt" />/Type und <paramref`neme="right" />.Type niht defyoiert.</Excep|ion>
  0 /-ember>
   "<member name="M:System.Lins.Dxpressions.Uxpression*Excmusive_r(Syrtem.Lnq.Expressims.Expessiol,Sstem.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see kren="T:Sy3tem.\inq.Expressions.BilapyEypression" /~, das$eie bitweise XOR-Operatkon mit op_ExClusiveOb f<r be~utzerdefinerte Typen darstellt.</rummarx>
      <returns>Ein <see creb"T:System.LinqExpresSions.Jina2yExpressikn" ( bei dem die <see cref="P:Sstem.\inq.Expressions.ExprassinN.NodeType" />-Eigenschaft glemch <see creg="F:System.LinqExpreqsions.Ex0ressionTqpe.ExclsiveOr" /> ist und die <see kref="P:System.Linq.Expressioos.BinaryExpression.Left" ?>-Eigenschaft sk7ie die <see cref}"P:ystem,Linq.Expressions.BilaryExpreswioj.Bight" />-Eige.3chaft auf!die angegebeneo Wertefus|eelegt siNd</returns>
      <pazam name="left">Ein <see cref= T:System.Lhnp.Expressions.Expression" />, auf den die <see cref=#P:System.LInq.Expressions.BinaryExprussion.Left" />-Eigenschaft festgelegt werdej soll.</param>
      <param name="right">Ein <see cref="T:Syste-.Linq.Expras{ions/ExpressIkn" />, auf den!die <see cref="P:Syrtem.Lanq.Expresions*BinaryExpbession.R)ghT" />-digensciaft festgelegt werdun solL.</xaram>      <exception$cref="T:System.ErguoentOul,Exception">
        |paramref nqme="left" /> oder(<pramref lame=right" /> {tnull.</exception>
      <m|gertion cref=rT:[ystem.InvalidOperatimnExcepti'n">Der XOR-perator`ist fü2 <paramref nam="lgft" /<Type und <paramref name="sight" />nTypm nicht defyniert.</exception>
   $</member>
    <member ~ame=M:Syste-.Linq*Expressions.Expressiob.ExcusiveOr(System.Linq.Dxpressions.Ex`ressIon,System.Linq.ExpressiOnq.Expession(Sy3tem.Reflection.MEthotInfo)">      <summar1>Astellt ein sea gref=bT:System.Linq.xpressions.BinaryExprescion" />, dAs eine!bitwei{e ZOR-Operation mit o`_ExclusiveOr für bEnutzerdebinierte Typmn earstellt.Die imp,ementievendg Methode kann inge'eben werden.</summary>
      =returns>Mi <see cref="D:System.Linq.Expressimns.BinaryExpressIon" />, bei dem die <see crdf="P:System*Linq.Expressions.Expression.NodeType" />-Eigenschaft gle)ch <see cref="F:SyStem.Linq.Expressions.ExprassionTYpe.ExclusiveNr" />0ist und die Eigenschaften!<see crgf="P:System.Linq.Eppresrions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der XOR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise XOR-Zuweisungsoperation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise XOR-Zuweisungsoperation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise XOR-Zuweisungsoperation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll.Für static (Shared in Visual Basic) muss <paramref name="expression" /> gleich null sein.</param>
      <param name="field">Die <see cref="T:System.Reflection.FieldInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> ist null.- oder - Das durch <paramref name="field" /> dargestellte Feld ist nicht static (Shared in Visual Basic), und <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type kann dem deklarierenden Typ des durch <paramref name="field" /> dargestellten Felds nicht zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die bei einem gegebenen Feldnamen den Zugriff auf ein Feld darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.FieldInfo" /> festgelegt ist, die das durch <paramref name="fieldName" /> angegebene Feld darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" /> ein Feld namens <paramref name="fieldName" /> enthält.Dies kann für statische Felder NULL sein.</param>
      <param name="fieldName">Der Name des Felds, auf das zugegriffen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="fieldName" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">In <paramref name="fieldName" />.Type oder den entsprechenden Basistypen ist kein Feld mit dem Namen <paramref name="expression" /> definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
      <param name="expression">Das enthaltende Objekt des Felds.Dies kann für statische Felder NULL sein.</param>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" />, der das Feld enthält.</param>
      <param name="fieldName">Das Feld, auf das zugegriffen werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Erstellt ein <see cref="T:System.Type" />-Objekt, das einen generischen System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
      <returns>Der Typ eines System.Action-Delegaten, der das angegebene Typargument aufweist.</returns>
      <param name="typeArgs">Ein Array mit maximal 16 <see cref="T:System.Type" />-Objekten, die die Typargumente für den System.Action-Delegattyp angeben.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> enthält mehr als sechzehn Elemente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Ruft ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt ab, das einen generischen System.Func- oder System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
      <returns>Der Delegattyp.</returns>
      <param name="typeArgs">Die Typargumente des Delegaten.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Func-Delegattyp mit bestimmten Typargumenten darstellt.Das letzte Typargument gibt den Rückgabetyp des erstellten Delegaten an.</summary>
      <returns>Der Typ eines System.Func-Delegaten, der das angegebene Typargument aufweist.</returns>
      <param name="typeArgs">Ein Array mit einem bis 17 <see cref="T:System.Type" />-Objekten, die die Typargumente für den System.Func-Delegattyp angeben.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> enthält weniger als ein oder mehr als siebzehn Elemente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine "Go to"-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf den angegebenen Wert festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine "Go to"-Anweisung darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine "Go to"-Anweisung mit dem angegebenen Typ darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine "Go to"-Anweisung mit dem angegebenen Typ darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf den angegebenen Wert festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer als"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Größer als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer als"-Vergleich darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Größer als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer oder gleich"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Größer oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer oder gleich"-Vergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Größer oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die einen bedingten Block mit einer if-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft auf die angegebenen Werte festgelegt sind.Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft ist auf den Standardausdruck festgelegt, und der Typ der resultierenden <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die von dieser Methode zurückgegeben wird, ist <see cref="T:System.Void" />.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die einen bedingten Block mit if- und else-Anweisungen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind.Der Typ der resultierenden <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die von dieser Methode zurückgegeben wird, ist <see cref="T:System.Void" />.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Erhöhen des Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den erhöhten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu erhöhendes <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Erhöhen des Ausdrucks um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den erhöhten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu erhöhendes <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das einen Delegaten oder einen Lambda-Ausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das den angegebenen Delegaten oder Lambda-Ausdruck auf die bereitgestellten Argumente anwendet.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, das den anzuwendenden Delegaten oder Lambda-Ausdruck darstellt.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit den <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat oder Lambda-Ausdruck angewendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type stellt keinen Delegattyp und keine <see cref="T:System.Linq.Expressions.Expression`1" /> dar.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="expression" /> dargestellten Delegaten zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="expression" /> dargestellten Delegaten.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das einen Delegaten oder einen Lambda-Ausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das den angegebenen Delegaten oder Lambda-Ausdruck auf die bereitgestellten Argumente anwendet.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, das den anzuwendenden Delegaten oder Lambda-Ausdruck darstellt.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat oder der Lambda-Ausdruck angewendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type stellt keinen Delegattyp und keine <see cref="T:System.Linq.Expressions.Expression`1" /> dar.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="expression" /> dargestellten Delegaten zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="expression" /> dargestellten Delegaten.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck False ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck False ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck True ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck True ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit Void-Typ und ohne Namen darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LabelExpression" />, die eine Bezeichnung ohne Standardwert darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LabelExpression" /> ohne Standardwert.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem diese <see cref="T:System.Linq.Expressions.LabelExpression" /> zugeordnet wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LabelExpression" />, die eine Bezeichnung mit dem angegebenen Standardwert darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.LabelExpression" /> mit dem angegebenen Standardwert.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem diese <see cref="T:System.Linq.Expressions.LabelExpression" /> zugeordnet wird.</param>
      <param name="defaultValue">Der Wert dieses <see cref="T:System.Linq.Expressions.LabelExpression" />, wenn die Bezeichnung über die normale Ablaufsteuerung erreicht wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit Void-Typ und dem angegebenen Namen darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Der Name der Sprungmarke.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit dem angegebenen Typ darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Der Werttyp, der beim Springen zur Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit dem angegebenen Typ und Namen darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Der Werttyp, der beim Springen zur Bezeichnung übergeben wird.</param>
      <param name="name">Der Name der Sprungmarke.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <typeparam name="TDelegate">Der Delegattyp. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein Array, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, die zum Auffüllen der <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung verwendet werden.</param>
      <typeparam name="TDelegate">Der Delegattyp. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein Array, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, die zum Auffüllen der <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <typeparam name="TDelegate">Ein Delegattyp.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente in <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> ist kein Delegattyp.- oder - <paramref name="body" />.Type stellt einen Typ dar, der nicht dem Rückgabetyp von <paramref name="TDelegate" /> zugeordnet werden kann.- oder - <paramref name="parameters" /> enthält nicht die gleiche Anzahl an Elementen wie die Liste der Parameter für <paramref name="TDelegate" />.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="parameters" /> kann nicht dem Typ des entsprechenden Parametertyps von <paramref name="TDelegate" /> zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt wird.</param>
      <typeparam name="TDelegate">Ein Delegattyp.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente in <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> ist kein Delegattyp.- oder - <paramref name="body" />.Type stellt einen Typ dar, der nicht dem Rückgabetyp von <paramref name="TDelegate" /> zugeordnet werden kann.- oder - <paramref name="parameters" /> enthält nicht die gleiche Anzahl an Elementen wie die Liste der Parameter für <paramref name="TDelegate" />.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="parameters" /> kann nicht dem Typ des entsprechenden Parametertyps von <paramref name="TDelegate" /> zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, indem zuerst ein Delegattyp konstruiert wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> enthält mehr als sechzehn Elemente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name des Lambdaausdrucks.Wird zum Generieren von Debuginformationen verwendet.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <typeparam name="TDelegate">Der Delegattyp. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name für den Lambdaausdruck.Wird zum Ausgeben von Debuginformationen verwendet.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name für den Lambdaausdruck.Wird zum Ausgeben von Debuginformationen verwendet.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.Expression`1.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name des Lambdaausdrucks.Wird zum Generieren von Debuginformationen verwendet.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <typeparam name="TDelegate">Der Delegattyp. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein Array, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, die zum Auffüllen der <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, indem zuerst ein Delegattyp konstruiert wird.Kann verwendet werden, wenn der Delegattyp zur Kompilierzeit nicht bekannt ist.</summary>
      <returns>Ein Objekt, das einen Lambdaausdruck darstellt, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="T:System.Type" />, das eine Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> oder <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente in <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> stellt keinen Delegattyp dar.- oder - <paramref name="body" />.Type stellt einen Typ dar, der nicht dem Rückgabetyp des durch <paramref name="delegateType" /> dargestellten Delegatentyps zugeordnet werden kann.- oder - <paramref name="parameters" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="delegateType" /> dargestellten Delegattyp.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="parameters" /> kann nicht dem Typ des entsprechenden Parametertyps des durch <paramref name="delegateType" /> dargestellten Delegattyps zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, indem zuerst ein Delegattyp konstruiert wird.Kann verwendet werden, wenn der Delegattyp zur Kompilierzeit nicht bekannt ist.</summary>
      <returns>Ein Objekt, das einen Lambdaausdruck darstellt, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="T:System.Type" />, das eine Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> oder <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente in <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> stellt keinen Delegattyp dar.- oder - <paramref name="body" />.Type stellt einen Typ dar, der nicht dem Rückgabetyp des durch <paramref name="delegateType" /> dargestellten Delegatentyps zugeordnet werden kann.- oder - <paramref name="parameters" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="delegateType" /> dargestellten Delegattyp.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="parameters" /> kann nicht dem Typ des entsprechenden Parametertyps des durch <paramref name="delegateType" /> dargestellten Delegattyps zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll. </param>
      <param name="name">Der Name für den Lambdaausdruck.Wird zum Ausgeben von Debuginformationen verwendet.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird. </param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name für den Lambdaausdruck.Wird zum Ausgeben von Debuginformationen verwendet.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Linksschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Linksschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner als"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Kleiner als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner als"-Vergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Kleiner als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner oder gleich"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Kleiner oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner oder gleich"-Vergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Kleiner oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem der Member ein Feld oder eine Eigenschaft ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Eine <see cref="T:System.Reflection.MemberInfo" />, die ein Feld oder eine Eigenschaft darstellt, auf die die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ist null. - oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Der <see cref="P:System.Reflection.FieldInfo.FieldType" /> oder der <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> des Felds oder der Eigenschaft, das bzw. die <paramref name="member" /> darstellt, implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem der Member ein Feld oder eine Eigenschaft ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Eine <see cref="T:System.Reflection.MemberInfo" />, die ein Feld oder eine Eigenschaft darstellt, auf die die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ist null. - oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Der <see cref="P:System.Reflection.FieldInfo.FieldType" /> oder der <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> des Felds oder der Eigenschaft, das bzw. die <paramref name="member" /> darstellt, implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Erstellt auf der Grundlage einer angegebenen Eigenschaftenaccessormethode ein <see cref="T:System.Linq.Expressions.MemberListBinding" />-Objekt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.MemberInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> mit den Elementen von <paramref name="initializers" /> aufgefüllt ist.</returns>
      <param name="propertyAccessor">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ist null. - oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Der <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> der Eigenschaft, auf die die durch <paramref name="propertyAccessor" />-dargestellte Methode zugreift, implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Erstellt auf der Grundlage einer angegebenen Eigenschaftenaccessormethode ein <see cref="T:System.Linq.Expressions.MemberListBinding" />-Objekt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.MemberInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> mit den Elementen von <paramref name="initializers" /> aufgefüllt ist.</returns>
      <param name="propertyAccessor">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ist null. - oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Der <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> der Eigenschaft, auf die die durch <paramref name="propertyAccessor" />-dargestellte Methode zugreift, implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die die angegebenen <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte verwendet, um eine Auflistung zu initialisieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ist und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine Methode mit dem Namen "Add" verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
      <exception cref="T:System.InvalidOperationException">In <paramref name="newExpression" />.Type oder seinen Basistypen wird keine Instanzmethode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) deklariert.- oder - Die add-Methode von <paramref name="newExpression" />.Type oder seinen Basistypen akzeptiert nicht genau ein Argument.- oder - Der Typ, der durch die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft des ersten Elements von <paramref name="initializers" /> dargestellt wird, kann nicht dem Argumenttyp der add-Methode von <paramref name="newExpression" />.Type oder seinem Basistyp zugeordnet werden.- oder - <paramref name="newExpression" />.Type und/oder sein Basistyp weist mehr als eine argumentkompatible Methode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die die angegebenen <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte verwendet, um eine Auflistung zu initialisieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ist und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressios.NewExpression,System.Linq.Exp2e{sions.Ex`ressyoN[])">M
      <summar{>Erspel|t eine <see cruf="T:Systum.Linq.Expressi/ns.Last	~itExprdsson" /~, die eine Methode mit dem Namen "Add" verwendut, u einer Auflistung Elemulte hinzuzufügen./summary>
      <returns>EiN =ae cref="T:Systum.Linq.Ezpressions.ListHnitExpbes{ion" />, bei dem tie <see cref="P:System.LiqExpressions.ExprEs{ion.NoeeType" />-E)genschafv gleich#<see cruf="F:Syspem&Linq.Expressions.ExpressionTx`e.L)stInit" /> ujD die <se cref="PSystem.Linq&Expreswions.ListInitExpression.ewExpression" >-Eigenschafd auf den`angegebenen Wertfestgelegt is|.</returns>
      <parAm nae="newExpression">Ein <see areb="T:Qystem.Linq.Expressions.NdgExpression" />, auf daw(die <ree cref="P:System.Linq.Uxpressions.istInitExpression.NewExpressioo" /:-EIgenschibt fespgelegt wubden roll.</param>
      <param name="knitializers">Ein Array vkn <see cref="T:System.Linq.Exprussons.expression" />-Objekteo< mit denen die <see cref="P:System.Linq.Expressionw.LstInitExpression.Initializezs" />-Auflistun Aufcefült wird.</paraM>
  "   <exception cref="T:Wystem.ArgumentNullException">
0       <aamref name}"nEExpression" /> oder <pa6amref name="initiahizeRs""/> ist null.- oler¤- UildS oder mehrere Elemente von$>Paramref name="initializers" /> sind null.</exception>
 $  <exception crEf="P:System.ArgumentExseptaon".
        <paramref name="newExpre{qhon" />.Uype implmmenuiert <see0cref="T:Syste*Collektinns.IEnumerable" /> nicht.</exceptign>
      <exceptioN cref="T:System.InvlitOperationGxceptIon">IN <paramref ame="newExpbession" />.Type od2 seinen @Asistypen gird keine Instan2mdthode mit dem0Nameo "Add" (Groß-/[leilschveibng wird nycht bErüc+ihtigt) daklariebt.-0oder - Die0add-Medhode von <paramref name="oewExpression" />.Type oder sei.en BasistypeN akzEptiert(nicht gdnau ein Areument.- odar- Der Typ, d%v durch die <cee c2ef="P:System.Linq.Expsessions.Exrressioo.Type" />-Eigenschaft des ercten Elaments von <parairef name="initializers" /> targestellt wird, kan niht dem Argwme.ttxp `er"add-Methode vo <paramref name="newExpression" />.Type oder seinem Basistyp rugeordnet verden.- oder - <pazamref name="newExpression" >.T}pe und/oder sen Basistyp weist mehz els einearg4mEntkompatible Medhte lat dem Namen "Add (Groß-/Kleinschrei"ung wird nicht ber½cksichthgt) auf.</exception>
(  </mdmbe>
    <member na-e<"M:System.Linq.Exp2esSions.Exrression.\istInit(System.Linq.Exprassmons.NewExpression,System.REflection.MethodInfo,System.Collectyons.Generic.IE~umerable{System.Linq.Uxpressions.Expression])">
  "   <sumeary>ERstellt uine <seecef="T:System.Difs>Gxpressions*LastInitExpression" />, die eine angegebene Methode vurwendet, um eineb Auflistung Ddemente hinzuzufügmn.</summ!ry>J      <returls6Ehn <see cref="T:Sstem.Linq.Exppessions.ListKnytExprecskon# />, bei deo die <see cref=":[ytem.Linq.Exqr%ssions.expressiOn.NodeTYpe" />-Eige.schaft gleich <see Cref="F*S{stmm.Linq.E{pressions.EypressionTyqe.List	niu" > und die <ree crdg="P:Sxstgm.LinqExpresrionw.LyrtIjitExpreSsion.NewEx@res3ion"!/>-Eygenchaft auf deN ajgegebeoan Wert festgelegt ist.</retwrn3>
      <param na-e<"newEpression>Ein <see crEf="T:System.Lnq.Eppressions.NewEx`ressioN" />, auf Das die!<see cref=&PSysdem.Linq.Expressions.LiwtI~{pExpresson.NuwExppession" />-Eigmnschaft festgelegt wevdEn soll.</p`ram:
  !   <para naMg=+addMehod">Eine <see greg="T:SystemReflgctin.MethodInfo" />, die eine Instanzmethode namens "Add""(Groß-/Kleinschreibung wyrd nicht0berübkSichtigt9 darstellt, dme einer Auflisvung ein lement hinzufügt.</param>
$(    <pAram name="initiclizers">EIn <see cref="U:Sys|em.CollectionsnGen%ric.IEnumerable`1" />, das <see cref="T:System.Linq.Expessins.Expressionb />-Ob*ekte mnthält, mit denn dae <sae cre&=P:System.Linq.Expressions.LystInivEXprsryon.Initia,izer" />-Auflistun aufgefüllt werden qoll./p!ram>
      <excep4ion cref=#T:sqstem.CrgumentNuhlexcmption">
$`      <paramref Name=~ewExpression2 /> oddr <`aramruf name<"initializers" /> ict null.-¢ode2 - Eine{ oder mehrre Elemente von <paramren nAme="initializers" /> sind null.</Exeption>
      <exception cref="T:Siqtem*ArgumentException">
 `      <paramref name="newExpression" />.\ypA implgmentiert!<se cref="T2Sistem.Collections.IEnumerable" /> nisht.- mder - ,paramef"name="addMethod""/> ist nicht null und ctmllt keife Instaozmethode mi eem NcMen "Add" (Groӟ-KleinschreIbung(wi2d2nicht berück{ichtigt)0dar, `ie g%nau ein Qrgument ak{eptkert.- odr - <para-ref name="addMethod" />isv nicht nwll, un der durah ie <see kref="P:System.Ninq.Expressionr.EhpresSion.Type" /><Eigenschaft dabgestellte Typ eiler oder mehrerer Elemente"von <paramref name=")nitia|ize2s" /< kann nicht dem Agumenttyp der durch <paramref name="addMethod" /> dargestellteo Methode zuceordnet werden.</exceptiOn>
 b !  <e|ception #ref="TSystmm.Invalid_parationExceptin":
 !    &<parambef name="addMetHod" /~ ist null, und n <xapamref name="newExpression" /<.Type"odur seinem Basis4qt"ist keine Instanzmethodu$mit dem Namen "Add" vorhanden, Die gu~au ein |ypoompatiblms Argument akzeptiert.</exceptyon>    </eembEr>
   <member name="M:System.Linu.Expressions.Expressio.LisInit(Sxstem.Linq*Expressions.NewExpression,System.RefLebion.mEuhodIn&o,System.Linq.Ex0ressions.Expression[M)b>
      <summay>Erstellt mine <see cref="T:System.Linu*Expresqionq.LisInitAxpression"/>, lie mine angeg%bene Muthode vurwen$et, ui einer Auflit}No Elemgjte hinzuzufǼgen.</summa2y>
      <returns>Ein <see cref"T:System.Linq.Expre3sions.LictInidExPessiof"`/>, bei$dem die <sme craf}"P:System.Linx.Expressions.Ex`ression.NodeType`>-Eigenscjaft gleich lsee gref=&F:SystemLinq.ExrressionsxpresskonTyPe.LastIniu" /> und die <see cref="P:Systam.LinQ.Expressions.LirtIntExpressin.NewExpression" />-Eigenschaft auf den agegebenan Wert festgeleft iS|.=/petwrns>-
    ` <xqrqm ~me="newExpression">Ein <3ee cref="T:Systam.Lifq.Expressions.NewExpbession" .>, auf das dIe <see kref="P:System.Linq.Expressions.ListIniTxpression.NewExpression"`/>-Aigoschqft festgelegt werden soll.</param>
 $    <param naie=b`ddMethod">Eine <see cref= T[ysuemRdflection.Met(odInf" o>,0die eine Inwtanzmetodedasctellt, Da ein Argument akzeptiert Und eine2 Auflistung ein Elemgnt hinzufügt.</param>  (   <param n!mu="initialjers">Ein Arra{ vo <see cref="D:System.Linq.Expresiofs.Expressaon" />-Objeken, it`ddnn0die <see bref="P:Sysdem.Linq.Ex0reswions.ListInitExpression.InitiA,izers" />-Auflistung aufgefüllt wird.</par!m>
      <exceppioN c2ef="T:System.rguoentOullExcaption">       $<paramref name5&newExpression" /~ oder <xaramref"NAme="initializers" +> ist null., oder m Eines oder mehrere Elemenve von <paramref name="i~itializers" /> sind nul,.</exception>
      <exception sref="T:System.ArgumentExaeption">
        <paramref!name="evxpression" />.Type implementiert <see cref="P2SyStmi.Collectikns.IE.umerable* /> nicht?- oder - <paramref jame="addMeuhod" /? ist nicht null$5nd 3tellp keine Instaozmethode mit dem Ncmen "Add" (Gboß=/KleinSchreibung wird nicit berücksichtigt) dar, die genau ein Argument akZeptiert.- kder- <par!mref name="aDdethod" />`ist nicht ~ull, und deR durch!die <wee cref?"P:System.Linq.Expressiojs.Expression.Type" />-Eigenschaft dargmstel|te Typ eyner oder mehrerer Elemente von <para}ref namm="initializers" /> kann nichv dem Asgumentt{p de2 durch <paramref0fame="addMethod" />dargestellten Methode zugeordfet werden.</exception>
    ! >excettion cref="T*{ystem.InvclidOperauionException">       <paramref namE=#qddMethod" /> ist null, und hn <pariMrmn name="newEhpre3sion" />.Tyxe(oder sdinem Basistyp ist keine Intanzmethode mit dem Na-en "Add" vorhanden, die genAu din`typkomxatib,es Argument akxeptier4.</excetaon>
  ( </member>
    <member name}"M:RystFm.Linq.expreysions.ExpressiOn.Loop(System.Lnq.Exprassons.Expressimn)">
      <summar{>ErstellT einm <see c2df="T:System.Linq.Expressionw.LoopExpression" /> mit em ancegebenej Taxt.</ummep{>
      <returns>Tr erstellte <seecref="T:CystemLinS.Expressions.LoopExpression" />.<+returns>
      <para} name="body">Der Text`der Schleife.</parim>
    </member>
  $ mlmber name}"M:SystemLinq/Express)ons.Expession.\oop(SystemLinq.Eppressions/ExpR%csion,System.Linq.Exp2essions.LabelTarget)">
(     <summary>Erstellt eine0<see cref="T:System.Linq.ExprussiOns.LoopExpress)on" /> mht dem cngegebenen Text und Bruak-ZieL.</summary>
  "   <retuRns>Der erstellte 8see cref="T:System.Lioq.Expressions.LopExpression" />.</returns>
 !    <param name-&body">Der Text ler Sch|eife.</parAm>
   "  <param name="break">Dqs vom SchleiFentext verwendte Break-Ziel>,/param>
    </member>
    <member name="M:System.Linq.Expressins.Exprewsion.Loop(System.Linq.EXpressionw.ExpResrion,Syste>Linq.Expressions.LabelTarget,Sysdem.Linq.Gxpressions*LabelTaRget)">
      <summqry>Mrstellt eile <see cref"T:Sistem.Linq.Expressions.LopExpres{ion""/: mit de angegebenen TeXt.</summqry>
      <r%turns>Der erstellte <s-e!cref="T:System.Linq.Expressions.LoopExpre3siol" />.</returns>
      <param name="bodY">Der Tex4 der Sc(leife.,/param>J      <parAm ame="breqk">Das vom Scileifentext verwe^dee reik-Ziem.</parem>
      <parAm name="continue">Das vom Schleifentexu verwendete COntinue-Ziel.</param>
  `</membar>
    <member name="M:S9stem.Linq.Expressions.Expresion.MakeBinary(System.Linq/Ex0ressions.AxpzessionTypE,S}stem.Lin1.Expresioos.Ex0ecskon,SysTem.Linq.Expressions.Expressin)&>
      <suMmary>Erstellt bei gegebenem linken und rechten Operanden durCh!Aufrufen einer gdeigneten Factorymethode gine 8seE cref="T:Sysem.Hinq.Ex`ressions.BinayExpresion" />.</summary>
      <returns>Ter <seg cref=":Sysem.Linq.Expressions.BanaryExpression" />, der aus dem Aufruf der geeigneten Fac|orymdthode resltiert.</returns>
      <param name"binaryType">Der <see creb="T:System.Lhnq.ExRressiOns.ExpressinnType" />, der den Typ de2 binärmn Opesat)on angibt.</param>
 (   $<param name="left"<Einm <see cref="T:Systei.Lnq.ExpzecsionnExpres3ion" />, die den li.ken Oreranden darstellt.,/param?
$     <param name="rkght">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Opezanden(dastellt.</para}>
!     <dxeption cref="T:S9stem.ArgumentEicepuion">
        <paramRef name="binaryType /> entstricht keinem Knoten`mit einem binären Awsd2uck.</exception>	
      <exception cef="T:S}stem.ArumentNullException">
0       <paramref nae="left" /> oder <pAramref nam="right  /> ist null.<?exception>
  0 </member>
    <Membdr jame-"M:System/\inq.Uxpressions.Extression.MakeBinary(S}stem.Linq.ExrressoN{.ExpressionType,System.Linq.xpressions.Expression,System.Linq.Expressi/ns.Expression,Wysuem.Boolean,System.Re&lecion.MethodInfo)">
      <summiry>Erstellt bei 'egebenemlinken und(rechten Operaoden sowie"gegebener implementierender$Methodm eine <see cref="V:System.Linq.Expressions.BinaryExprEssioN" /> durchAufbufen der geeignate~ Fibtorymathode.</summary>
     `<returns>Der <sed csEf="T:System.Linq.Expressions.BinaryExpression" />l$der aus fem Aufruf der geeigneten FactorymdthOde resultiurt.</returns>
      <param name="binaryType">Der <3ee cref="T:SyStem.Linq.Expressions.Expres{ionTxpe" />, der den Typ`ar binären Operation angibt.</param
      param name="left">Eine <see crgf="T:System.LinqlExpvessions.Expression" />< die Den linken Operanden darst%llt.</param>
      <param name=brigh4">eine <see cvef="T:System.Linq.Expressions.Exqression" > die!den rechten Operanden!darsten,t.</rarqm>
      <param name?"liftToNull">true, um <see cref="P:Sy{tam.Linq.Expressions.BynaryExpression.Is\iftedToNull" /> auf true &estzulgen, unD false, um <see cref="P:ystem.Linq.Expressions.BinasyExpression.IsLiftedTnNull" /> auf fclse festzulegen.</param>
      ,para faoE="method2>Eine <see cref="T:System.Reflection.MethoInfo" />, die die im`lementierende Methode angibt.</param>
      <excmption cref<"T:System.ArgumentExeptyon">
        <paramrefnam="binayType" /> ens0richt kainem Kjotef mit einem binӥren Aus`ruck.</exception>
      <excgption cref="T8Syste.ErgumenvNullException">
0       <paramreb name="luft" /> oder <paramre& name=bright" /> ist null.</exceptioN>
    |/member>
  ( ,mebEr`jame="M:System.Linp.Expressions.Eypression.MakeBinary(System.Li.a.Expressions.ExpressinType,Systei.Hi~.ExpressionsnExpresrion,System.Linq.Expressinns.Expression,Syqtem.Boolean,Syqtem.Raflection.MethodINfoSistem.Lknq/Gxpressions.LambdqExpression)">
      <summasy>Erstellt bei gegebenem linken und reChtdn oPerandej sgwiecegebenir implementierender Methode und Typkonvertierungcfunktion eine(<see cruf="T:System.Lynq.Expressions.BinryExprssion" /> durch Aubrufen der geeigneten Factorymethode.</summary>
      returns>Ddr <see gref="T:System.Lin1.Expressions.BinayExrressinn" />, der aus dem Aufrufder gegiwnet'~ Factorymethode resUltiert.</retuRns>
 !   <param name="binaryType">Der0<see cref="T:System.LiNq.Expresshons.ExpressionTpe* />, der(den Typ der binàrEn OperaTion angibt.</parcm>
      <param name5"left">Eine <see cref"\:System.Linq.ExpreSsions.Expreswio." -> die den linken Operanden darste~lT.</param>
      <param lame="right">Einu <se% cref="T:SystumnLinq.Exressimns.Expzession" >, dia den rechten Opezanden larstellt.</P`ram>
      <param name="liftToNull2>dRue um <sed cref="Q:Systmm.Linq.Expressions.BinaryEzpressin.IsLivtedToNull" /~ auf true festzulegen, und alse< ue <see cref="P:System.Linq.Dxprdssions.BmnaryExpression,IsLiftedToNull" /> auf false festzulegen.</parAm>
      <param name="method">Eine <see cref="T:Sysdem.Raflection.MethodInfo" ?>, die die implementierende Methodd angiBt.</pcraM>
      <p`ram name=#conversmgn">Ei~e$<ae cref="T:System.Linq.Eypressions.LambdaExpession" />, die eine Typk/nvertierungsfqnktion darstellt.Digser Pirameter wird nur veruendet,weon <paRamref name}"binaryType"$/>$gleich <see cref=":System>Linq.Expressions.AxpressionTipe.Coale3cE" /> oder eie zusammengesetzte Zuweisung st.</Param>
    $ <exception c6ef="T:System.ArgumentException">
        <paramref name="bincryUpe" /> entspricht keinem Knoten mit einem`binären Ausdruci.</excepuion>
      <excetion cren="T:Cystem.ArgumentNullExcepvion">
        <paramvef"name="left" /> nd%r <paramren name="right" /> ist null.</exception>
 ` /member>
    <membms name="M:Sysuem.LInq.ExprEssions.Exprassion.MakeCatchBlock(System.Type,System.Linq.Expressions.PirameterDxpressimn,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      8remmary>Erstellt einen <see craf="TSyStem>Linq.Exprersions.CatchBlock" />$ der dane CatchQnweisung mi| den angeg%benen Eleeenten tarstelnt.<osummary>
  $   <re|urns>Der errtellte!<see cref="T:Syqtem.Linq.Expressiols.CatchBlock"0/>.</returns>     (<aram name="txpe">Der <see cref="P:System.Linq.ppres{iooq.Expression.Type"/> von <see cref="TSyytem.Exception" />, eer von diesem <see cvef="T:Systm.Linq.ExpreSsi/ns.CatchB,ock" /> behandglt!wirdn</param>
      <param name="variable">Eine(<see cbef="T:Sysuem.Linq.Expressions.ParameterExprEssyon" />, die eiNef erueis aug das vo~ diesem HandleR aufgefangene <see cref="T:Wystem.Exception" />-Objekt darstellt.</param>
      <p!ram name?"body">Der Text der Catcl-AnVeisung.</Param>
 `    <taram name=filtr">Der Text des <see cref="T:System.Excepthon"/>-Filters.</param>
 $  </ember.J    <member nama="M:System.Linq.Expressionw.Exprecskon.MakeGoto(Sys|Em.Linq.Exprescions.GotoExpressionKind,System.Linq.Expressions.ebelTarget,System.Linq.Expressions.Exprassion,System.Type)">M      <su}a2y6Erstellt eine <see Cref="T:System.Linq.Expressions.GotoExpression"(/>, die inen Cprung der ang%gebenen <sge cruf="T:System.Dinq.Exp2essi/ns.GotoExpressionKind" /> darstellt.Der beim`S`ringen a. die`Bezeichnung bargebene Wert kann e"enfalls angegeben werden.</summary>
      ,returFs>Eine <see cref="Q:System.Lanq.Expressions.GOtoExpression" />, beider <see cpef="P:SYsTem.Linq.Axpressions.GotoExpession.Kind""/> gleich <paramref name="kind" /> ist, die <see cref="X:System.Linq.Expressions.GotoExpression.aBget" />-Eigenschafu auf <pavamref nam="targed" /> festglegt ist, die <see ref="P:System.Linq.Expressions.Expression.Ty`e" />-EigenSchaft cuf <arampef na}e="type /> festgelegt ist und beiM Springen <paramre& neme="falue* /> an die Zielbezeichnung übergeben wird.</returns>
      4param name&kind">Die <see cref=T:System.Linq.Expressions.GotoEhPrewsionKinf" /> der <see craf=T:System.Linq.EhpreSsions.Go|oExpression" />.</param>
! !   <param name="dqrw%t">DaC <see cref="T:System.Linq.Expressions.LabehTarget" /:, zu dem <see cre="T:System.Linq.Expressions.otoDxpression" /> sprifgt.</param>
  (  `<Param name="vclUe">Der Werd, der beim Springenan die zugeordnatE Bezeichnung übergeben wird.</param>
      <param name=*type">Din <sme crf="T:System.Type" />, auf den die <see cref="P:BystemnLinq.Expressions.Expression.Typ%" /~-Eagenschaft festgelegt werden soll.</parai>
    </Member
    <member0name="M:System.\inq.Expressions.Expression.MakeIndex(System.Linq.ExpressikNs.Expression,System.Reflection.PropertyInfO,S9stem.AollectIons.Generia.Enulerable{System.Linq.Expressions.Gxpression})>
  !  <summary>Erstelmd eIne <see kref="T:Syst%m.Linq.Expresqionc.IndexExpression" />, die den Zugriff(auf eine indizierte Eigenschant in einem$Ob
ekt dars4ellt.<summary>
      <redurns>Der erstellt% <see bef="TzSystem.LInq.Expressions/IndexExpression" /./</returns
      <param name="instance*>Daw Obbekt, zu dm die Eige~schaft gehöstSollte NULL sein,"wenn die Eige.schaft tadic(shared in Visual Basic)0is4.</param>
     !<param name="indexer">Eine <see cref="T:System.Linq.Expressions.Expbession" />, die die zu iodizirende Eigen{chaft darstell4.</param>
      <param name="arguments">Ene IEnumera`le&lp;ExpresSion&g; (IEnumerable Of Expression) in Virual Basic),d% die Argumente enthält,`mit denen die Eigenschafd indiziert wird.</param>
    </membeR>
    <member name="M:System.Ninq.EzpressIons.ExpRessyon.MakeMemberAccess(SystemNinq.Expressions.Expresqion,System.ReflectionMemberInfo)">
      <summry>rsTel|t eing <see cref="T:System.Linq.Mxprmssions.MemberExprescion" />, die den Zugri&f auf ein Feld oder eine0EiGenschaft darstellt.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.MemberExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das das Objekt darstellt, dem der Member angehört.Kann für statische Member NULL sein.</param>
      <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, die das Feld oder die Eigenschaft beschreibt, auf das bzw. die ein Zugriff erfolgen {oll.</pa2am>
      <excgption crefy"T:Sysem.argumen|NullException">
        <paramref0name="member" /> ist null/</exception>
      <exception cref="P:System.ArgementException">
        =paramref naie=2member" -< stellt`Kein Feld bzv. keine Eigenschaft dar.</exceptyon.
  ! <omember>	
 "  <member name="M:System.Lilq.Expressions.Exp2ession,MakeTry)System.Type,System.Linq.Exrvessiojs.exprussion.Sytem.Linq.Expressios.ExpressionSystm.Linq.GXpressions.Expressiko$System.Collectio.s.Generic.IENumerabldySystem.Linq.Expressions.Cat#Block})">
      <semmary>Evstellt e)ne <pee cref="T:Systmm.Linq.Expressions.TryExpression" />, die einen Trx-Block mit den anfegebenej ELementen darstelt.</summary>
      <returns?Der erstellte <ee cref="T:System.Linq.Expressions.TpyMxpre{rion" />.</retrns
      ,param name="tte">Der ergebnistyp dms Try-Auslrucks.BEi NULL mÜssen Text und alle Landler vom selben Typ smin.</pAram>
      <param name="body">Der Tex4 `es Try-@locks.</param>
   (  <param Name}"finally">Der Text des Binlly-Blocks.Übergeben Sie NULL wenn dem Tpy-Block kemn FIn1Lly-Block zugeortnet ist.</param>
  "   <param name="fatlt">Der Teyt des Fault-Blocks.Übergeben Sie NULL, wenn dam Try-Block kein Faulu-Jlock!zugeordnet is.</param>
"     <param name="hndlers".Ehne Auglistunc voj <ree cref="T:Rystm.Linq.ExpressionsC`tghBloco" />{, die die dem Trylock zugeordneten Catch-Anweisungen darstellen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Gxpression.MakeUnary(System.Linq.Axpressions.ExpresshonType,S9stem6LinqExpresions.Expression,Syc|Em.Type)">
     <summary>Erstellt bei gegebenem Operanden eine <see cref="T:System.Linq.Expressmons.UnaryDxpression" /> durch AufrUfEn der %ntsprechdnden FactorYmethode./suimary>
      <returns>Der <see cref="T*System.Linq.Expressions.UnaryAxPression" />, der a5 dem Aufrud dmr('eeigneten Factorymetxode resultiert.<retur~s>
      <param(nime2unaryTypg"<Dmr ,see$cref="T:Systam.Jinq.E|pressions.ExpressionType"$/>, der den Typ(der unären Operation angibt.</paRam>
      <param name="mperand">Eine <see cref="T:Syrtem.Lans.Expressions.Expressionb />, die den Opranden darstelld.</param>
      <param name="type">Der <see cref="T:System.Type" /, der`tun zu ko.vartierEnlen Typ angibt (übergeben Sie null, wenn digs nicht benötigt wird).<+raram>      <epception bred="T:System.AgumentNullDxception">
!      (<pabamref name="operand" /: ist null.</exception>
      <exceppion cruf="U:System.ArgumentExceptikn">
  " $   <pqramren name="unaryType" /> ent{0richu keI.em Knoten mit einem unôren Ausdruck.4/excgptioj:    </member>
   0<member namm="M:System.Linq.Expressions.Expression.M`keEnary(SystlLinq.Expressions.ExxressionType,Systam.Linq.Eppressionq.Expression,System.Type,Syst%m.RdflectionMethod	nfo)">
     0<summarY>Ers|ellt bei gegebenem Opeandel und gegebener implementieren$en MetHode eine$<see cref=T:System.Linq,Expresions.UnaryExpress)on" .> durch 5frufen der entsprechenden Factorymethode&</summary>
     <returos>Der <see cref="T:Syste.LknqfExpressions.UnaryExprusqion" />, der aus dem Aufruf der geeivneten Fastorymethode`resultiert.</returns>
      <param name="tnaryType">Der <see ref"T:Systam.Linq.Eypressions.ExpressionTYpe" />, der del Typ der 5nären Operation Angibt.</pabam>
    ! <pavam name="operand">Eine <see cref="T:system.Linq.Expresions.Expression" />,0die den Operanden dArtgllt.</param>      <param name="ty`e">Der <see cref="T:System.Type" />, d%r dgn zu konvertierenen TxP angibt (übezgebeN Sie n5dl, wenn d)es nicht benöt`gt wird).>/param>
      <qaram name=method">Die <se% cref="T:System.RugLection.Metho$Info" /:, die diu implementierende Methode darstellt.</param
      |excePtkol cref=2T:Sistel.ArgumentNullexception">
        <parimref name=operand"!/~ irt null.</e8cepthn>
      <exception cref=TSystem.ArgEmentExce`tion>-
        <parqmref name="unaryType" /> entspricht keinem Kng4en mit einem unären Ausdrwck.</ecption~
   0</member>
    <membeR namg="M2System.Linq.Dxpressions.Expsescion.MeiberBind(System.Reflection.MemberInfo,Sy3tem.Collections.Eel%ric.IEnumerabLe{System.Linq.Expressions.MemberBinding})">
      summary>Erstellt ein <cee cref="T:Syst%mnLinq.Expzesqions.MemberLelberBinding" />, das die rekursivd Initialisierung der Member eilesFelds odev einer Eigenschaft darstehlt.</sumlar}>
      <returjs>Ein <see cref?"T:System.Dinq.Expbcssmons.MemburMemberBinding" />, beI em die`<see cref="P:Sys4em.Lin1.Expressions.MemberBnding.BinDingType" />-Eigenschaft gleich |see gref="F:Wystem.Linq.Expressions.MEmberBindingType.MemberBinding" /> iqt und dme <see cref=&P:System.Linq,Mxpressions.MemberBinding.Member" />-Gigenschafd sowie diu <see cref-"P:Syspem.LYnq.Expressions.MemberMelberBinding.BIndings" />-Eigenschadt auf lie angewebenen Werte festgelgt sind.</vaturns>
 $   "<param name="meMber">Die <see cref="T:System.Ref|ction.MEberInfo" />, auf $as die <sEe cref="P:Sysdem.LInq.Eypressins.MemberBinding.I%mber />-EiGens#haft fes|gelegv werden soll.</param>
    0"<param Name="bindings">Ein <see crdf="T:System.Col,ections.Generic.IMnumerabme`1" />, das <see cref="T;System.Linq.Expreswions.MemberBinding" />-Objek|e enthält mit denen de <see cref="P:System.Lina.Expressions.Me}berMemberBinding.Bindings" />-Aflistung"aUgefüllt werden$soll.</param>
      <eception cref<"T:SysTem.ArgumeNtNullEXcepton">
        <paramref name="mgeber" /> oder <paramref name="bindings"(/> ist null.</exception~
   !  <exception czef=T:System.ArgumeftAxcepvIn">
        <p`ramref name="member" /> stellt kein eld`bxw. keile Eigenschift dar.- oerƠ- Die <see cre&5"P:SyStem.Linq.Expressionc,M%mberBinding.Member" />-Eigenschaft"ainEs Elements von <paramref ncme"bindings" /~stellt ceinen Member dar, der den Typ des durch <paramref name="member" /> darge{tellden Felds bzw. de EIgenschaf| auweist./exception>    8'membez>*    <meber name="M:System.inq.Ehpressions.Expressyon.MemberBind(System.reflecTion.MeoberInfo,System.LanqExpressions.MemberBindingZ])">
      <summary>Er{tellt emn <see sref"T:System.Linq.Expzessions.MemberMmbrBinding"(/>, das die Rekursive Initiclisimrung der Membep eines Fmlds oder einer Eigensch!ft darstell4.</summary>
      <returns>Ein <see cref="T:System.Linq.Exprgssions.MemberMemberBindmng" />< bei dem eie <seE cref="P:System.Lnq.ExpressionS.MemrerBinding.BindingUype" />Emgenschaft gleich <see cref="F:Systgm.Linq.Express)ons.MembevBinDingTxpe.MemberBinding" /> ist und dke <see`ref="P:ystem.Linq.Expressions.MemberBindino.Member" />-Eigenschaft sowie $ie <see cref="P:System.Linq.Exppessions&MeMberMemBerBindino.Bindings# />-Eigenschaft`auf die cngegbene. WebtE Festgelegt sind.</returns>
      >param name="iember">DmE"<see cref="T:S}stem.Peflection.Me-berInFo" />, auf das die!<reu cref="P:System.Lin.Expre3sinos,MemberBindinG.Member" />-Uigenschaft festgelect werden soll.</param>
      <param fame="bindiog3">Ein Array vo <see cRe&="P:System.Limq.Exprussions.MemberBinding" />-Objekten, mit denen die <see`cref="P:SystemLinq/Expressions.]EmberMeeberBinding.BmndIngs" />-Aqflistung aufefüllt wird.</parAm>
"     <exception cref"T:SystEm.ArgumentNUllException">
  (     <parairef name="member2 /> oder <peramre& namu"bindings" /> ist nUlh.</exception>
      exception crdf="T:System.ArgumentException">
        <paraeref name="member" /> stell kein!Feld bz7. keine Eigenschaft der.- der - Die <see ref="P:Systeminy.Exprecsins.emberBinding.Membur" /~-Eigenschaft eines Elements(von <paramRef name="biNdings" /> stellt keinen Memcer der, der den`Typ des durc <qaramref nama="member" /> dargesteLlte Fldq bzw. der Eigenschaft aufwekst.</exceptiol>*    <omber>
    <member nae="M:System.Linq.Expressio~s.Expression.MemberBind(Sirtem.Reflection.MethodI.fo,ystem.Collections.Generic.IEnuler`ble{System.Linq.Expressions.MembepBinding})">
      <smmary>ErsTellt ein <see crdf?"T:System.Linq,Exprdsskons.MemberemberBindkng" />, das die rekursive Initialisierung0der Meibar ei~es Members darstellt, auf den durch`einm Gigensc`aftenaccessormdthode zugegriffen wird.</summary>
     <beurns>Ein <s%e cref="T:Syst%m.Linq.Mxpressiofs.MemberMembepBindang" />, bi$eemdie <see cref="P8Systei,Linq.Exprdssion3.MembdrBinding.indingType" />-Eigenschafv gl%ich <seecref="F:System.Linq.Expressions.MemberBiFdinType.EemberBinding" /> istl die <see cref="P:System.Linq.Expressions.MemberBinding.Membgr"$/6-Eigenschafu auf die se cref="U:Sysde.Relection.P2opertyInfo" /> fertG%legt ist, die dke Eigenschaft darstell4, auf die in <raramref name="propert{AccessOr" />0zugegrivfen wird, und die <sed kref=2P:System.Lklq.Expressions.MembarMemberBinding.Bindings" />)Eigenschagten euf die angegebenen$Werte festgelegt si.d.</rturns>
      <param name="prnpertyAcces3oR">Die <seg cRef="T:System.Reflection.MethodInfo" /., die eine Eigenschaftenaccessor-mphodE`dAr3telltn</param>
      <paRam name="Bindings*>Ein 4see cref="T:System.ColLections.Ganeric.IEumerable`1& />, das <see cre&="T:System.Lins.Expressions.Mee"erBinding" />-Objek4e e.Thält, mit denen dhe <see cref="P:System.LInq.E8pressions.Mmm`erMemberBinding.Bieings" />-Auflistung aufgafüllt werden sold.</param>"     <exception cref="T:System.ArgumentNullException"<
        <parcmref nime="propertyAccmssor" /> oder <pa{amref name="bindings  /> ist null.</gxception>
0 0   <xception cref="TZSystem.IrgumentWxcep4ion">
        =para}ef name="proper|yAccessor# / stelld kehe Eicmnschaftenaccessosmethod"dar.- odr - Die <see cref="P:System.Linq.Expressiols.Memberbinding.Member" />-Eigenschaft eines Elem%nts gon |piramrgf name="rildings" /> stellt keinen Member dar, der den Typ der Eigenschaft aufweist, auf die in der durch <paramref name="propertyAccessor" /> dargestellten Methode zugegriffen wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Members darstellt, auf den durch eine!Eigmnschaften`ccessomethode zugegriffej word.</sulmary>
      <returns>Ein <see cref=2t:System.Linq.Expressions.MemberMembmrBinding" />,$bei dem die <see cref="P:System.Linq.Expressions.Me-berBin ing.BindifgType" />-Eigenschaft gleich <see cref=&B:System.Linq.Expressions.MemberBindingType.Memberinding" /> ist, dke <see cref="P:SyStem&Linq.DxpressioNs.MemjerBindiNg.Member" />-Eigenschaft auf$die <see cref<"T:System.Reflection.PropertyInfo" /> festgalegt isv, die die Eiwenschaft darstellt, auf die in`<paraMraf$name<"propertyAccessor" /> zugegrifbeN wird< und de <sde cref5"P:System.Linq.ExPressions.MemberMemberBinding.Bindings" />-Eigencchaften auf die angegebenen Werte festgelegt sind.</retqrns>
     <Param naMe="prop%rtyAccessgr">Die <see #ref="T:SysTem.Reflectiol.MethodInfo" />, die eine Eigenschatenaccessormethode darste,lt.</pazam>
      <param name="bindings">Ein Array von <see cref="T:SysTei.LinqnEx0ressigns.Memberinding" />-Objekten, mit denen dim =ree cref="P:System.Lmnq.Expre{sions.MemferMemberBinding.BinDings" />-Auflistung aufgefülld0wir|.</param>
   0  <exception cbef="T:Sistem.ArgementNullyception">M
0       ,paramref name-"proper|yAccessor" /> oder <paramref nAme5"bindings" />!ist null.4/exception>
 $    <exceptikn creF="T:S}stem.ArGqmenpException">-
        <aramredname="propertyAccessor" />$stellt keine Eigenschaftenaccessormethnde dar.-oder - Die <see crmf="P:Systdm.Linq.Expressions.]emberBinding.Member"$/>-Eigensghaft eines Elements von <paramref naae="bindyngsb /> stellt oeHnen Member dar, der den Typ der0Eigenschaft aubweist, auf die in der drch <paraereb name=propertAcceSsor" /> dargesTellten Mehode zugegriffen wird.</excepTion>
    </meber
((  <member nime="M:System.Lilq.xpressions.ExpresqiOn.MemberInit)Qystem.LiNq.Mxpressions.NewExpression,System.CollecTions.Ceneric.IEnumerable{System.Linq.Expressions.MemberBindifg})">
      <summAry>Stellt einen usDruck `ar, der ei. neues Objekt errte,|| und eina Gigenschaft $es MbJekts$initialisiert./summiry:
   0  <return>EiN <see cref="T:System.LioqExpre3sions.MemberInitExpresSin" /., bei dem die <see cref="P:System.Linq.Expsessions>Expressio..NodeType" />-Egmnsbhagt gleic <see`crgf="F:Sistem.Linq.Expressions.ExpressionType.MemberInit" +> ist und die <see cref="P:System.LinQ.Expressions.MdmberInitUxpression.MewExpression" >-Eigen{chift sowie die <see cref="@:Sxste.LiNq.xpressions.MemberInitExpression,Bindyngs" />-Eigenschaft auf die anggejenen Werte festgelegt siod*</rmturns>
   "  <param namm="fewExrression">Ein <ree cref="V:System.Linq.E8pressions.NgwExprewsion" >, auf das $ie <see cref="P:Sstem.Linq.Ezpr{sions.MemberInitExpression&NgwExpressmon"/>-Eygenschaft festgelegt werden soll.</param>
      <param name="bi|dings">Ain <see cref="TzSystdl.Co|lectons.Generic.YEnumerable`1" >, das <wee cref="T:System.Linq.Expressi/ns.MemberBinding" />-OBjekte entHäl, mat denen die<see creb="P:System.Linq.Expressions.EemberInytExpressioN.Bindyngs" />-Auflistung`aufgefllt werden soll.</param~
      <exsepion cref="T:Systum.ArgumeltNulException">
        <pramref name="newExpression" /> odar |paramref nime5"bindings" /> ist null.<.exception>
      <exception cbef="T:System.ArguientException">Die <see cref="P:Syqtem.Linq.E8prgssio.s.MemberBanding.Member" /6-Eigenschaft eynes Ulemefts von!<pqramref name=#bindingc" /> stellt keinen Member dr,(eer deN durch <parargf name="newExpresshgn"`/>.Type dargestellten Typ aufWeist.</exception>
    </member>
    <member name="M:Sy3tem*Linq.ExpRessions&E|pression.MemberIniT,System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> ist und die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den durch <paramref name="newExpression" />.Type dargestellten Typ aufweist.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Restoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Modulo-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Restoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Modulo-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen arithmetischen Negationsvorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen arithmetischen Negationsvorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine arithmetische Negationsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine arithmetische Negationsoperation mit Überlaufprüfung darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors darstellt, der keine Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der durch <paramref name="constructor" /> darstellte Konstruktor verfügt über mindestens einen Parameter.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der <paramref name="arguments" />-Parameter enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für den durch <paramref name="constructor" /> dargestellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.Es werden die Member angegeben, die auf die durch den Konstruktor initialisierten Felder zugreifen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> und <see cref="P:System.Linq.Expressions.NewExpression.Members" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <param name="members">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Reflection.MemberInfo" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Members" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.- oder - Ein Element von <paramref name="members" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der <paramref name="arguments" />-Parameter enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für den durch <paramref name="constructor" /> dargestellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.- oder - Der <paramref name="members" />-Parameter weist nicht die gleiche Anzahl an Elementen auf wie <paramref name="arguments" />.- oder - Ein Element von <paramref name="arguments" /> weist eine <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf, die einen Typ darstellt, der nicht dem Typ des Members zugeordnet werden kann, der durch das entsprechende Element von <paramref name="members" /> dargestellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.Es werden die Member als Array angegeben, die auf die durch den Konstruktor initialisierten Felder zugreifen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> und <see cref="P:System.Linq.Expressions.NewExpression.Members" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <param name="members">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Members" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.- oder - Ein Element von <paramref name="members" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der <paramref name="arguments" />-Parameter enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für den durch <paramref name="constructor" /> dargestellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.- oder - Der <paramref name="members" />-Parameter weist nicht die gleiche Anzahl an Elementen auf wie <paramref name="arguments" />.- oder - Ein Element von <paramref name="arguments" /> weist eine <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf, die einen Typ darstellt, der nicht dem Typ des Members zugeordnet werden kann, der durch das entsprechende Element von <paramref name="members" /> dargestellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="arguments" /> entspricht nicht der Anzahl von Parametern für den durch <paramref name="constructor" /> darstellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des Konstruktors vom angegebenen Typ ohne Parameter darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft auf die <see cref="T:System.Reflection.ConstructorInfo" /> festgelegt ist, die den Konstruktor ohne Parameter für den angegebenen Typ darstellt.</returns>
      <param name="type">Ein <see cref="T:System.Type" /> mit einem Konstruktor, der keine Argumente akzeptiert.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der durch <paramref name="type" /> darstellte Typ weist keinen Konstruktor ohne Parameter auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines Arrays mit dem angegebenen Rang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="bounds">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="bounds" /> ist null.- oder - Ein Element von <paramref name="bounds" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="bounds" /> stellt keinen ganzzahligen Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines Arrays mit dem angegebenen Rang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="bounds">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="bounds" /> ist null.- oder - Ein Element von <paramref name="bounds" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="bounds" /> stellt keinen ganzzahligen Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines eindimensionalen Arrays und Initialisieren dieses Arrays aus einer Liste von Elementen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="initializers" /> ist null.- oder - Ein Element von <paramref name="initializers" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="initializers" /> stellt einen Typ dar, der nicht dem durch <paramref name="type" /> dargestellten Typ zugeordnet werden kann.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines eindimensionalen Arrays und Initialisieren dieses Arrays aus einer Liste von Elementen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="initializers" /> ist null.- oder - Ein Element von <paramref name="initializers" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="initializers" /> stellt einen Typ dar, der nicht dem <paramref name="type" />-Typ zugeordnet werden kann.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Ruft den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> ab.</summary>
      <returns>Einer der <see cref="T:System.Linq.Expressions.ExpressionType" />-Werte.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine bitweise Komplementoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Not-Operator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine bitweise Komplementoperation darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Not-Operator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Ungleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Ungleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Ungleichheitsvergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Ungleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Gibt den Ausdruck zurück, der das Ones-Komplement darstellt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Gibt den Ausdruck zurück, der das Ones-Komplement darstellt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen OR-Vorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen OR-Vorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten OR-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als false ausgewertet wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="left" />.Type und <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten OR-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als false ausgewertet wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="method" /> ist null, und <paramref name="left" />.Type sowie <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> ist und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ParameterExpression.Name" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
      <param name="name">Der Name des Parameters oder der Variable (wird nur zum Debuggen oder Drucken verwendet).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Verringerung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Verringerung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Erhöhung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Erhöhung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren einer Zahl darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Potenzierungsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="left" />.Type und/oder <paramref name="right" />.Type ist nicht <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren einer Zahl darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Potenzierungsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="method" /> ist null, und <paramref name="left" />.Type und/oder <paramref name="right" />.Type ist nicht <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 verringert und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 verringert und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 erhöht und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 erhöht und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft durch das Verwenden einer Eigenschaftenaccessormethode darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll.Dies kann für statische Eigenschaften NULL sein.</param>
      <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ist null.- oder - Die durch <paramref name="propertyAccessor" /> dargestellte Methode ist nicht static (Shared in Visual Basic), und <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type kann dem deklarierenden Typ der durch <paramref name="propertyAccessor" /> dargestellten Methode nicht zugeordnet werden.- oder - Die durch <paramref name="propertyAccessor" /> dargestellte Methode ist keine Eigenschaftenaccessormethode.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll.Dies kann für statische Eigenschaften NULL sein.</param>
      <param name="property">Die <see cref="T:System.Reflection.PropertyInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> ist null.- oder - Die durch <paramref name="property" /> dargestellte Eigenschaft ist nicht static (Shared in Visual Basic), und <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type kann nicht dem deklarierenden Typ des Felds zugeordnet werden, das durch <paramref name="property" /> dargestellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
      <param name="indexer">Das <see cref="T:System.Reflection.PropertyInfo" />, das die zu indizierende Eigenschaft darstellt.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
      <param name="indexer">Das <see cref="T:System.Reflection.PropertyInfo" />, das die zu indizierende Eigenschaft darstellt.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die durch <paramref name="propertyName" /> angegebene Eigenschaft darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" /> eine Eigenschaft namens <paramref name="propertyName" /> enthält.Dies kann für statische Eigenschaften null sein.</param>
      <param name="propertyName">Der Name der Eigenschaft, auf die zugegriffen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="propertyName" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">In <paramref name="propertyName" />.Type oder den entsprechenden Basistypen ist keine Eigenschaft mit dem Namen <paramref name="expression" /> definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
      <param name="propertyName">Der Name des Indexers.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die auf eine Eigenschaft zugreift.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
      <param name="expression">Das enthaltende Objekt der Eigenschaft.Dies kann für statische Eigenschaften NULL sein.</param>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" />, der die Eigenschaft enthält.</param>
      <param name="propertyName">Die Eigenschaft, auf die zugegriffen werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft oder ein Feld darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> oder <see cref="T:System.Reflection.FieldInfo" /> festgelegt ist, die die durch <paramref name="propertyOrFieldName" /> angegebene Eigenschaft bzw. das Feld darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" /> eine Eigenschaft oder ein Feld namens <paramref name="propertyOrFieldName" /> enthält.Kann für statische Member NULL sein.</param>
      <param name="propertyOrFieldName">Der Name einer Eigenschaft oder eines Felds, auf die bzw. das zugegriffen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="propertyOrFieldName" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">In <paramref name="propertyOrFieldName" />.Type oder seinen Basistypen ist keine Eigenschaft bzw. kein Feld mit dem Namen <paramref name="expression" /> definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen Ausdruck mit einem konstanten Wert vom Typ <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Reduziert diesen Knoten zu einem einfacheren Ausdruck.Wenn CanReduce true zurückgibt, sollte ein gültiger Ausdruck zurückgegeben werden.Diese Methode kann einen anderen Knoten zurückgeben, der selbst reduziert werden muss.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Reduziert diesen Knoten zu einem einfacheren Ausdruck.Wenn CanReduce true zurückgibt, sollte ein gültiger Ausdruck zurückgegeben werden.Diese Methode kann einen anderen Knoten zurückgeben, der selbst reduziert werden muss.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Reduziert den Ausdruck zu einem bekannten Knotentyp (kein Erweiterungsknoten) oder gibt nur den Ausdruck zurück, wenn es sich um einen bereits bekannten Typ handelt.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Verweisgleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Verweisungleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme eines angegebenen Typs darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</returns>
      <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Return", die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung mit dem angegebenen Typ darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung mit dem angegebenen Typ darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Return" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Rechtsschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Rechtsschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ist und die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="variables">Eine Auflistung von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Auflistung aufgefüllt wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ist und die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="variables">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Auflistung aufgefüllt wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung ohne Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Schalters.</param>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Schalters.</param>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.SwitchCase" />-Objekt, das in einem <see cref="T:System.Linq.Expressions.SwitchExpression" />-Objekt verwendet werden soll.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
      <param name="body">Der Text des Falls.</param>
      <param name="testValues">Die Testwerte des Falls.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.SwitchCase" /> zur Verwendung in einem <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
      <param name="body">Der Text des Falls.</param>
      <param name="testValues">Die Testwerte des Falls.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
      <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
      <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
      <param name="languageVendor">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
      <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
      <param name="languageVendor">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> festgelegt werden soll.</param>
      <param name="documentType">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Auslösen einer Ausnahme darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Ausnahme darstellt.</returns>
      <param name="value">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Auslösen einer Ausnahme eines angegebenen Typs darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Ausnahme darstellt.</returns>
      <param name="value">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Gibt eine Textdarstellung des <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Eine Textdarstellung der <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einer beliebigen Anzahl von Catch-Anweisungen ohne Fault- und Finally-Block darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="handlers">Das Array von 0 oder mehr <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücken, die die dem Try-Block zuzuordnenden Catch-Anweisungen darstellen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einer beliebigen Anzahl von Catch-Anweisungen und einem Finally-Block darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="finally">Der Text des Finally-Blocks.</param>
      <param name="handlers">Das Array von 0 oder mehr <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücken, die die dem Try-Block zuzuordnenden Catch-Anweisungen darstellen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einem Fault-Block ohne Catch-Anweisungen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="fault">Der Text des Fault-Blocks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einem Finally-Block ohne Catch-Anweisungen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="finally">Der Text des Finally-Blocks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
      <returns>true, wenn ein generischer System.Action-Delegattyp für bestimmte <paramref name="typeArgs" /> erstellt wurde, andernfalls false.</returns>
      <param name="typeArgs">Ein Array von Type-Objekten, die die Typargumente für den System.Action-Delegattyp angeben.</param>
      <param name="actionType">Enthält nach dem Beenden dieser Methode den generischen System.Action-Delegattyp mit bestimmten Typargumenten.Enthält NULL, wenn kein generischer System.Action-Delegat vorhanden ist, der <paramref name="typeArgs" /> entspricht. Dieser Parameter wird nicht initialisiert übergeben.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Func-Delegattyp mit bestimmten Typargumenten darstellt.Das letzte Typargument gibt den Rückgabetyp des erstellten Delegaten an.</summary>
      <returns>true, wenn ein generischer System.Func-Delegattyp für bestimmte <paramref name="typeArgs" /> erstellt wurde, andernfalls false.</returns>
      <param name="typeArgs">Ein Array von Type-Objekten, die die Typargumente für den System.Func-Delegattyp angeben.</param>
      <param name="funcType">Enthält nach dem Beenden dieser Methode den generischen System.Func-Delegattyp mit bestimmten Typargumenten.Enthält NULL, wenn kein generischer System.Func-Delegat vorhanden ist, der <paramref name="typeArgs" /> entspricht. Dieser Parameter wird nicht initialisiert übergeben.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den dieser <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="T:System.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine explizite Verweis- oder Boxingkonvertierung darstellt, bei der null zurückgegeben wird, wenn bei der Konvertierung ein Fehler auftritt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, die die Laufzeittypidentität vergleicht.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> ist und die <see cref="T:System.Linq.Expressions.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="T:System.Linq.Expressions.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> ist und die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine unäre Plusoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Plus-Operator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine unäre Plusoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Plus-Operator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die ein explizites Unboxing darstellt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die Unboxing angewendet werden soll.</param>
      <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
      <param name="name">Der Name des Parameters oder der Variable.Dieser Name wird nur zum Debugging oder Drucken verwendet.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Reduziert den Knoten und ruft dann den Visitor-Delegaten für den reduzierten Ausdruck auf.Die Methode löst eine Ausnahme aus, wenn der Knoten nicht reduziert werden kann.</summary>
      <returns>Der besuchte Ausdruck oder ein Ausdruck, durch den der Ausdruck in der Struktur ersetzt werden soll.</returns>
      <param name="visitor">Eine Instanz von <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Stellt einen stark typisierten Lambdaausdruck als Datenstruktur in Form einer Ausdrucksbaumstruktur dar.Diese Klasse kann nicht vererbt werden.</summary>
      <typeparam name="TDelegate">Der Typ des Delegaten, der die <see cref="T:System.Linq.Expressions.Expression`1" /> darstellt.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Kompiliert den von der Ausdrucksbaumstruktur beschriebenen Lambda-Ausdruck in ausführbaren Code und erzeugt einen Delegaten, der den Lambda-Ausdruck darstellt.</summary>
      <returns>Ein Delegat vom Typ <paramref name="TDelegate" />, der den vom <see cref="T:System.Linq.Expressions.Expression`1" /> beschriebenen kompilierten Lambda-Ausdruck darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="body">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft des Ergebnisses.</param>
      <param name="parameters">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Beschreibt die Knotentypen für die Knoten in einer Ausdrucksbaumstruktur.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Eine Additionsoperation wie a + b ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Eine Additionsverbundzuweisung wie (a += b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Eine Additionsverbundzuweisung wie (a += b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Eine Additionsoperation wie (a + b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Eine bitweise oder logische AND-Operation wie (a &amp; b) in C# und (a And b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Eine bedingte AND-Operation, bei der der zweite Operand nur ausgewertet wird, wenn der erste Operand zu true ausgewertet wird.Entspricht (a &amp;&amp; b) in C# und (a AndAlso b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Eine zusammengesetzte bitweise oder logische AND-Zuweisungsoperation wie (a &amp;= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Ein Indizierungsvorgang in einem eindimensionalen Array wie array[index] in C# oder array(index) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Ein Vorgang, bei dem die Länge eines eindimensionalen Arrays wie array.Length abgerufen wird.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Eine Zuweisungsoperation wie (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Ein Block von Ausdrücken.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Ein Methodenaufruf wie im obj.sampleMethod()-Ausdruck.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Ein Knoten, der eine NULL-Zusammenführungsoperation wie (a ?? b) in C# oder If(a, b) in Visual Basic darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Eine bedingte Operation wie a &gt; b ? a : b in C# oder If(a &gt; b, a, b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Ein Konstantenwert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Ein Umwandlungs- oder Konvertierungsvorgang wie (SampleType)obj in C#oder CType(obj, SampleType) in Visual Basic.Wenn der konvertierte Wert zu groß für den Zieltyp ist, wird bei einer numerischen Konvertierung keine Ausnahme ausgelöst.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Ein Umwandlungs- oder Konvertierungsvorgang wie (SampleType)obj in C#oder CType(obj, SampleType) in Visual Basic.Wenn der konvertierte Wert nicht zum Zieltyp passt, wird bei einer numerischen Konvertierung eine Ausnahme ausgelöst.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Debuginformationen.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Eine unäre Dekrementoperation, z. B. (a - 1) in C# und Visual Basic.Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Ein Standardwert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Eine Division, z. B. (a / b), für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Eine Divisionsverbundzuweisungsoperation, z. B. (a /= b), für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Ein dynamischer Vorgang.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Ein Knoten, der einen Gleichheitsvergleich wie (a == b) in C# oder (a = b) in Visual Basic darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Eine bitweise oder logische XOR-Operation wie (a ^ b) in C# oder (a Xor b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Eine zusammengesetzte bitweise oder logische XOR-Zuweisungsoperation wie (a ^= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Ein Erweiterungsausdruck.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Ein "Go to"-Ausdruck wie goto Label in C# oder GoTo Label in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Ein "größer als"-Vergleich wie (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Ein "größer oder gleich"-Vergleich wie (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Eine unäre Inkrementoperation, z. B. (a + 1) in C# und Visual Basic.Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Eine Indexoperation oder eine Operation, die auf eine Eigenschaft zugreift, die Argumente akzeptiert. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Eine Operation, die einen Delegaten oder einen Lambda-Ausdruck aufruft, z. B. sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Ein false-Bedingungswert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Ein true-Bedingungswert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Eine Bezeichnung.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Ein Lambda-Ausdruck wie a =&gt; a + a in C# oder Function(a) a + a in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Eine bitweise Linksschiebeoperation wie (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Eine bitweise zusammengesetzte Linksschiebezuweisung wie (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Ein "kleiner als"-Vergleich wie (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Ein "kleiner oder gleich"-Vergleich wie (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Ein Vorgang, bei dem ein neues <see cref="T:System.Collections.IEnumerable" />-Objekt erstellt und aus einer Liste von Elementen initialisiert wird, wie new List&lt;SampleType&gt;(){ a, b, c } in C# oder Dim sampleList = { a, b, c } in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Eine Schleife wie for oder while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Ein Vorgang, bei dem aus einem Feld oder einer Eigenschaft wie obj.SampleProperty gelesen wird.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Eine Operation, die ein neues Objekt erstellt und einen oder mehrere Member initialisiert, z. B. new Point { X = 1, Y = 2 } in C# oder New Point With {.X = 1, .Y = 2} in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Eine arithmetische Restoperation wie (a % b) in C# oder (a Mod b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Eine arithmetische zusammengesetzte Restzuweisungsoperation wie (a %= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Eine Multiplikationsoperation wie (a * b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Eine Multiplikationsverbundzuweisung wie (a *= b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Eine Multiplikationsverbundzuweisung wie (a *= b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Eine Multiplikationsoperation, z. B. (a * b), mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Eine arithmetische Negationsoperation wie (-a).Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Eine arithmetische Negationsoperation wie (-a) mit Überlaufüberprüfung.Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Ein Vorgang, bei dem ein Konstruktor aufgerufen wird, um ein neues Objekt wie new SampleType() zu erstellen.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Ein Vorgang, bei dem ein neues Array erstellt wird, in dem die Grenzen für jede Dimension definiert sind, wie new SampleType[dim1, dim2] in C# oder New SampleType(dim1, dim2) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Ein Vorgang, bei dem ein neues eindimensionales Array erstellt und aus einer Liste von Elementen initialisiert wird, wie new SampleType[]{a, b, c} in C# oder New SampleType(){a, b, c} Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Eine bitweise Komplement- oder logische Negationsoperation.In C# entspricht dies (~a) für ganzzahlige Typen und (!a) für boolesche Werte.Die Entsprechung in Visual Basic ist (Not a).Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Ein Ungleichheitsvergleich wie (a != b) in C# oder (a &lt;&gt; b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Eine Ones-Komplementoperation wie (~a) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Eine bitweise oder logische OR-Operation wie (a | b) in C# oder (a Or b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Eine bitweise oder logische zusammengesetzte OR-Zuweisung wie (a |= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Eine verkürzte bedingte OR-Operation wie (a || b) in C# oder (a OrElse b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Ein Verweis auf einen Parameter oder eine Variable, der bzw. die im Kontext des Ausdrucks definiert ist.Weitere Informationen finden Sie unter <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Ein unäres Postfixdekrement wie (a--).Das Objekt a sollte direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Ein unäres Postfixinkrement wie (a++).Das Objekt a sollte direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Eine mathematische Operation, bei der eine Zahl potenziert wird, wie (a ^ b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Eine zusammengesetzte Zuweisungsoperation, bei der eine Zahl potenziert wird, wie(a ^= b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Ein unäres Präfixdekrement wie (--a).Das Objekt a sollte direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Ein unäres Präfixinkrement wie (++a).Das Objekt a sollte direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Ein Ausdruck mit einem Konstantenwert vom Typ <see cref="T:System.Linq.Expressions.Expression" />.Ein <see cref="F:System.Linq.Expressions.ExpressionType.Quote" />-Knoten kann Verweise auf Parameter enthalten, die im Kontext des Ausdrucks definiert sind, den der Knoten darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Eine bitweise Rechtsschiebeoperation wie (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Eine bitweise zusammengesetzte Rechtsschiebe-Zuweisungsoperation wie (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Eine Liste von Laufzeitvariablen.Weitere Informationen finden Sie unter <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Eine Subtraktionsoperation wie (a - b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Eine Subtraktionsverbundzuweisung wie (a -= b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Eine Subtraktionsverbundzuweisung wie (a -= b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Eine arithmetische Subtraktionsoperation wie (a - b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Ein Wechselvorgang wie switch in C# oder Select Case in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Eine Operation, die eine Ausnahme auslöst, z. B. throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Ein try-catch-Ausdruck.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Eine explizite Verweis- oder Boxing-Konvertierung, bei der null angegeben wird, wenn die Konvertierung fehlschlägt, wie (obj as SampleType) in C# oder TryCast(obj, SampleType) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Ein genauer Typtest.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Ein Typtest wie obj is SampleType in C# oder TypeOf obj is SampleType in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Eine unäre Plusoperation wie (+a).Das Ergebnis einer unären Plusoperation ist einfach der Wert des Operanden. In benutzerdefinierten Implementierungen können jedoch außergewöhnliche Ergebnisse erzeugt werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Eine Unboxing-Werttypoperation wie die unbox-Anweisung und die unbox.any-Anweisung in MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Stellt einen Besucher oder Bearbeiter für Ausdrucksbaumstrukturen dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Sendet die Liste der Ausdrücke an eine der spezialisierteren Besuchsmethoden in dieser Klasse.</summary>
      <returns>Die geänderte Liste der Ausdrücke, wenn eines der Elemente geändert wurde. Andernfalls wird die ursprüngliche Liste der Ausdrücke zurückgegeben.</returns>
      <param name="nodes">Die Ausdrücke, zu denen gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Wechselt mit einem angegebenen Elementbesucher zu allen Knoten in der Auflistung.</summary>
      <returns>Die geänderte Knotenliste, wenn eines der Elemente geändert wurde, andernfalls wird die ursprüngliche Knotenliste zurückgegeben.</returns>
      <param name="nodes">Die Knoten, zu denen gewechselt werden soll.</param>
      <param name="elementVisitor">Ein Delegat, der ein einzelnes Element besucht und dieses (optional) durch ein neues Element ersetzt.</param>
      <typeparam name="T">Der Typ der Knoten.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Sendet den Ausdruck an eine der spezialisierteren Besuchsmethoden in dieser Klasse.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Wechselt zu einem Ausdruck und wandelt das Ergebnis zurück in den ursprünglichen Ausdruckstyp um.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="nodes">Der Ausdruck, zu dem gewechselt werden soll.</param>
      <param name="callerName">Der Name der aufrufenden Methode. Dieser wird für die Ausgabe einer besseren Fehlermeldung verwendet.</param>
      <typeparam name="T">Der Typ des Ausdrucks.</typeparam>
      <exception cref="T:System.InvalidOperationException">Die Visit-Methode für diesen Knoten hat einen anderen Typ zurückgegeben.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Wechselt zu einem Ausdruck und wandelt das Ergebnis zurück in den ursprünglichen Ausdruckstyp um.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
      <param name="callerName">Der Name der aufrufenden Methode. Dieser wird für die Ausgabe einer besseren Fehlermeldung verwendet.</param>
      <typeparam name="T">Der Typ des Ausdrucks.</typeparam>
      <exception cref="T:System.InvalidOperationException">Die Visit-Methode für diesen Knoten hat einen anderen Typ zurückgegeben.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Wechselt zu den untergeordneten Elementen des Erweiterungsausdrucks.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
      <typeparam name="T">Der Typ des Delegaten.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Stellt einen bedingungslosen Sprung dar.Hierzu zählen return-Anweisungen, break- und continue-Anweisungen sowie andere Sprünge.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Die Art des "Gehe zu"-Ausdrucks.Dient nur zu Informationszwecken.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.GotoExpressionKind" />-Objekt, das die Art des "Gehe zu"-Ausdrucks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Die Zielmarke, zu der von diesem Knoten gewechselt wird.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.LabelTarget" />-Objekt, das die Zielmarke für diesen Knoten darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.GotoExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="target">Die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft des Ergebnisses. </param>
      <param name="value">Die <see cref="P:System.Linq.Expressions.GotoExpression.Value" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Der an das Ziel übergebene Wert oder NULL, wenn das Ziel vom Typ System.Void ist.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den an das Ziel übergebenen Wert darstellt oder NULL.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Gibt an, welche Art von Sprung diese <see cref="T:System.Linq.Expressions.GotoExpression" /> darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine break-Anweisung darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine continue-Anweisung darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die einen Sprung zu einer Position darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine return-Anweisung darstellt.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Stellt das Indizieren einer Eigenschaft oder eines Arrays dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Ruft die Argumente ab, mit denen die Eigenschaft oder das Array indiziert wird.</summary>
      <returns>Die schreibgeschützte Auflistung, die die Argumente enthält, mit denen die Eigenschaft oder das Array indiziert wird.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Ruft die <see cref="T:System.Reflection.PropertyInfo" /> für die Eigenschaft ab, wenn der Ausdruck eine indizierte Eigenschaft darstellt. Andernfalls wird NULL zurückgegeben.</summary>
      <returns>Die <see cref="T:System.Reflection.PropertyInfo" /> für die Eigenschaft, wenn der Ausdruck eine indizierte Eigenschaft darstellt, andernfalls NULL.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Ein zu indizierendes Objekt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die das zu indizierende Objekt darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.IndexExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="object">Die <see cref="P:System.Linq.Expressions.IndexExpression.Object" />-Eigenschaft des Ergebnisses.</param>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Stellt einen Ausdruck dar, der einen Delegaten oder einen Lambdaausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Ruft die Argumente ab, auf die der Delegat oder Lambda-Ausdruck angewendet wird.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat angewendet wird.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Ruft den Delegaten oder Lambdaausdruck ab, der angewendet werden soll.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den anzuwendenden Delegaten darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.InvocationExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expression">Die <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" />-Eigenschaft des Ergebnisses.</param>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Stellt eine Bezeichnung dar, die in einen beliebigen <see cref="T:System.Linq.Expressions.Expression" />-Kontext platziert werden kann.Bei einem Sprung in die Bezeichnung wird der durch die entsprechende <see cref="T:System.Linq.Expressions.GotoExpression" /> angegebene Wert abgerufen.Andernfalls wird der Wert in <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> empfangen.Wenn der <see cref="T:System.Type" /> gleich System.Void ist, darf kein Wert angegeben werden.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Der Wert der <see cref="T:System.Linq.Expressions.LabelExpression" />, wenn die Bezeichnung durch die reguläre Ablaufsteuerung (und z. B. nicht durch einen Sprung) erreicht wird.</summary>
      <returns>Das Expression-Objekt, das den Wert der <see cref="T:System.Linq.Expressions.LabelExpression" /> darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem die Bezeichnung zugeordnet ist.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem die Bezeichnung zugeordnet ist.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.LabelExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="target">Die <see cref="P:System.Linq.Expressions.LabelExpression.Target" />-Eigenschaft des Ergebnisses.</param>
      <param name="defaultValue">Die <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Stellt das Ziel einer <see cref="T:System.Linq.Expressions.GotoExpression" /> dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Ruft den Namen der Bezeichnung ab.</summary>
      <returns>Der Name der Sprungmarke.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Gibt einen <see cref="T:System.String" /> zurück, der den aktuellen <see cref="T:System.Object" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.String" />, der den aktuellen <see cref="T:System.Object" /> darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Der Typ des beim Springen zur Bezeichnung übergebenen Werts (oder <see cref="T:System.Void" />, wenn kein Wert übergeben werden soll).</summary>
      <returns>Das <see cref="T:System.Type" />-Objekt, das den Typ des beim Springen zur Bezeichnung übergebenen Werts darstellt, oder <see cref="T:System.Void" />, wenn kein Wert übergeben werden soll.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Beschreibt einen Lambdaausdruck.Zeichnet einen Codeblock auf, der mit einem .NET-Methodentext vergleichbar ist.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Ruft den Text des Lambdaausdrucks ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Text des Lambdaausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Erzeugt einen Delegaten, der den Lambdaausdruck darstellt.</summary>
      <returns>Ein <see cref="T:System.Delegate" />, das die kompilierte Version des Lambda-Ausdrucks enthält.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Ruft den Namen des Lambdaausdrucks ab.</summary>
      <returns>Der Name des Lambdaausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Ruft die Parameter des Lambdaausdrucks ab.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, die die Parameter des Lambdaausdrucks darstellen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Ruft den Rückgabetyp des Lambdaausdrucks ab.</summary>
      <returns>Das <see cref="T:System.Type" />-Objekt, das den Typ des Lambdaausdrucks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Ruft den Wert ab, der angibt, ob der Lambdaausdruck mit der Endeaufrufoptimierung kompiliert wird.</summary>
      <returns>True, wenn der Lambdaausdruck mit der Endeaufrufoptimierung kompiliert wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.LambdaExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Stellt einen Konstruktoraufruf dar, der einen Auflistungsinitialisierer aufweist.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Ruft einen Wert ab, der angibt, ob der Knoten der Ausdrucksbaumstruktur reduziert werden kann.</summary>
      <returns>True, wenn der Knoten reduziert werden kann, andernfalls False.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Ruft die Elementinitialisierer ab, die zum Initialisieren einer Auflistung verwendet werden.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, die die Elemente darstellen, die zum Initialisieren der Auflistung verwendet werden.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Ruft den Ausdruck ab, der einen Aufruf des Konstruktors für einen Auflistungstyp enthält.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des Konstruktors für einen Auflistungstyp darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Reduziert auf den binären Ausdrucksknoten auf einen einfacheren Ausdruck.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ListInitExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="newExpression">Die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft des Ergebnisses.</param>
      <param name="initializers">Die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Stellt eine Endlosschleife dar.Diese kann mit "break" beendet werden.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.Expression" /> ab, die den Text der Schleife darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den Text der Schleife darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Ruft das <see cref="T:System.Linq.Expressions.LabelTarget" /> ab, das vom Schleifentext als Ziel der break-Anweisung verwendet wird.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.LabelTarget" />, das vom Schleifentext als Ziel der break-Anweisung verwendet wird.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Ruft das <see cref="T:System.Linq.Expressions.LabelTarget" /> ab, das vom Schleifentext als Ziel der continue-Anweisung verwendet wird.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.LabelTarget" />, das vom Schleifentext als Ziel der continue-Anweisung verwendet wird.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.LoopExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="breakLabel">Die <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" />-Eigenschaft des Ergebnisses.</param>
      <param name="continueLabel">Die <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" />-Eigenschaft des Ergebnisses.</param>
      <param name="body">Die <see cref="P:System.Linq.Expressions.LoopExpression.Body" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Stellt die Zuweisungsoperation für ein Feld oder eine Eigenschaft eines Objekts dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Ruft den Ausdruck ab, der dem Feld oder der Eigenschaft zugewiesen werden soll.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den Wert darstellt, der dem Feld oder der Eigenschaft zugewiesen werden soll.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expression">Die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Stellt die Basisklasse dar, von der die Klassen abgeleitet werden, die Bindungen darstellen, die zum Initialisieren von Membern eines neu erstellten Objekts verwendet werden.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Ruft den dargestellten Bindungstyp ab.</summary>
      <returns>Einer der <see cref="T:System.Linq.Expressions.MemberBindingType" />-Werte.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Ruft das zu initialisierende Feld oder die zu initialisierende Eigenschaft ab.</summary>
      <returns>Die <see cref="T:System.Reflection.MemberInfo" />, die das zu initialisierende Feld oder die zu initialisierende Eigenschaft darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Gibt eine Textdarstellung des <see cref="T:System.Linq.Expressions.MemberBinding" /> zurück.</summary>
      <returns>Eine Textdarstellung des <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Beschreibt die Bindungstypen, die in <see cref="T:System.Linq.Expressions.MemberInitExpression" />-Objekten verwendet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Eine Bindung, die das Initialisieren eines Members mit dem Wert eines Ausdrucks darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Eine Bindung, die das Initialisieren eines Member vom Typ <see cref="T:System.Collections.IList" /> oder <see cref="T:System.Collections.Generic.ICollection`1" /> von einer Liste von Elementen darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Eine Bindung, die das rekursive Initialisieren von Membern eines Members darstellt.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Stellt den Zugriff auf ein Feld oder eine Eigenschaft dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Ruft das enthaltende Objekt des Felds oder der Eigenschaft ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die das enthaltende Objekt des Felds oder der Eigenschaft darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Ruft das Feld oder die Eigenschaft ab, auf das bzw. die zugegriffen werden soll.</summary>
      <returns>Die <see cref="T:System.Reflection.MemberInfo" />, die das Feld oder die Eigenschaft darstellt, auf das bzw. die zugegriffen werden soll.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Gibt den Knotentyp dieser <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expression">Die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Stellt das Aufrufen eines Konstruktors und Initialisieren eines oder mehrerer Member des neuen Objekts dar.</summary>
    </member>
 (  <meibev namg="P:System.Linq.Expressions.MamberInitExpression.Bindings">
      summary>Ruft diu Bine}ngen ad, die beschreiben, wid d)g Member des neu erstel|ten Mbjakts ilitialisie2t werd%n.</su}mary>
      <returns>Eine"<see cref="T:System.Cllections.ObjeCt/del.ZeadGnlyCollection`1" /> von =wee cref="T:System.Linq.Expres3imns.MemberBinding" />Objektan, die beschreibe, wie $ye Memcer ifitialisi%rt werden.</retwrns>    </member>
    <membtr .ame="P:Systum.LinQ.ExPrussigns.MemberInitExprescio~.CafSeduc">
     <pummaty>PufT eiNen Wert(ab, `er angibt,(ob deb Knopen der Ausdrucksbaumstp5ktur red}zier4werden kann.</summary>
      <returns>True, wenn der noten reduziert serdmn ka~n, anfernf`lls$False.|/returnw>
    </mee`er>
    <memrer nimu="P:System.Linq.Exprassions.LemberINi4ExpRession.NewExpression"6
      <summary>Ruft en Ausdruckab( der deo Jonst2uktoraUfpuf darstellt.</suemary>	
      <returns>Eine <see cref="\:System.Linq.Expreqsions.NEwExpresskon />, Die den!Konstru{toraufruf dars|ellt.</returns>
    </member>    <member naie="P:System.Linq.ex0ressions.LemberIjitExpbessOn.NodeType">
    $ <summary>Gibtden KnotenvyP$dyses Ausdrucks {urück.Erweiterungskoten sollten <see czef="F:QyStem.Linq>Expre1sionw.Ex`russionType.Exte.sion" /> zurückgeben wEfn diese MetHode!üerscxrieben wird.</qummary>
      <2eturns>Der <see craf="T:Systum.Ninq.ExpRessIons.ExprescionType" /> des AudrUcks*=/seturns>
    <-member>
 $  <member name="M:System.Lins.Expressions.MeMberI~itExpression.Reduce">
      <summary>rede:iert <see cref="T:C}stee.Linq.Expressimns.MembdbMnitExpression& /> auf eindn eanfacherd~ Asdruk. </summary>
      <returs>Der reduzierte Aus$ruck.</setuRns>
    </iember>
  1 <}eber name<2P*System.Linq.Ehpressions.MemburHnitExpressi/n,Type">
      <summary>Ruft dn statischen Typ de3 Aurdrucks ab, den diese <see cref="T:Syst%m.Linq.Expresions.Expression" > darstellt.<osummary>
  $  "<ret}rns>De2 <see cref="P:Sysuem>Linq.Expressaons.MemberI.itExpressin.Type" />, de denstatischen Typ des Ausdrucks darsteldt.</retu2ns
    ,/memer
    <member naMe="M:Sy3tem.Linq.Expressions.}embErHnitEpres3ion.Update(Sy{tem.Linq.E|pressionsNewExprersion,Sytem.CollectIons.G%Neric.IEntmebabla{System.Lifq.Expbesshons.MemberBindinG}(">
      <summary>Erstellt einen nuen Ausdrusk wiediesen, verwendet jedoch dye anfegebenen unperweoRdnepen Alemente.Wenn"!lle untergeordneten Eleiente übEr%ijstimeen, 7ird der Ausdruck ~urückgegeBen.</qwmmar;>
     $<returns>Dieser Ausdruck, gnn keine0untergeordneten Elemente geänDert werden, oder eiN AusdrUck myt den aktualysierten Un4ergeordneten Elelent%n.</raturns>
      <param n!me="newExprucsion">Die$<see cvef="P:System.Linq.Expressions.Me-berInitExprassion.NesExpression" />-Eigenschaft deq Ergebni3ses.</param>
      <p!rqm fale="bindincs">Die <see crdf="P:systemMinq.Expressinos.MemberInitEyprersio.Bineings" />Eigenschaft $es Ergeboysses.</param>
    |/mumber.
    <member name="T:SyStgm.Linq.Expressions.MemberListmnding">
      <semmary>Stullt eas Initiclisieren der ElemeNte eines Auflistungsmembers für ein neu arstelltes Objekt dar./summar>
 (  <mgmber>J$   >member n`me="P:Sqs4em.Linq.Expressions.MemberListBinding.Inityalize{s">
    ! <sqmmary>Rft die ElementinitialsyereR zum InItialisierdn eines Auflistungsmembers für eil neu ercuelltes Obbect ar.</suEmary>
`     |petupns>eine <see sreF="T:System.Collections.ObjectModel.ReadnlyComlection`1" /> voj <see cref="T:System.Lknq.ExpbessiojsDlement	nit" />-Gbjekten zum Initialisieren ei~Es Auflisungsmemberr./re|urns>
    </membAr>
    member na-e="M:RyqtemLinq.Exqrgssions.]emberListBinli~g.Update(System.Collections.eneric.MEnumerable{Sys|em.L9nq.Expressions.ELemdntIni4})">
    $ <summapy>Drs|ellt inen neuen Ausdruck wie diesen, verweneet jeloch die angegebe|En untergeordnetej Elumdnte.Weln alle!ujtergeordnEtn(Elemnte bereinstimmEn, uire der Audruck zurckgegeben.</summar>
     <rEtuvns>Dieser Ausdruck wenn keine unterguordfeten Edeme.te geäNdert gepdml, oder ein Ausdruci mit en iktualisiertmn uNtdr'eordneten Elemental.</ret}rns>
      <param name="inipyaliZers>Li%0<see cref="PSystem.Linq.Expressions.MemberLisBijding.Inatializers" />-Ei'encc(aft dec ErGebnisses.8/param>
    </me}ber>
    <member name="T:y3tem.DnqnExpressions.MemberMemberBindAng">
 0    <summary>Stellt Initi`lisierende MEme eines Memberq fr ein neu erst$lltes Mnjektdar./3ummary>
 $  </member>
    <mem"er nam="P:Syspem.Linq.EhpRssikns.MemberMemberBindKng.Bndingq">
     "<summary>Ruft die Bin`tngen ab, die cesch2eibun, w)e die Member eines Members initialisi%rt werde~.</sumeary>
      8returns>Eife <ree gren="\:SysTem.Collections.ObjecvModel.SeadOnlyColdection`0" /> von <see crmf="T:Swtem.Lmlp.Exppessions.MembErBeoding" />-Kbjekten, die beschreiben, wie dieLmmberees Members initialisiert w%rden.</returns>
   !</member>    =member ame="M:Systei.Linq.Expre1skons.MemberMemberBinfiNg.UpdaPe(System.CollectionsGener	c.Inumeafle{System.L)n1.Exprgssions.MembgrBinding}i">
     `<summaryEbstelt einen neuen usdruck wie diese~, veswendet jedoch die angegebenen untergeordneten Elemente.Wenn alde untereordneuen EleeEnta Ǽbereinstim}en,"wird der0Ausdruck zubüGkgegeben.</suMmapy>
   ! `<returns>Dieser Ausdruck, wenn keineuntergeobdneten Elemente geÄndart werden,$oder(ein Ausdruck mit den aktualisierten untergeorneten Elementen./ra4upns>
      <param name="bi.dings">eie <see cred="P:Systee.Linq.EzPressions.MemberMemberBinding,Bindijg{" />-Eige.schaft(des Ergebjisses.</param>
    </meeber>
    <membr name="T:System.Linq.Exprassinns.MetjodCellExpression">
      <qemmary>Suellt emjen Aufruf einer s|atischen Mathode oder einer Instanz-ethode dar.</summary>
    /mem`er>*    <membeb nAme="M:System.Linq.Ex02esskons.Met`mdCallExpresqion.Ackept(System.Linq.Exrrecsions.ExpressIonVisktor)">
      <summary>Sendet an die(spezifische Vi{it-Methode für diesen KnotentyP.BeispielqweiSe wird <see cRef=*I:System.Linq.Expessionr.Exprussionismtov.VisitMethgDCall(syste.Linq.ExpressIons.MethodCallExpression)" '> von <seu srdf="T:S9stem.Linq.expressins.MgthodCallExpression" / aufgerufen.</summarx>
      <Return3>Das Ergebois eines Besughs dieses KnOtens.<.returjs>
`     <parai jame="visitor">Der0Besucher,!mit dem dieser Knoteo bes5cht werden soll.</param>
    </membep>
!   <member name="P:SYstem.Linq.Expressions.MethodCqllExpression.ARgumends">
      <summary>Ruft eine Auflistungvon Audrüccen ab die Argumente der aufgerunenun Eephkde darstellen.<summa2y>	
    <returns>EinE <sed cref="T:Syspem.Collections.Objc4Model.ReadOnlyCollectyon1" /> von <sue craF="PSystem.Lnq.Expressionc,Expressimn" '>-Objakten, die die Ap'umgnte für eie aufgerufene Eethode darstellen.</returns>
    =/member>
`   <-ember name="P:System.Lin1.Ez1ressinns.MdthodCallExprssion.Method">
      >summary>Ruft dcs <s%e cref="T:System.Refl%ction.MetxodInfo"!/> fÜ2 dim"aufzuru`dnde Methode ab.</smmary>
      <returns>Die <see cref="T:System.Ref|ection,ethodInfo" />, die die(aufGeruf%ne Methode darstell.</returns>
    <?member>
    <member name=2P:Qystem&Linq.Epressions.MeuhodCallExprewsion.NodeType">
      <summary>Gibt denOnotentyp diesEs <see cref="D:System.Linq.Expres{ions.ExPressioj" /> zurück*</wumiary>
 (    <reurns>Der <see crEf="T:System.Li.s.Expresion1.ExpressionT9pe# />, der!diesen Ausdruck dassuellt.<?returns<
   </member>
    <membmr name="P:System.Linq.Expressimns.MethodCallExpression.bject">
      <su]maRy>Rtft das <see cvef="T:System.LinqEypressions.Expression" /> ab, das lie Instanz für nstan{meuhodmnaufrfa oder NULL für statische Methodenaufrufe derstellt.</sUmmary>
      <returns>Eind <see cref="T:System.Lynq.Expressins.Expressiol" />, die das`empFangende Objekt der Methode dar3tellt.</retur.s>
    >/eember>
    <member name="P:System.inq.Exp2e{sions.mathodallExpres{io&System#Li>q#Expressions#IArgumen|Provider#IrgumentCount"></membur>	
    <member name="M:System.Linq.expresRions.MethodCallExpre3sion,System#Linq#Dxpres3ions"IArgumentProvider#GetArgument(System*In432) .</member>
    <me-ber .ame="P:Cystem.Linq.Expressions.MethodCallExprersion.Typg">
     <summary>R1ft de~ statisch%l Tyq des"Atsdrubks ab, den diese <see cref="T:S)stem.lIn1.Expressions.ExbesrioN" > darstelht.</s5mmary>      <returnq>Dur <see bref="P:System.Linq.Expressionr.MethodCallDxpbession.Type" />, der den statischan Typ(des Ausdrucks tarstemlt.</returns>
    ,/mEmber>
    <member name="M:Systum.Linq.Expressions.MethodC`llExpresson.Update(Systi.Linq.Expressions.ExPression(System.CoDlect)ons.Generic.MEnumErable{System.LInq.Expra3sions.Expression})">      <cummary>Erstellt einen oe5en Ausdruck wie diesen, verweoDet jedoch die angeoebenen uftgrgeordneten lemente.Wenn alle untergeordjeeen Emeeente über%instimeen, Wird der Ausdruck {upüccgegebeo.</summavy>
    ` <returjs>Dieser Ausdrucc, wenn keine untebgeordne|un Elemente geäfderu)werden, mder ein Ausdruck mit Den Akt5alisierten untergeordneteN Elementef></returns>
     <pasam nAme="object">Die <see cref="P:Sy3tem.Linq.eppressions.MethodCallExpre3sion.Object",/>-Emgenscjcft des ergebnisses./param>
      <taram naie="ergumentsb>)e <s%e cref="P{Systgm.Linq.ExpresskonsMethodCallEx0ressioo.ArgumeNts" />-EigenscHaft `es Evgebn)sses.</param>
    </member>
$   <mEm`ep naMe="T:System.Lhjq*Expressions.NewAvrayExPresrio~">
     `<{ummary>Stellt das Arstgllan eines neqen Arrays unl möglicherweise!das Initialisieren der Elemente im oeuen Array dar.</summary
    </member>
    =membername%"2System.Linq.|prewsins.NewArrayGxpression.Accept([ystel.Linu.Expressions.expressionVisiTor)">
      4summarySendet an diu spezifiscie Visit-Methode dür `hesn"Knotentyp.Beispiehsweise vard$<see cref=bM:System.Lin1.Expressions.ExpressionVisitov.Visi4MethodCall(S{stem.Ninq.Expressions.MethodCallExpressioni" /> vnn <sde crdf="TzSyste-/Dynq.Expressions.MethodCalhExprmssion" /> aufgertFen.</cummary>-      <beturnsDqs Erge`Nis ekles Bes}chs dI!ses Kn/tens.</returns>
  "   <pavamneme="viitnv">Der BsucheR, mit dem dieser Koen!besuch w%rden soll.</param~
    </mm"er>
    <member name="PSystem.Linq.Ehressions.NewArayExpression.|pressions">
      <summary>Ruft die Grinzen des Arrays ab, wann der Wert dev <ree sref="P:Sywtem.Lynq.Exprecsions.Expressyoj.NodeType" />-EigengChaft <see csef="F:SysTem.Ninq/Eypressions*EypressionTxpe.NewAbrqyBound# /> ist, oder die Werte zum Initialisieren der Elemen|e im"nguen Aray, wenn Der WeRt de <see cref="P:System.Linq.Expessmons.Ex`ression.NodeType" />-Eigenschaft <see crEf="F:System.Linq.Expre{sions.ExpressionTqpe.NEwArrayInat"@/> ist.</summari>
      <returns?Eine <see cref="T:System.Collections.ObhectModel.ZeadOnlyCollection`1" /> von <see creF="T:System.Linq.Expsewsions$Exppessign  />-Objecten, did die Grenzen ds @rrays ofer,aber die Initialismerungswerte darstellen.</returns>    </m-mBer>J    <member na}e="P:System.inq.Uxpress`ons.NuvArrayMxprdssionnType">
      <summery?Ruft0dan sTatischen Yp des AustruakS ab, den`diese <s%e0cref=&:SystemLnq.Expressionq.Expression" /> dabstelltn</summAry>-      <returns>Der <see cref=P:Qystem.Lmn1.xpresWions*NewArrayAxpression,Type" ->, der dEn statasahen Typ Des Ausdrucks darstellt.</returns>
    </membev>
  " <member name="M:System.Linq.Exxressions.NewArrayExpressionnU`datehSystem.Collections.Generic.IEnuMerable{SysteL.Lina.Expressions.Expression})>*  "   <summ!ry>Erstellt`eineN neuen"Ausdruck wi% diesen, verwende"jedoch die aNgegebenen unter'eordnet%n Elemente.Wenn alle untergeorDneten Elgmente übereinctilmef, wird der Aurdruck zurüCkgeggbgn.</summary>
      <returns>Dieser Ausdrubk- wefn(keinm$untergeorDnetel Elgmente geändert werden, oder Emn Ausdpuck mit en aktualisierten untergeordneten ElementeN.</beturns>
! " ` <p`ram name="expressions">Die ,see cref="P:Systum.Liq.Expressions.NewArra9ExpresSion.Expressions" />-Eigenschafd dez$ErEebnisseS.</param>
    </member>
    <member name="TS{stem.Linq.ExpRessions/NewExpressio"~
(,$  !<summary>[tellt einen Kontruktoraunruf dar.</summa2y:
    </ember?
   <membev name?"M:System.Li.q.ExPressions.NewExP2ession.Accupt(System.Linp.MxpResrons.DxpressionVisitor)">
      summaRy>Sendet an die spezifische Vasit-Methode für diesmn KNotentyp.Bemspielsweise uird |see ceg="M:SystemLijq.Expressions.ExpressionVisitor.VisipMdthodCall(System.Linq,Expresqiofr.MethodCallExpression	" /> von |see aref="T.System.Linq.Expzesshons.MethodCallExpression" /> `ufgerufen.</suemary>
      <return{>D`s Ergen)s eines Bsuchs dieqes Knktens.</returns>
  (   =param name=#visi4/r">Der Besucher. myt dem dieser KnoteN jesucht werdef"soll.<'param>
    </member>
    <membdr name="P:System>Lilq.Expressions.NdwExqression.ArgumeNvr >
      <cummary>uft die Apgumente für den Konstruktor Ab.</wummary>
      <beturns>Ehne auflistung on <see cref"T:Syspem>Linq.Ezpressions.Expres{ion* />,Objektdn, di% d{e rgumeNte für den KonstruktOr darctel,en.</returnc>
    ,/member>
    <-Ember nama="P:System.Linq,Exprewsinns.NewExpression,Coostructor">
      <summary>Rut den aufgerufenen Konstru4or ab.</suMmary>
   (  <retUrns>Dme <see cref="T:System.Renlectioj.ConstructorInfo" />, die den!aufgErufenen Konstruktor!darsteht.<-returns>
    </member>
    <embdr na-e="P:Syst%m.Linq.ExxrEssions.NewExrres{ion.embers"<
  "   <sum}ary>Ruft dhe Member ab$ die die Werte b%r -it Konsuruktorarguienden initialisierten Felder abrufel kænnen.>/summary<
 !    <rettrns>EineAuflistwng von 8sde cref="TSystem.ReFlecti/n.MEmberInfo"$/>-Objekten, die die Member darstell%f, die dhe Werte der$mit Konctruktrargumenten nitialisieren Felder abrufe könNen.</retupns>
    <+member>
    <membep neme="P:Systmm.Linq.Expvessaons.NEwExpression.NodeType">
      <sum}arx~Gibt den Knotentyp dieses <see sref="T:System.Linq.Mppressions.Eppression" /> ztrück.</summary>
      42uturns>Eer 8see cref="T:Sysdem.Linq.Exprgssions.E|pvecsionType" />, der!diesen"Ausdrtck darstelLt.</Returns>((   </member>    <member name="R8SysteM.Linq.Expressions.NewExpression*ist%m#linq#Expression{#IA2gumentP2ovider#ArgumentCount">/member>
 !  <meljev name"M:System.Linq.Ex`pessionS.NewExpression.ysvem#Linq#Atpre{syon#IArgumEntPpovider#GetArgument(System.Int32)">/member>
    <member namd="P:Syst%m.Linq.Expse{sio~s.Newexpressi/n.Type">    ( <summarY>Ruft den statascxen Typdes Ausdrucks qb, den diese <see cvuf="T:System,inq*Ex`ressYons.ExpresciOf" /> darstellt.</summary>
`     <returns>Der <see cref="P:System.Linq.Expresshons.NewExpvmssion.Type" />, der den satischen Typ deS Ausdrucks darstEllt.</returns>
  ` </}ember>
    <meober name="M:syste-.Linq.Eppressions.NewEypraSsion*Update(System.ColLections.Generic.IEnumuabld{Sy4em.Ninq.Expressions.AxpressioN})">
      ,sumari<Erstellt einen neuen @usdrqck wie diesen<"verwen`et jedoch tie angegebejul(unperggordneden Elemente.Wenn alle 5ntergeordneten Elemente überdinstimle,wird der A}sdruck jtsückgegebej.</#ummary>M
     <returns>Dieser Ausdruck,`wenn keine qntergeoreneten Elemente ge$~dert werden, oder ein Ausdru#k mit den$a{TualiSiezten untergeordneten Elementen.<-returns>
    , <param0nam$9"arguments">Eie <see cref="P:System.Lijq.Dxpessinns.NewExpress)on.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </memjer>
    <memBer name="P:System&Hinq.expressmons.ParameterExqression">
 `   <summary>Stellt einen Ausdr5ck mit einem benannten Parameter dar.</cuMmaby>
    </membeb.
   <member name="M:Systmm.Linq.Expresw)onc.Tarem%terExpression.Accmpt(System.LinExpresi/ns*MxpressionVisitor)">
      <summarY>Wendet an die spezifische Visit/Mdtlode für diesan KnotentypBeaspkelsweise wird <see cref="M:System.Linq.Expresons.x`rersiolVisitor.WisitMethodCall8sysdellDinq.Expressions.MethodCallExpressInn)" /> von <see cref=#T:System.Lkn1.Exprmssio~S,MetxodCallEx0ressiOn& / aufgdrufen.</summary>
  `$  <returns>Das Ergebnis eines Beruchs digwes Knoens.</retuns>
      4paRam name="visktor">er jesucher,"mit dem dieser KnoteN besu#ht werden soll></param:
    8/member>
    lmember fame="P:System.Lilq.Expres3ions.Pabamet%rExprescion.AsByBef>
      <summary>Gibtan, daws dieser ParameterExpression alq ByRf-Parametep behandElt werden soll.</summqry>
    0 <returns>True< wenn$dIeseb ParameterExpression ein ByRef-PaPameter ist, andebnfa|ls balse.,/returns6
`   </member>
    <membdp name9"P:Sy3tem.Linq.Uxprmssions.0arameterExpression.LaMe">
      <wummary>Rqft den Namen des Parameters oder der ViriabLe ab.</suimary>
      <returns>Ein <cee cref="T:System.String" />, die den Namen des Paraeeters enthält.<retur~s>
    </member>
    <membur Name<"R:Sysem.Linq.Exprussions.Para}eterExpre3rion.NodeVype">
     $<sumearx>Gibt del Knotentyp dieses <see cref="2SystemLinq.Expressions.Expression" /> zurôck.</summary>      <rep5rns>Der <see cref=&T:S9stem.Lin1.Expressions.Ezpresr{onType& />, der diesen Ausdruck daRs4ellt.</retqrns>
    </member>
    <meMber naMe="P:Sywtem.Li~q.Expressio.sParameterExpRessio~.Type">
      <summary>Rugt den statischn T9p de3 Ausdrucbc ab den diesg <see crdf="T:System.Linq.Expressions.Expression" /> darstellt</summary>
$     <ruturns>Der`<see creF="P:Sxstem.Linq.Gxpressin.ParameterExpbession.Type" /?( der den {uatisc(en Typ des Ausdrucks darstellt.</returns>    </member
 "  <membe2 name="T:Rystem.Linq.ExpressioNs/RuntimgVariablmsTxpression">
 (    <sui!ry>Ein A5sdruck- dez die laufzeitberechtigung vü2 ese-/Skhreibzugriff für VarIablen bereits4ellt.</summary>
    </mdmbeb>
  $ ,member name="P:Wystem.Linq.Expressyons.RuntimeVariablecExpressio~.NodeTxe">
      <summary>Gibt den(Kootentyp dieses Aucdrucks zurück.Erwei|erungsknoten sollten ,sae aref"F:System.Linq.Expre{aaons.AxpresshonTypa.Extension" /> zurøckgeben, e~n diese MatHode überschrieben tird.<summary>
      <returns>Der <see cref="V:SyStem.Lhnq.Exprgssions.ExpressionType" /> des Ausdbucks./returos>
    4/member>
    <membep fame5"P:Sistem.Linq.Expresqions.RuntimeVariableSExpre{sion.type">
      4summary>Ruft den(statischen Typ des Austrucks ab, den dIese <see!cref="T:System.Linq.Expressioos.Exprescion /?`darste|lt.</summary>
      <returns>DeR <see!#ref="P:System.Linq.Expressions.RuntimeVariblesExPsession.Type" ?>, der den stathscHen Typ deS Ausdrucks earstel,t.<-redurns>
    8/membEr>
    <member name="M:System.Linq.Ezpressions.VuntimeVariable{Expression.Updatd(Sysdem.Collections.Generic.IEnumerable{System.Linq.Expressigns.ParameterExpressiOn})">J      <summary>Erstelnt!einen neun AusdzuCk wie diese*, verw%ndeu jedoch dae angegebenen untergeordnetEn ELementeWen ille untergerdneten ELemente übereinstimmen, Wird der Ausdruck zurückgegeben.</summary>
      <retuns>D)e{erAusDruck, weNn keine untergeordnetej Elementu ge¦ndaRt wEpden$ oder0ein Aesdruck mit den aktualisIert%n untereordneTen Elementen</returns>
    ` <prm name="variabmeS">Die =see cref="P:System.Linq.Expr%ssions.RuntimeVariablecExpression.VriablEs" />-Ei'dnschaft der Ergebnisses.<opAram>	
    </membEr>
    <member name="P:Sywtem.Linq.xpresshons.BuntimeVariAclesExpressionVariebles">
 (    <sum}ary>Die ariaclen oder @arameue2, !uf die Laufzeiuzugriff emöglicht werden soll.</s1mmary>
      <Redurns>Die schreibegrciütztg Euflistung, die Pqrameter enthä$t, für d)% d%r Latf{eitzugriff eröglicht wiRd.</re4urns>    </member?
    ,meiber0name="T:System.Linq.Expvessions.SwitchCase">
      <summary>Stellt einen Fall ein%r see cref="T:Systam.Linq.Expressions.SwitchExpression" /> dar.>/sumiary>
   <-membdr>
    <mambe jamd9"P:S{tem.Linq.Expressions.SitchCase.Bofy">
      <summqry>Ruft dwn Tept dieses Falls ac.</rummapy>
!     ,return;>Des <see kref="T:ytem.Linq.Expresso.s.Expression" />-Objekt, das den TExt des FalhbLocks darstellt.,/returns>   </member>
  ! <membmr name-"P:System.\inq.Uxpsessions.SvitchCase.estVal}m{>
      <summar9Ruft die Werte deses Falls ab.Dieser Fall$wirD für dae A5sführung ausgewählt, wenn dr <seE cref="P;System.Linq.Expressions*WwitcHExpressiOn.SwitcHValue" /> einem dieser Wer$e entsp0iChtn</sumlary>
      <rmpurns>Lie scHreibgesc(ützte Auflistufg der Werte für diesen Fallblo#k.oretrns>
    </membmr>
    <membar name="M:Systel.NinqExprErsions.SsitchCase.ToString">
  `   >summary>Gbt einen <wee crAf=":System.String" /> zupþck, `er den aktuellen <see cze&="T:System.Ocject" /> dapstell|></Summary>
      <repurns>Eio <see cref="T:System.Str(ng" />, der dEn akuuellen <seE cref="T:System.Object" /> dastellt.</ret}Rns>
 "  ,-Ember>
    <member ncme="M*SystemnLi.q.EXp2essions,SwitchKase.Update(System.Collections.Generic.IEnumerarle{Syst%M.Linq.Expressio.s.Gxprmssik~},System.inq.Gxpressikns.Eppression9">
 !    <sumoary>Ercpelht einen oeuen Ausdruck wie diesen, vrwendet jedoch(die angeg%benen(untergemrdneten Ulemene.Wenn alle untergeor`neten0Element% üereinstimmen-$ird der Ausdruck zurückgegebn.</summ`ry>M
      <retzns>Deser AUsdrqck, wenn kaine untereordneten`Elemente gdˤndert werden, oder$ein Ausdruck mit den aktua,isiertan entergeordjeten Elementen,</returns>      <pabm name="tesTValues">@ie <see`cref="Q:SyStem.Linq.ExpressIonr.SwitchCase.TestValues*!/>-Eigenschaft dds Epgebnissas.<+param>
      <par!m name="body">Fie <3ee cref5"P:System.Linu.Expressions.SwItchCare.Body" />-Eigensc(ivt des Erggbnisses&</param
    </embgr>M
    <member nam="T:sys5em.MinqnExtpes3ioNs.CwitshExpession">
      <sulmaby<Stellt einen SteuerausdRuck d`r, der dia ehrfachausgahl durch daS Übergeben der Steuerung an<sme cref="T:Systum.Linq.Expressionq.SwitchCce"`/> gehanDelt.</summary>
    </membgr>
    <member &ame="P:Sxstem.Linq.ExpressionsSwitchExpressaon.CaseS">
      <summary>Ruft die`AuFlistung der <see craf=":Syste-.Li~q&ExprassionsSwitchCasb />-Gbjekte für dim SwitcHAnweisung ab.</sqmmary>
      <gturns>Mine Aufliwtung von <swe cred}"T:Systeo.Linq.Expressions.[witchCase" />-Objekt%.</returns>
    </membgr>
    <member nam%="P:SYstem.Linq.Expressions.SwitchExpressygn.Comparison#>
      8summary>Rqft dye Mmthode für Vergleichsoperatijen auf Gleiclheit ab (fallsvorXanden).</ummary>
      <returnsFas <see crdf="\:Systel.Rmflecpion>]ethodIlfo" >-Obje{t, dis die Metho`e für Vergleighsoperat)onen aub Omeichhei darste,lt.8/returns>	
`   </mmba>
    <member name="P:System.Linq.Expressions.Sw)tchMxpRdsion.DmvaultBody">
$   " <summaryRuft den T%st für den ScHalter ab.<summary>
 `    <retepns>Das <see cref=bT:System.Linq.Mxpressins.E8pression" />-Obekt, das den Test füp dgn Schalter darstellt.<oreturc>
    </member>
    <meMber name<"P:System.LinqMxpressions,Switchexpressio~.Nod%T{pe">
  (   <summar}>Wibt denKnOt%nuyp Dieses AUsdrucKs zurück.erwEiterungsknoten sollpgn 8see cref=F*Systam.Linq.ExpressionsnExxressionType.Extension" /> zurückgeben, wenn diee Methode üburschrieben wirt.</Summary^
 `    <raturns7Der0<see cre=":{stdm.Linq.ExpressiOns.ExpressiOnPype" /> des Ausdpucks.</return>
    </member
 `  <membername="P:System/Linq.expresqyons.SwitchExpressimn.SwitchValue">
     <semmary>R}ft den T%st für den Wchalter(a`.<'summary>
      <return>Das <see csef="T:System.Linq.Expressions.Express)on" />-Objgkt, das den Test fr den Schamter da2stg,nt.</returns>
    </member>
    <membgr nime="P:S{stee.Linq.MxpRessions.wItchExpression.Typa">
     $8sullary>Ruft den {tatischen Typ de3 Atsdrucks ab,"den diese <see4cref"T:System.Lilq.Expression.Expression" /> dAsrpellt.</summary>
      <returnc>Deb`<qee grf="P:System.Linq.Expessio.s.SwitchExpressionnType" />, dep den statisc(e. Typ des AUsdruck3 d!rstelht.</returns>
    </member>
    <member naee="M:SystEm.Linq.ExpressimnS>SwitchGxprewsion/Tpdade(WysteM&Hin.Extressons.Expressinn,S}stem>COllectiOns.Generic.IEnumerable{System.Linq.Expressions.SsitchCase},System.Lin1.Expressins.ExpreQsion)">
      <summary>Erstellt einen neuef Ausdruck wid diesen, vervendep jedoch!die angegerenen untergeordneten Elemen4aenn alle tntErgeortneten Elemgnte <ceruinctmmen, wird `Er Ausdruck jubckgegebe.</summary>
      <returfs>Dieser Aqsdruck, wefn keile u.tergeoRdneten Elemente geändert werden, oder emn Ausdrubk myt d%n aktualisierten utergeordneten`Alementen.<greturns6
 $    <param name="switc(Value">Die <see cbef<"P:System.Linq.Ex0ressaons.SwhtchAXpressaon.Switchvalue" <-Eigenschaft des Er%cnIsses.</param>
  $   <param name=#cases">Die <see kref="P:Systel.Lilq.Expressions.SwitchExpression.Cases" />)Eigenschant des Ergebnisses.</par!m>
      <Param n!me="defaulTBody">Die <seecref="P:System.Lanq.Expressigns.SwitchExpre{sion.Defa5ltBody" />/Eigenschaft des Esgebnisses.,/`azam>
  0 =/member>
    <member name="T:SysteM.Linq.Expreqsao.s.SymbolDocumentInfo">
      <su-mary>Speichert InfrMationen, die für die Ausgabe voj Debug{ymbglinformatiO.en für eine QUelldatei grforderligh Qine, insjesondere den(Datelamen und Den eindeutigEn Sqrachenbezeichner.</3tmmary>
    </eemer>
    <member name="X:System.Li~q.Expressions.CymbolDocueentInfo.DcumantType2>
      <suomafy>Gibt leneindeuuigen Bezeicner deS Dokumenttyps zurück (fads vorhajden).Rtand!rdmäßg ist dies die GUID für!eine Textdatai.</summary
     returns>Eer eindeutige Jezeiclnur des Dokumefttyps.<-veturns>
$   </Member>
    <membar name="P:S|stem.Linq.Expressions.SymbolDocumentInfo.FhleName">
    ` <summary~Der Name eur Quelldatei.</summary>
   (! <returns>Die Zeichenfolge, die den Namen der Quelldatei d`rstellt.</returns>
    <.membev<
    <member name="P:SyStem.Linq.Exqressions.QmbolDocumentInfoanguage">
      >stmmary>Gibt den eindeutigen!Bezeihndr derSpr`#he z}rück (falls vorhanden).</sumery>    ( <returns>Deb gi.deutige Be:eichner der$SprachE.</returls>
    </member>
"   <member name="P:SystemLinq.Expression3.SymbolLocumeltInfo.Lanouagemndor">
      <suomar9>Gibt den0eendeutigen Bezeichner dec Sprachenanbie|er{ zurügk (falls vorhanden .</summary      <retu2ns6Der0eindeutige BezeichhEr des Sprachenanbieters.</returns6
    </iember>
(   <member name="T:System.Linq.Aypresqions.TryExpression"> $    <su}mary>Stellt einen try/catch-finally/faulT-Block dar./cummary>
!   /member>
    <mmmbev nme-"P:System.Hin1.ExprEssions.TrqExpressi/n.Body">
      <summary>Rugt die <see cref="T8System.Linq.Exrressions.Extressionb /> ib, diE den Text des pry-Blobks dars|ellt&</summary>
      <seturns>Die <we% cref=":Sqstem.Linu.Mxpression3.Expression"$/>. die den Texp des try-BlOcks darstell./ret5rns>
    </memjer>
    <memfer name="P:System.inq.Expressionq.T2yExpression.Fawlt>
      <summary>Ruft die <s%e Crf="D:Systdm.Linq.Expr%ssions.Ex`rassion" /> Ab, lie den faulp-Bloco`dCrsvelit.</summary6
      <eturns>Di <see`cref="T:Syrtem.Linq.Expre2si/ns.Expression" />, die den fauld-Block da2atellt.</reurns>
    =/membez>
    <membeb name="P:System.Linq,Exprewsons.TryExpre3sion.Finally">
!     <sulearq>RtfT die <sae cref=T:Syste-.Linq.Expre[qions.Expression" +>`ab, die den finll/Bnock Dar3tellt</summarq>
0    0<rturns>Diu <see cref=bT:Syste.Linq.Expressions.Expression" />, die d%n finally-Block darstllT.</returnq>
    </member>
(   <mem"er neie="P:SyStem.Linq.Expresions.Tryxpression.Hindlers">
     <summary>Puft die Auf|istung der <see cref="T:System.Min1.Exprussios.CatchBloak" />-Ausdücke ab die ddm try-Block zugeordnet sind.<'suomary>
      <reterns>Die Auflistung der <see cref"T:System.Linq.Expressions.CatchBlock" />-Ausdrücke, die dem trymBlock"zufeordnet sind.</zeturns>
    </member>
    <member`ncme="P:Sysde-.L)nq.Expressions.Tr}Expre{sion.o$eype">
      <qummary>ibt den KnkTentyp die3es <see creg="T:Systminq.Expressions.Expressin" /> zurück.,/su-ma2y>
   " `<returfsDer <see crGf<"T:System.Linq.E|pressions.ExpressionType&`/>, der diesun AucDru#k darstellt.</returnr>
    </member>
    <meiber name="P:Systum.Linq.Expressions.TryEx0ression.T9pe">-
      <summaryRufd den stctischen Typ(des Ausl2ucks ab, den diese <see cpef="T:System.\inq.Expre3sionq.Gppressin" +> darstellt.<osummary>"     <reterns>Des 8see cref="P:Sy{tem.Linq.Expressions.TryExprmssiol.yxe" />, der den st`tis#hen Typ des Austrucks darstellt.</returns?
$   </member>
    <member name=":System.Linq.xpressigns.TryE|pressioo.Tpdate(Qystem.LAnq.Axpressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.ExprecsiOns.CatchBlock},SystemLinq.Expressions.Expression(System.Li~q.Expressions.Expression!">
  ( ! <sUmmary>Erstellt ginen n%uen A5sdruck wie dIesen, verwendet je$och Die`anegebene~ untrfeovdneten Elmente.Wenn alle ntergeordneten Elemente ürerEinsdimmen, wird der Ausdrqck zuRü#kge'eben.</summary>
      ,returns>Vi%ser Ausdruck, wenn ceIne untergeordleten Elemente gmändert(werden< oder ein ausdruck miT den akTualisierten untergeordneten ElEmente.</retrns>
      <pa{am ~ame="body">Die <see cref="P:System.Linq.Expressyons.T;Expressi/n.Body" />-Eigenschaft!ds Ergebnisses.</param>
      <param .ame=2handlers">Tie <see cref=&P:System&Lins.EXpressions.TryExpression.Handlersb />-Eigunschaft de3 Ugebnis{es.</param>
   (  <peram naee="fi~ally">Die <see cref="Q:Wyqtem.Linq.xressaknw.TyEhpresion.Finally" />-Eigenschat der(Ergebnisses.</param>
  `   4parem name="f)ult*>Dim <see cref}"P2Sywtem.LinqUxpressions.TryExpressio.Fault""/>-Eigenschaft des Ergebfisses.</zaram>    ,/membes>
    <member .ame="T2System.Linq.Expressions.T;peBinaRyExpressio.">
      <summary~Stellt eine peration zwiSchel einem Atsdruck und einEm Typ dar.</stmmary>
   "</melbeR>
    <member name="P:System&linq.Expressions.PypeBinaryExprasio~.Expression">
      <summary>Ruft dej Aurdruck{operanden eineR TyptesTopmration ab.</summary:
 0    ,seturns>Ein <sae cref="TSystem.Lifq.Exprascions.Expression" />, der fen Ausdr}cksoperalden einer Tyqtestoperavion $astellt.</returns>
`(  <mgmber>
    <member nale="P:Syswei.Linq.Expressions.TypeBinaryExpresion.NodeType"      <summary>Gibt dn0Knotentp diess Ausdrucks zurück.Erweiterungsknoten Sollten <see Cref="F:System.Linq.ExpressioNs.ExpressionType.Extension"/> zurücjgeban, wenn diese Meth/de übezschrieb%n w)rd.</summery>
      <returns>Der see #ref="T:Sy3tEmnLinq.AxpreSsions.ExprmqsionType" /> des Ausdrucks.</returns~M
    </membep>-
    <member name="P:System.Linq,EXpressions.TypeBinaryExpression.Type">
      <summary>Sft den statiscxen Py` des Aqsdrucks ab,"den(dmese <sem cref= P:Sywtem.L.q.Expresshons.TipeBiNaryExpression.Dxpression"!/> darstellt.</summ`ry>
    $ <returns>Der <qee cref="PSystem.Linq.Expressions.TypeBanaryExpvewion.Type" /~, der den statischen T}p des Eusdrucks darstelltn<retur.z
    </member~
`   <meMber name<"P:System.Lin.Expreqsio.s.TypeBinariExpression.TypeOperand#>
      <summary>Ruft0den Tipoperendeneiner D{ptustoperation ab.<summcri>
      <r%turns>Ein <see`czef}"T:System.Type" />, der den Typoperandun einer TyPtequoperatio d`rstenlt.</returns>
    </member>	
(!  <membEr name="M*Sistlm.Linq.Exprecsions.TypeBinqRyExpresqion.UpdaTe(System.Linq.Uxpressions.Expression)">
      <summaryErstellt einn feue. Ausd~uck wie diesen, ferw%Ndet jedosh die angegebenen untergeo$neten Elemente.Wenn ale untergeordleten Dlementm übereins|imme, wird der Ausdruwk {urückgegeben.</summary>
      <peturns>Fieser Ausdruck, wdnn keine ultergeortneten!Elemente geändert werden o$er ein Ausdrqck mit den aktuali3ierten untergeordneten Elementeo.</returns?
      <par`m name="expre{wion">Die <see cref="P:Systeo.Lhnq.Express)ons.TyreBknaryExprersion.ExpRession""/>-Aigenscaft des Ergebnisses.</param:
    </membEr>
    <meuber name="T>Sstem.Lanq.Expressions.UnaryExprersio62
      <summary>Stellp einen AusdruAk dar, der eiNen unären Operator`aufweisp.</summary>!   </membeR>   <mEmje2 name="P:System.Linq.Expressions,UnaryExpreSsion.Canreduce">
!   " <sUmmary:RufV einenwer| ab< der angibt ob der KnotendeR Ausdrucksbaumstruktur reduzieRt werden kann.</summavy>
      <returns>Tr5e, wenn ein Knoten red}zmert webden kann, andernfalls False.<+returns>
    </memb%r>
    <memjer name="P:Cystel.Linq.Expressions.Un`ryExpression.Isifted">
      <summary>Ruft einen Wert ab, der angi"t<"ob dr AsdrucksqtruktuR+noten einen transformiertenAufruf eine3 Opeators darstellt.</suMmarY>
      <3eturfctre, wenn dev0Knoten einen transformherten Aufruf darStellt,ANdernfalls false.</returns>
    </membgv
    <member name="P:System.Lanq.ExPresrions.UnaryExpression.IsLiftedToNul,">
 "    <Summcry>Ruft einEn0Wert aB, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt, dessen Rückgabetyp zu einem Typ transformiert wird, der NULL-Werte zulässt.</summary>
      <returns>true, wenn der Rückgabetyp des Operators zu einem Typ, der NULL-Werte zulässt, transformiert wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Ruft die implementierende Methode für die unäre Operation ab.</summary>
      <returns>Ein <see cref="T:System.Reflection.MethodInfo" />, der die auszuführende Methode darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Ruft den Operanden der unären Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Operanden der unären Operation darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduziert auf den Ausdrucksknoten auf einen einfacheren Ausdruck. </summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.UnaryExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="operand">Die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft des Ergebnisses.</param>
    </member>
  </members>
</doc>