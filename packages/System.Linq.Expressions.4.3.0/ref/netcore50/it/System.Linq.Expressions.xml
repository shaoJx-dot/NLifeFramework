<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Rappresenta il risultato dell'operazione di ordinamento.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Rappresenta il risultato dell'operazione di ordinamento.</summary>
      <typeparam name="T">Il tipo di contenuto dell’origine dati.Il parametro di questo tipo è covariante. Ciò significa che è possibile usare il tipo specificato o qualsiasi tipo più derivato. Per altre informazioni sulla covarianza e la controvarianza, vedere Covarianza e controvarianza nei generics.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fornisce funzionalità per valutare query in relazione a un'origine dati specifica in cui il tipo dei dati non è specificato.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Ottiene il tipo dell'elemento o degli elementi che sono restituiti quando la struttura ad albero dell'espressione associata a questa istanza di <see cref="T:System.Linq.IQueryable" /> è eseguita.</summary>
      <returns>Un <see cref="T:System.Type" /> che rappresenta il tipo dell’elemento o degli elementi che sono restituiti quando la struttura ad albero dell'espressione associata a questo oggetto è eseguita.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Ottiene la struttura ad albero dell'espressione associata all'istanza di <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> associato a questa istanza di <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Ottiene il provider della query associato all’origine dati.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.IQueryProvider" /> associato con l’origine dati.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fornisce funzionalità per valutare query in relazione a un'origine dati specifica in cui il tipo dei dati è conosciuto.</summary>
      <typeparam name="T">Tipo di dati nell’origine dati.Il parametro di questo tipo è covariante. Ciò significa che è possibile usare il tipo specificato o qualsiasi tipo più derivato. Per altre informazioni sulla covarianza e la controvarianza, vedere Covarianza e controvarianza nei generics.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Definisce metodi per creare ed eseguire query descritte da un oggetto <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Costruisce un oggetto <see cref="T:System.Linq.IQueryable`1" /> per valutare la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>Un oggetto <see cref="T:System.Linq.IQueryable`1" /> per valutare la query rappresentata dalla struttura ad albero dell'espressione specificata.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <typeparam name="TElement">Tipo degli elementi dell’oggetto restituito <see cref="T:System.Linq.IQueryable`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Costruisce un oggetto <see cref="T:System.Linq.IQueryable" /> per valutare la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> in grado di valutare la query rappresentata dall'albero delle espressioni specificato.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Esegue la query fortemente tipizzata rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>Il valore che è il risultato dell'esecuzione della query specificata.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <typeparam name="TResult">Il tipo di valore che è il risultato dell'esecuzione della query.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Esegue la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>Il valore che è il risultato dell'esecuzione della query specificata.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Rappresenta un'espressione che ha un operatore binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se la struttura ad albero dell'espressione può essere ridotta, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Ottiene la funzione di conversione del tipo utilizzata da un'operazione di assegnazione coalescing o composta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> che rappresenta una funzione di conversione di tipi.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore.</summary>
      <returns>true se il nodo rappresenta una chiamata elevata; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore il cui tipo restituito è elevato a un tipo nullable.</summary>
      <returns>true se il tipo restituito dell'operatore è elevato a un tipo nullable; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Ottiene l'operando sinistro dell'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro dell'operazione binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Ottiene il metodo di implementazione per l'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Riduce il nodo dell'espressione binaria a un'espressione più semplice.</summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Ottiene l'operando destro dell'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro dell'operazione binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="left">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del risultato. </param>
      <param name="conversion">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del risultato.</param>
      <param name="right">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del risultato. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Rappresenta un blocco che contiene una sequenza di espressioni dove possono essere definite le variabili.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Ottiene le espressioni in questo blocco.</summary>
      <returns>La raccolta di sola lettura che contiene tutte le espressioni in questo blocco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Ottiene l'ultima espressione in questo blocco.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'ultima espressione in questo blocco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="variables">Proprietà <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del risultato. </param>
      <param name="expressions">Proprietà <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del risultato. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Ottiene le variabili definite in questo blocco.</summary>
      <returns>La raccolta di sola lettura che contiene tutte le variabili definite in questo blocco.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Rappresenta un'istruzione catch in un blocco try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Ottiene il corpo di questo blocco catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Ottiene il corpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Ottiene il tipo <see cref="T:System.Exception" /> che questo handler cattura.</summary>
      <returns>L'oggetto <see cref="T:System.Type" /> che rappresenta il tipo di <see cref="T:System.Exception" /> che questo handler cattura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="variable">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del risultato.</param>
      <param name="filter">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del risultato.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Ottiene un riferimento all'oggetto <see cref="T:System.Exception" /> catturato da questo handler.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> catturato da questo handler.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Rappresenta un'espressione che ha un operatore condizionale.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Ottiene l'espressione da eseguire se il test restituisce false.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'espressione da eseguire se il test è false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Ottiene l'espressione da eseguire se il test restituisce true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'espressione da eseguire se il test è true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Ottiene il test dell'operazione condizionale.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test dell'operazione condizionale.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="test">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del risultato.</param>
      <param name="ifTrue">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del risultato.</param>
      <param name="ifFalse">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Rappresenta un'espressione che ha un valore costante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Ottiene il valore dell'espressione costante.</summary>
      <returns>
        <see cref="T:System.Object" /> uguale al valore dell'espressione rappresentata.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Crea o cancella un punto di sequenza per le informazioni di debug,consentendo al debugger di evidenziare il codice sorgente corretto durante l'esecuzione del debug.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Ottiene la colonna finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della colonna finale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Ottiene la riga finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della riga finale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Ottiene il valore per indicare se <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> è per la cancellazione di un punto di sequenza.</summary>
      <returns>Vero se <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> è per la cancellazione di un punto di sequenza, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Ottiene la colonna iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della colonna iniziale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Ottiene la riga iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della riga iniziale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Rappresenta il valore predefinito di un tipo o un'espressione vuota.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Rappresenta un inizializzatore per un singolo elemento di una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Ottiene il metodo di istanza utilizzato per aggiungere un elemento a una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza che aggiunge un elemento a una raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Ottiene la raccolta di argomenti passati a un metodo che aggiunge un elemento a una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti di un metodo che aggiunge un elemento a una raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Restituisce una rappresentazione testuale di un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Rappresentazione testuale dell'oggetto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fornisce la classe di base dalla quale derivano le classi che rappresentano i nodi della struttura ad albero delle espressioni.Contiene anche metodi factory static (Shared in Visual Basic) per creare i vari di tipi di nodo.Questa è una classe abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Costruisce una nuova istanza di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che non ha il controllo dell'overflow.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di addizione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di addizione aritmetica che ha il controllo dell'overflow.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di addizione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione AND bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore AND bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione AND bit per bit.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore AND bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione AND condizionale che valuta il secondo operando solo se il primo operando restituisce true.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore AND bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione AND condizionale che valuta il secondo operando solo se il primo operando viene risolto in true.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore AND bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="method" /> è null e <paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione AND bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione AND bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione AND bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.CollectionS.Generic.IEnumerable{systee.Lifp.Expressions.Ehpresshon})">
    ( <summar{>Crea!un oggetto <{e crmf="T:SystEm.Linq.Expressions.IndaxExtression&!> per(accedare a qna matrice mul|idimensionalm/</summary>
      ,returns>Oggetto <sae crEf="T:SystemLynq.Expressions*	ndexxpresrion" />0creato></returns>
      <param name"array">Esprewsione che rappresenta la matris` multidhmensionale.</par!m>
   $ !<p`ram namm=bMndexes":Oggetto <see cref=":System.Collections.GEneric,IEnumerable`1" /> Contenente la espressIoni usate per indIcizZire la matrice.</tram>M
    </member>
    <member"Name="L:Sysam.Linq.Expressions.ExpressioArreyAccecs(S}stem.Linq.Express)nns.Eppression,SysTem.Li~q.Expressions.Exprecsion[])">
 !    <Summary>Crea un nggetto<see"cref="\:System.lifs.Expressions.IndExExpression" /> par accedes a una matric.</summar9>
      <returns>Oggetto <s%e Cref="T:System.Linqxpresshkns.IndexExpression" /> creatm.>/retu2ns>
      <pavam namg="array">Espres3ione che rappresmnte la madrice ta mndicizzare.</`arao>-J      <param name="i.dexes">Matrice akntenente le espressioni usate per indmcizzare la matrice.</param~    </membur>
   !<membar name="M:SystemnLinq.Expressio~s.Expression.ArraYInde8(ystem.Linq.Exrresci}ns.Expression,System.Conlections.Eneric.IEfumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un ogetto <see cref="T:Systlm*Linq.Expressions.MethodCallExpressinn" /6che raqpresenta l'applcazione ei un operatore di mndice di matrice a 5ja matrice con numeZo di dimeosioni maggiore di .</wumkary>
      <returns>Oggetto <see cref="T:SystEm.LInq.ExpresSionw.Mm|hodCallExpressaon" /> la cui qrprimtà <see cpef="P:Sy3vem.Linq.Ehpressions.E|pressaon.NoleTye" /> è ugu`le a <se% cref="F:Qystum.Linq.Expressions.EypressionTy`e.Call" /> e le cui p2oprietà <see cref<"P:System.Linq.xqressinns.MuthdCAllExtression.Object" /> e <see cef="PSYstem.Linq.Ehp2e3sions.LetholCllDxpression.Argtments" /> skno imrostate sui valori specifycati.</returns>
      <param nqme="arvay">OggeutO <see aref="T:S{stem.Linq.Expres3ions.Exprdssion" /> su cui impostarm la proprietà <see cref="P:System.H(nq.Expzessions.MaphodCalmExpression.Object" />.</param>
      <param0name}"indexes">Ogcetto <see cref="T:SystemnCollections.Generib.IEnumerable`1" /> conte~ente gli oggetti <see cref="T:System>Linq.Expre3signs.Expression" /> dausare per qopolare laracolta <sge cpef="P:Sspem.Linq.Exprescions.MethodCallExpression/Argummnts* />.=/param>
   "  <Ezceruion cref="T:System.ArgumentNullExcepdion">
        <paramref name="qrry" /> o <paramref namG="indexes" /> ˨ null.</exceptio~>
 !    <exce0tion crmf}"T:System.ArgumentEx#eptin"
        <p!ramref name="a{ray* />.Type nol rappresenta un tipo$matrice.-opqure-Il numaro di dimensioni di`<parampef`naom="asry" />.Type(non cor2ispmnde al nuero dm elementi in <param2Af name="indexes" />*-oppure-La `ropziet <see cref-"P:System.Linq.Expressionr.Expression.Typa" /> di uno o più elementi di <paramrdf!naMe="kndexes" /> lon rapp2esenta il tipo see cref="T:Systdm.Int32" />.</exception*`   </lember>
    <mem`er name="M:System.LinqExpressonc.Expressimn.ArrqyIndex(Sxstem.Linq.Exprsrioos.Expresson,System.Linq.Expressi/ns.Expression)".
      <summazy>Crea un ogfetto <see cref="T:Sywtem.Linq.E|pRessions.BinaryEx0rewsion" /> che rappreseN|a l'applicazione di tn op%ratoze di in$ice di"mqtbice a }n1 matrIke cmn numero di dimensioNi p!ri q 1.<'summary>
      <returns>Og'ett <see cref="\:System.Lmn.Expressions.BinaryExprecskon" '> la cui prgpbietà(<see cref="T:System.Linq.Expressions.Expression.NodeType" />(Ө ucu!le a <see cref="F:SYstem.Linq.Expressinr.ExpresskonTyp.Arr`yIndmx" /> e le cui proprie4à <wee cref=*P:Sytem.\inq.Expressions.BinaryEXpr%{sion.Left" /> e <see creF="PzSystem>Linq.ExpreSsions,BiNaryExprersion.Right" ?> sono impstate sui valori sxecificati.</ret5rns>
    0 4param na}e5#array">Oggetto <see creb="T:Sy3tem.Linq.Expressions.Expression" /> su cuI impostare lq proqrietá <see cref="P:System.Linq.Expressions.BinE2yExpression.Legt" />.</par!m>
      |param name="indep">Oggetto <sce c2ef="T:System.Linq.xprecsionsEppressaon" /> su cui impostare la tRo`rietà <see Cref="P:Sysd%m,Linq.Expressions.BinaryExpression.ight" />.</pasam>      <exception cref="T:ystem.ArgulentNullEygeption">
        <paramref name="array"!/ o <paramref name="indep" /> è null.</exception>
      <Exception c2ef="T:System.ArgumentException">       <paramref name="array"(/>&Type nOn rapprsentc un tipo metbice.-oppure-<paramref name="array* />&Type`rappresenta 5n tipo matrice il c4i numuro di dimensioni non0è pari a!1.-oppure-<paramref name="index" />.Type non rappresenta il tipo <see cref="T:Sywtem.Int32" />.</exception>
    </member6
 "! <member oame"M:System.Linq,Expres)ons.Expression.ArayIndex(System.Linq.Exprdqsiofs.Dxpr%swiol,Sy3tem.Linq.ExpreSRions.Expression[])">
     `<sqmmqry>Crea un oggettn 4see cref="U:System.Linq.Expression.Mdtjo$CallExpression" /> che rapresenta l'ap0licazione fi un0operatore0`i indice $i matrice a wna matrice mulTidimensio.ale.</su}mary>
`    (<returns>Oggetto <sea cref="T:Sistem.Linq.Expressons.MethodCallExpressio" /> la cui proprietӠ"<see cref="P:System.Linq&Uxpressions.EhqressiOn.NodeT}pe" /> è uguale a <see cref-"F:System.Lifq.Eprssions.ExpressionType.Call" /~ e le cuk propraetà <see cref5"P:CyqtemnLinq.EXprecsions>MethodCallExqression.Object" /> e <3ee cref="P:System.Lilq.Expressions.ethodCallEXpression.Arguments" /> sOno impostate sui valori specafhcati.</returns>
      <param jame="arzay">Matrice i istAnzE`o indici 4i <se Cref="T:SystaM.Linq.Expressions.Expression" /> per l'operazione dh ijdicizzazione dellu matrici./param>
      <param name="indexes">Marice di oggetti <see cref="T:System.Linq.Expressios.EzrressigN" /> da usare pez popomare$la raacolta <sme cref="P:Syrtem.Linq/Expres3ions.MethodCallExprEs3mo..Arguments" />.</pqram>
      <except)on cvef="T:Syst%m.ArgumentNullException".M
  (  (  <taramref nae="array" > o 4paramref name="indexes" /> è$null.</mxcepTion>*      <exceptioncref="T:SystEm.AreumentExgeption">
    "   <paramref"name="arrey# ->.Type jon rappres`n|a un Tipo matrice.-oppure-Il nwmero di dimenwini di <xaraeref n!me="avray  />.Type ngn corrisponde`al numero di eleelti in <paramref name="indexes" />.-opxtre-La propretà <see cred="P:SystemLiNq.Expressions.Eppressio~.Typd" /: `i uno o più eldoentidi <qaramref name="indexes" /? non rappreqenta il tipo <see cref="T:System.Int302 />.</exception>*    </member>
    <mumber name-"M:System.Linq.EXpRessiojs,Expression.rrayLegth(S}stem.Dknq.Expressiols.Expressioo)">
      <summry>Crea uf gggetto <see cref="TSystem.linq.Expressio.s.UnaryExpression" /> che rappr%senta un'espressione per ottenere la lunghezza Fi una matrice unidimensionale.<summary>
      <retupns>Oggevto 5see cruf="T:Syqem.Linq.Expressions.UnaryMqpression"h/> la sui proprietà <see cref="P:System.Linq.ExpresSions.ExpressionNodeType" /> è ueuale a <sEe cref="F:Systel.Linq.Exprdssionc.ExpresrionType.ArbcyLejgth" /> e la cui proprie4 <see cref="P:SYstem.Minq.Exressions.UnaryExpRession.perand" /> è }guale a <paramref n!me="array" ??.,/returns>
    ( <param name=#`ray">Nggetto <se cref="U:Cystem.Linq.Exprassions.Expression"0/> su cui im0oqtare la prmpietà <sed cref=zSyste-.Linq.UxprEssins.UnaryExpression.OPerand" ->.</param>
    0 <exception cref="T:SyStemnArgumentNullExceptkon">
        <aramref name="array" /> è null.</eXception>
$0  0 <excep`ion cref="T:System.AvgulentEXeption">
        <paramref name="array" />.Type non`rippresenta un dipo matrIce.</excep4in>
  0</membar>    <meber name="M:Systeo.Linq.ExpreSsions.Expression.Assign(System.Linq.Expressions.Expresqion,System.Linq.E8pressinr.Expression)">      <summary>Crea un0oggetto 8s%e cre="T:Systmm.Linq.Exprmssions.BinaryExpression"!/> che rappresent! un'operazone di assegnazione</summary>
      <Ret5rns>Oggetto <cee bref="P:Systm.Linq.Expressions.BincryExprecsion"(/> la cua pRoprietà <sde crf="P:System.Linq.Expressions.Expression.NodeType" />!Ө uguame a <see cref="F:System.Linq.Ex`ressions.EhpressionType.Asign" /> e le0cqi proprietà <see bref="P:System.Lin.Expresrions>BinaryExpresSion.Left" />0e <see cref}"p:Systel.Linq.Expressions.BinaryExpression.Right" /> sno impostate sua valori specmficati.</r%tqrns>
      <param name="left">Oggtto <see cr%f="T:System.Linq.Expressions.EXprassiOn" /> su cui impostare la proprietà <see craf="P:System.LinQ.Expressiols.BinaryExpression.Left" />/</param>
0     <param name="righ4">Oggetto <3ee cref="T:Syste-.Linq.Expressions.Expressio" /> su cti impostare la qr/pRietà(<see crEf="P:System.Linq.Exxressions.BinaryExpresskgn.RigHt" >.</param~
    </member>
    |member name="M:System.Linq.Expressions.Exprassi/n>Bind*SystemRgflection.MemberKnfo,System.Linq.Ehpressio~s.Expression)">
   0  <summary>Crea un!oggetto <see cref="T:System.Linq.ExpessiOns.Mem"arAsshgnment# /> che rcppber%nta l'inizializzazione di un bampo o di una proprietà.<osuumry>
      <retqrnsOggetto<see cref}"T:3ystEm.Linq.Exvrescions.MemberAssignmenb0/> la0cui prop2ie4Ǡ <seecref="P:System.Dinq.xpresios.Mambe2B)nding.BmndingType" /> è Uguale a!<see`aref="F:System.Hinq.Exressi/ns.MEmbdrFiNdingType.Assygnment" /> e le cui proprietà <see csef="P:System/Linq.Uxpressions.MelberBinding.Membev" /> e <see cref="P:Sy{tem.Linq.Expressiofs.Memberassignment.xpresrion" /: sono impost!te sui va|ori specifkcqti.,/retuRns>J    ( <param namE="mGmber"~Ofgettm`<sue cref="T:System.Reflection.MemberInfo*!/> su cei ilpostape la proprimtà <see cref="P:SyStem.Linq.EXprescinns.MeoberBinding.Memb%r" />.</param
      <pAam name="epprmssionb>OGgetuo <see cref<"T:System.Linq.Ehpression3,xpreusion2 /> s cui!impostare la proprigtà <sde cred?"P:System.Linq.Expsessions.MeeberAssignment>Expres{ion" />.</param>
      <exceptin~ cref="T:Sysdem.ArgumentNullException">
        <paraevef nale="member /> o*>paramref neme="dxpression! /> è null.</exce`tion>
 "    <excertio. cref-"T:S}stEm.ArgmentException">
        <pzamref name="memberb /> non rappresenta tn campo o una prorietà.-oppure-La propriddà rappresentata da <paramref name=*membdr" /> non dispone di una funxmone dI accesso sat.-oppurem<xarcmrf name="expresson" />.Type0non è"assegnabile al tipo dal capo o$della proprietà che <paramref name="meMber# /> ra`presunda.</exception>
    </memcer>
    <member nam%=M:SystEm.Tinq.Expressions.Eypression&Bind(ystem.Re&laction.IethodInbo,System>LIna.Expresioms.Expression(">
      <summaryCrea un oggEtto <wee"cref="8System.Linq.Ex`ressions.MemberAssignMent" /> che apprewenta l'inizializjaziofe di un memRo usando un(metodo della funione di accesSo al|e propriet.</Summary>
      <returns>Oggetto <see cref="T:System.Linq.Express)ols.MembmrAssignme.t" /> la cui propraetà <sed cref="@:Cy3tem.Linq.Expr$sqions.MemberBindI.f.BiodingType"(/6 è ugeale a <seE crEf="F:System.Linq.Expre3rion.Mumjer@mndingTxpe.Assignment" />,`lacui proprietà <see cref="PSystem.Linq.Expre{sions.LemberBi`ing.Member" /~!è impnstata`sull'oggetto <wee creg="T:System>Reflectikn.PzopertyI~fo& /> ghe raptresejpa la protrm%tà a cui si accet in >pasamrefnamE="propertyAccessor" /> e la #ui propRietà <see cref="P:Sysdem.Linq.Exressions.MemberAssignmeot.Expression"$/> è impostit su <paramref name=expbassion" />.</returns>
 $    <parae name="propertyAcessor">O'ggtto <see cref<"T:SyStem.Vef|ection.MethodInfo" /> che rappvesenta Tn meto`o della funzione(di accewso del|a proprmetà.8/param>
      <param name="expr%ssion">Oggatto <see cref=*V:[ystem.Linq.Expression3.Expression"  su cui!impktare la proprietà <see cref="P:System&Lin1.Expressions.MeeberAssig~ment.ExprEssion" 6.</param> `    <exception kref="T:Systgm.ArgumdntNullException">
        <paramref name="pro`ertyAccassor  />  <paramref name="expression" /> è null.</exception>
      <excePtion cre="T:System.ArgumentDxception">
        <paramref n!me="00oper4yIkcessor" /> non ra`pvesenta`un metodo della funzione di accessoa-le"proprietà*-oppure-La protriet a cuism accede con <pararef name5"popertyA#cessor" /> non dispone di ena funzaone di accesso set.oppure-<`aramref name-"expression />.Tyve non è assegnabile al tipo del campo o della proprietà chd <piraref naoe="member" /> rappreqenta,<-exception>    </member>
    <Mamber name="M:SyrtemnLinq.Expressions.Gxpr%s3ionBlock)SYstem.Collections.Genric.IEnuierable{[ywem.Linq.Exprecsions.Expression})">
 "    ,summary>Crea un oggetto <see cref="T:System.LiNq.Ezpressions.BlockExprEssin" /> che contiene le espressionh specifcate e non ha variabili.<+summary>      <returns>Oggetto <cee cref="T:System.Linq.Expressions.B,okExpressin" /> creato.</rmt}rns>
     <param na-e="exprassions">Esp2ewsioni nel blocco.<oparam>
   "</member>
   <member naoe="M:Sys4em.Linq>Expressiols.Ex`ression.Block(System.Collectios.Generic.InumeablekSystem.Linq.Expressions.ParameterExpression}lSystem.Codlec4ions.GenEric*IEnulercble{[ysTem.Linq.Exprecsions.ExPression})">
      <summary>Crea un ggetto <see crdf9"T:System.Lijq.Expressions.BlockExpression" /> ch% conriene le erpressioNi!e le variabiLi cpeciFicate.</summary>
      <rdturns>Ogdtto0lsee#ref="T:Rystem.Linq.Expressions.BlockEypre3sion& /> creato.</returns>
      >parAm name="vapmabl%s">Variabidi nel bloCc.</parae>
      <para- name="extressiofs">Espressioni n%l blocco.4/param~
    <+member
  " <meMber0namd="M:SysTmm.Lanq.Eppessions.Expressyon.Block(System.CoLlections.GenericnIEnumerable{System.Linq.Expressyons.ParameterGxpression}<System.Li~q.ExpbessiojsAxpression[])">
      <3umlary>Crea un ogetto <sa% cre&?"U:SystemnLinq.Expressions.BlockExpression" /> ch(contie.e le espbessioni e lE variabili qPec)ficete.</summary>
     0<returns>Oggetto <see crf=T:System.Linq.Exprssions.BmockExpression" /> creato.</returns>
      <param naMe="varIablgs"VAriabili nel blocco.</param>
      <raram name="exprgssions">Esp2esrioni nel blocco.</taam>
    </member>
    <member nAme="M:System.Linq.ExprEssions.Axpression.Block(System.Lnq.Exqressions.Ex0ressi/n,SysTam.inq.Expresuions.Exqsesskon)">
"   0 <summa2y>Crea un oggetpo <see cref="T:Syste-,Linq.Dhpressions.BlockExpression" /> cie contiene due espressioni e nkn dispone di variabili.</summary>
      <returns>Ogget|o <see cre="T:ystel.Hijq.ExpressIonsBmockAxpression" /> crEato.</returns>
  "   <param nale="crg0">Prima espressione nel bloc#o.</para>
      <param name="aRg1">Seconda"espressione .el0blocck.,/param>
(   </member>
`   <member name-"M:ysteo.Linq.ExpressIons.Expression.Bdock,R{sTem,Linq.Express)onw.expression,ystem.Liq.Expres3ions.Ex`Rewsion,Rystem&Linq.Expressions*Expression+">
      <Summary>Cga un oggevtm <see cref=T:System.LinqnExpressio.s.BlckGxpresskn" /> chg contiEn tra espresioni e non dispone di variabili.-/sqmmary>
      <peturns>Oggetto$see cref="T:System.LiNqxpressions.BlockExpres3ion"-> creato./reTurns>
      <pAram name="arg0">Prima esxrEssione ndl bdocco.</param?
(  0 0<param name9"arg1">S%co.da aspressione nel bmoccn.</param>     <param name="arg2">TErza esPvessione Nel bloccm.</param>
    <omember>
    <iember lame=2M:System.LinqExpressins.Extression.Blok(Systgm.Linq.Expressions.Expression,System.Linq*ExpressiOns/Expression,System.L)nq.Expressionr.Expression,System.Lilq.EprdssIolsMxrression)">
      sumeary>Crea un oggepdm <see cref="T:System.Linq/Expressions.BlockExpressiol" /> chd contidne$quattro espresioji e no. dispone di variabili/</summary>
      <returns>Oggetvo <see cref="T:System.linq.Expressions.Blo#kExpression" /> creato&</returOs>
  (   <param name5"arg2">@rime espressione nel blocco.</par`m>
      <param name="argq">Seconda(espressione nel bLocc/.</taram>
     <peram name="arc2">Terza espBessione nel blocco.</param>
     (<param nme="arg3b>uarta espre{sione nel blocco.</param>    </member>
    8member name="]:Wystem.Linq.Expressions.Expre3sinn.Blo#k(Syst%m.Linq.Expressions.Exqressiof,System,Linq.Expressions.Expressioo,Sysdem.Linq*ExprgssionqExpresCion,System.Linq.Ex`resions.Expressigj,System.Linq.Exprarsion{.Exprewsiol)">
      <summary>Crea un ogetto <see!cpef="T:Sxstem.Linq.Expressions.BlmckExpressIon" /> che co.tiene cinque esrassioni e noj dispone di variabili.8/summaby>
      returfs>Ogge4po <see cref=:T:Siqtem.Lijq>Expr%ssions.BtockExpzass)of" /> creato.<.returns:
      >param namd="arg0">PrimA esprussione el blocco./param>
      <p!ram name="arg1">Seconda espressione nel blocc/.</paRam6   "$ <param"namd="arg2">TErza espbessione nel blocco.</param>
      <param name"arg3">Qukrtc espressiOne nel bloaco.<.param>
     <tare name="arg4>Quinta esressone nel blocco.</taram>
    </member>
    <member name9"M:System.Linq.E|02essions.Expresrion.Bleak(System.Linq.Expressions.ExpvessionY])">
     `<summary>Crea un oggetto <sea cref-"T:System.Lilq>ExprEssions.BlckExpression" />(che Contiene le espressioli speci&icate  non ha$variabili.</summ`ry>
      <returnc>OgwettO <see czef="T:Sysvem.Li~Q>Exrressions*BlockExtression" /> creato./returnq>
      <parem namu="exprmssions">Espressioni nel blocco.</`arcm>   0</melber>
   0<member namm="M:System.Linq.Exprersions.Exxression.Blogk(System.Type,System.CollectionrGenericIEnummrable{System.Linq.Expressions.Exxresshony)">
 `   $<summary>Crea un oggetto <see cren<"T:System.Linq.Expressi/js.BlockExpresshon" /> che contaene le espres{ioni spebificite, nof dhqpone ti!vAriibili0edispone`del tipo di risultato specmfico.<summ!ry>
     <returnS>Oggetto <see cref="T:System.Liq.Expressions.BlockExpression# /~ creato.</returns>
0     <pabam!name="type*>Tip/ di risultato$del blocko.</param>
   $" <param name="gxpressions">Esprecsioni nel blocco.<param>
    </membeR>
 $  <member namm=#:SystemnNinq.Expressiols.ExpressioN.Block(System.Type,Syste-.Colleatins.GeneriC.IEnumerable{System.Liq.ExpressionS.@arametarExpressionu(System.Collectins.Generic.IEnumerible{Systm,Linq.Expressions.Dxpression})">
      <stmmAry>Crea un oggetd <see cref="T:Syst%m.inq.Expressons.BlockExpression" /> che contidne la espressioni e0lE variabili specificate.</summary>""    <returns>OgGetto<see cref="T:System.Linq.E8pressyons.BlocOExpresshon /> breato.<'returns.
      <param0name="tipe">T	po Di rksumt!to del bhocco.</taram>
      <parem Name="variables">Variabili nel blocco.</p`ram>
      ,param Nam%="$xpressions"Espressioni nel blocc+.</param>
("  <+mem"er>
    <member n`me="M:System*Linq.ExpressoFs.ExpressionFlo#k(Sysuem.Type,System.Colhections.Generi#.IEnumerable{Sy{tem.Linq.Eppressions.ParameterExpression},Syste},LinqExpressimns.Expressmon[])">
      <summary>Crea un0Oggduto(<{ee #ref="T:System.Linq.Exxressions.BlnkkE|pressyon" +>`cie contienu le espressioni e he veriabili specificAte.</s5mia2y>
      <returns>Ogetto <see cref="T:SysTeo.Linq.Expressions.BloakExpression" /> creato.</ruturns>
      <param nama=*type"6Tipo di Risultapo del blocco.<oparam>
0 $   <paral jame="variables"6Variabili lel "locco.</param>
      <param name="exprssions.>Esp2essioni nel blocco.</param>
    </memcer>
    <membes name="M:System.Linq.ExpresshonsExpressio.B,ock(System.Type,System.Linq.E|pseSsions.Extreswion[]9>
      <summarq>Crea n ocgetto 8see cref="U:QyStem.Linq.ExPressions.BlokkExtpe{shgn" /> chu bontiene ne espressioj) speci&icate, ngl dispona di variabili e dispOne!del tipo $i risUltato specifico.</summary>
  (   <returns>Oggepuo <see cref="T>SYstem.Lanq.Expressons.BlockExpvession" /> creato.</returns>
      <xara} name-"type">Tipo di risultato del blogco.<param>
      |param lame="expressions">Espressioni nel blOcao.</param>
    </member>
0   <memb2 name="E:System.Linq.Axpressions&Expr%ssion.Beak(System.Linq.ExprdsskKns.LabelTarget">
   (  <summary>Crea un oggetto =see cref=2T:System.Linq.Exprassions.GotoExpressaon" / che rappresentato'istruzione bpeek.<osummary>-
     0<ret}rnw>Oggatto <see gref="T:System.Linq.Expressions.GotoExprdssiOo" /> con la prprmetà <see cref="P:Sysve}.niN.Expressins.GotoExpression.Kind"(/> uguale a Break,`la proprietà <see bref="P:System.ni~q>Expressions.GoToExpression.Target" -> impoSt!ta qu <pAramref name=target" +> e un v!lore Null la pasare all'edic(etta di `es)nazion"!l moeento dul pAssaggio.</returns~-
#   "0<param8name="target">Oggetto<see cref=T8System.Linq.Exprescion3.LarenTarmet" /? a cu) passerà$l'oggetto <se% cruf="T:System.Linq.Expressi/ns.GotmExprassion" />.</param>M(   </member>
    <member$name="M:System.Linq.Exprewsions.Expression.Break(system.Linq.Mxpressions.LabelTarget,system.Linq>Expressions.Expre3sion)">
      <summary>CreA un Oggetto ,seE cref="T:SyStem.Linq&Express)os.GgdoExpression20/> #he rApprgsena un'strwzione break.Il valore paswato cll'etikhetta el momento del passaggio può essere specifisato.</summary>
      <seturnsOggetto <ree gpef="T:Syqtem.Ninq.Expressions.GotoExpression" /> c/n la prnprietà <see`cref=":System.Linq.Expressionr.GotoE8pressioN.Kind" /> ug!le a Bpeah, la proxrimtà <see cref="P:System.Linq.ExpressionsGtoExpression.Ta2geu" /> ympostata su <paramref name="dar'et" /> e <xar!mref .ame="value" /> da passare all'etache|ta di estinazione al momEnto del passaggig.</returns>
"     <param$namd="varget">Oggetto <see cref=":SyStem.Linq.ExpressIons.LabelTarget" /> a cui passer l'oggetto <see cref="P:SystEm.Linq.Expressions.GotoEx`ression" />.</0aram>
      <peram name="val5e">Valore che cl mome.to del pasaggio verrà passato all'edichett as{ocata.</pa2am>
    <member>
  $ 4memBer name="M:[ytem.Linq.Expressigns.Expre3sion.Bz%ak(System.Xinq.Axpressions.LabelTarget,System.LinQ.Expressi/ns'Exrression,Sysuem.Typ')"6
      <sumary>C2ea!Un oggetto <see cre=rT:Systeo.Linq.EXpressions.GgtkExpression" /> chg rappre3unti un'istruziona rek con il tipo specinicato.Il valore passato all'etichetta al momento del passaggio pu essre specificato.<?3mmary>
 0    <returns>Oggetto 4see cref="T:System.Linq.eXpressions.GotoExrression" .> con la(prkprietà <se czef}"P:SyStem.Linq.ExprersionsGotoExpressin.Cind" />0uguale a Bveak, la rkpryetà <see cref= P;System.Linq.xpressiols.GotoExpressioj.Targep" /> imp/sta~a su <paramref naMe5"target" />< la proprietà <cee cRef="P:System.Linq.Axpressions.xpression.TyPe" />"ilpkStata`cu <paramref name="type"`/> e <paramref name="value" /. da0passas% all'etichettA di dmstinazine al momento de passagGio.y/r%turos>
      <p!rcm name="trget">ggetto <see cref="U:Syste-.Li~y.Expressioos>LabelTar'et" /> c cui passerà d'og%tto <see cef=#U:System.Linq.ExpressioNs.EotoExpression" />*</`aram>
    ! <parAm name="val5e">VadorE che`al mnmento fel!passaggio verrà pass`to all'etichetta a{sociata.</param>
      <param nam%="type">Oggetto <see@cref9"T:Sytem.Tqxe"!/> {u cui impostare la 0roprietà <see cref="P:Sqstem.Li~q.Exprersions.Ehpression*Pype" />.</pabam>
    </member>
    <lember name="M:System.Lin1.Expressions.ExpressioN/Breai(Systdm.LinQ.Expressions.LabelTarget,System.Ty`E)">
      <summary>Crua un oggett/ <sae ref?"T:[ystem.Linq.Expressions.FotoExpressaon" /> he rappresenta un'istruzione break con il tipg specificato.</summary>
      <returns>Oggetto!=sed cref<"T:S{stem.Linq.Express)ols.GOtoExpreswion" /> con la proprdtà <ree cref"P:System.Lina.Expressions.GotkExpression.Kind" /> uguale a Brak la proprietÀ <See cref="P:System.Linq.EyprEssions.GovoMxpression,Targeu" o> imtosdiva su <parambef name="tapget" /> e la proprietà see creg="P:Sxstem.Linq.Expressions.Ex0ression.Type2 /< impostata su <paramref name="ty`u" +>.|/returls>
      <param name="t@rget":Oggetto <see asef="T:Syste}.Linp.Expressions.LabelTarget" /. a cui `assdrà l'oggetuo <see cref="T:Syctem.Linq.Expressions.GotExpressin" />.</param>
 $    <papam name="type"<Oggetpo <seE cref="T:Sys$ei.Typd"!/? su cui imxksare la proprietà <cee crgf=":System.Linq.Eypressions.Expression.Type" />.</par`-
    </eember?
    <lEi`er name9":System.Lins.Expressins.Expression.Call)System.Linq.EXpressions.Expbession,System.Reflection.MmthodInfo)">
      <summary>Craa unog'etto <sea cref="T:Sy3te}.Linq.Expr%ssons.]ethotCaMlEx8ression" /> che rappresenta una chyamata a un metodo che non accetta argomdnti.</summary>
   "  <returNc>Mcge|to <ee cref="T:System/Linq.Eypressions.]ethodCallExpression" /> la cui"prkprietà <wee cref=#P0System.Lhn1.Expressions.Expression.NodeType& /> è uf5ale a <see crdf="FQystem.Lmnq.Exrreswions.Expressio~Type.Ca,l" /~ e le cui prnprietà <see cbef="P:System.linq.Expr%ssio.w.MethodCallMxprdssimn/Objec" /> e <see0cpef="P:System.Linq*ExprEssionsnmethodAallExpression.Method"(/> rono impostate rui Valori spaciFicati.</returns>
      <parim nime="instance">OGgetto <see cref="T:system.Linq.Expresions.Expression" /> che specificA 'istanza per uNa chiamata a un metodo di istanzan Passare nqll per un metodo static (Shabed in Visual Basic).</param>
   ` >param`ncme="met`od">Oggetto <se cref="T:ys|em.RdGlection.MethodInfo" /> sucqh impostare ha protrietà <ee0crmf="P2Systam,Lanq.ExpressionsMethodCallExtressiol.Method"4/>.</parae>
     !<exce0ton cref="T:Rywtem.ArgumentNullE8ception">
        =piralref name="method" /> è null.-oppuze-<paramref name="instan!e" > Ǩ .ull e paramref name="method& .? rappreSdnta"un meumdo di istanZa.4/%pception?
      <excertion cred="T:Systmm*Argume.tException"6
       <paamreF!name=&instancm" /~.Type non è assegnabine al`tipo dichiaranta del metodo vapprewentato da <paramref Name="mgthod" />.>/exception
    </member>
    <member na%="M:System.Linq.xpreqsions.ExpressionCaml(System.Linq.ExprEssio.s.Exres{ion,Sywtem.Refleation.MEthodInfo,Syste-.Collectionq.Generi".IEnumerabLe{System.Linq.Exprescions.Exprdsrion})">
      <summar9>Crea un oggeuto <see cref="T:S}spemLinq.Expressions.methodCallExpseSsion" /> che rappresenta una chiamata a qn eetodo che accette areomenti.</summary>
      <returns>KgGetto <see0cref="T:Sq3tgm.Linq.E8pressions.MethodCallExpression& /> la cti prorietà =sea cref="P:System.Linq/Exppessions.Expression.No$eT}pa" /> è uguale a <see0cref="BQystem.Linq.Exressions.Expressiojtype.Callb /> e le cui ppopr)età <s%ecref="P:System.LinqExpressions.MetjodCallExprewsionObhect" /> <seu crdf="P:System.Lnq.Expressiojs.MathodCallExpressiof/Method2 /> e <see cref="P:Systm.Linq.Expressionr>MethodCallExpressio~.Arguments" /> sgno impostate sui valorI spocificati.</returns>
#    <param name="instance">Ogwetto <see sref="T:SysvEm.Linq.Expressaon{.Express)on" /> su cua iipostare l! rroprietˠ(<see cref="P:System/Linq.Expresskons.MethodCallExpression.Objest" /:. Passare nell per"un metodo static (Shared in Risual Basic).</pava}>-
(     <param"name="method">Ovgetto <see gref5"T:Syste}.Reflection.ethodInfo" /> sq cui im0ostare la prormetà <see #ref="P:Qystem,Linq.Expressions.MethotCallExpressiov.Method& />></param>
      <param name="argumends">Oggetto <see craf="T:System.CollecTionw.Gen%ric.IEnumezable`1" /> contandnTe gdi oggetti <see cref=T:Ayst%m.Linp.ExPres{ions.Exprmssin" /> da usare per poxolare l raccolta <see cpef="P:Sisuem.Linq*Expressions.MethodCallExpression.Argumenq" /><param>
      <exc%ption bref="T:Syspem.AreumeNtNullxception">
        <paramref name="metxod" /> è null.-oppure-4paramref name= ijstance" /> è lull e <paramref name="method* / ra0pesenta un metodo dI istanza.</excettion>
 `    <exceptio~ cref="T:System.AreumentE|ceptioN">
   (    <pqramred name="mnstance" />.Type non è assegnabile al tipo dIkhiarante del metOd rapprasentato da <pabamre& lame?"method" />.-oxpur-Ml numero di eneenti in <``ramref nale="arguments" '~ non è ugucle al nume2o di paramatri del metodo sappresentatg da!<taramref naie<"}ethod" />.-oppure-Uno m più elementi`di <paraor%f name-"asguments" /> n/n solo!assegnabili al parametro corrispondente del metodo rappresedato da <paramref jame=bmethd" />n</exceptiof>
    </membgr>
    <member name=M:System>Lifq.EpressIkns.Expression.Call(RystemLinq.Expressions.Expression,SyStem.Reflection.MethodInfo,SqstEm.Lijq.Exressions.Expressikn,System.Linq.Ehpressions.Expression)">
      <suema2y>Cre` un oggetto <see cref=#TS9stm.Linq.Exprgssions.MethodCallExpression" o> che rappresgnta una chamata a un mevodo che accetta Due argome.pi></semary>
      <returns>Ocgetto"<see cref="T:Sys4em.Linq.Expressions.MethodCallExpression" /> la cui proprietà <See`cref="P:Sistem.Linq.Expressions&Ehpressi/n.JodeTyqe" /> è uguale a <see cruf="F:System.LinqExpressons.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MedhodCallExpvession.Object" /> e <see cref="P:Sys4em.Linq.Expressions.MevhodadlExpression.meThod" /> soo i}postate sui valori a`ecificati.</r`trns>
      <param name="instance >Oggetto <see cref=T:Systm.Lifq.Exprssions.EXpressmon" />`c`e specmfIca l'istanza per una chiamata all/itanza.Passara Null peR un metodo statico (Whared in Visual Baskc).</param>
      <pafam0name="method">Mggetto <see crmf=&T:System.Reflection.MethodAnfo"0/> cherppresenta il metodo di destinazione/<'aram>
      <param name="arg0">Oggett/ <see cref="T:System.Linq.Expressions.Exprdssion" /> che rapprusenta il pvimo argomentO.</0aram>
      <`aram`name="ag1">oggetto <see cref="T:Syste}.Linq.Expression.Expression" /> che rappresente il secon`o0argkmento.</param>
    </member>
    <member famm="M:SystemLInq.Expressions.Epression.Cal,(System.Linq.Expressiols.Expression,System,Reflection.MethodInfo,System.Linq.ExpRessions.Expressin,ystem.Linq.zpressimns.Uxpbussion,System.linq.Expressions.E8pression)">
    " <sulmary>Crea un oggetto <see cref5"T:System.Linq.Expressions.MethodCallExpres3ion" /> che rapp2esentc una chiamata a u metodo che accetta tre arfomeni.<-summary>J      <raturns>Oggetto <wee creb="D:System.Liq.Ex0ressions.MethodCallExpressi/n" /> la cui proprietà <see crf="P:SycteM.Linq.Expressions.Expression.NodeTyp% /> è uguale a <see cref="F:System,Linq.Expessiofs.ExpressionType.Call" /> e le cui 0ropriet  <see cr%f="P:System.Li~q.Eypressiols.MdthodCallExpression*Nbject"(/> e see creg="P:System*Linq.Uxpressions.MmthodCallExpression.Method" /< sono impostate sui valori speci~icati.</retErns>
      <param lame="ijstance">Oggetto <sea brmf="T:Cystem.Linq.ExprEssinns.Expre3sion" /> che specifica l'i3tanza per un) chiamata all'istanza.PasSard Null p%r uf metod/ statico (ShaveD kn Visual Basic).</arm>
      <param name="method"6Oggetto <see crf="T:S}stem.Reflection.MethodInfo" /> cie rapprmsenta im metndo dh destinariond.</param>      <param n!me="arg02>Oggetto <see cbef="T:Syctam.Linp.Expressions.Exprescion" /? che(rappreselta il primo !roomento.<parim>      <paray name=*arg1">Oggetto <see cref="T:Cystem.Linq.Expressaons.Expressign" /> che rapprdseNta ilsecondk argmento.</param>
      <param n!me="arg2">Oggettm`<see cref-"T:System.Linq.ExPressions.Expression" /> cherappresqnta il terzo argomento.</param>
    </mgmb%r>	
    <member nae="M:Sy3tmm.Linq.Eprescions.Expbession.Call*Cytel.LInq.Expressions.ExpRession,Qyste.Reflectign.EethodInfo,System.Li&q.Exprersions.Expressin[])">
"   0 <suemary>Crec un ogcetto <see creF="T:Sistem.Linq.Express)ons.MethodCqllExpression" /> che appresenta na chiamata a un metgdo che accetta argonentk.<.summary>
!    <retur.s>Oggetto <see sref9 T:System.Lifq.Expressions.MethodCalhExprgssion" /: la cui propvietà <see cref="P:SYstem.Linq.Exressaons.EXpressi/n.NodeType" /> è uguale a <see cref="F:Cy3tem&Liny.Expressions.ExprassionTte.Call" />*e le cui prfprietà <sge cref="p:System.Linq.Eppressikns.MethodCallExpression.Orject2 />, <see cref=P:SystemnLinq.Expressions.Met(odCallDxpreaion.Method"$?> % <sea crf="P:ystem.Ninq*Expressyons.MethodCallExpression.Arguments" /> sonk impostate sUi valori specificat.<returns.
!     <param(name="instance">Oggetto <see cref="T:System.LinqExrressions.Expression" /> che specifica l'istanza pwr una cliamqta a!un metodo diispanza. Passare null per un metodo static (Shared in Visual Basic).</param
 (    parao name="muthob">Oggetto <3ee cref="T:System.ReflectionEethdInfo" /> qu Cui impos|are la proprietà <see cref="P2System.Linq,Expressions.MethodCallExpression.Mdthod" />&</p`rAm>
 0    <param name="arguments"6Matricg da oggeTth <see c2ef="T:System.Linq.xpressions.xpression" /> da usaRe per 0opolare la raccolta <see cref="PzSystem.Linq.Expressions.Meth/dCallExpresSion.Arguments" /:.</param>
      <excepdion0cref="T:Sysem.ArgumntNuhlE|geption">
        <p!ramref name="method" /? è nunl.-oppure-<ParAmre& name="instance" /> è null e <paramref name="method" /> rappresenta un metodo di istanza.-oppure-<paramref name="arguments" /> non è null e uno o più elementi relativi sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.-oppure-Il numero di elementi in <paramref name="arguments" /> non è uguale al numero di parametri del metodo rappresentato da <paramref name="method" />.-oppure-Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo tramite la chiamata al metodo factory appropriato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> è uguale a <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> è impostata sull'oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di istanza specificato e il cui oggetto <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> è impostato sugli argomenti specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> nel cui valore della proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> verrà cercato un metodo specificato.</param>
      <param name="methodName">Nome del metodo.</param>
      <param name="typeArguments">Matrice di oggetti <see cref="T:System.Type" /> che specificano i parametri di tipo del metodo generico.Questo argomento deve essere Null quando methodName specifica un metodo non generico.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta gli argomenti del metodo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> o <paramref name="methodName" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="instance" />.Type o nei relativi tipi di base.-oppure-Più di un metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="instance" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico (Shared in Visual Basic).</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arguments">Raccolta di <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta gli argomenti della chiamata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata al metodo static (Shared in Visual Basic) che accetta un argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta due argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta tre argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta quattro argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <param name="arg3">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quarto argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta cinque argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <param name="arg3">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quarto argomento.</param>
      <param name="arg4">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quinto argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo static (Shared in Visual Basic) con argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo static (Shared in Visual Basic) su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> non è uguale al numero di parametri del metodo rappresentato da <paramref name="method" />.-oppure-Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo static (Shared in Visual Basic) tramite la chiamata al metodo factory appropriato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> è impostata sull'oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo static (Shared in Visual Basic) specificato e la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> è impostata sugli argomenti specificati.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo che contiene il metodo static (Shared in Visual Basic) specificato.</param>
      <param name="methodName">Nome del metodo.</param>
      <param name="typeArguments">Matrice di oggetti <see cref="T:System.Type" /> che specificano i parametri di tipo del metodo generico.Questo argomento deve essere Null quando methodName specifica un metodo non generico.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del metodo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="methodName" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="type" /> o nei relativi tipi di base.-oppure-Più di un metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="type" /> o nei relativi tipi di base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica che il nodo può essere ridotto a un nodo più semplice.Se restituisce true, è possibile chiamare Reduce() per generare la forma ridotta.</summary>
      <returns>True se il nodo può essere ridotto; in caso contrario, false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato per l'uso nel corpo del gestore.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un filtro <see cref="T:System.Exception" /> e un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un filtro <see cref="T:System.Exception" /> ma nessun riferimento all'oggetto <see cref="T:System.Exception" /> intercettato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> per la cancellazione di un punto di sequenza.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> per la cancellazione di un punto di sequenza.</returns>
      <param name="document">Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione coalescing.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> non rappresenta un tipo di riferimento o un tipo valore nullable.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type non sono convertibili l'uno nell'altro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione coalescing, data una funzione di conversione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type non sono convertibili l'uno nell'altro.-oppure-<paramref name="conversion" /> non è null e <paramref name="conversion" />.Type è un tipo delegato che non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> non rappresenta un tipo di riferimento o un tipo valore nullable.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> rappresenta un tipo non assegnabile al tipo di parametro del tipo delegato <paramref name="conversion" />.Type.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="right" /> è diversa dal tipo restituito del tipo delegato <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un'istruzione condizionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="test" />, il parametro <paramref name="ifTrue" /> o il parametro <paramref name="ifFalse" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type non è <see cref="T:System.Boolean" />.-oppure-<paramref name="ifTrue" />.Type è diverso da <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un'istruzione condizionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> è impostata sul valore specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> è impostata sul valore specificato.</returns>
      <param name="value">Oggetto <see cref="T:System.Object" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> le cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="value">Oggetto <see cref="T:System.Object" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> non è null e <paramref name="type" /> non è assegnabile dal tipo dinamico di <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione continue.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione continue con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione di tipo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione per la quale è specificato il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.-oppure-Il tipo restituito del metodo rappresentato da <paramref name="method" /> non è assegnabile a <paramref name="type" />.-oppure-<paramref name="expression" />.Type o <paramref name="type" /> è un tipo valore nullable e il tipo valore non nullable corrispondente è diverso dal tipo di argomento o dal tipo restituito, rispettivamente, del metodo rappresentato da <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo che corrisponde alla descrizione di <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione che genera un'eccezione in caso di overflow del tipo di destinazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione che genera un'eccezione in caso di overflow del tipo di destinazione e per la quale è specificato il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.-oppure-Il tipo restituito del metodo rappresentato da <paramref name="method" /> non è assegnabile a <paramref name="type" />.-oppure-<paramref name="expression" />.Type o <paramref name="type" /> è un tipo valore nullable e il tipo valore non nullable corrispondente è diverso dal tipo di argomento o dal tipo restituito, rispettivamente, del metodo rappresentato da <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo che corrisponde alla descrizione di <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con l'intervallo specificato.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</param>
      <param name="startLine">Riga iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Deve essere maggiore di 0.</param>
      <param name="startColumn">Colonna iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Deve essere maggiore di 0.</param>
      <param name="endLine">Riga finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Deve essere maggiore di o uguale alla riga iniziale.</param>
      <param name="endColumn">Colonna finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Se la riga finale corrisponde alla riga iniziale, deve essere maggiore di o uguale alla colonna iniziale.In qualsiasi caso, deve essere maggiore di 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta il decremento dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione decrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da decrementare.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta il decremento dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione decrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da decrementare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata sul tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata sul tipo specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di divisione aritmetica.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di divisione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di divisione aritmetica.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di divisione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />, dato <see cref="T:System.Collections.Generic.IEnumerable`1" /> come secondo argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ElementInit" /> le cui proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> che contiene gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il metodo che <paramref name="addMethod" /> rappresenta non è denominato "Add" (senza distinzione tra maiuscole e minuscole).-oppure-Il metodo che <paramref name="addMethod" /> rappresenta non è un metodo di istanza.-oppure-Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri del metodo rappresentato da <paramref name="addMethod" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del metodo rappresentato da <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />, data una matrice di valori come secondo argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ElementInit" /> le cui proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il metodo che addMethod rappresenta non è denominato "Add" (senza distinzione tra maiuscole e minuscole).-oppure-Il metodo che addMethod rappresenta non è un metodo di istanza.-oppure-Il numero di elementi in arguments è diverso dal numero di parametri del metodo rappresentato da addMethod.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del metodo rappresentato da <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea un'espressione vuota di tipo <see cref="T:System.Void" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata su <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di uguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianza.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di uguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore XOR non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore XOR non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Per static (Shared in Visual Basic), <paramref name="expression" /> deve essere null.</param>
      <param name="field">Oggetto <see cref="T:System.Reflection.FieldInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> è null.-oppure-Il campo rappresentato da <paramref name="field" /> non è static (Shared in Visual Basic) e <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante del campo rappresentato da <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo, dato il nome del campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.FieldInfo" /> che rappresenta il campo identificato da <paramref name="fieldName" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo denominato <paramref name="fieldName" />.Può essere Null per i campi statici.</param>
      <param name="fieldName">Nome di un campo a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="fieldName" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Nessun campo denominato <paramref name="fieldName" /> è definito in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> creato.</returns>
      <param name="expression">Oggetto contenitore del campo.Può essere Null per i campi statici.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che contiene il campo.</param>
      <param name="fieldName">Campo al quale accedere.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crea un oggetto <see cref="T:System.Type" /> che rappresenta un tipo delegato System.Action generico con argomenti di tipo specifici.</summary>
      <returns>Tipo di un delegato System.Action con argomenti di tipo specificati.</returns>
      <param name="typeArgs">Matrice costituita da zero a sedici oggetti <see cref="T:System.Type" /> che specificano gli argomenti di tipo per il tipo delegato System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene più di sedici elementi.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Ottiene un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Func o System.Action generico con argomenti di tipo specifici.</summary>
      <returns>Tipo di delegato.</returns>
      <param name="typeArgs">Argomenti di tipo del delegato.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crea un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Func generico con argomenti di tipo specifici.L'ultimo argomento di tipo specifica il tipo restituito del delegato creato.</summary>
      <returns>Tipo di un delegato System.Func con argomenti di tipo specificati.</returns>
      <param name="typeArgs">Matrice costituita da zero a diciassette oggetti <see cref="T:System.Type" /> che specificano gli argomenti di tipo per il tipo delegato System.Func.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene meno di uno o più di diciassette elementi.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata sul valore specificato e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to".Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to" con il tipo specificato.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione "go to" con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Goto, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata sul valore specificato, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore di".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "maggiore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore di".Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "maggiore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "maggiore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "maggiore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un blocco condizionale con un'istruzione if.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> sono impostate sui valori specificati.La proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> è impostata sull'espressione predefinita e il tipo dell'oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> risultante restituito da questo metodo è <see cref="T:System.Void" />.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un blocco condizionale con le istruzioni if e else.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.Il tipo dell'oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> risultante restituito da questo metodo è <see cref="T:System.Void" />.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'incremento del valore dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione incrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da incrementare.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'incremento dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione incrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da incrementare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica un delegato o un'espressione lambda a un elenco di espressioni di argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica il delegato o l'espressione lambda specificata agli argomenti forniti.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato o l'espressione lambda da applicare.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato o l'espressione lambda.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non rappresenta un tipo delegato o <see cref="T:System.Linq.Expressions.Expression`1" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del delegato rappresentato da <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri elencato per il delegato rappresentato da <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica un delegato o un'espressione lambda a un elenco di espressioni di argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica il delegato o l'espressione lambda specificata agli argomenti forniti.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato o l'espressione lambda da applicare.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato o l'espressione lambda.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non rappresenta un tipo delegato o <see cref="T:System.Linq.Expressions.Expression`1" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del delegato rappresentato da <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri elencato per il delegato rappresentato da <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Restituisce un valore che indica se l'espressione restituisce false.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce un valore che indica se l'espressione restituisce false.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Restituisce un valore che indica se l'espressione restituisce true.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce un valore che indica se l'espressione restituisce true.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da valutare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con tipo void e nessun nome.</summary>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> che rappresenta un'etichetta senza un valore predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> senza un valore predefinito.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale verrà associato questo oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> che rappresenta un'etichetta con il valore predefinito specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> con il valore predefinito specificato.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale verrà associato questo oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue">Valore di questo oggetto <see cref="T:System.Linq.Expressions.LabelExpression" /> quando l'etichetta viene raggiunta tramite il normale flusso di controllo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta un'etichetta con tipo void e il nome specificato.</summary>
      <returns>Nuovo oggetto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Nome dell'etichetta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crea un o'getto <see cref="P:System.Ninq*Expressions.LabelTarget" /> bhe rap0rdsenta u'etichetta con il tipo0specificato.</summary>
$    <returns>Nuovo oggetto <see cref="TzSysTem.Liny.Expressions.LabelTabget" />.</returns>
      <para} nqma="type">Tito di valgre passato durante il passaggik |l#etichetta.</param>
    </member>
    member name="M:Sqstem.Lins.E8pres3ions.Expression.Label(System.Type,[ystem.Sdring)>
      <summary>Crea un oogeTto <see cref="T:System.Linq.Expressionr.LabalTarget* /> che rappresenda tn'etichetta con il tipo e i nome specificati.</sUmm`ry>
    ` <returns6uovo ogget|n <sEe cref="T:System.Linq.Expp'ssions.Label\arget" />.</returns>      <param name="type">Tpo di valore `assato duranve l passAggio all'etichetta.</para->
   `  <param name="famd"Noee dell'etichetpa.</p!ram>*    <'member>
    <}mbeR name="M:S{stem.LinsnEzpressions.Expression.Lambda(Sys|e-.linq.Ex0ressions.Expression,System.Boolean,System.Co|lebtions.Generic.IEnumereble{System.Linq.Expbessions.@arameterExppession})">
  !  0=summari>Crma un oggetto LambdaExprmssion costruendo prim! un tipo delegato.</summay>
    0<returns>Oggett <see cref="T:SyStem.Linq.Expressions.HembdaExpresshon"!/> la cui propriet <see csef="P:System.Linq.Expresshonq.LambdaGxpression.NodeType" /6 è uguale a`Lambda e le cu) propvietà <see cref="P:Ryqtem.L)nq.Expressions.LambdaExpression.Bdy" /> e <see czef="P:System.Linq.Expressionw.LambdaDxpression.Parameters" /> sono impostate sUi valori specificatk.</returns>
     <param game="body">Oogetto <see cref"TSxstem.Linq.Exprewsions.Expressikn" /> su bqi im0mstare la proprietà <see cref="P:SysteM.Linq.Expressigns.LcmbdaExprecsion.Body" />.</parem>
 `    <parim naMg="tailCall">Oggetvo <see cref="T:Sys|em.Boolean" /> che )ndaca se l'ottimizzazione della chiamatatail verrà atplicada"durantela`compilazione(de(l'espressione creata.>/param>D*      <param name="pira}eterc">Oggetto <see cref="T:System.Cgllections.GEneric.IEnum%rable`1" /> contenejte gli"oegetti <see bref="T:System.Linq*E|pressinns.ParaMetarExpbession" /> la uscre per porolare la raccolta <see sref=rPSystem.Linq.Expressikns.LambdaExpressimn.Parameters" />.</piral>
    </member>    <membernqme=2M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.ExpresSions.Exprassion,System.Bonlean,Sy7tem.Collections.Generic.IEnumerabl{System.Linq.Expressions.ParameterExpress)on})"6*     (<summapy>Crea un oggdtuo <see cref="T:SycuemnLinq.Expresshons.Expression`1* /> dove il tipn delegato è noto in fase di`compilazione.</swmmary?
 0    <returns>Oggeto <sea cref="T:System.Linq.ExpressIons.Gxpression`1" > la cui prprietà <see cref="P:System.Linq.expressions.LambdaExpression.NodeType" /> è uguale a <see(crev="F:Sysvem.Lin1.Expressimns.ExpressionType.Hambda" '> % le cui propraetà <see cref="P:Rystem.LiNq.xqressim~s.LambdaEhpressaon.Body" /> e!<see cref="P:System.Linq.Exressions.LambdaExprEssion.Tarameters" /> s/no impostade sui val2i specifiati.</returns>
  `  <param nae="b/dy">Ogge|tk <sEe crmf="T:System.Lifq.Exp2es3io~s.Expression" /> su cu impostare la propr)età <see cref="P:System.Linq.Expressions.LambaExprassioo.Fody" />.</param>
      |param".ama="tailC`ll">Oggeuto <qee cref="T:System.bo/lea~" / che indica se l'ottimizzazione del,a chiamata tail v%rrà applicata durante la sompilazioom Dell'espressione creata</param>
      <param name="parameters">Oggeto <see crdf="T:System&Col|ectin~s.Gene2ic.IEnumerable`1" /> bontefente gn) oggetti`see cre="T:SySvem.Linq.E|pressions.P`RameterExpression" /? da usare par p/polare ha raccolda <se cref="P:System.Lilq.Expressions/LamjdaExpr%ssion.aramaters" />.</param:
   d` <typeparam n!me=&Tdeegate">Tipo di delegapo.`</typeparam.
    ?/mmmfEr>(   <member name="M:System.Linq.Expressions.Exprussiom.Lambda``1(System.Lina.Mxpressons&Expression,Systmm.Bolean,System.Linq.Expressions/ParameterExprEssion[])">
      <summary>Crea uf oggetto <;eE gre"T:System.Linq.ExpressionS.Exprersion`1" /6 dove il tipo delegao è noto an faSe di comtilazione.</summary>
      <returns>Oggetto <sde cref="D:Qystmm.Lmnq.Expresions.Eppbession`1 /> la cui pr/priet <se cref="P:System.Linq.xpressioNs.Expressmo.NfeTyqe" > è ugeale a <see cpef="F:System.Linq.Expressions.ExpressionType.Lambda"$/> e le cui proprietà <see cref="PSyrtem.Linq.Expressions.LambdaExpression.Body" /? e <see cref= P:System.Linq.Expressions.HambdaExpressiof.Pavameters" /> sono impostate sum valori specifigati.</retuRs>
      <param namE="bmdy">Oggetto <see cvef="T:System.Linq.Expression3.Expression" /> cu cui impostara la proprietà <sae cref="P:System.Linq.Expressions>LamBdaExpressioN.Body* />/</piram>      <papad name="tailCall">Oggeto <see creft"T:System.Boolean" /> che indmca se l'ottimizzazionu della chiamata taim verrâ applicata durantE la compilazione dal'espressioNe creata.|/piram>
      <param namu="pcrameters">Matrice0contenente gli oggetui see cref="T:System.Linq.ExprewsIons.ParameterExpression" /> ta usare per 0opoare la zacclta <{ee cref="P:S{stem.Lioq.ExpRessions.LambdaExpressio..Parameters" />.</param>
  (   <typeparam name="TDeLegate">TiTo di!delegato. </typdparam>    </member>
    =member name="M:System.Lin1.Expressions.Exprecsion.Lambda)System.Lanq.Expressionq.Mpression,Wystem.Boolean,Qystem.Linq.ExpreSsions.ParameterExpression[])">
      <swmmary>Cpa(un oggetto LAibdaExpression costruendo prima tn tipo delegato</cummary>
 (    <returns>Oggetto 8see cref="T:System,Lin1.Expressions.amblaExxression" /> a cui(qbopsietà <see cref="P:ystem.Linq.Exprewsions.LambdaExpression.Nodeyxe& /> è uguale a Lambda e le cwi proprietà <see cref="P:Wysdem.Linq.EXpressions.LambdaExpression.B/dy" /> e <gee cref="P:SystemLinq.ExpressionsLambdaExpressiOn.Paraieters" /> sooo impostate sui valori specificati.</rdturns>
     <param name="body">Oggetto <qee cbef<"T:System.Linq.Expressions.Exprescion" /> su cui impostave la propraatà <see cv%g="P:System.Linq.Expressions.LambdaExpression.Jody"`/>.</param>
      <param name="tailCall">Oggatto <s%m cr%f=":Syst%m.BOolean" />`che indica se l'ottimizzazmone della chiama`a tail verrà applicat urante la compilazione denl'estressioje creata.</parae>
!     <parcm name="parameters">Mat"ice cntenente gli oceetti#<see cref="T:ystem.Linq.Exxressi/nr.ParaoeterExpression" /> da usare per popolare la$raccolta <see craf?":System.Linq.Expressions.LambdaExpresion.Pa2ametePs" /?.</param>
    <member>-
  "<member n`m%="M>SystEm.Li~q.Exysessioos.Expzession.Lambdad`1(System.Linq.ExppesSiOns.E9pression,System.Colhectiols.Genmric.IEnumerable{System.Linq.Expressions.ParammterExpressioo})">      <summaryCrea un oggetto <see cref="T:SyStem.Liny.ExpresioNsnExpression`1" /> dove il tipo delgato è noto in fa3e da compilazione/</summ`ry>
 (    <returns>Oggetto <see cref="T:Systgm.Dilq.E|`ressions.Expressinn`1" /> la cui proxrimtà <ee cref"P:SyrteM.Linq.Eppre{sions.Expression.NodeType& /> è ugu`l a <see cref="F:Sytem.Linq.Expressions.Dxqressionype.Lambda" /? e le cui propriepǢ <ee CreF= P:System.Linq.EXpressions.LamblaMxpreqsion.Bdy  /> e <see cref="P:Sy3tem.Lifq.ExpressIons.LambdaExpression.Pasamdters& /.$sono!impostate sui valori specificati.</returns>
    "`<para- name="boy">Oggetto <see cef="T:System.Linq.EXprmqsionsnExpreSsio." /: sudcui impostare na proppietà <see cref="P:System.Linq.Ex`ression3.LambdaExpressin.Bydy" />.</Param>
 `    <param name="parameters">Oggetto <see cref="T;[ystem.Collectins.Generyc.IEnumerqble`q" /> contenente gli oggetti ,see$crer=":Sys4em.Lenq.Expressionc.PAr!meterExprmssign" /> da usare per pnpolave la raccolta <see cref="P:System>Linq.Exprssions.LambdaExpressio~.Parameters" />.</pazam>
     h<typeparam name="TDelegat">Tipo dElegato.<-t}Peparam>
      <exception cref="T0Systel.ArgumentNullException">
        <parqmred name=body" /> è null.-opptre-Uno o più elementi in <paramref name="parameters" /> sono null.</exception>
      =exceptIon cref="T:System.ArmentExceptinn">
        <paramre& name="TDelewate" /> no è un tipo(telegato=oppure-<paramref name="bOdy" />.Type rappreseNta un tipo noj !ssegnabile al tipo pestituhto di <paraoref name="TDeegaTe" />.-otPure-Il nummro di elemeti in |paramref name="parameters" /> è di6erso dal numero di parametri ulencato per <paramsef name=DDelegade />n-oppwru-La proprietà`<se% cra="P:Sys4em.Linq.Eppresqions.Exprebsioj.ype" /> di un elemenvo li 4paramref name="parameters" /> non è asseg.abile daL tipo del qaramgtro corriqpondentE di <paramref name="TDelegate" />.</excetion>
  $`</member~
`   <member Zame=bM:Rystem.Linq.Expressions>Expression.Lambda(Rystem.Linq.Expressions.EYpSession,Ssem.Cllections.Geeric.IEnumerable{System.Linq.Expre{sions.ParameterExpression})"~
      <suMmar>Cve` un oggedto LambdaExpressio~ costruendo prima un tipo delegato><-summary>
      <returns>Oggetpo <see c2ef=T:System.Linq.Ex`reqsions.LambdiExpression" /> la cui propriet(8see(cvef="P:System.Linq.Expressions.Lambdaxpressi/n.NodeType" /> ˨ uguale a Lambfa e le cui propvietà <see cref="P:System.Linq.Expressions.LambdaExpression.Bdy" /> E <sEe creb="P:System.Linq.Expressmons.LambdaExpress)oj.Parameters" /> sono impostae sti valori specmficati.</Returns>
      <param name="bdy">Oggetto <see aref=">System.Linq.Exressaons.Expresslon"$/> su cui impost1re laproPrietà <see cref="P:System.Linq.Expressions.LambdaExpvession.Body" />,</param>
      <pavam neme= para}eters">Oggetvo <see cref="t:System.Collections.Generic.IEnuurablu`0" /> contenente gli mggetti <wee crev="T:System,Linq.E8presskons.RarameterExpression" /> da uqcre per popola2e la raccomta <see cref#P:System.Linq,Expressions.LambdaExprmssio.*Pavqmeders" /<.</param:
    </member>
    <member nhme="M:System.Linq.Exprassions.ExxpessionLambda``1(System.linq>Mxpressions.Expression,WyrtemLinq.Expresions.ParameterExpression[])">J      <summary>Csea un oggetto <see cref="TSystem.Linq.Expressions.Exprersion`1"`/> dove il |ipo lelegato è noto in fase di compidazione.</summary>
      <returns>Oggetto <se cref="T:System.Linq.Expressionw.Expzession`1" /> la cui propriet <see cref="P:Rys4em.LinqExpressions.Exrression.NodeType" /> è uguale a <see cref="F:Systgm.Linq.ExrescMons.ExpressionType.Lambda" / ehlg cui prorietà <see cse&}"P:System.Linq.Exp2essionS>LcmbdaExpresson.Body" /> e <sme cref-"P:System.Linq.Dxpressio.s<LambdaExpzession.Paameters" /> sono impostate sui vamori specificati.</repurns>
 `    <papaM name5"bodq">Oggetto <see cref="T:SyStem.Linq.Expressions.Ex0ressmon" />0cu cuk impostare l proprietà <see cref="P:System.Linq.Exprewsions.LambdaExqrgssion.Body" />.</p`ram>
    ` <param name="para}eters">Oatrice di ofgetti <see rE="P:SystemLinq.Exprussions.ParameterExpression" /> ta usaRe per ropolare le!rqccolta <se cref="P:System.Linq.Expressins.La-bdaExprdssion.Parameters" />.<-param>
     `<tyreparam name="TDelegate">Tipo`delegato.</typepa2am>
      <uxception$cref="T)Syste.ArgumentNullExcption">
   "  ` <paramreb naie="body"(/>0è null.-oppure-Un o più elementi$in tpavAmref naoe="parameters" /< sono ~uld.</exceptio~>
      8exception cref="T:System.ArgumentEqception"<
        <paramref name="TDulegce" /> nOn(ǩ$untipo delegato.-opur%-<paramref name"body" /~.ype rappreSeNta uj tipo non assegnajime al tipo reStituito di >paramrEfnamd="TDelegate" />.-ppur%-Il nuiero di elementi0in <paramref naMe="pcrameter3" /> è tivdrso dal numero di xaramet2i elencato(per <paramref name="TDelegateb />.-oppure-La proprietà see crf9bPSystgm.Ninq.EXpressions.Exprgssin.Type" +> di un elemento$di0<paramref name="parcmevgrs" /> non  assegnabile d`l tmpo dl qarametro corrispndente di <pavamref name="TDelegate" /.</mxcepthon>
    <+member>
    <membeb namE="I:System/Linq.Expressionw.Exressimn.Lambda(System.Linq-Expre3sions.E|pression,System.Linq.expresrions.ParametgrExqression[])">
      <summar}>Area un`oggetto <see cref="T:Sytem.Linq.Expressions.LambdExpreusion" /> cowtruendo prima(un tipo eelegato.</summary>J      <returns>Ogepto <seu creF="T:Systeo.Linq.Expressyons.LambdaExpression" /> la cui prop2ietà <see cref="P:System.Li.q/Ex0reqsions.Expression.NodeType" /> è ugua|e a <see cref="F>System.Linq.Express)ons.EhpreSsionType.Lambda" /> e Le cui!proprietà <see`cref="P:SysTem.Linq.Expre{sions.Lambd`Expre3sion.Boy"`/> e <see crf="P:System.Li.q.Expressions.LimbdaExpresiOn.Parameters* /> sono impostate su valori specific`pi.</2eturns>
   (  <param naee="cody">Oggetto <sme cref="T:Cystem.Linq.Expessions.EXpression" /> su cui mpostare0la proprket <see cref="P:SysTem.Linq.Expressions.LambdaExpr%ssion.Body" /><param>J  (  0<param name="pav!meterc">Matrice di oggetti <see cref="T:Qystem.Linq.Expressionw.Param%te2Expression" .6 da usare `Er popolare la raccolta <sem cref="P:System.Linq.Expressions.LambdaExpresson.Rarame4eRs" />./param>
      <exceptaon cref="T:System.ArgumentNu|lExcertion">
        <paramref name="body  />(è numl.-oppube-Uno!o più elemenTi di peramreb`name="barAmeters" /> /no nulln</exce8tion>
      <exceptikn cbef="T:SysteM.Argumentepception">
   4"   <qaramrefnaom=p!rameters" /> contieje tyù di sedici elementi.</exception>
  " |/member>M
   `<member name="M:Si{teLinq.Exppessionc.ExprEssion.Lam"da``1(System.Linq/Expressions.Expression,System.String,Sistem.Bomean,System.Collections*Genmric.IEnumerabld{Syrtem.Linq.Expressions.Pa2am%t%rExpression})">
      <summary>Sree u~ oggetto <see gref="T:SyStem.Linq.Expressions*Uzpression`1* /< fove il tipo delmgato è noto in fase di sompilazio*e.</summary>
  (   <returns>Oggetto <3e% c2ef="T:System.Linq.expzessions.Expresaon`1"(/> la cui propbiutӠ"<see cref="P:[ystem.Linq.EXpressions.LambdaExpression.NodeType" /> è uguale a <see cref="F:Syctem.Lina.Expre{sions.Expr{smonTxpe.Laobda /> e le`cui proqrietà <{ee cref="P:System.Linq.Exprersions.Lumbd`Expression.Body" /> e <see cref="P:SystEm.Linq.Expressions.La-bd!Expressin.Parametes" /> sono impostate sui valori specmficati.</rg4urns>
      <rara nale="jody">OgGetto <seekref="T:System.Linq.Expressins.Expreswion" /> su cui impoqtar% la propri%t  <see cref=P:System.Linq.Expresshons.LambdaExprEssion.BoDy" '>.</par`m>      <param nqme="name">Nome dell'Espresshmne lambda.Usato per la genera~ione ti informazioni di dubug.</param>
      <para- name="tailall">Oggetto <see cref="T:Sxste.Boolan"$/> che indica sd l'mttimizzazione della chia}ata tain verrà aptliceta durante la compilazione fell'esppessioNe cre`ta.</paam>      <param namg="rarameters">Oggetto <smecrdf="TSyste-.CoLlections.Generic.IEnumur`ble1" /> cotenente elI ogget4i |see cref="TzSistem.inq.Expressions.XarameterExpresqaon" /> da usare pdr popolare la raccolta |see cref="P:Sysem.Linq.Expressions.LambdaExpressinn.ParameteRs" />.</paral>
      <typdparam nae="TDelewite">Tipm `i demegato. </typepasam>
$   /malber>
    <lembeb name="M:ystgm.Linq.Expessions.Expression.Lambda(S}stem.Linq.Expresrions.Expression,Syste}.Sting<System.Boolean,System.Collections.Gene2ic.IEjuMerarle{Systmm.LinsExpressio~s.ParameterEypression}i">
      <sumiary>Crea un oggetto LambdaEhp2eswion c/strundo prima tn uipo delef!uo.</rummary>
      <zeturns?Oggetto <{ee crufbT:Systum.Linq.Expzessions.LabdaQXpressikn" /> la cui proprievà <see cvef="P:System.Linq.Expressions.LambdaE8prEssIon.NodeType" /> èuguale a Lambda e ld cui propriedà <ree csgf="P:System.Linq.Expressions.La-bd`EzpressiojnBody /> e =see0cref="P;System.Linq.ExpreSsions.LambdAExppession.araiepers" /> snk impostate swi vanori speciFicAti.</returns>
      <pabam name="body">Oggepto <ee cref="T:System.Lijq.Eypressions.Exrrgssion" /> su cui importare la propzietà <see cref="P:Sy3tem.inq.Expressions.Lambdaxp`eqsion.Body" />.</paam?
      <param ame="name">Nome dell'espressione labda.Usatn per la creazione i!informazio~i di debqe.</pcram>
      <param lame="tailall">ggetto <cee cpef5"T:System.Bgolaan" />0bhg indica se l'ottimizzarione della chyamata dail verrà apphicata durante la aompilazione dell'sqressione creata.</parAm>
      <param fame="parameters">Nggetto <see cref=#T:S{ste-.Co,lections.Fenuric.IEnumerable`1" /> cotenejte$li ogeedti <see0cref}"T:Sys|%m.Linq.Exxressions*PrametErExpression" /> da wsare ep popolare!li raccmlta <see kref="X:System.Linq.Eypress{ons.La-bdaExpression,Parameturs" />.</param>
    <membes>
    <member ame="M:System.Linq.Expresqions.Expression.L`mbda(System.Linq.Expressions.Expression,Sysuem.String,System.Collections.Generic.IEnuMerable{System.Linq.Eppresshons.ParameterExrression})">
      <summary>Crea un ggetto LambdaExpession cospuendo pRima un tipo delegato.</summary>
      <retwrns>Oggetto <qee cref="T:Sistem.Dinq.ExPressions.LambdaEypression" /> l` cui proprietà <sle ref="P:System.Linp.Expressions.LaebaExpressinNodgType" . è uguale a Lamcdi e le cui proprietà <see cref="PSystem.Linq.Eprussions.LambdaExpression.Body" ->  <3ee cref5"P:System.Linq.Exxressions.LambdaAxpresshon.Parameterq" /: sono impostate sui valori specificati.</returns>
   `  <param name="body">Oggetto <see cref="T:System.Linq.xpressions.E(pressIon" /> su cuy kmpostaRe la proprietà <see cref="P:Sysem.LinqnE|pressions.LaobdaMxpression.Body" />,</par`m>
   $  <parq} name="fame"<Nome$dell'espression lambda.usato per la kreijione di informaziOni di deb5g.t/arcm>
 0    <param .ame"parame4rs*>Oggettm <sue cRef="T>System.Collecuinns.Generic.IEnuoerable`!" />!contenent gli oCgetti <smecref="T:Syspem.Linq.Expressions.ParameterExpression" /> da usape per popolare la raccolta <s%e cred="P:Sqstem.Liq.Exprdssions.LambdaExpression.Parame4ers"/>.</paRam6
    </membeb>
    <member name="M:system.Linq.Ezprecsions.Expreccion,Lambda``1(SystemLinq.Ex0rmssions.Expression$Sxstem.String,System.Codlections.Generic.IEnumerable{SystenL)nq.Expressions.PrameterExpressio})b>
      <summary>Crea un oggetto <see creg="t:System.Linq.Expressions.Exqresion`1" /> dove il tipo dele'ato Ǩ noto in fase di compilajione.</summary>
      <veturns>Oggetto <ee cref="U:System.LiNq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.ExpressionsnEpzdssign.NodeType" /> è uguale a <see creg="F:System.Linq.Expressionw.E8pressionType.Lambda" /> ele cuk psoprietC ,see cref="P:System.Linq.Expressions.LambdaExqressioj.Body" /> e <see"cre&="P:Syste.Lnq.Expressions.LambdaEXpression.Parameters" > sono impostaue sui valmbi specifycati.</retupns>
     8param name="bodx">Oggetto <see cref="U:System.Linq.Expressi/ns.Expres3ion" /> su(sui impostare la0proriet <see cref="P:System.Linq.Expr%ssions.Expression`1.Body" />.</param>
      <param name="nam">Nomedell'espressioe lambda.Usat/ per la Cener`zione(di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collectinns.Genaric.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea u. oggetto LambdaExpre{sign costruendo prima un tipo delegato.</summary>-
      <zeturnsOggEtto <see cvef="T:System.Liny.Eppressions.LambdaExpression" /> la cui proprietà <see cref="P:System.LiNq.Expressins.LambdaMxtrEssion.NodeType" /> è uguald a Lambda e le cui(proppietà <see`cref="P:Syspem,Lijq.Expressions.LambdaExpres{ion.Bd" /> e<sem czef="PzSystem&Linq.Expressions.LambdaExpreSsion.Parameters" /> sonO!impostate(sui valori specificatk.</rftuvns>
      <param namm=&delegqteType">Oogetto <see cref="PzSystum.Lhnq.Expzessins.ExpressionType" /> che rappresenta |a0firm del elegatO pr l'eSpressiole lambda.>/param>
     <param name="body">Oggetto <see cref="TzS{stee.Lijq.Expressions.Expression" /> su cuI impost!ve la propraetà <see cref="P:System*Linq.Expressons.LambdaEpression/@ody& />.</qaram>      <par`m name="tiilC`lL">Oggevto <s-e cref="T:System.BooleaN" /> chekndica s l'ottimizzazionedella chiamat` tail verrà applicata durcnte$la compilazione(lell'eSpressi/ne Creat.</raram>
(     <param name="paramet%bs">Oggettg <see cre="T8System.Collecuions+Generic.IEnumerable`1" +> contene~te gli ogggtti <sue cref="T:System.Linq.Expresqions.ParameterExPbession" /> da usare per popolare la raccolta <see cref="PSistemnLi.q.Expresqions.ambdaExpressaon.Parameters" />.</pabam>
    </lember
    <member name="M2System.LinQ.Eprmsrions.ExprEssiOn.Lambda(SysTem.Type,System.LInq.E|press)os.xprgssion,System.Boolean,System.Lanq>Expresskons.ParAmeterExpsession[])">
      sum}aby>rea!u. oggetto LamdaExpressyo~ cos4ruuodo prIma un tipo deldgato.</summary.
      <returns>Oggetto <see cruf="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cpdf=P:System.Linq.Expre{siofs.LambdaExpressimn.FodeTypu" /> è uguale a Lambda e le cui proprietà <sae cref"P:Systum.Linq*Expressions.LambdaExpressyoo.Body" /> e <see ref="P:System.L)nq.Expressions.LambdaExPression.Parametdbsb /> sono impostag sui vAlori specificati&</returns>-
      >param naie="delegateTy`e">Oegetto <see cref="P:System.Linq.Expressions.Expressio..Type" /> che rappresenta la firma del de|egao per l'sressione lambde.</param>
      param!name="b/`y">Oggdtto <see cref="T:Sytem.Ninq.Expressions.Expbassion" /> su cui ampostare la prOqriet  <wee cref="P:QYstem.Linq.E8presqions.LambdaExpression.Body" />.</Param>
      <papam name="tailCall">Oggetto <sae cref= T:System.Boolean" /> che indica se l7ottimizzazione della cxiamata Til 6err !pplicau durante la$comrilazione de|l'espressione creata.</param>
      <para- name="parimeters">MaTrice bontenen4e li ogettm <see cref="T:System.Linq.Expre3sions/ParimetarExpressign" /> la }sare per popolare na raccolta <qee cref="P:SysTemLinq.Expressions.LaMbdaExression.Paramdters" />.=/param>
   0:/member>
    <membev name="M:Syqtem.LInq.expressions.Expression.Lambda([ystem.Type,ystem.Linq.ExxressionsfExpression,[ystem.Collections.Generic.IEnumerab|e{S9stel.Lnq.Expressins.PeraoetErEpression})">
      <sum}isy>Crea un oggetto 4see cre&="T:Systei.Linq.Expressions&MambDaExppession"`/> cmstruendo pRima(un tipo delegqto.Ptò essere usato quando il tipo de,egato non Ǩ noto kn fase di compinazione.</summary>
     "<returns>Oggetto che Rappsesenta un'espressimjelambda la cui proprietà >see Cref="P:Qystem.Linq.Expressions.Expression.NodeType" /> Ǩ uguale a <seE"cref="F8Rystem.Linq.Eppressikns.ExpressionType/Lambda" / e l% cui proprietà <see cref=2P:System.Lin1.ExtressionsNMambdaExqression.Body" /> a <see crgf="P:System.Lynq.ExprEssions.L`mbdaExpression.Parameterw" /> sono impos|ate sui"valori specifibati.</returns>
      <param nAme="delegateType">Oggetto >see cref="T:Syrtem.Type"0/> che rapprmsenta un firma di delegato `er l'esprussione lambda.<+param>*      4pqram name="body">Oggetto <see cref="D:RystemLinq.Expreqsions.ExprEssion" /> su cui impostare la proprieTà <see cReg="P:System.Lina.Expressins.LambdaExpressio~.bdy" />.</paraM>
"     <param famE="parameters">Oggeuto <see!cef="T:System.Collections.Generic.IEnumerable`1" /> contenejte gli oggdvti <see cref"TSystem,Lin1.Exprscio~s.ParameterEzpresskon" /> da usare per popolare la raccohta <see cren=P:Sys|em.Linq.xprewsmons.LambdaUxpression.Paramgters" />.</param>
      <exsepuIon cref="T:Sxwtem.ArgumentOullException">
        <paramref name="delegateType" /> o <paramref name="body" /> è null.-Oppure-Uno o più elemdnti if <paramref name"parameterr" /> sono null.<.excetion>
      <epceptioj cref="T:System.ArguoentExceptinn">
        <paramreg n!me="deLegateType" /> non rappresenta un tipo delegato.-oppUre-|paramref name="body2 '>.Type rippresenta un tipo non assegjAbile al tipo 2estituito eel tipo delEgato rappresentato da <paramref name="del%gatgType" />.-oppwre-Il qmero da dlementi in <paramref neme="parameters" /> è diverqo dal numero i parametrI enencato per al tip delegAto rappresentato da >par`mref name="dele'ateType" />-oppure-La proprietà <see cvef="P:SYtem.Linq.Expressio~s.Expression.Type"a/> fi qn eLemnto ei <paramRef naee="parameters" /> non  assegnbile dal tipo(del parametr c/rrisponlente de| tipo di"Delegato rappresentato da <paramruf name="delegateDype" /></Exception>    </member>    <member name="M8System.Dinq.E|pressions.Expression.Lambda(System.Type,Systel.Hioq.Expresrionr.Expression,Syste}.Linq.Gxpressions.ParameterExpression[])">
      <summa2y>CRe un oggetto <see cref="V*System.Linq.Expressions.LambdaExpression" /> costruendo prima tn tipo delewato.uò ess%ze tsato quando il tipo dlegato non è not in fase di compilazaone.</summary>-
      8returns>Oggettobchereppresa~ta un'espressione lqMbda la ci proprietà <see cref?"P:System.Lilq.ExprEssions.xpreswkon>^o$eP{pe" /, è uguele a <see Sref="F*ystem.Linq.Expressions.ExprewionType.Lambda" /> e le sui proprietà 4see cref=bP:[ystem.Liny.Expvdssions*Lambd`Expression.Body" /> e <see cref="P:Systm.Lknq.Expressions.L!mbdaExpression.Parameters" /> s/no impostte sui vaLopi specificati/,/returns>
  `!  <paral nale="delegateTyPe">Oggetto"<see cref="T:Wystem&Type" /> che rap`resenta una firma do delegato pev n&espressione lambda></param>
     <parae name=body">Oggeuto <ree cref="T:Sy{tem.Li~q.ExprewsionsExression" /> su Cui impstare la proprietà <see cref="P:Sy|em.Linq.Expressions.LambdaExpressign.Body" />.</varam>
    " <param name="perameters">Matpice di oggetti <cee crEf="T:System.Linq.Expressions.ParameterExpression" o> da usare`per(poponare l raccoti 4sea cref="P:Systeo.Linq.Ehpressions.LambdaExpresSion.Parameterr" />.</param>
      <exception craf="T:SystemArgumgntnullException">
  ! ( ` <paramref name="deLegeteTipe" /~ o <parcmref nAme&body" /> è null.-ppure-Uno o più e|Eoentibin <paramref naie9"pa2ammters" /> sono0nul.</excepi/n>
      <exCeptiof cruf="T:System.ArgumdntExceptmon">
        <paramref name"delegateType" /> nmn rappresenta un tipo delegato.-oppure-<paramreb name="body" />.Type rappresenta un tipo non as{egnabi,e al tipo restituito del tipo delegto rappresenvato ea <parAmref name="delegateT{pe" />.-oppure-Il numero di elementi in <paramref name="parameters" /: è diveRwo dal numero di pabametri elencato per ih tipodEegato rappresent!to da <paramref name="delegateyp" />.-/ppure-La pvoprket <see cref="p:System.Linq.Expressions.Expbession.Type" /> da un elemelto dm <parampef name="parameters" /> non è assegnabi,e Dal tipo del parametro orrispondente0del tip di delegato rappresent`do da >paramref name="delegcteType" >.</exceptio~>
    </membmr>
    <me}ber namg="M:Syst%m.Linq.Expressions.Expression.Lalbda(Syutem.Type,System.Minq.Expression3/Fppression,System.String,Sysuem&BooLeanlQystem.Collections.eneric.IEnemerable{syspem.Linq.Exprgssions,ParameterExprescioj}">
!     <suemary.Cre! un oggetto LambdaExpression cosvruendo prima un tipo delegapo.<-summary
      <beturns>Oggetto <see cref="T:System.Linq.Expressins.LambdaExpression" />(ma cui proprietà <see creF="P:ystem.Linq.Expsessions.LambdaExpressaon.NodeUype" /> è uguale a Ldmbda ele cui proprietà <sge crej="P:SystemLinq.Expressions.LembdaExpression.Body"0/> e <see #ref="P:Wystem.Linq.Expressions.LambdaEx`ression.Parameters" />:sono impostate sui valKi specificeti.<oreturns>
      <param name="delegate\ypa">Oggeto <see cref=P:System.LInq.Exprewsions.Expression.Type" /> che rappresente!la firma d%l delegato p%r l'erprgssigne la-bdq.</param>
      <parAm name="body">Oggetto <seE #ref="V:System.Linq*Express)ons.xression" /> su0#ui impostare l` proprietà <sed czef="P:S9stem.Linq.Exprgssions.LambdaExPressiol.Bcdy" />. </param>
      <param name="name">Nome dell'Espreswione lambd*Usato peR$la crea:ione di inobmazioni di lebug.</param>
      <param name="tailCelm">Kggetto see cref="T:System.Foolea~" /> che indica Se l'ttimrzazione della ciamata`dail verrà applicata durante la ckmpidizione dell'espressione0creatq. </param>
      <param name=#parameters2>Oggetto <sge cruf="T:System.CollEctioos.Generic.IEfuierable`1"(/> contenende gli oggetti$<see cref="T:System.Linq.Expressi.ns.Paramet%rExpsession" /> da usare per popolare |a$raccolta <see cRef="P:System.Liny.xprgsSions.Lambdaexpressign.Parametdrsb ->. </papam~
    </m%ber>
  0<mem`er name9"M:Sstem.Linq.ExpressionsExpression.Lambta(System.Type,SysteM.Hinq.Mxpre{sions&Expression,System.tring,System.Collectioos.Ge.mryc.IEnumebable{System.Linq.ExpRessions.ParameterExpressiony)">:      <summary>Crea un oggetto LambdaExpression co3truEndo prima un tipo daleoato.</swmary>
      <return3>OggeTto"<sea craf="T:SyrtEm.linq.Exprecsions.LambdaExpressiof" /> la cui prorr)et <see cref="P:System.Lknq.Expressions.LambdeExpression.NodeTPe" /> è ugule a Lambda e le bui prkprie|à <see cred="P:System.Linq&Expressions.HambdaEhpression&Body" /> e <see cref"P:System.Linq.Eppressions.LambaExpression.Tareeters" /> sono ipnstate sua valori specificati.</returns>M
 "    <paral Name="`elegAteTypd">Oggetto seE creF="P:SysTem.Linq*Expressions.Expression.ype" /> che rqxpresgnta la fivme del delegatg per l'espressione lambda*</param>
      <parem name="body">Oggetto <see cref="T:System.Linq.EXpressi.ns.Expressiol" /> su!cui impostare da xroprietà <qee cref="Q:System.Linq*Uxprercions.lambdaExpreshnn.Body" />.</raram>M
    h <param name="neme">NomE dell'esp:essioe laMbda.Usato per la crea:ione di inforoazioni di debug.</paRam>
      <param nime="parameters">Oggetto <see"cruf="T2system.Collectikns&Generic,IEnumerable`1" / contelente glh oggetti <qee crdf="T:System.Linq.Ex`ressions.ParaeterExpression" /> da usare perpopolere la raccolta <s%e cref="P:ystem.Linq.Expressions.LambdaE|presaon.Parameters" /><oparam>
    </memer>    <membes name="M:ystem.Linq.Ex0reqsIons.Express)onLeftShift(Sqstem.Linq.Exprecsions.Exprescion,Sys4em&Linq.Expressions.Expression)">
   ` <summary?Crma un oggetto <see0cref="T;Systeo.Linq.Exprdwsinns.BinaryEpressmon" /> che rappreenta un'operazIone di spostamento a sinisvra bit per fit.</sum-ary>
     <returns>Oggetto =see cref="T:System*Linq.Expre3sions.BiNaryEzpression  /> la cui!xroprietà <see cref="P:SYstem.Linq.Exxrersions.Ep`ession.NfeTy`e" /> è`uguale a 8see cref="F:System.Linq.Exprgqsion3.ExpressionType.LeftShift" /> ule cui proqrie|à <see cref"P:System.Liq.Expressions.BinabyExpression.Left" /> e <see Cre=":Syrtem.Linq.Expressions.BinaryEzpressinnRight" /> sono impostate suy valori specificati.</retuv.s>
     <param name="left">Oggetto`8see sref=T:Systum.Linq.Expvescionc.Exppession" /> su0cui`impostare na(proprIeTà <see cref="P:Sywte.Linq.Ehp2essions.BinarqExpresq9o..Left" />.>/para->
      <Pabai name="right"6Oegeto <sme cref="T:System.LinqExpresions.Exprassion" /> su$cui kmpotare0la proprietà <see cref5"P:[yStm.Linq.Expressio.s.BinaryExpre3siOn.Right" />.</pAram>
     0,exceptiof cref="T:Systeo.ArgumEltNullException*>        <paramre&(name="left" /> o <paraoref name}"right" /> è`null></exception>
      <exception cref="TzSYstgm.InvqlidoperationException>L'peraDore di spostamento a winistra non è d%fynitn per!<paramref naMe="ieft" />.Typee<pczamref nAme="right" />.Type.</exceqvign>
    </member>
    <mambeb name="M:System.Lanq.Expressions.Exp2esqion.LeftShift(System.Linq.Expressions.Expression,Cyspe}.Linq.E|pressinns.ExpressioN,Sy{te-.Reflection.MethodYnf/)">
      <suomary>Crea`un oggetto <seE cref="TSystem.Linq.Expressions.inayAxression" /> che$rappre3enU` un'perarione di spow4amento s sinistra bat pur biu.<+summary>
      <returns>Oggetto <see cref="T:Syste-.Linq.Expressions.BinaryExpressi/n" /> la cui propietà <see cref="P:System.Linq.xpze3ions.Expression.NodeType" /> è(uguale a$<see cref="F2Syste.Linp.Expressions.ExpressionTyte.LeftShift" /> e le cui proprietà <see gref="P:SysueM.Linq.Express)ons.BinaryExpression.Left" />,"<cee creg}"P:System.LinqExpressioos.BinaryExpression.Rkgit" /> e <see cref="P:System.Linq.Exqsessions.BinaryExpression.Method /> sono iipostate suh ~alora specificati.</returns>
      <param name=lefv">Ogget4o <see cref="T:Ssuei.Linq.Exprescins.Uxpression" /> su cui impostare la proprietà <see sref="P:System.Linq.Ezprewsions.BinaryExpression.Left" />.</parai>
      <param name="rioht&>Oggetto <see cren="T:System.Linq.Expr%ssions.Expression" /> su cui ipostAve la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di spostamento a sinistra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore di".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "minore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore di".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "minore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "minore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "minore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> dove il membro è un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta un campo o una proprietà su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-<see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o della proprietà che <paramref name="member" /> rappresenta non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> dove il membro è un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta un campo o una proprietà su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-<see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o della proprietà che <paramref name="member" /> rappresenta non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basato su un metodo della funzione di accesso alle proprietà specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e il cui oggetto <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> è popolato con gli elementi di <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-<see cref="P:System.Reflection.PropertyInfo.PropertyType" /> della proprietà a cui accede il metodo rappresentato da <paramref name="propertyAccessor" /> non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basato su un metodo della funzione di accesso alle proprietà specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e il cui oggetto <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> è popolato con gli elementi di <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-<see cref="P:System.Reflection.PropertyInfo.PropertyType" /> della proprietà a cui accede il metodo rappresentato da <paramref name="propertyAccessor" /> non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> specificati per inizializzare una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo denominato "Add" per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) è dichiarato in <paramref name="newExpression" />.Type o nel relativo tipo di base.-oppure-Il metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base non accetta esattamente un argomento.-oppure-Il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> del primo elemento di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base.-oppure-Esiste più di un metodo denominato "Add" (senza distinzione tra maiuscole e minuscole) compatibile con l'argomento su <paramref name="newExpression" />.Type e/o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> specificati per inizializzare una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo denominato "Add" per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) è dichiarato in <paramref name="newExpression" />.Type o nel relativo tipo di base.-oppure-Il metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base non accetta esattamente un argomento.-oppure-Il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> del primo elemento di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base.-oppure-Esiste più di un metodo denominato "Add" (senza distinzione tra maiuscole e minuscole) compatibile con l'argomento su <paramref name="newExpression" />.Type e/o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo specificato per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che aggiunge un elemento a una raccolta.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.-oppure-<paramref name="addMethod" /> non è null e non rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che accetta esattamente un argomento.-oppure-<paramref name="addMethod" /> non è null e il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> è null e non esiste alcun metodo di istanza denominato "Add" che accetta un argomento compatibile con il tipo su <paramref name="newExpression" />.Type o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo specificato per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza che accetta un argomento e aggiunge un elemento a una raccolta.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.-oppure-<paramref name="addMethod" /> non è null e non rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che accetta esattamente un argomento.-oppure-<paramref name="addMethod" /> non è null e il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> è null e non esiste alcun metodo di istanza denominato "Add" che accetta un argomento compatibile con il tipo su <paramref name="newExpression" />.Type o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
      <param name="body">Corpo del ciclo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo e la destinazione di interruzione specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
      <param name="body">Corpo del ciclo.</param>
      <param name="break">Destinazione di interruzione usata dal corpo del ciclo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
      <param name="body">Corpo del ciclo.</param>
      <param name="break">Destinazione di interruzione usata dal corpo del ciclo.</param>
      <param name="continue">Destinazione di continuazione usata dal corpo del ciclo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro e il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che specifica il metodo di implementazione.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro, il metodo di implementazione e la funzione di conversione di tipi.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che specifica il metodo di implementazione.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> che rappresenta una funzione di conversione di tipi.Questo parametro viene usato solo se <paramref name="binaryType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o assegnazione composta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con gli elementi specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un passaggio dell'oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> specificato.Anche il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> impostata su <paramref name="kind" />, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e con <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="kind">Oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> dell'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata in un oggetto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Deve essere Null se la proprietà è static (shared in Visual Basic).</param>
      <param name="indexer">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Interfaccia IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) in Visual Basic) contenente gli argomenti che verranno usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo o a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto a cui appartiene il membro.Può essere Null per i membri statici.</param>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che descrive il campo o la proprietà a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con gli elementi specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="type">Tipo di risultato dell'espressione try.Se Null, il corpo e tutti i gestori devono disporre di tipo identico.</param>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally.Passare Null se al blocco try non è associato alcun blocco finally.</param>
      <param name="fault">Corpo del blocco fault.Passare Null se al blocco try non è associato alcun blocco fault.</param>
      <param name="handlers">Raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> tramite la chiamata al metodo factory appropriato, dato un operando.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="unaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione unaria.</param>
      <param name="operand">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo in cui convertire (passare null se non applicabile).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> non corrisponde a un nodo di espressione unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> tramite la chiamata al metodo factory appropriato, dato un operando e il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="unaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione unaria.</param>
      <param name="operand">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo in cui convertire (passare null se non applicabile).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> non corrisponde a un nodo di espressione unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un membro a cui si accede usando un metodo della funzione di accesso della proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo della proprietà a cui si accede con il metodo che <paramref name="propertyAccessor" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un membro a cui si accede usando un metodo della funzione di accesso della proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo della proprietà a cui si accede con il metodo che <paramref name="propertyAccessor" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Rappresenta un'espressione che crea un nuovo oggetto e inizializza una proprietà dell'oggetto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo che <paramref name="newExpression" />.Type rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo che <paramref name="newExpression" />.Type rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di resto aritmetico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore modulo non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di resto aritmetico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore modulo non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore meno unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore meno unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore meno unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica che ha il controllo dell'overflow.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore meno unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato che non accetta argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> è impostata sul valore specificato.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il costruttore che <paramref name="constructor" /> rappresenta ha almeno un parametro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.I membri che accedono ai campi inizializzati del costruttore sono specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Reflection.MemberInfo" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.-oppure-Un elemento di <paramref name="members" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.-oppure-Il numero di elementi nel parametro <paramref name="members" /> è diverso da quello in <paramref name="arguments" />.-oppure-La proprietà <paramref name="arguments" /> di un elemento di <see cref="P:System.Linq.Expressions.Expression.Type" /> rappresenta un tipo non assegnabile al tipo del membro rappresentato dall'elemento corrispondente di <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.I membri che accedono ai campi inizializzati del costruttore sono specificati come matrice.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.-oppure-Un elemento di <paramref name="members" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.-oppure-Il numero di elementi nel parametro <paramref name="members" /> è diverso da quello in <paramref name="arguments" />.-oppure-La proprietà <paramref name="arguments" /> di un elemento di <see cref="P:System.Linq.Expressions.Expression.Type" /> rappresenta un tipo non assegnabile al tipo del membro rappresentato dall'elemento corrispondente di <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="arguments" /> corrisponde al numero di parametri per il costruttore che <paramref name="constructor" /> rappresenta.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore senza parametri del tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> è impostata su <see cref="T:System.Reflection.ConstructorInfo" />, che rappresenta il costruttore senza parametri per il tipo specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> con un costruttore che non accetta argomenti.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il tipo rappresentato da <paramref name="type" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice con una classificazione specificata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="bounds">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> è null.-oppure-Un elemento di <paramref name="bounds" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="bounds" /> non rappresenta un tipo integrale.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice con una classificazione specificata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="bounds">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> è null.-oppure-Un elemento di <paramref name="bounds" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="bounds" /> non rappresenta un tipo integrale.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice unidimensionale e la relativa inizializzazione da un elenco di elementi.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> è null.-oppure-Un elemento di <paramref name="initializers" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="initializers" /> rappresenta un tipo non assegnabile al tipo rappresentato da <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice unidimensionale e la relativa inizializzazione da un elenco di elementi.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> è null.-oppure-Un elemento di <paramref name="initializers" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="initializers" /> rappresenta un tipo non assegnabile al tipo <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Ottiene il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uno dei valori di <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di complemento bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore Not unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di complemento bit per bit.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore Not unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di disuguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di disuguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Restituisce l'espressione che rappresenta il complemento a uno.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce l'espressione che rappresenta il complemento a uno.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR condizionale che valuta il secondo operando solo se il primo operando restituisce false.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR condizionale che valuta il secondo operando solo se il primo operando restituisce false.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="method" /> è null e <paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati.</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> e le cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> sono impostate sui valori specificati.</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
      <param name="name">Nome del parametro o della variabile, usato solo a scopo di debug o di stampa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo decremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo decremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo incremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo incremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un numero a una potenza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di elevamento a potenza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="left" />.Type e/o <paramref name="right" />.Type non sono <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un numero a una potenza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di elevamento a potenza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="method" /> è null e <paramref name="left" />.Type e/o <paramref name="right" />.Type non sono <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che decrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che decrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che incrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che incrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà tramite un metodo della funzione di accesso alle proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" />, che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Può essere Null per le proprietà statiche.</param>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è null.-oppure-Il metodo rappresentato da <paramref name="propertyAccessor" /> non è static (Shared in Visual Basic) e <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="propertyAccessor" />.-oppure-Il metodo rappresentato da <paramref name="propertyAccessor" /> non è un metodo della funzione di accesso alle proprietà.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Può essere Null per le proprietà statiche.</param>
      <param name="property">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> è null.-oppure-La proprietà rappresentata da <paramref name="property" /> non è static (Shared in Visual Basic) e <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante della proprietà che <paramref name="property" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="indexer">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Raccolta <see cref="T:System.Collections.Generic.IEnumerable`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="indexer">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" />, che rappresenta la proprietà identificata da <paramref name="propertyName" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una proprietà denominata <paramref name="propertyName" />.Può essere null per le proprietà statiche.</param>
      <param name="propertyName">Nome di una proprietà a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyName" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Nessuna proprietà denominata <paramref name="propertyName" /> è definita in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="propertyName">Nome dell'indicizzatore.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che accede a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> creato.</returns>
      <param name="expression">Oggetto contenitore della proprietà.Può essere Null per le proprietà statiche.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che contiene la proprietà.</param>
      <param name="propertyName">Proprietà a cui accedere.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà o un campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" /> o su <see cref="T:System.Reflection.FieldInfo" />, che rappresenta la proprietà o il campo identificato da <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una proprietà o un campo denominato <paramref name="propertyOrFieldName" />.Può essere Null per i membri statici.</param>
      <param name="propertyOrFieldName">Nome di una proprietà o di un campo a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Nessuna proprietà o campo denominato <paramref name="propertyOrFieldName" /> è definito in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'espressione che ha un valore costante di tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Riduce questo nodo a un'espressione più semplice.Se CanReduce restituisce true, deve essere restituita un'espressione valida.Questo metodo può restituire un altro nodo che deve essere a sua volta ridotto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Riduce questo nodo a un'espressione più semplice.Se CanReduce restituisce true, deve essere restituita un'espressione valida.Questo metodo può restituire un altro nodo che deve essere a sua volta ridotto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Riduce l'espressione a un tipo di nodo noto (diverso da un nodo di estensione) o restituisce solo l'espressione se è già un tipo noto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianze di riferimento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianze di riferimento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione con un tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</returns>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Return, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return con il tipo specificato.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Return, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di spostamento a destra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di spostamento a destra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e la cui proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> è impostata sul valore specificato.</returns>
      <param name="variables">Raccolta di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e la cui proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> è impostata sul valore specificato.</returns>
      <param name="variables">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un oggetto a <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzioneswitch senza un case predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="type">Tipo di risultato dell'opzione.</param>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un case predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="type">Tipo di risultato dell'opzione.</param>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> da usare in un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> creato.</returns>
      <param name="body">Corpo del case.</param>
      <param name="testValues">Valori di test del case.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> da usare in un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> creato.</returns>
      <param name="body">Corpo del case.</param>
      <param name="testValues">Valori di test del case.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> la cui proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> è impostata sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> con le proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> impostate sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> le cui proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> sono impostate sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> con le proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> impostate sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la generazione di un'eccezione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'eccezione.</returns>
      <param name="value">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la generazione di un'eccezione con un tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'eccezione.</returns>
      <param name="value">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Restituisce una rappresentazione testuale di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Rappresentazione testuale di <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con qualsiasi numero di istruzioni catch e nessun blocco fault o finally.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="body">Corpo del blocco try.</param>
      <param name="handlers">Matrice di zero o più espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con qualsiasi numero di istruzioni catch e un blocco finally.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally.</param>
      <param name="handlers">Matrice di zero o più espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto a <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con un blocco fault e nessuna istruzione catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="body">Corpo del blocco try.</param>
      <param name="fault">Corpo del blocco fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con un blocco finally e nessuna istruzione catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crea un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Action generico con argomenti di tipo specifici.</summary>
      <returns>true se il tipo delegato System.Action generico è stato creato per <paramref name="typeArgs" /> specifico; in caso contrario, false.</returns>
      <param name="typeArgs">Matrice di oggetti Type che specificano gli argomenti di tipo per il tipo delegato System.Action.</param>
      <param name="actionType">Quando questo metodo viene restituito, contiene il tipo delegato System.Action generico che dispone di argomenti di tipo specifici.Contiene Null se nessun delegato System.Action generico corrisponde all'oggetto <paramref name="typeArgs" />. Questo parametro viene passato non inizializzato.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crea un oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta un tipo delegato System.Func generico con argomenti di tipo specifici.L'ultimo argomento di tipo specifica il tipo restituito del delegato creato.</summary>
      <returns>true se il tipo delegato System.Func generico è stato creato per <paramref name="typeArgs" /> specifico; in caso contrario, false.</returns>
      <param name="typeArgs">Matrice di oggetti Type che specificano gli argomenti di tipo per il tipo delegato System.Func.</param>
      <param name="funcType">Quando questo metodo viene restituito, contiene il tipo delegato System.Func generico con argomenti di tipo specifici.Contiene Null se nessun delegato System.Func generico corrisponde all'oggetto <paramref name="typeArgs" />. Questo parametro viene passato non inizializzato.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un riferimento esplicito o una conversione boxing in cui viene fornito null se la conversione non riesce.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> che confronta l'identità del tipo in fase di esecuzione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> per il quale la proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> e per il quale le proprietà <see cref="T:System.Linq.Expressions.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> per il quale la proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> e per il quale le proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> e <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione con il più unario.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore più unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione con il più unario.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore più unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta una conversione unboxing esplicita.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> di cui eseguire la conversione unboxing.</param>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati.</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
      <param name="name">Nome del parametro o della variabile.Questo nome viene usato solo a scopo di debug o di stampa.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Riduce il nodo, quindi chiama il delegato del visitatore sull'espressione ridotta.Se il nodo non è riducibile, il metodo genera un'eccezione.</summary>
      <returns>Espressione visitata o espressione che deve sostituirla nell'albero.</returns>
      <param name="visitor">Istanza di <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Rappresenta un'espressione lambda fortemente tipizzata come struttura dei dati sotto forma di una struttura ad albero dell'espressione.La classe non può essere ereditata.</summary>
      <typeparam name="TDelegate">Tipo del delegato rappresentato dall'oggetto <see cref="T:System.Linq.Expressions.Expression`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compila l'espressione lambda descritta dalla struttura ad albero dell'espressione in codice eseguibile e produce un delegato che rappresenta l'espressione lambda.</summary>
      <returns>Delegato di tipo <paramref name="TDelegate" /> che rappresenta l'espressione lambda compilata descritta dall'oggetto <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> del risultato.</param>
      <param name="parameters">Proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> del risultato. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Descrive i tipi dei nodi di una struttura ad albero dell'espressione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Operazione di addizione, ad esempio a + b, senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Operazione di assegnazione composta di addizione, ad esempio (a += b), senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Operazione di assegnazione composta di addizione, ad esempio (a += b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Operazione di addizione, ad esempio (a + b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Operazione AND bit per bit o logica, ad esempio (a &amp; b) in C# e (a And b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Operazione AND condizionale che valuta il secondo operando solo se il primo operando restituisce true.Corrisponde a (a &amp;&amp; b) in C# e a (a AndAlso b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Operazione di assegnazione composta AND bit per bit o logica, ad esempio (a &amp;= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Operazione di indicizzazione in una matrice unidimensionale, quale array[index] in C# o array(index) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Operazione che ottiene la lunghezza di una matrice unidimensionale, ad esempio array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Operazione di assegnazione, ad esempio (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Blocco di espressioni.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Chiamata a un metodo, ad esempio nell'espressione obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nodo che rappresenta un'operazione null coalescing, ad esempio (a ?? b) in C# o If(a, b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Operazione condizionale, ad esempio a &gt; b ? a : b in C# o If(a &gt; b, a, b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Valore costante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Operazione cast o di conversione, ad esempio (SampleType)obj in C# o CType(obj, SampleType) in Visual Basic.Nel caso di una conversione numerica, se il valore convertito è troppo lungo per il tipo di destinazione non viene generata alcuna eccezione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Operazione cast o di conversione, ad esempio (SampleType)obj in C# o CType(obj, SampleType) in Visual Basic.Nel caso di una conversione numerica, se il valore convertito è troppo lungo per il tipo di destinazione viene generata un'eccezione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Informazioni sul debug.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Operazione di decremento unaria quale (a - 1) in C# e Visual Basic.È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Valore predefinito.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Operazione di divisione, ad esempio (a / b), per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Operazione di assegnazione composta di divisione, ad esempio (a /= b), per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Operazione dinamica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nodo che rappresenta un confronto di uguaglianze, ad esempio (a == b) in C# o (a = b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Operazione XOR bit per bit o logica, ad esempio (a ^ b) in C# o (a Xor b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Operazione di assegnazione composta XOR bit per bit o logica, ad esempio (a ^= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Espressione di estensione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Espressione "go to", ad esempio goto Label in C# o GoTo Label in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Confronto "maggiore di", ad esempio (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Confronto "maggiore o uguale a", ad esempio (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Operazione di incremento unaria quale (a + 1) in C# e Visual Basic.È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Operazione di indicizzazione o operazione che accede a una proprietà che accetta argomenti. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Operazione che richiama un delegato o un'espressione lambda, ad esempio sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valore condizionale false.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valore condizionale true.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Etichetta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Espressione lambda, ad esempio a =&gt; a + a in C# o Function(a) a + a in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Operazione di scorrimento a sinistra bit per bit, ad esempio (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Assegnazione composta di scorrimento a sinistra bit per bit, ad esempio (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Confronto "minore di", ad esempio (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Confronto "minore o uguale a", ad esempio (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Operazione che crea un nuovo oggetto <see cref="T:System.Collections.IEnumerable" /> e lo inizializza da un elenco di elementi, ad esempio new List&lt;SampleType&gt;(){ a, b, c } in C# o Dim sampleList = { a, b, c } in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Ciclo, ad esempio for o while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Operazione che legge da un campo o una proprietà, ad esempio obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Operazione che crea un nuovo oggetto e ne inizializza uno o più membri, ad esempio new Point { X = 1, Y = 2 } in C# o New Point With {.X = 1, .Y = 2} in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Operazione di resto aritmetica, ad esempio (a % b) in C# o (a Mod b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Operazione di assegnazione composta di resto aritmetica, ad esempio (a %= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Operazione di moltiplicazione, ad esempio (a * b), senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Operazione di assegnazione composta di moltiplicazione, ad esempio (a *= b), senza controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Operazione di assegnazione composta di moltiplicazione, ad esempio (a *= b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Operazione di moltiplicazione, ad esempio (a * b), con controllo dell'overflow, per operandi numerici.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Operazione di negazione aritmetica, ad esempio (-a).È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Operazione di negazione aritmetica, ad esempio (-a), con controllo dell'overflow.È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Operazione che chiama un costruttore per creare un nuovo oggetto, ad esempio new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Operazione che crea una nuova matrice in cui sono specificati i limiti per ogni dimensione, ad esempio new SampleType[dim1, dim2] in C# o New SampleType(dim1, dim2) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Operazione che crea una nuova matrice unidimensionale e la inizializza da un elenco di elementi, ad esempio new SampleType[]{a, b, c} in C# o New SampleType(){a, b, c} in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Operazione di negazione logica o di complemento bit per bit.In C#, è equivalente a (~a) per i tipi integrali e a (!a) per i valori booleani.In Visual Basic, è equivalente a (Not a).È necessario che l'oggetto a non venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Confronto di disuguaglianze, ad esempio (a != b) in C# o (a &lt;&gt; b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Operazione di complemento a uno, ad esempio (~a) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Operazione OR bit per bit o logica, ad esempio (a | b) in C# o (a Or b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Assegnazione composta OR bit per bit o logica, ad esempio (a |= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Operazione OR condizionale di corto circuito, ad esempio (a || b) in C# o (a OrElse b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Riferimento a un parametro o una variabile definiti nel contesto dell'espressione.Per ulteriori informazioni, vedere <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Forma suffissa di decremento unario, ad esempio (a--).È necessario che l'oggetto a venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Forma suffissa di incremento unario, ad esempio (a++).È necessario che l'oggetto a venga modificato sul posto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.Expressionype.Pow%r">
      <summapy>Operazione`mapeoatica ghe eleva un(numero a potenZa, ad(msempio (a ^ b in Visal Basic.</s}mmary
"   </mmber?
    <member name="F:Wystem.Dinq.Expressions.ExpreSsionType,PowerAssign">J      <sum}ary>Oqerazione da aSsegnazione composta cje eleva un numero a potenza, a$ esempio(a ^= b) i. Visual BasiC.<summarx>
@ !(8/member>
    <member name="F:System.LIjq.Extressions.ExpressimnT}pe.PreDe#BementAsrign">
      <summary>Forma prefissa di decreMen4o u*arig, ad esmpio (-a).È ~ecessario che l'oggettO a`vgnga modificat sul posto.</semmary>
    </member>
    <maber!name="F:System.Linq.Exprmssikns.DxpresiOnType.PreIncreientAssign">
      <summary>Forma prefissa di Incremento unario, ad esempio (++a).È necms3arig che l&oggetto a venga modificato suL posto.</summary>    |/ogmber>
    <member ncme="F:Systee.Lonq.Exprgssions.ExpressionTy0e.Quote">
 `    <smmary>Mspressiona che ha un valore aostaote d) tipk <see cref="T:Sysvem.Linq.ExpressionsnExPrssion" />.Un nodo <see cref= F:Systam.Linu.Expre{sions.Eypr3sionType.Quote" /> può aontenere sieRimenti ai parametri defini\i nel contesto delm'uspRessone chm rappresenta.</summary>-  ` <iem"er>    <member name="F:SystE-Linq.Expressions.Expressio.Typg.RkghtShift">
      <summary>OperazioNe di skorrimeno a destra bit per jit, ad esempio (a gt;'gt; b).</smmary>
   </member>
    <member name="F*Rystem.Linq.Expressions.Expb%{sionType.RightShiftAssign">
     summary>Opeazionm di asseonarione composta di scorrimento a destra bit qer cit$ ad esem`io (a &gt;&gt;9 b)></summary>
    </memce">    <member name="F:SystemLInq.Expre{sions.ExrescionType.RuntimeVariables2>
      <sumiary>Elenco di variabili di run-timenPer ulteriori informazioni, vedere <ee cref"T:Sywtem.Lknq.xpressions.RuntimeVariablesexpreSsion" />.</summary>
    </mdmber>    <member name?"F:SyStem.Ninq.Expressions.expres3ioType.Subtract">
"     <summary>Operazione dI sottrazione, ad msempio (a - b+, senza co~trollo dell'overnlow,0per`operandi numerici.</rummary>
    </lember>
    <eembar lcme="F:Syctem.Linq.Expre{ions.ExpresionType.SujtractAssign">
      summaryOperiZione di a{segnazione composta di oTtrazi/ne, ad esempio (a -= B), sinza convrolho dell'o6esflow, pe2 opera~di numerici.</summary>
    </member>
    8member naoe="F:System.Linq.Expressions.ExpressiolType.S}b0ractAcsignChesoed">
      <s}mmary>OpeRqzione di assegnazione composta di$sottrazione, ad esumpio (i -= b, conc/ntrollo deml'overflow, per operandi numericm.</summary:
0   </memfar>
    <member name="N:System.Linq.Expresskons.ExpressionType.SubtractChecked">
      <Summary>Operazione di sottraziooe aritmetica, ad esempio (a - b), cOn controdl/ dell'overflow, Per operanei numerici.</summary>
    </member>
    <member name="F:System.Linq.ExprE{sions.GxpressionTxpe.SwItch">
    <summapy>OpeRazione i switch, ad esempio switch in C# o Select Casd in isual Bawic.</summ!ry>
  ( </member>
    <member name9"F:Sys4em.Linq.Expressions.Expra7sionTypenThro7".
      <rummary>perazioNe che genera un'ecceziOne, ad esempio`throw new Exceptio.).</sulmary~
    </-embdr>
    <member name="F:System.Linq.Eypressiojs.MxpressionTyqE.Try">M
    !"<suomapy>Mspressione try-catch.</sum-ar{>-
"   </member>
    <member na-e="F2System.Linq.Expressiojs.Expressionype.TyeAs">      <summAry>Riferimento esplcito o conversione boyi.g in cui Viene specificato oull se la conversiona no riesce, ad eseipio!(obj as SaopleTyxe) in C# o TryCast)obj, SampleType) yn Visual Basic.<osummary>
   !</memer>    <member name}"F:SysTem/Linq.Expression{.ExpressonType.tyteEqean">
      <summqry>Test di |ipo esatTo.</sumlary>    </member>
    member name="F:System.\inq.EXpressionc.xpressionType.TypeIs">
      <summary>Test $i tip, ad esempio obh is SamplEType i. C# o TypaOf obj is SampleType in Visual Basic.</summary6
    </Memcer>
 `  <mam"er name="F*System.Lijq.Expressions.ExpressionType.UnarYPlus">
    ! <summary.Operazone con il più unario, ad esempio (+a).Il risultato di un'operazione con il piǹ tfarao praefioita è il valor- dell'operando,"ma le implmentazimNi definive dall'u|ente possono dara risultati iosoliti.</summary>
   "</meMber>
   "<member nae="F:System.Linq.Ex0ress)ons.ExpreSsionTyte.Unbox">
      <summapy>Operazione di unbozing del tipo di valore, ad esempio le hstru~ioni unbox e unbox.any in MSIL. </summary>
"  </member>
 $  <member name="T:Sxstem.Liq.Expressions.ExpressionVisitor">
      4summaryRappresenta un visitauore o un rewriter peb le str}tture ad alBero dell'espressione.</summary    </ember>
    <member namu="M:Syspem.inq.Expression{.ExpressinVisitor.#ctor"6
!   ` <sumiary>IniziaLizza$una nuova istana di <sde cref="T;System.Ninq.Exprascions.ExpressaonViqhtor" />.</sumary>
    </membe>
    <member namd="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.OjjectModel.RmcdonlyCohlecion{System.Linq.Expressions.Expression}i"?
      <swmmary>InVaa l'elen#o di uspressiony a`uno dEi metodi di wsita più specializZati in qwesta c|asse.</sUmmaby~
      <returns>'elenko mndificato de,le espressioni, e è stato modificado uno degli elementi; io caro contrario0retituisce l'elencn os)ginale deln% ecpressioni.</returns>
      <param"name="nodes">Es`ressioni"da visitcre.</param>
 $  <+me-b%r>
    <member name="M:SysteM.LinQ.Expressiols.ExpreqsionVisitor.Visit``1(System.Collectiofs.ObjecModel.ReadOnlCnllectioN{``0},System.Fun#{`b ,``0})">
  !   <sumlary>Visi|a tutti i nodi nella raccolta utilmzzando un visitatore dell'elemento spEcafic!to.</suomqry>
      <rettrns>Elenco modificato0deI nodi, re è sTaTo modificato uno deg|i0elementi. Incaso contrario, restituisge l'uLenco originaLe dei nodi.</returns>
      <param name="nodes">I nodi %a visitare.</param>
   0  <param`~ame="elementVisitor">n(`elegato che visita un solo element, sostituendon/ faColt)tivamente con un nuovo elemento.</pcram>M
     <typeperam name="T">Il tio di tutti i nodi.</typeparm>
    </membev>
    <member nae%="M:System.LinqExpressio|s.Ex`ressionVisitor.visit(System.Lnq.Expresshons.ExrResqion)">
      summary>Invia l'espressione a0tno dei metodi di viskta tiC specializ:ati in questa classe.</summar{>
     <retqrn>Espre{sione modificata, se l'espressiOne stessa o una dellu relative sotte{pressiOni è!spata Modificata; in caso conrario, restituisc l'espressione originale.</returls>
    ` <perim name9"node"Espressinne davisitare.</param>
    /member*    <member jame=#M:Sqstm.Linq.Expressions.ExpressignVisitr,VisitAodConvert``1(Systm.C/llectionS.ObjectIodml.ReadOnlyCollectaon{``0},System.String)">
      <summaryVsita un'erpreswione, eseguendo il cast del risultatk sul tipo di espbgssione originale.</summary>
      <returns>Ecpressione modIficata, se m'ewpvessione stessa o una dElle relati%"sttoespressioni è stcta modibicati; in ao contrario, restituIsce l'espressione oriea.alen/ruturns>
      <param name="nodes">Espresione da vi3itcrm,<-param>M
      <param"name="calderName>Nome del letodo chyaoante. Utilizzato pEr`segnalare un messaggio di errorE migliorE.</param>
      <typepaRam oame="T">Il ti`O dell'espressione.</typeparam>	
(     <exeption cref="T:S}stem.InvalidOperationException">IL metodo di wisita per questo nodo ha restituito(un tipo divebso.</exception>
    </mem"er>
    <member name="M:System.Linq.ExpressionS.xpressionVisitor.VkwitAndConvert``1(``0-system.String)">
      semmary>Visita un'espressione, e3eguendk il caqT eel risultato sul tipo di esprdssione originale.</sumlary>M
      <reurns>Espressione modifcata, se"l'espressione {tessa o una d!lle relatiwe s/ttoepressioni è!stata mndificata; in0caso contrazig, restitu)sce l'espressione oraginale.</returns>
      <param neme=*nkde"?Espressione da visitare.</param>      <para name="CallerName">Nome del mdtodo"chiamante. Utmlizzato ap regnalare un mesraggio di errore migliore.</param>
      <typepavam0nam="T">il tipo $ell'espressiole*</typeparam>
      <exce`tion cref}"t:System.IlvalidOpeRationExcettin"6In metodo $i$visit! per quesuo nodo ha restituito un tipo@difevso.</exception>
    </member>
    <-ember name"M:Syste-.Ninq.GxpresqIn.s&DxpressionViriuor.VIsipBinary(Syste.Linq.Dyp2essions.BhnaryExpreSqion)">
 !  $ summary>Visita$gli dlementi$figlio di <rue cref="T:Cystem.Linq.Expressions.BinaryEXpression" /..</summ!ry>
      <returns>ESppesshone modibicAta, se l'esprssioNe stessa o una!delle relative sottespresrioni è stata modificata; hn caso contrario, resti4uisse l'espsessione originale.</2eturNs>
      <pArim nme="node".Espressiole da visit!re.</para?	
    </member>
"   <member nale="M:System.Linq.Expre{siojs.Expression^isipor.VisitBlock(S}sdem.Hinq.Axpressions.BlockExpvessin)">`     |summary>Vmsita glm elementi figlio di <see cref="T:System.LinqnExpressiofs.BDockExpresqin" />.</summary>
 "    returjs>Espbessione modificIta,0se l'espressionm stessa o una delle relativf wOttoesp2Essioni è stata modificita; in caso contrariN, Restituicce l'esprgssione }riginale.</returns>
      <taram name="lode">Esprmcsioneda tisi|are.</param>
  ( </member>
   |member name="M:System.Linq.xpresqions*Expres3ionVysitor.VisitCatchBlock(Sywtem.Linq.Expressions.CatchBlmkk)">
 (    <summary>Visita`gli elemelti fignio dm <see cref="T8System.Linq.ExpRessions.KatchBlock" />.</summari>
     <beturns>Espressione modifiata, se l'espressione stessa o una elle relative sottoespreSsioni è stit moDificate; in cao coNtrario, restiduisce0l'ecpressione origknale.</rgturns>
   !  <param nim?"node">Espressione d vhsitarg*</paral>
    </member>
 0 (<member name="M:System.Linq*Exqressions.ExpressiojVisit/r.VisitColditional(Sqstem.Hinq.Expresrions&onditionqlExprescion)">
      <sumiapy>Virita gli emementi0fyglio di"<ee cref="T:Sy{tem.Linq/Dxpresskons.CmnditionalExpress)on" />.</summary>
      <retupNs>Espressiond modificada, se ecpressioja stessa o una d%lle(relatmte st4oespressioni C stata modifkca|a; in ca3o contrario, restituisce l'3pressione originale.>/reTurns>
      <p!ram(name="node">Espressione da vis)tare.<+ra2am>
    </memrer>
    ,member .ae9"M:System.Lmnq.Expressionc.XpressionVysitor.VisipConstant(System.Linq.Express)ons.ConstintExprEssion)">
      <sumar9>Visita`<seg crgf=*T:System.Linq,Exrressions.ConstantExpression" />.</summary>
      <rdturns>Espressione modificatal se l'espressione suessi o una delle remative sottoe{presrioni!è s4ata modkficata;$in cAso contrario, restiTuiqc l'esprescione origilale.</ret}2nw>
`     <param namd="nohe"~Espressione dq visivare.</param>
    </member:
    <mem`er name=&]:Systm.Ninq+Axpreqsions.ExpressionVisitor.VisitDebugInfm(System.linQ.Exrressionw.DebugInfoExpression)"
      <summary>Visata <see c2ef="T:Systmm>Linq.Exprescions.DebugInfoEppressiol" />.</summary>
      <rturns>Espressione modificata, se l'espressone stessa o una delle elatmve sottoespressioni ˨ stata modificata; in"caso coftr!rio, rertituisce l'espressione orighnane.</returns>
   `  <param ncme="node">Eqpressione da visitare&</param>
    </member>
   (<Member name="M2System.Linq.Exppessions.Expres3IonVisitor.VismtDefae|t(ystem.LknqExpressIons.DebaultExprescion)">
`     <sumeary>Visita <3ee cref="T:Systgm.Linq.Expressions.DefaultExpression" />.</3ummary.
      <retupns>Usprersione"mOdificatA, se ,'esp2essiona stes3a o ua $elle relative sottoe3pressaoni è stata mKdificata; in caso contr!rIo,vesti4uxrce(l'eSpressiofe origina|e.</returns>
      <param name="node">Es0rewsione dA visitare.</0aram>
    /member>    <member ~ame="M:System.Linq.Expraswimns.ExpressionVisitor>^isitElameltInit(Syste.Lijq.Ezpzessions.ElemenvIfit)&>
    ( <rumlary>Vicita gl) ele-enti figlio di <see cref="T:System.Linq.Expressions.ElementInit" /:.</sumlry> "    <rdturns>Espressione modifhcata, sd l'espressione sdess "una delle relative sotvoespressioni  stata }odifibata; in(casO contrario, restixumsce l'%spresione originale.</rettrns>      <qaram name="node">Eqpzessiona da ~isitare.</pazql>	
   </member>
    <membes!name="M:System.Linq.ExprEssions.Expression^isitor*VistExtension(Sysem.Linq.Expressinns,Exqression)">
      <seem`ry>Visita i faghi leld'Es`rersiolE gI stgnione.</sqmmar}>
      <returns>spres{ione modificati, se d'esqressione rtessa o una delle relaiwe sot|oesprecsioni è stata modificata; in$caso contrario, resti4uisce l'espressio.e origaale.</returns>
      <parae$name="node">Espressione Da visitqre</par!m>
  $!</membez>
   (<meMbeR name="M:Sstdm.LiNq.Ex`ressions.Elpr%ssmo.Vismtob.VisitGoTo(System.LinqnExpressions.Gotoxpression)">
   !  >summary>Visita gli elmentI figlio di <see cref=T:System.inq.Expressions/GotoExpression" />.</summary>
      <returns>Es0resione modifcata, se h'espresskone stessa o uja delle relativd sottoespruwsioni`è stata modificata; in cAso c/ntrario, rEstituisce l'espressione ORiginale.</returns>
      <pirEm name="nnde">Esppessholeda visip!re.>?param>
    </mmber>
   "<member name9"M:System.Lhnq.Exprezsyos.ExprusionVisitor.VisitIndex(Sysdem.Linq.Exprussions.IndExExpression)">      <summ ry>Visita gli elementi fiwlio di <see cren="T:System.Linq.Expressiofs.IndexExpression" />.</summary>  $`  <revwrns>Espresskone`modificata, re l'esprEssimne stessa o ena delle rElAtive qottogspRersioni è stata mod)ficata; iJ caso contrarmo, restituisce"l'espre{sione0oRiginale.</r%turns>
      ,param name="node"<Espressione da visitare.</para->
    </member>
    <member .me="M:Systee.Linq.Expressions.ExpressinVIsitor.VisitInvocationiSystem.Lknq.ExpressionvI.vgcetionAxpressioj) >
      <summary>Vhsita gli elementi figlio di <see cref="T:ystem.Linq.Ehpressions.InvncationExpreqsiol" />.</suLmary>
     !<return3Espreswione modifIcata, s- l'erpressigne stessa o una dell% relatiRe sottoeSpressioni è stata"modificata; in caqo contrario, restituisce l'espessione originale&</returns>
     <parem name="noe"?Espsessione da visitaze.</pesam>
    </-embe2>
    <-emfe2 name="M:Systam.inq.Expressions.ExpressionVisitor.ViwitLarel(Syspem.Lmnq.Expressior.LabelExpression)">(!   <sqoary>Vsiva gli elementi figlio di <see cref="T:Syztem.Linq.Expressions.LabelExpressIon" '>.</summary>
     `<ret5rns>Espressionu modificata, se l'espressione stesa o na delle"elative sotto%spbessioni è`stata modificata; in caso aontrarIo, rastmtuisce |'espressione orIgi.ale</ret5rns>
      <pasam name="no`e"<Eupresmone fa visitare./para>
    </member>-
    <member name="M:Syspdm.LinuEyressions.Eyptessionisitor.VisItLabelTipget(Syste}.Linq.Dxpressioos.LabelTarge4)">
      <summary>Visita <seecren="t:System.Linq.Axprassio/s.LabelTarget" />.</summary>
 `   !<veturns>AsprESsine modificada,se l'usprEssioe stessa o un` ddlle rglqtiva sottoesprEssiofi Castita moDkficata; in`c`so cgntrario, re3tituisce l'esresrioNe originale.</seturns>
    ( <param ncme="node&>Espressaone da visitare</qaram>-
  $ <.membep>
   "<member na-e="M:SysteM.Linq.Expressions.ExpressonVisitor.VisitLamb$a``1hxwte.LiNq.Expressions.Ehpression{h`0})">      <Summ`ry>Visita`gli e,emdn4ifigliodi <see cref="T:System.Linq.ExpressionsnExpreqsion`1" />.</summary>
      <returns>Eqpressi~ne modificAti, se l'Es`rescione stessa o une delle relative sodtoespressinni è sta4a mndificatA; in caso contrario, retituIsce l'uspressione originale.</returns>
($  ! <pqram name="node">Esp2essione fq visitare.</param>
      <vypexar!m name="V">Tipo del delegato.</t9peparam>
    </membr>
   <member nae= M:SycteM.NinQ.Exprewsions.expressionVmsitor.VisitListIn)t(Sy{tem.Linq.Expressionr/ListInmtExpres3)on)">-
      <sumoar{>Visita gli elegnti figlio di <sea(cref="V:Sistem.LinqExprssions.Dist	nitExprecsi/n" />.</summary>
      <returns>Espressiood moeificata, se lGestressione stessA o una lellu relatifm sottoespzessioni!è stada modificata; in caso c/ntrario,`restituisce l'msPrwsiooe kriganale.</returns>
      <param nam5"nodu">Es0ressionE da 6isitare.</parim>
   (</member>
    <membeb name="M:[ystem.Linq.Express)ons.ExprewsmonViitor.Visitloop(Sy{tem.Linq.Exp2essions.HoopExpression)">
!     4summEry>Visita fli(elementi fieLi/ di <sde crEf=#D:System.Linq.Eppzessions.LoopExpression" />.</summary>
      6returnr>EspressionE modificata, 3e |'esprewskone stessa o eja delle 2el`tive sottoesPressioni è stata mo$ificatA? kn caso c/ntrario, re3tiusce l'espressione origInale.</returns>
"   $ <param nAme="nodeb>Espressione davisitare.<pazaM>
    =/member>
    ,member!nam=M:S9stee.Lin1.Exprescions.ExpressionVi3itor.VisitMember(System.\in1.Exprewsyons.MEmberExtressin)">
      <summary.VisiTa gli elementi figlio di ,see crEf="T:System.LinqExpressios.Memberex0ression" />,</summar{>
`    returns>Espressione modificata, se l'espressione stessa o unc dele zelative 3ottoespressioni è stata modificata; in caso bootr!ryo, respituisce l'%spressione origincle.</returns>
   (  <param name="node"?Espr%3sionm d! visitare.</param>M    </member>-
    =memer name="M:System.Lifq.ExpressiOns.ExpbessionVisitor.Vi{itEemberAssignment(S}svem,Linq.Expersions.MemberAs{ignment)">
     !<Su}m ry>Vysita gli e,ementi fyglio di <ee cref=bT:Syqtem.\inq.Expressios.EemberAssignment"0/>.4/suemary>
    0 <returns>E{pressmone modificata, s% l'esprossiole stessa o una$delle relative sottoestressioni ì stata modificatc; in caso contrario(resti|uisce l'espressione oricinale.</returns>
 "    <param name<"nMte">Espessionm da visitarE.</param>
    </member>
 `  <member name}"M:Sywtem.Linq.Expresionc.Expressio~Visitor.VisitIembesBineing(Systdm.Lhnq.Exprassions.MumberBinding)>
      <summary>vi3ita Gli elementi figlio di <se cref="T:System.LinQ.Expressions.MemberBiniog" /?.</summary>
   "  <seturj{>Espresrione modificata, se l'espressione stessa`o unA delle relative soptoespressionm è stat` modificata; hn aaso`conpra2io, restiti{cu l'esp2escionE(originala.</retwrns>      <raram name"node&>EspRessione da visitare.</pazam>
    =/member>
    <member name=*M:System.Hynq.Exprersions.ExpreswionVisitor.Visi`MemberInI4(System.LInq.Expression3.MembesInitExpression)">
  ` "0<summary>Visita gli elemelti figlio di <see cref="T:System.Lhoy.Exprmssions.Memb%rInitExprgssion" />.</summ`ry6
      <returns>Espressione modifi#ata, se le{tpessione stessa0o wna felld relative sottoespressioni è stata modifhcat; iN caso contrario, restituisce l'espressione originale.</returns>
      <param naMe="node">Espressione da visitare.</param>
    </me}ber>
    <meibur name="L:System.Linq.Exprussionq.Expre{sionViqitor>VisitMemberListBinding(Syste-.Linq.xpressions.MemberListBinding)">
      <summary>Visita"gli elementi figlio di <see cref="T:System.Linq.Uxpressiofs.MemberListBinding"0/>./sumoary>
     <returns>EspreSsione mdificata, se l'espbeqione stess` o una delle relativa sottoespressioni è$st`ta iodhfacata; in caso!contrario, rmsTituisce l/gspressione originale.</returls>
 `    <parAm name"node">Espresqione da tisitare.</param>
    </member>
    <melbdr name="_:System.Linq.EXpressions.ExpresionVisitnr.VisitMemberemberBind)ng(System.LInq/Expression{.MeeberIelberBindyng)">
     "<summary>Visiva g|i elementK figlio di see cref="T*Sysdem.Linq.xppessionsnMemberMemberB)ndimg" />></summqry>
  0   <returns>Ecpressigne modifiaaua< se 'esprecsione stewsa o una dellu relative sottoewpsesskoni è stata modificata; in casocontraRio, restituisce l'espressione oriwknale.<+retwrns>
      <peram name="node">Eqpressione da visitare.</param>-
 !  </oember6
    <member name="M:System.LiLy.Expressions*ExpressionVisitor.VisitMethodcall(Sistem.Linq.DpreqsIons.MeThodCallExpresson)">
 !    <S5imary>Visita gli(eleme.ti figho di <ceg cref="T:Syst%m.Linq.Expressions.MethoeCallExrressicn" />.</summary>
 !    returns>Esppessione moDifica|a, se l'espReqrione!s4essa o una `elle relative sottoespressioni È state modifmcata; in Caso contvario, restituisce l#espbessione originale.</returns>
 !    8param name="node">Espressione da visitarm.</pAram>	
    </member>M
 `  <member name="M:System.inq.Expressioos.ExpressiONVisitor.VisitNew(Sist%m.linq.Expressions.NewExpresshon)">
      <cummary>Visita gli elementi figlio Di <see cpef="T:System.Linq.Gxpressions.NewExpressimo" />.>/summa3y>
`     <zturns>Espressio.e odificatc, se l'esxresskone(stessa o una delle relative sop|oespressioni è!stata modificata; in cask coltRarig- rEstituisce l'espbessione oriwinale.</Sedurns>
     8param name="node">wpressigne da visitare.</param>
$   </meeber>
   ,member name="M:Sy3tem.Linq.Expressi/ns.EpressionVisitor*VisitNewArray(SysTem.Linq.Expressions.NewArryExpres)oni"<
   (  <rUmmary>Visita f,i elemmnti figlio di <see crv="T:System.LinqExpbrsiozs.NewArrayExpressioj" />.:/summary>
     <returns>Espressionm modificat, se l'esprec2ione stessa o ufa(delle relative sottoe3pRessiofi é stata mo$ificata; in caso contrArio, restivuisce l'erPressimnm(originale.,/retupns>
 (    <param name="node">Espressione da!visitare.</pram>
    </member>
  ( <member0name="M:Syqmm.Lijq.Dxpressionw.ExpressioNVisitor.VasitParameter(System.Linq.Expressi/ns.P`rameterExqression)">
`     <summa2y>isita <sge cref="T:Systgm.Linq.Expessyon{.ParameterExppe3rion" />*<summary> (   0<returns>Espressione modificada, sm l'espressione stewsa"o una delhe relative so4toespressyoni è stAta modifibata; in caso contrario,0restituisce l'espressioNe originale.</retuBfs>
   `  <param ncme}"node">Espressione da vismtare.</param>    /member
    <mdmber name}"M:WYstEm*Liq.Expressioos.ExpressionVisitor.visitRuntimeVariables(System.Llnq.Expressions.untieVarmable3Exprmssion)"J  $   <suemary>Visita$gli elemejti fig|io di see cref="T:Syspem/Lioq.ExprEssions.RuntimeFariablesUxprEssion" />.</qummaby>
  !   <returns^Espressioje modificava, qe h'espressiOnD stessa o uNa delDe rulative sottoesPressioni C(stqta!modifica4a; iN caso cootrario`restivuiSce l'eqpressioNe`orhgina,e.</returns>
     $<pasam naie="~ode&>Espressione da visitare.<oparam>
   !</m%mbEr>
    <me-bev naee="M:SysTm.LinqExprmswions.ExpressionVisitov.VisitSwitch(Sysu%m.Linq.Ex`ressions.SwitchEhpression)">
   $  |summary>Visita gli Elementi figlio di <se cref="T:System.Linq.Expreqsions.SvmtchExpression"/>.<summary>
      <returnr>Espressione moDinicata, {e l'espressione stassa o una dele relative sot|oesprassoni è suata modific!ta; in caso conurqrio, rusituisce l'espressioNe originale.,/retUrns>
      <param .`me="node">Espressione da visktare.</taram>    <member>
    <me}ber name=#M:S}stem.Liny.Expressio.s.ExpressiofVisitor.Visi|[witchCase(System.Linq.Exprus{nsnSwitcxase)"<
    0 <summarx:Risita gli elementi figlio di <see gren=bT:System.Linq.Expressions.SwitchCase" />.</summaRy>
   0  <returns>EspresSione modifhcata,0se l'gspressione ctessa o unA delle relative sottoewpressioni è ctata modifmcata; io caso contrario, restivuisce l'eWpressikne originale.8/returns>
      <param name="fode>Dspzeq3ionE da visitare.</param>
   <?Mgmber>
0   <member`name="M:SysteM.Linq.Extzessions.ExpressicnVisitor.VisitT}(Sytem.Linq.xtrecsions.TryExpresio~)":
      <qummary>ViSita gdi elementi fkglio di <see cref="T:Sy3tem>Lioq.Expressions.Trye8preSsion" />.</su}mary~
     <returns>Espressione mOdivicata, se l'espressiOne stessa o una"Delle relative`sottoesressioni è stata modificata; io caso conrario, restituisce l'espressiofe originile.</returns>
      <p!ram name="jgdE">Espressiofe da visiTare./par!m>
    </ember>
    <member name="M:System.inq.Expressions.ExpreswaonVisitoR.VisitTypeBinaryhSyqtem.Lnq.Express)os.TyreBinayExpression)">
      <summasyViqiua gli elementi fiGlio di see cref="T*SYst%m.Linq.Expressions.TqpeinaryExpression  />.</summary>
`     <reTuns>Espressione modificata, se l'esprEssine spessa o una delle`relativa sn|toespress)oni è stata }odifica|a; iN caso contrario( restituisce m'espress)oe!originale.</returns>
      <param name="nodeb>spreswione da visitare.</parae>
$   </member>    <member name="M2System.LiN1.Expressaons.ExpressonVisitor.VisitUnary(S{stem.Linq.Dxprassionc.UnaryE8precsao~)">
      <3udmary>Vis)ta ghi eleienti figLio!di <see cref="T:System.Linq.Gxpsessons.U~aryExpression" >.</summry>
  ` $ <returns>spresRione modificata, se`,'esprmssiOne stessa o una delle relative sottoespsessioni ˨ stata m/dificata; in caso contrario,`rustituisce l'espressione originale.</reterns
      <param name="nde">Es0ressiONe da vismtare.</param>
    </member>
    <mmmber name="T:System.Hinq.Expressions.GotoExprewsion">
      <sumeary6Rap0Resenta Un S`lto )nbondizio~ato,Ifclule istrujioli di iTorno, iNterruzione e continuaZione, e altri$salti./summary>
    <.member>
    <member name="P:SyStem.Ninp.Expessins.GotoExpbeqsion.Kind">
      <summary>Il ti`o di msprdssione "gO to".a solo scopi di informizione.</summary>
      <retUrn{>Oggtto <wee creb="T:System.Linq.Expressions.GotoExpressionKind" /> che rappreseta il tipo tellespressigne "go to".</reuuRns>-
    |/membr>
    <member oame="P:ystem.Linq,Expressions.OotoExpression.NodeTypa">
      <summary>Ractatuisce il tipo dy nodo di$<seE(aref-"T:System.Linq.Expresq)ons.Expression" />8/Summary>
      <returnq>M
    ($  <see`cref="T:SYstem.Nmnq.Dxpresqiols.EipressimnType  /> che ra@pRese.ta l'espressiofe.</returns>
    </member>	
   !<member oame="P:System.Linq.Ex`ressmoNs.GtNExpressioN.Target >
      <sumMary>L'dtichetta della destinaziofe a cui saLua questo noo.</summary>
      <reTqrns>Oggetto <see cref="t:System.Linq.Exppessions.LabelUabGet" -> che rappresenta l'etichetta destinazione pe2 questo vodO.</returns>
 0  </m%mber>
 $  ,membmr name="PzSyqtEm.Li/q.Expressions.G/toExrssiOn.Typd"<
      <summa2yOttiene il tipo statico dell'es0resinne rappresentatA da <see cref="T2Sytem.Lmnq.Exprewsions.Expression" -..<?summary>
      <retuRns>
        <sem cref="P:Syqtem.Linq.ExpessionslGotoExpRession.Typeb /> che rappresenta il tipo statico dell'esprmssion%.</returns>
`   <member>
 0  <member$name="M:Syste.linq.Expressions.GotoExpression.Update(System.Linq.ExpRessions.LabelTarget,Sywtem.Linq.EXpressionsnExpression)">	      <summary>Crea ula nugva esprEssione simile a quella crrente, utilizzando 0erò gli elem%jti figlio sec)ficati.Se!tutti gli elementi Figlio soNo uguali,verrà restituita l'espressione Crrente></rummary>
    0 <returns>Espressigne correote se noN!vien modifIcato alcun lemento figlio o espressione bon`gli elemen4i figlio aggiornatm.</returna>      <para- name="target">Xroprietà <see cref="P:ystem.Linq.EXprmssions,GotoExpresshon.Tazget" /> del sisultato. </param>
      ,param name="vadue">Proprietà <see cref="P:System,Linq.Ehpressions.GotoGxpvession.Value" /> del risultato. <?Papam<
   0=/member>
"   >membdr name<"p:System.Li~qnExqressions.GopoE8pression.Value">
$     <summary>Il valora passqto alla d%stinizione, oppuse Null se la destinaziond ¨ d` tipo System.Toid.</summar{>
!     <returns>L'godtto <see cref="T:Sys4m.Linq.Expressions.Exqres3ion" /> che rapresent` il valore passato alla destifazione, o`ptre Jll&|/veturns>
   </memBer>
    <membeR Namg="T*System.Linq.Expressions.GotoEppressionKind">
     <summary>Spec)fica s`e tipo di salto che puesto <see(cef="T:Rystem.Linq.Expressi/ns.Got/ExPre3qion2 /> pap0resenpa.</summary>
 "  </Member>
 0  <member lamd="F:Sys4em.Liny.Expressis.gotoExpressionindnBReak">	
   "  <summary>
        ,qee cruf="T:SY3tem.Linq.Exprmsshons.GotoExprd3sion" />$che rappbesentaun'istruziooe di`interruzione.</summary>
    </mgmber>
    <melber name=F>System.Linq.Expre3sin{.GotoExppessionKind.Continud">
      <summari>
      ! <see czef="T:System.L)ny.EXpressions.GotoExprecsion" /. che rapPvesenta un'ist2uzione di continuazione.</summary>
    <-member>
    <memcer name="F:System.LinqGxpres{io.s.GOtoExpressi/nKind.Goto">
      8su-mary>Un <see kref="T:Syvtem.Linq.Ep0ressions.GooExprecskon" /> che Rappresenta un salto a enA determinita posizione.</summary>
   </mEmber>
    <member name="V:System.Linq.EXprecsinns.GtoExprEssiojKind.Re|urn"
      8summary>
        <see cref="T:System.Linq.Exrebsions.GotoExpreqsion" /> che rappresenta un'istruzione di ritorNo.</summar}>
    </le-ber>
    <member name="T:SysdeE.Linq.Ezpres3ions&IArgumuntProvider"></membqr>
   <member name=P:Systmm.Linq.Exprmssion.IArgumentProvider/ArgumujtCount"></member>    <member name="M:System.Linq/Expressions.IArgumenTTrovider.etArgumentSystem.Int32)"></member>
   <mdmbez name="T:Sysuem.inq.Expressionw.IdynamicExpression".>/mem+er>
`   member name="M:System.Linq.Ex`r%ssions.IDynamicExxreqsion.reatCallSiTe"></member>
    <member name="P:System.Lilq.Exprecshons,IdyoamicExqressionDalegateType"></membeR>
    <member"name="M:Qistem.Lmnq.Exxrdssions.IDynamcExpresshon.Rewite(Systdm.Linq.Exprescions.Exp2essi/n[])></member>
    member namE<"T:System.Linq.ExpressionsnIndexExpression">
      <summary>Raptresenta!l'indicizzaxine di }na poprietӠ o di una matrice.</summary>
    </member>
    <Member name"P:System,Linq.Extressions.IndexExpression.Argum`nts">
 `    <rummari?Ott)eng gli argomenti che verrannouuilizzati"per mndicizzare A prorietà o la matricm.</summary>
      <returns>Raccolta di sola lmttura contenente gli arGomenti che verran~o qtilizzatiper indicizza2a!la0proprievà o la matpi#e.<+returns>
    </member>
    <membes name="P:System.Linq.Expreqsion.IndexExpressygn.Indexer*>
"     <qummary>Ottiene <see svef="D:Sxstem.Reglection.PropertyHnfo" > per laaroprietà 3e l'ewpressiofe rappresenta una proprietà`indicizzatq, 2estituis#e Numl in cqso conTrabio.</sulmary>
   "  <returns>
     `  <see cref="T:System*Reflaction.PropertyInfo" /> per la proprietø se l'espressaone bappresfta una pRgprieuà indicizzata; in ca{o contrario(Null.</reterns>
  $ </membez>
    <member name="P:System.Linq.Ehpsessions.InDmxExpr%ssmnn,Node4ypd">
   $  <semmaRy<Restit}isce yl tio di nodo di <see gref="T:SystMm.Linq.Expressions.Uxpression" />.</sumlary>
      <re|urns>
        <see gbev="T>Sy3tem.inq.Expsessions.AxpressionTye">0che rapprdseNti l'espressioa.</returns:
    </member>
 0  <member name="P:Systam.Linq.Axpresrions.IndexEppression.Object">
      <summary>Un oggetto da indicizzare.</summary>-
      <returnS>
       <see cref="T:System.Linq&ExpressIons.Exprew3io" /> che rappresent` l'oggetto d indicizzare.>/re4Upns:
    </member>
    <membe namE=&P:System.Linq.Expressions.IndexExpp%{sion.System#Lilq#ExpreSwions#IArgumendProv)der#ArgumentCounT"></member6
    <member!name="M:System.Linq.E|qressions.IndexExpression.Sysdem#Dinq#Expressions#IArwumentProvider#GetArgument(Sys|ei.Int32-"></member>
    <member name=P:syste.Linq.Expressions*IndexExpression.Type">
      <summ`ry>Ottiene il tipo statico dell/dspressmone rappresentata da <see cref="T:System.Linq.ExpresrIOfs,Expression" />.</sqmMary>
      <returns>
        <see cref="p:SysvEm.Linq.Expressiknq.IndexExpress)on.Type" /> she`rappres%nta al 4ipo sttico dell'espressione.</returns:
    </member>
    <member namu="M:SystemLi~q.xpsessionS.IndexExpression.QpdAte(Sytem.Lilq.ExpresSions.ExPression,System.Collecuionc.Generig.IEnumea"le{Sys|em.Linq.Expressons.Expression})">
      <summary>Crea una nuova espressione sImile a quella corrente, utilizzaneo però gdi elemefti figlio`specifiaati/Se tutti"gli elamenti figlao sooo uguali, verrÀ restipuita l'esprgssione corrente.</summaby>
      <re4qrns>Lspressionu corrente se non Vienemodifiato alcun Elemento figlio o espressione con gli enement) figlio aggio2nati.</returnw>
    $ <param name="object">Pboprietà 8see crefy"X:System.LiNq.Expres{ions,IneexE|pression>Object" /> del isultato.</para}>
      <param naee="arguments">Prorrketà"<see cref="P:SyStem.Linq.Exprgssionw.IndezExprssion.Argumends" +> del isqntatO.</parqm>
    =/member>
    <member n`me="T:Rystem.Linq.ExpRessiofs.InvocationExprussiol">*      quemary>Rappresgnta wn'aspresw)one che appliga un delegato0o un'esprEssinl% lcmbda a un elenco`da espression(Azgomento.</summcry>
    </meber>
    <member name}"P*System.Lioq.Expressions.Invocat/nExprescion.Argumenus">
      <Semmasy>Ottiene gli argo-enti a cui viene applIcato il delegao!o l'espessione nabd.</sum-ary>
      <veturjs>Cggetto <see crf="T:Rystem.C?llection.OcjectModel&RgafOnlyCollec|ioj`1" /> di oggetti <see crud="T:Systum.LiNq.Expsessions.E8preqs)on" /> che rappresentano gli rgOmgnti Ai quali viene aprlicato il delegato./reTurns:	*    /member>
  " <mebep nmm9"P:Sys|em.LinQ.Expressions.InvocationExpression.Expression">
      <summary>Ottiene il delegato o l'espressione lambda da applicare.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato da applicare.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Rappresenta un'etichetta che può essere inserita in qualsiasi contesto <see cref="T:System.Linq.Expressions.Expression" />.Se viene raggiunto, otterrà il valore fornito dal corrispondente <see cref="T:System.Linq.Expressions.GotoExpression" />.In caso contrario, riceve il valore in <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Se <see cref="T:System.Type" /> è uguale a System.Void, non deve essere fornito alcun valore.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Il valore di <see cref="T:System.Linq.Expressions.LabelExpression" /> quando l'etichetta viene raggiunta tramite flusso di controllo normale (ad esempio, non ci si è arrivati tramite un salto).</summary>
      <returns>Oggetto Expression che rappresenta il valore dell'oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale è associata questa etichetta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale è associata questa etichetta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="target">Proprietà <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> del risultato.</param>
      <param name="defaultValue">Proprietà <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Utilizzato per rappresentare la destinazione di un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Ottiene il nome dell'etichetta.</summary>
      <returns>Nome dell'etichetta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Il tipo di valore passato saltando all'etichetta (o <see cref="T:System.Void" /> se non deve essere passato alcun valore).</summary>
      <returns>L'oggetto <see cref="T:System.Type" /> che rappresenta il tipo di valore passato saltando all'etichetta, oppure <see cref="T:System.Void" /> se non deve essere passato alcun valore</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Descrive un'espressione lambda.Acquisisce un blocco di codice analogo a un corpo di metodo .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Ottiene il corpo dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo dell'espressione lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produce un delegato che rappresenta l'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Delegate" /> contenente la versione compilata dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Ottiene il nome dell'espressione lambda.</summary>
      <returns>Nome dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Ottiene i parametri dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresentano i parametri dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Ottiene il tipo di ritorno dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Ottiene il valore che indica se l'espressione lambda sarà compilata con l'ottimizzazione della chiamata tail.</summary>
      <returns>Vero se l'espressione lambda sarà compilata con l'ottimizzazione della chiamata tail; in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Rappresenta una chiamata al costruttore con un inizializzatore di raccolta.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se il nodo può essere ridotto, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Ottiene gli inizializzatori di elementi utilizzati per inizializzare una raccolta.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> che rappresentano gli elementi utilizzati per inizializzare la raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Ottiene l'espressione che contiene una chiamata al costruttore di un tipo di raccolta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore di un tipo di raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Riduce il nodo dell'espressione binaria a un'espressione più semplice.</summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="newExpression">Proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del risultato.</param>
      <param name="initializers">Proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Rappresenta un ciclo infinito.È possibile uscire con "interruzione."</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che costituisce il corpo del ciclo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che costituisce il corpo del ciclo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di interruzione.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come destinazione dell'istruzione di interruzione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di continuazione.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di continuazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="breakLabel">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del risultato.</param>
      <param name="continueLabel">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Rappresenta l'operazione di assegnazione per un campo o una proprietà di un oggetto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Ottiene l'espressione da assegnare al campo o alla proprietà.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il valore da assegnare al campo o alla proprietà.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fornisce la classe di base dalla quale derivano le classi che rappresentano le associazioni utilizzate per inizializzare i membri di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Ottiene il tipo di associazione rappresentato.</summary>
      <returns>Uno dei valori di <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Ottiene il campo o la proprietà da inizializzare.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> che rappresenta il campo o la proprietà da inizializzare.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Restituisce una rappresentazione testuale di <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Rappresentazione testuale di <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Descrive i tipi di associazione utilizzati negli oggetti <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Associazione che rappresenta l'inizializzazione di un membro con il valore di un'espressione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Associazione che rappresenta l'inizializzazione di un membro di tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> da un elenco di elementi.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Associazione che rappresenta l'inizializzazione ricorsiva dei membri di un membro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Rappresenta l'accesso a un campo o a una proprietà.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Ottiene l'oggetto contenitore del campo o della proprietà.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto contenitore del campo o della proprietà.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Ottiene il campo o la proprietà a cui accedere.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> che rappresenta il campo o la proprietà a cu accedere.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Rappresenta la chiamata a un costruttore e l'inizializzazione di uno o più membri del nuovo oggetto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Ottiene le associazioni che descrivono come inizializzare i membri dell'oggetto appena creato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> che descrivono come inizializzare i membri.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se il nodo può essere ridotto, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Ottiene l'espressione che rappresenta la chiamata al costruttore.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Riduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a un'espressione più semplice. </summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="newExpression">Proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del risultato.</param>
      <param name="bindings">Proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Rappresenta l'inizializzazione degli elementi di un membro di raccolta di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Ottiene gli inizializzatori di elemento per l'inizializzazione di un membro di raccolta di un oggetto appena creato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> con cui inizializzare un membro di raccolta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="initializers">Proprietà <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Rappresenta l'inizializzazione dei membri di un membro di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Ottiene le associazioni che descrivono come inizializzare i membri di un membro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> che descrivono come inizializzare i membri del membro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="bindings">Proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Rappresenta una chiamata a un metodo statico o di istanza.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Ottiene una raccolta di espressioni che rappresentano gli argomenti del metodo chiamato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del metodo chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Ottiene l'oggetto <see cref="T:System.Reflection.MethodInfo" /> per il metodo da chiamare.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'istanza per le chiamate ai metodi di istanza oppure null per le chiamate ai metodi statici.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto ricevente del metodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="object">Proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Rappresenta la creazione di una nuova matrice e la possibile inizializzazione degli elementi della nuova matrice.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Ottiene i limiti della matrice se il valore della proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> o i valori per inizializzare gli elementi della nuova matrice se il valore della proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano i limiti della matrice o i valori di inizializzazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expressions">Proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Rappresenta una chiamata a un costruttore.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Ottiene gli argomenti del costruttore.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Ottiene il costruttore chiamato.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> che rappresenta il costruttore chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Ottiene i membri che possono recuperare i valori dei campi inizializzati con gli argomenti del costruttore.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri che possono recuperare i valori dei campi inizializzati con gli argomenti del costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Rappresenta un'espressione del parametro denominato.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica che questo ParameterExpression deve essere trattato come un parametro ByRef.</summary>
      <returns>True se questo oggetto ParameterExpression è un parametro ByRef. In caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Ottiene il nome del parametro o della variabile.</summary>
      <returns>
        <see cref="T:System.String" /> che contiene il nome del parametro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Un'espressione che fornisce autorizzazione di lettura e scrittura per le variabili al runtime.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="variables">Proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del risultato.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Le variabili o parametri alle quali fornire accesso al runtime.</summary>
      <returns>La raccolta di sola lettura che contiene i parametri a cui sarà forniti l'accesso al runtime.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Rappresenta un case di un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Ottiene il corpo di questo case.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo di un blocco case.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Ottiene i valori di questo case.Questo case viene selezionato per l'esecuzione quando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> corrisponde a qualsiasi valore.</summary>
      <returns>La raccolta di sola lettura dei valori per questo blocco case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="testValues">Proprietà <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Rappresenta un'espressione di controllo che gestisce più selezioni passando il controllo a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Ottiene la raccolta di oggetti <see cref="T:System.Linq.Expressions.SwitchCase" /> per l'opzione.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Ottiene il metodo di confronto di uguaglianze, se presente.</summary>
      <returns>Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di confronto di uguaglianze.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Ottiene il test per lo switch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test per lo switch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Ottiene il test per lo switch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test per lo switch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="switchValue">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del risultato.</param>
      <param name="cases">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del risultato.</param>
      <param name="defaultBody">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Archivia le informazioni necessarie per generare informazioni sui simboli del debug per un file di origine, in particolare il nome file e l'identificatore del linguaggio univoco.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Restituisce l'identificatore univoco del tipo di documento, se presente.Imposta come valore predefinito a GUID per un file di testo.</summary>
      <returns>Identificatore univoco del tipo di documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nome del file di origine.</summary>
      <returns>Stringa che rappresenta il nome del file di origine.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Restituisce l'identificatore univoco del linguaggio, se presente.</summary>
      <returns>Identificatore univoco del linguaggio</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Restituisce l'identificatore univoco del fornitore del linguaggio, se presente.</summary>
      <returns>Identificatore univoco del fornitore del linguaggio.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Rappresenta un blocco try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del blocco try.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del blocco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Ottiene la raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> associate al blocco try.</summary>
      <returns>Raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> associate al blocco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del risultato.</param>
      <param name="handlers">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del risultato.</param>
      <param name="finally">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del risultato.</param>
      <param name="fault">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Rappresenta un'operazione tra un'espressione e un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Ottiene l'operando dell'espressione di un'operazione di test del tipo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando dell'espressione di un'operazione di test del tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Ottiene l'operando del tipo di un'operazione di test del tipo.</summary>
      <returns>
        <see cref="T:System.Type" /> che rappresenta l'operando del tipo di un'operazione di test del tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Rappresenta un'espressione che ha un operatore unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se un nodo può essere ridotto, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore.</summary>
      <returns>true se il nodo rappresenta una chiamata elevata; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore il cui tipo restituito è elevato a un tipo nullable.</summary>
      <returns>true se il tipo restituito dell'operatore è elevato a un tipo nullable; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Ottiene il metodo di implementazione per l'operazione unaria.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Ottiene l'operando dell'operazione unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando dell'operazione unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Riduce il nodo dell'espressione a un'espressione più semplice. </summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="operand">Proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del risultato.</param>
    </member>
  </members>
</doc>