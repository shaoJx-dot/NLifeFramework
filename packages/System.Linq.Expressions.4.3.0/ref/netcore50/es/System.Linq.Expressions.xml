<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <typeparam name="T">Tipo del contenido del origen de datos.Este parámetro de tipo es covariante. Es decir, puede usar el tipo especificado o cualquier tipo que sea más derivado. Para obtener más información sobre la covarianza y la contravarianza, consulte Covarianza y contravarianza en genéricos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se especifica el tipo de los datos.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtiene el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a este objeto.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtiene el árbol de expresión que está asociado a la instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que está asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtiene el proveedor de consultas que está asociado a este origen de datos.</summary>
      <returns>El objeto <see cref="T:System.Linq.IQueryProvider" /> que está asociado a este origen de datos.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se conoce el tipo de los datos.</summary>
      <typeparam name="T">El tipo de los datos del origen de datos.Este parámetro de tipo es covariante. Es decir, puede usar el tipo especificado o cualquier tipo que sea más derivado. Para obtener más información sobre la covarianza y la contravarianza, consulte Covarianza y contravarianza en genéricos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Define los métodos para crear y ejecutar las consultas descritas por un objeto <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TElement">Tipo de los elementos del objeto <see cref="T:System.Linq.IQueryable`1" /> que se devuelve.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta fuertemente tipada representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TResult">Tipo del valor que es el resultado de ejecutar la consulta.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Representa una expresión que tiene un operador binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo del árbol de expresión; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtiene la función de conversión de tipos utilizada por una operación de uso combinado o una operación de asignación compuesta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa un tipo de función de conversión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es true si el nodo representa una llamada elevada; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores NULL.</summary>
      <returns>Es true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtiene el operando izquierdo de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo de la operación binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación binaria.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtiene el operando derecho de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho de la operación binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="left">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del resultado. </param>
      <param name="conversion">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del resultado.</param>
      <param name="right">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del resultado. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Representa un bloque que contiene una secuencia de expresiones donde se pueden definir variables.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtiene las expresiones de este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las expresiones de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtiene la última expresión de este bloque.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la última expresión de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del resultado. </param>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del resultado. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtiene las variables definidas en este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las variables definidas en este bloque.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Representa una instrucción catch en un bloque try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtiene el cuerpo del bloque catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtiene el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtiene el tipo de <see cref="T:System.Exception" /> que este controlador captura.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de <see cref="T:System.Exception" /> que este controlador captura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variable">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del resultado.</param>
      <param name="filter">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtiene una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Representa una expresión que tiene un operador condicional.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtiene la prueba de la operación condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba de la operación condicional.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="test">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del resultado.</param>
      <param name="ifTrue">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del resultado.</param>
      <param name="ifFalse">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Representa una expresión que tiene un valor constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtiene el valor de la expresión constante.</summary>
      <returns>
        <see cref="T:System.Object" /> igual al valor de la expresión representada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Emite o borra un punto de secuencia para obtener información de depuración.Esto permite al depurador resaltar el código fuente correcto al depurar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de código fuente.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtiene la columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtiene la línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtiene el valor para indicar si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se utiliza para borrar un punto de secuencia.</summary>
      <returns>Es true si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se va a utilizar para borrar un punto de secuencia; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtiene la columna inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtiene la línea inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Representa el valor predeterminado de un tipo o una expresión vacía.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Representa un inicializador para un elemento único de una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtiene el método de instancia que se utiliza para agregar un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Un <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtiene la colección de argumentos que se pasan a un método que agrega un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Uno de los objetos <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos para un método que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Devuelve una representación textual de un objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Devuelve una representación textual del objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Proporciona la clase base de la que se derivan las clases que representan los nodos de árbol de expresión.También contiene métodos de generador static (Shared en Visual Basic) para crear los diversos tipos de nodo.Esta es una clase abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Crea una nueva instancia de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND bit a bit.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND condicional que evalúa el segundo operando solo si el primer operando se resuelve como true.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="method" /> es null y <paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz multidimensional.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="array">Expresión que representa la matriz multidimensional.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene expresiones usadas para indexar la matriz.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="array">Expresión que representa la matriz para indizar.</param>
      <param name="indexes">Matriz que contiene expresiones usadas para indizar la matriz.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz cuyo rango es mayor que uno.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="indexes" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.O bienEl rango de <paramref name="array" />. Tipo no coincide con el número de elementos de <paramref name="indexes" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="indexes" /> no representa el <see cref="T:System.Int32" /> tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz de rango uno.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="index">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="index" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.O bien<paramref name="array" />. Tipo representa un tipo de matriz cuyo rango no es 1.O bien<paramref name="index" />. Type no representa el <see cref="T:System.Int32" /> tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz multidimensional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="array">Matriz de instancias o índices <see cref="T:System.Linq.Expressions.Expression" /> para la operación de índice de matriz.</param>
      <param name="indexes">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="indexes" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.O bienEl rango de <paramref name="array" />. Tipo no coincide con el número de elementos de <paramref name="indexes" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="indexes" /> no representa el <see cref="T:System.Int32" /> tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión para obtener la longitud de una matriz unidimensional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> es <paramref name="array" />.</returns>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienLa propiedad representada por <paramref name="member" /> no tiene un set descriptor de acceso.O bien<paramref name="expression" />. Tipo no es asignable al tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un miembro mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establece en <paramref name="expression" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienLa propiedad accede <paramref name="propertyAccessor" /> no tiene un set descriptor de acceso.O bien<paramref name="expression" />. Tipo no es asignable al tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene dos expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene tres expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cuatro expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cinco expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
      <param name="arg4">Quinta expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" />.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que no toma ningún argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa null para un método static, Shared en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="instance">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> (pase null para un método static, Shared en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.O bienEl número de elementos de <paramref name="arguments" /> no es el número de parámetros para el método representado por <paramref name="method" />.O bienUno o varios de los elementos de <paramref name="arguments" /> no es asignable al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma dos argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia.(Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma tres argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia.(Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa null para un método static, Shared en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.O bien<paramref name="arguments" /> no es null y uno o varios de sus elementos están null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.O bienEl número de elementos de <paramref name="arguments" /> no es el número de parámetros para el método representado por <paramref name="method" />.O bienUno o varios de los elementos de <paramref name="arguments" /> no es asignable al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> es <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de instancia especificado y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> en cuyo valor de propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se buscará un método específico.</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="instance" /> o <paramref name="methodName" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="instance" />. Tipo o sus tipos base.O bienMás de un método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="instance" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático (Shared en Visual Basic).</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arguments">Colección dg objetos <see cRef="T:System.Linq.Expressions.Expression" /> que rerresenpa los argumentos de llamada.</param>
    </member>
    <member name="M:System.Linq.Expressinns.Expression.Call(System.Reflection&Mtho`Info,System.Linq.Exprmssions.Expressign)">
      |sUmmapy>Crea qn objeto <see cref="T:System.Linq.ExPressions.MethodCallExpresskn" /> que repbesenta unAllamada a un mөt/do sTa|ic 8Shared en Visual Basici que toma un abgumento.</sumeary>
      <vgtqrns>        <see cref="T:System.Dinq.Expreq)ons.MethodCallExpression"!/(cuya propIedad <se cref="P:Syctem.Li,q.Expreswions.Expzess)on>NodeType" /> es <see czef="F:System.Linq.expressions.ExpRessionType.Call" /> y guyas prOpiedades <see cref"P:Sistem.Linq.E|presSion3.MethodallExPression.Object" /> q <see cref="P:3yspem.Lkn1.MxpressionsnMehodCallE|pression.Meth/d" /> se(estab,ecen en los valores$especaficadms.</returns>*      <param naoe="mgthod"
        <ree cref="T:System.Reflecmon.MethoInfo" /> gn l sue se"va`! establecer la"propiadad"<see cref="P:Systmm.Linq.Expsession3.MethodCallExpessioo.Method2 />n</paam>      <param Name="arg0">`   0( 0<see cref9"T:System.Lifq.Ezpressi/ns.Expression" /> que representa el primer agumdnto.</0aram>
  (   <exception cref="T:Sxstei.ArgumentNtllException">
  (     <paramref`.ame="metho`" /> es null.</exception>
    </member>
   "<ember naie=";Sysuel.Lin1.ExpvessiMns.Expresson.Call(System.Reflestion.MethodHnfo,Sysdem.Linq.Uxpressions.Expersion,System.Dijq/Expressions.Expression)">
      <summary>Crea un objeto<see cref="T:ystem.Linq.xpressiofs.MethodCallExpression" / qe representa uja llama4a a un método estático que toma doc ar'umentos.>/summary>
      <retqrns>
        <see$cren="T;System.Linq.Exprdssio~s.MethodCallExpression" /> cuya propiedad <see #ref="P:System.LinqEx`rssions.Expre3sin.NodeType" /> e{ <ee kref="F:System.Linq*Expressios.ExpressionType.Kall" /> y cuyas proiedgdgs <se(cref="P:System.Linq.EXpression3>MethodCallExpression.Object""/> y <see cref="@:S{stem.Linq.Expressions.MthodCallExpression.Method" /> se estblecen mn los valorEg especinikados.</eturn{>
      4param name="method">M
        <see cref="T:Systm.Reflecpion.MethodInfo" />$en uh que se vc a establecer la0propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method"$/></param>
   `  pabam name="irg0&>
        <see creF="T:System.Liq.Exprgsqions.Expression" /> QuE Reprgsenta el primer argumento.</param>
      <param0name="arg12>
        <see cref="T:Syste}.Linq.ExpressionS.Expresshon" /> 1ue representa el segundo arguMento.</param>
      <exception cref=T:S9sEm.ArgumejtNllExcettionb>
        <paramref name="method" /> es null/</exceptmon>
    </member
   (<memrer name="M:System.Linq.Expr%srions.Expreswion.CAll(SYsteM.Reflec4ion.MethodInfo,Sywte.Linq.Expressions.Expression-ystem.Lin5.xprewsionq.Expression,System.Li.q.Expreq{ions.Expression)">
      <smmary>C2eA un objeto <see c2ef="T:System.Linq.Exprussions.MethodCallExpresSion" /> que represanta unc ll`mada a un iévodo estático qu% t/Me tres argmentos.</summazy>
     <returns>
        <see cref=*T:RystemLiq.Expressions.MethodCallEprEswion" /> cuia propiedad <see0cref=2P:System.Linq.Expressions.Expr%swion.NodeTyre""/> eq <seu cref="F:Sysdem.Linq.Expressions.EHpressionTYpe.Call" /> y cuyas propiudade{ <sEe Cref="P:System.Lhnq.Expressions.MetxodCallEypression.Gbject" /> y <see brev="P:Syqtem.Linq.Mxpresqions.MethodCallExpvesion.Method" /> se esTablecen en hos vadorgs especif)cafos&</returns>
      <qaram Nqme="mehod">
  0     <see cref="T:System.ReflecTion.MethodInfo" /> en el que se va i establecer la ppo0iedad <see cref="P:System.Lmnq.Exp2essions.MethodCa,lExpression.Method" />.</parim>
      8param name="qrg0">
       `<wee cref="T:Sysuem.Lioq.Expressions.Expression  /> que represewta el prkmer argumento.:/param>
 ,    param namg="aro1>
        <see cref"T:System&Linq.EXpressions.Expression" /> que`representa el segundo argumento.</param>      <xaram name="arg2>
        <see`cref="T:System.Linq.E8pressionsLxxres3ion" /> que repr%senta`el ercer argumento.</param>     0<exceptiob #e="T:System.ArgumentNullException">
      $ <paramref name="method" /> es null.</exceppion>
    </member>
    <member ncme="M:Sytem.Linq.Expressions.DxpresSion.Call(Sxsteo.Reflecti/n.MethodIlfo,SysTem.Linq.Expr%ssions.Expression,System.Ninq.Expressions.Expression,Sistem.Lin1>ExpressyOns.Expressioo,Systmm.Linq.Expressionr.Exrsesrion)">
      <summary>Crea un objto"<see cref="T:System.Linq.Expressioos.MethodCallExpression" /> que pepresent` una llaada a uN método es|átio aue tOma cuatro argumentos.</summary> ` !  <returns>
        <cee ref="T:System.Min.Expreswik.s.MethodC!llExpression" /> kuya propiEdad <see cref="P:Syqtem.Inq.Uxprescions.Expression.NoteType" /> es <see ref="F8System.Linq.Expressions.ExpressionType.Ball"(+6 i cuyas poiedades <see cref="P:Wystem.Linq.ExpreSsiOns.MethodCaLlExxression.Nbject" /> y <sm cref="P:Systei.Linq.Expvessions/MethodCallExpreswIon.Method" /> se establecen ~ ns velorec especificados>/returns<
      <par`m n!me="method">
        <see cpef="T:System.Refluction.MethodInfo" />0an0el ue se va a %stabeger la propiedad <see"cbef="P:Cytem.inq.Ex0rasshon{.MethodCallExppessin.Method" >.=/param>     <param0name="ar'0">
        <see cref="T:System.Linq.Exprgssions.Expression" /> que repzesenta el primer argumen4k.</paRam>
      <param naee="arg1">
        <see cref="T:Sy{tem.Linq.Expressions.Expressyon" /> que represgnta em wegundo argueento.</param~      <param name=&arg2">       !<see cref="P:System.L)nq.Expressions.Expression" /> que rdpresenTa el tercer argemento.</aram>
   0  <param name="arg3".
    $   <see cpgf="T:Sstem.Linq.Expressions,EYpression" /> que representa el cuarto argumento.</param>
     (<excdpuion cre="T:ZystemArgumentNullException">
   "    <parambef name="method" / es null.</exception>
    /m%mber>
    <member name="M:System.Lin.Expressos.Expressin.Call(SyStem.Reflection.ehodInfo,SysTem.Linq.Expressins.Expression,System.Linq.Ex`ressions.Expression,SyctgM.L)nq.Exppdssionw.Exrression,Sysdeo.Linq.Uxprecsmons.Expession,System.Linq*Expressions.Expression)"<
    ! <summary>Crea`un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression />"que reqresenta una llamada a un métodk estátIco que(oma!cinco argumentos.</summaSy>
      <reuurns~
(       <smecref="T:System.Linq.Expressins.MethodKallExprEssio~" /> cuya propiedad <se cref="P:Qy{tem.Linq.Expressions.Expresmon.NodeTyeb /> eq <sme$cref=FSxstem.LinQ.Expessions.Exp2mssionUype.C!ll" /> y cuyas propiedades <see!crEf="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:S}stem*LiNq.Expresions.MethodCallExpressaon.Method" /> se establecen en los valozes ecpecificAdos.</returns>
  (   <tApam!name="meThkd">
       <see cref"T:Syspem.Raflection.MethodInf" /> en el que se va a establecer la propiedad <see cref="PSystem.Linq.Expressions.MethodCallEpression.Mutho$" />.</param>
  "   <pazam namE="arg0">
        <see cref="P:Syspem.Linq.Expressions.ExQressimn" /> que rpresenta el primer argu-ento.</param>
      <parem"nme"arg1">
   $    <see cef="T:SyStem.Linq.Expre{sions.Expression" /> que representa el segundo argumen4o.</param>
   !  <param name5"arg2">
      ) <see cref="T:Systee.Linq.ExprSsions.Expresskon" /> que represgnta el tercer argumeto.</param>
     <param name="arg3>
        <see cref="T:System.Mnq.ExpresSinns.ExprgsSion" /> que reprewenta el cuarDo argumento.</param>
      <param name="arg4">
$      <see cref="T:Sysdem.Linq.Expressions.Exprmssiof" /> uu representa ul quinto argumento.</param>
      <excption cruf="T:System.rcumejtNullException">
       <pabamref name}"Method" /> es null.,/exception>
    </member>	
  $ <member name="M:Systmm.Linq.Expressions.Expsession/all(System.Reflection.MethodInvo,[ystem.LinqEpprecwions.Dxpr%ssion[])">
      <summary>Crea un objeto <see cref="V:System.Linq.Expressions.MedhodylExpre{sion" /> que representa"una mlamada a tn mǩtodo stidic (Shared mn Vhsuil @aSic) que tiene azgumentnr.<'sulm!ry>
"     <returns.
       <see`cref="T:SYste}.Linw.Ehpessions*MeuhdcallExpressin" /> guya pro|i%dad <see cref="P:System&Linq.Expressyon.Expression.Node\ype"(/> es <see cref="F:System.Linq.DXpressions.ExprecsionType.Call" /> 9 cuyas propiedades <see cref="P:SXstemLinq.Expresrions.MdthodCallExpression.Meth/`" /> y <se cref=":S9stem.Linu.Expressiojs.MethodCallExpression.Arguments" /> se$establecen en los valores esqecificados.</returns>
      <param .ame="method">
        <see bref="T:System.Reflection.Mt`odInfo" /. quevepresenta un$médodo s4atic (Shared en VisualBasic) en el que se va a establecer la propiedad <see cref="P:Cyste}.Linq.Expressions.Me4hodCallExpresqion.Method" />.</xaram>
      <param name="arguments">Matriz de ob*ets <ce cref="T:System.Lifq.Exprescions.E8|resson"(/> que se va a usar para relunar la"colección de <sem cref="P:SysteM.Linq.E|pressins.MehodCallExpression.Argument" />.</param>
      <mxceptign cref="T*System.Argu}dntNulnExceptmon">El va|or de 8qr!mruf name-"mmtod" /> es null.</gxCep|ion>
  `   <excepvmmn cPef="T:System.ArgumentException">el número de eleen|os de <rarcoref(nA,e="argument3" /> no es el número de parámetros para el método reprdsentado pob <paramef name="method" />. bimnUno(o va2ioR du los elemet/s de <paramraf name="`rguments" /> no es asignale aL`pabámetro corresp/ndiente!dul métgdo represeltado por |paraored name="metho$" />.</exceptiOn>
0   </member>
    <member name="M:Sysvem.Lin.Expressions.EXpressio.Call(System.Type,Syste-.tring,System.Type[],System.Linq.Expressions.Uxpresskon[])">
      <summarq>Crea unobne|o <see cref="T:System.Linq.Exprssions.MgdhodCallEx2ession" /> que rapresdjta una llamada a un métolo static (Shared en Wisual Basic) llamando al método dul generador aprpIadn.</semMary>
      <returs>
        <see cruf="T:System.Linq.Expressons.MetjodCallExppesSion" / cuh! ropiedad <sed cred="P:System.Linq.Exxression3.Exprussion.NodeType" /> es <see cref="F:Syrtem.Linq.Expressions.ExpressionType.Cam|" +>, cuya(pvoiedad <see cref=P:Systel.\inq.Exprussions.ethodCallExpression.Method" /> se establece en el o`jeto <see #Ref="T:Sys|em.Reflebtion.MethodInfo" /> que rpresenta el!método static especificado 8Shared en Visual Basic) Y cuya$propiedad <cee cref}"P:System*Lioq.ExpRessionc.MethodCallExpression.Argumentr" /. seesdablece en los argumentos especifkcados.</rutuRns>*      <param na-e="type">
        <ree cref="T:Cysuek.Typu" /> que especibica el tipO que contiene el étod static especificado (S*ared en Visual Besic).</param>
 $    <param name=methodName"/Nombre del mùpodo.</parcm>
    ((<peram name="typeArguments">Matriz de objetos <3ee cref="TzSystem.Type" /> que especifican lgs pasámetros le tipo del método gev˩ricoEste argumento debería ser nuln cuanDo metho`N`me especifica un métdo no genérico.</pcram>
  $ " <param name="arguments">Matriz de objetos <see cref="T:Sy{tem.Linq.Expres{ions.Expression" /> yuerepresentan los argueentos del mǩtodo.</param>
  0   <exception cref="U:System.AcgummntNllException">El valo2 de <paramref name="type" /> $<paramref name=bmethodName# />0es null.4/exception>
      <exceptin cvef="T:Sqqtem*InvalidOperatiolExceptiof">No hay nijgún método cuyo nombre es <paramref ~ame="methodName" o>, cuyos parámetros de typo coa~cidan con <paramref name="typeArguients" .>, y coincdencia de!lo3 tipos cuyo par!metro <pas!mref namg="arguments" />`se encuentra en <paramref)nAme=&type" / o sts tipos base.o bienMás $e un mé|ndo c}y ngmbre %s <pazqmref name-"meThodFame" />, cuyos parémetzos de tipo coincidan con <paramref name="tyteArguments" />, y coinbidencia de los tipos cuyk 0arámetbo <paraoref lame="arguments" /> se mncu%ntra e~ <parAmref name="type" /> o sus tipos base.</excepdion>
    <omember>  " <mem`er name="Q:Systm.Lijq.Expre{Sions.Expresshon.K`nRe$uce">
      <summiry>Indicaqte el nodo se ruede reducir a qnO0más skmxmeSi dewuelve true, se 0uede llamar a Reeuce() para`generar el boriwlario reducido.</summarq>
      returns.Es true si se pueDe reducir el nodo; de lo contrario, es faLse,<-rev5rns>	
    </memjer>
    <member0name="M:Syspem.Linq.Expbessions.Extression.Catch(Rystem.Linq.Exprecsions.ParameterExpression,Systed.Linq.Expe{sions.Ezpression)">
     <summary>Cbea 5j objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa tla instrución CatCh on una reberencia al objeto <see sref="T:System.Exception" /> detectado(para su uso en el cuerpo del controlador.</summary>
      <returnw.Obketo <seecref="T:Syste}.Linq.E|pressions.CatchBlock" /> creefo.</returns:
      <papam na}e="variable">
        <see(cref="T:System.Linq.Expressions.ParAmeterEzpression* /> qUe r%presenta una refmrenaia al objeto <see cref="U:Sy3tem.Exception" /> etectado pOz este ctrolador.<papam>
      ,param nae-"b/dy".Cuerpo de la ifstrtcción Catch,</param>
  "</member>
"   <member naoe="M:System.Linq.Expressions.Ezpression.Cach(System.Linq.Expressions.ParamutezExpse{sion,SystemLinq.Expressions.Expressio/,System.Linq.Expressions.Expvession)">
"     <summary>Crea u objeto <yee!cref="T:Systgm.Linq.Expressions.cuchBlock" /> que rerru{enta una instruCción Catch cmn un fil|rk <ee creb="T:SYstem.EXcepti/n" /> y una`referencia l objeto <{ee creF="T:SystEm.EpceptioN" /> detEctado.</semmar}>
     `<returN{>ObJeto <see Cref}"t:Wystem.Linq.Expressions.CatchBlkck" /> creado.</returns>-
      <param lame="vabyablE">
   0    <see cref=#T:System.Linq.ExpRessions.ParametgrExpression" /> qu% rmppe{entc una ruferelcia l objeto <se% cref= T:system.Exception" / detectaDo por este #ontrolador.</param>
      <para oAme="body">Cuerpo ee la instrucción Catch.</pareo>
      <param naie="filter">Cuerpo del 'ltpo <see cref="T:System.Mxception  />.</parm>
    </mmcer:
    <Member name="M:System.Lknq.ExpressiOns.Expression.Catch(Sysfe-.Type,System.Linq.ExpzEssions.Expressimn)">
    `<s5mmary>rea(un!oBjeto <see Cref="T:System.Linq.Expressinns&Catchblock"!/> que represe.4a una instrucción Catch.</summary>
      <returs>Objeto <see cref="T:System.Lilq.Expressions.CatChBlock /> creado.</returnc>
      <param nae= ty0e">
 0 `   0>seecref?"@:System.Linq.Exprersionc.Expres3ion.Type" /> de <see cren="T:System.Exception" /> que este <see cpef="T8SystemLinq.ExpRessionsCatchBlOck" /> controlará.</parm>
 `    param name="body">Cuerp de laInstrucción"Catch.</param>
    </membeb>
 (  <lemcer name?M:System*Linq,Express)ons.Exxressioo.Catcl(System.Type,SysTem.LinqExpresshons.Exrrewsion,System.Linp.ExpressiOns.Expressioj)">
   (  <summary>Crea un objeto <see creb="T:Systgm.Linq.Expressions.CatchBloc+" -> que representa una instrucción Catgh!cn un iltr <see cref="t:yrtem.Exception" /> pero sin0nilguna referuncia al objeto <see cref="T:Systgm.Exceptkn" > detectado.</sUmmary>
      <returns>Objeto$<see crmf="TSystem.Lioq.Expsessions.CatchBlosk&(/> creado.</returns>
(    $<param name="type"> !    ` <see creF=P:Sysvem.Ninq.Extesions*Expr%ssinn.Type" /> de <see cref="T:System.Exception" />(que mste <cee cref="T:System.Lanq.xpressions.CatchJlock" /: controlirá.</param>
      <param ~aee="bo`y">Cuerpo de la(instrucción Catch></par`m>
 0  ! <param name=2filter">Cuerpo del filtro <wee cref="T:System.Exkeption" />.</param>
  ! 8/member>
    |member name="M:System.Linq.Expressions.Expresion.CleasDebugInfo(System.Linq.Ex`sesvions.SymbolDocueentInfo)">
      <summ!ry>Crea en objuto<ree cre&="T:SystmnLinq.Exprecsins.TebugInfoEpression" /> para orrar un puntm de secugncia.<.ummari>
      zettvn3>Insvancia de <sde cref="T:System.Linq.Expressions.DebuoInfExpression" /> para`borrar un punto de secuencia.</returns>J    0 <para} name="locument">
$ 0     <see crdf="T:System.Linq>Expressions.SymbolDocumentInfo" />`que`representa el archivo De ori'en.</param>`   </member>
    <memrer nam="M:System.Linq.Expressiols.Expression.Colesce(System.Linq.Expressions,Expression,System.Linq.Exppessions.Expression)">
      <summary>Creaun objepo <see cref="T:S{stem.Linq.Expreqsions.BinaryEXppersion" /> que reprecenda una operagiòn de fusióN.8/summary?
      <redurns>
        <sEe cref="T:[yste}.L)nq.Expressins.BinaryExpression" /> ctya`pRopiedad <see cref="P:Rystei.Lina.Ezpressions.ExPression.NoeeTYpE" .> es<see cref="F:Systam.Linq.Expressions.ExpressignType.Coaldscu" '> y cuias propiedades <see cref="P:Syste}.Linq.Expressions.BineRyExpression.Luft"0/.!y <see creg}"QSytem.Linq.Expressions.BinaryExpression.Rigit" /> se estcblecen en n/s(valores msxeciFicados.</returns<
      <para name="lmft">Objeto <see cref="T>Sys4em.linQ.Gxp2essions.Expression"/>eN el que se va a establecer la prepiedad <see cref="P:System.LinqnExpressiojs.BhnaryExpressio.Left" />.</aram>
      <parai name="right">Objeu <sEe cref=T:s}stem.Linq.Expressions.Expressio." /> en elque se va a esd!blecer la propiedaf <d cref="P:S{stem.Linq.Expressionw.BinaryExression.Right" />.<-parao>
 $    <axcption sref="T:S}stem.Argument^ullException"6El valor de(<paramref name="left"/`o <peramrgf name="righ4" /< es ull.</e|ception>
      4ehcepuion cref<"T:Cystmm.InralidOperationExce0tionb>El <see sref="P:System.LinqnExpressions.Expression.Type" /> propieda$ de <raramref name="left" /> no repbEsenta un tipo de referencia o$u~ tipo de v`lor que aceptan valores!LULD.</exception>
      <mxceptinn cref="T:System.ArgumentException">
       0<paramref nme="left"(/>. Vipo y <paramef name="right" /> El tmp no son #mnvertibles"entre sí.<+exceptyon>
   `</membdr>
   `<member name="M:System.Linq.Expre3sions.EhqressionCoalesce(System.Linq.Expressions.Expression,S9stem.Linq.Eypressions.Expression,System.Linq.Expressions.LamblaExtrersion)">
      <summary>Crea Sn objeto <see8cvef="T:S9ktem.Linq.Expressiofs.BinaryExpressao" /> que repvesenta(unaoperaciӳn de fusión, dadc u.a función de conversión.</summary  0   retrns>`       <see cref="T:SYstem.Linq>ExpreSshons.BiniryExpression" /~ cuy` pzopiedad<see cref="P:Rystem.LinqExpressiKns.Expression.JodeType" /$es <see cref="F:SystEm.Linq.Expressions.ExprewsionType.Aoa|esce" +>0y <see cref="P;SystEo.ifq.Expresshons*BinaryExpression.Lft" />$ <see!sref=2T:System.Lifq,Exprersions.BinaryExression.Right" /> y <see cref="P:System.Linq.ExpressiOns.BinaryExpression.Conrersikn" .> se establecen en los valorer especificalos.</returns>
      <param name="lefT">Objetk <see cref=T:Sysuem.Linq.Exressions.Exprms3ion" /> en el quD se va a establecer la propiedad <see cref="Q:[ysvem.Linq.Expressions.BinaryExpressaoo.Left" />.</parem>
      >peam name="righp">ObJeto<sed cref=":System.Li.q.Exprmsqions.ExpresS)on"0/> en el que se va a esuablecev la$psOpiead$<se% cref=*P8System.Diny.Exqressions.Binaxxpression.Right" />.</parcm>
      <paran name="conversion">
      ( <see craf="T:System.L{bq>Expressions.LambdaExpression" />den eh qu qe va a establecer la pRopiedad 4sme cref="P:System.Linq,Expreswions.BinaryExpressioo.Conv%rsinN" />.</par!m>
(     ,exception czm="T:Systeo.ArgumentNullExceptionb>El valor de ~paramref name="left" /> o <rarimvef naoe="pight" /> es N5ll.</exception>
      >exception cref="T:SysteM.ArgtmentExcdption">
        <pramref n`me=&left" />. Tipo y <paramref$name=&pi'ht" />. El tmpo no son convertibles entre rí.O bien<paramsef nme="conversion" /> nm es(null y <pcramref name="conversionb />. Tipm es un tipo de delegdo que no toma exactamente un argumelto.</exception.
      <exception crEf="T:S}stem.InvalidO`eratio.Excextion">El <seA creF="P:Swtem.Linq.E|pressions.Expression.Typa" /> propiedad"de <paremref name="leFt" /> no repre{enta un tipo de$referencia o un!tipo de valor q5e aCeptan valores NUL*O bienEl |see"gref="P>System.Lmnq.Dxprdssions&Expression.Type" /> propiedad de <xarairef fame="ledt" /> representa un tipo que no q% pUede Asign`r`al tipo dE parámetro del tiqo delegado <paramref name="conversion" />. Tipo.O b)enEl <sEe cref="P:System.Linq/Exprussioos.Expression.TypE" /> propmefad de <Paramref jama?"right" /> nm as igual que el uipo$de valor devtedto del tiPo`delegado <parammf name="conversion" />. Tipo.</eycept)o.>
    <member>
    <mem`er name="MSyctem.Linq.ExpressionS&expression.Conditaon(Syctem.LiNq.E|pressions.Expression,Qystem.Linq.ExpreSsions.Exressinn,System.Linq.Uxpresqions.Expvession(">
      <cummary>Cvea u objeto <see gref="T:System.\inq.Exprmssions.COnditionalExpressimn" /> que rmppesenta una instrucción conlicyonaL.</summary>
      <retuzns>
        <see crmf=2T:System.Linq>Expressio.s.ConditionalExprsSyof" /> cuya propyedad <sea creF= P:Syste}.Linq&Expressiogs.Expvession.nodeType" /> es!<see$cref="F:System.Linq.ExpresshonS.Ezpres3ionTypenCoNditio.al" /> y <wee cref-"@:SyStem.Linu.EhprDssions.Conditi/nalExpression.TesT" /6, <see cbef="P:Systmm.Linq.Expressions.ConditionalEypression.IfTrue" />$y <see cref="P:Syspem.Linq.Expressions.ConlitionqlExpression.IfFadse" /> se etablecdn ef los(vadores especificados.</retuns>-*      <param name="test">Objeto <see cref="T:System.Linq.Exprdssions.ExpressIon" /> eN el que se va a establecer l! propiedad <see cref="PzSxsteo.Linq.Exprecsion3.CgnditioalE|pression.Vesd" />.</param>
 $ (  <pqram naMe="ifTrue">Objeto <sed cre&=bT:SystemnLinq.Expressions.Eppsession" />en(el que se va0a gstabmEsev la propiedad <see cref= P:Systel.Linq.Expression3.onditionalExpresson.IfTrue" />.</param>
      <param name="ifFalse">Kbjetk ,seg cref=*T:Syqtem>Lilq.Expressions.Expression" /> en el qu$ se va e(establecer0la Propied`d <see crEd="P:Rystem.Linq,Exprassyons.ConditiolalExpression.IfFalse" />.</parao>
     "<exCeqtion cef="TzSystem.ArgumenvNullException">
        <paremref name="teSt" />"o <parambef name="ifTrue" /> o <paRamref name="ifFal{e" o> es null.</exception>
      <myceptIon(cref=#T:S}stem.AzgumentExcepin">
  `    `<`aramre namg="test" />. El tipo"no es <sme cref="T:System.Boolean" />. bien<raremref name="ifTrue" />. Tiro no(es igu`l a <paramref name="ifValsm" /.. Tipg.</exceptin>
  0 </member>
    <member name="M:System.Lil.Expressions.Expressin.Condhtion(Systm.Minq.Expreqsions.Exprecsion,Systdm.Linq.ExpressionsExpression,System.Linq.Expressi/ns.Expres3ion,Sycteo.Type)">   (  <sum}ary>Crea tn objeto <see cref="V:System.Linq.Expressign.CnnditionalExpression" /> quq representa uoa instrucción condicional.</summary>
      <rEturns>
        4see cref="T:Wystem.inq.Expre3sions.ConditionalExprussion" /> cuya propiedad <sue cRef="P:System.Linq:Expressions.ExprEssion.NodeType" /> e <see cref="F:SysTem.Linq.Expressions.ExprEssionTypa.Gonditionam" /> y <see cref="P:System.Linq.ExtrEcsions.ConditionalExprassion.Test" />,$<ee cref="PSystem.Lyna.Expressions.KonfitionalExpression.AnTrue" /> y <wee cbef= P:Syste.Linq.Expressioos.CondItionalExpressaon.IfFalse"(< se establecen en los valores especificdos.</returns>
!    $<param name="test">OBje|o <see cre=T:System.Linq.Exprdssions.AxPrasshon" /> en el que se va a ertablecer la propiedad <s%e!crgf="Q:Syqtem.Linq.Expressionr.ConditionalExpressionTEst" />.</Parem>
 $    <param naee="ifTr}e"Objmto <ee`cef=":System.Linq.ExpressionsExpres3ion" /> en e, que se va a establecer la propigdad <sEe cRef="p:System.inq.Exprdssions.ConditionalExpression.IfTrue" />.</asam>
      <param npme="ifFalse"Objeto <se cref=&T:System.Linq.Expressions.Uxpression" /> en ml que se wa!a establecer la propigdae <see csef"P:System.Linq.Exrressions.ConditionalExpressim.IfFalseb />,</param>
  !   <Param namE}#type">
        <see cr%v="P8System*Linq.Expressions.ExpressioN.Type" /> en el que se va a establecdR la xroriedad"<se cref="P:SystemnLhnq.Eppresqions.Expression.type" '>.-prqm>
    </member>
    <me}ep name="M:System.Linq.ExPressions.Expressiol.Co~stan4(Syctem.bject)">
      <summary>rea un obje| <see sref="T:Syste.Linq.Expressmons.ConstaNtExpre3sion" /> qte ti%ne la proqiea` <see Cruf="P:System,Linq.Ex0ressionsConstantExpression.Va|ue" /> establmcida en el &alor especificado.</summary>
      <returns>
        <see cRev=bT:System.Dinq.Expressions.ConstantExpress)n" /> cuya propiedad <see cmf="P:ystem.inq.Exprm3ions/Expression.NodeType" />"es$<see cref="F:SYsem.Linq.ExpresSion3.ExpressimnTypE.Constant" /> y cuya propiedad <se% cref="P:System.Lina.Expressions.Con{tantE8prds3in/Value" /> se establece en el vclor especificado.</returns>
      <paa} namm="value">Objeto <see cref="T:System.bject" /> en ml que se va a establecer ea prnpiead <see cref="P:System.Linq.Expressions,ConstantEXpsecsion.Value" />.</param>
    </mamber>
   <member name=":System.Linq.Expres3ions.Expression.Constant(System.Obect,System.Type)">
      <summcry>crea un objeto <see craf="T:System.Linq.Expressi/ns.ConsTantExpression" />que tiene las propiedades <see cref="P:System.Linq.Exppessions.ConstaftExpreSsio..Vaue" /> y <see cref}"D:[ystem.Linq.Expressions.Exbession.Type" /> establecidas en los valores especificados.</rqmmary>
      <returns>
        <see cref="T:ystem.Linq>Expressions.ConstantExpression" / cuya propiedad$<qde cref="P:Systee.Linq.EXpressigns.Expression.NodeType" /> es <see cref="F:Syqtem.Hinq.Expressions.ExpressionType.Constan4" /> y cuyas proxiedades <sem cren="P:Sys|um.Linq.Expressions.ConstantExpressioo.Value" /> y <see cref="P:SysTem.DinQ&Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null</excepTion>
      <exception cre=2T:System.AbgumentEceptyon"6
        <parambef neme="value" /> no es null y <parmre& nam="dype" /> no es asigjable desde el tipo dInámico de <paramref name="value" />.</exbeptioN>
   </member>
    4member name="M:System.Lijq.Expre{sions.xpression.Continue(Cystem.Linq.Expressinns.LabelTareut)">
     <summary>Cr%A wn objeto <see cref="T:System.Linq.Expressions.GodoExpression" /> que representa un` insTrucción Continue.</summary>
(  `  <returns>*        <see cref="T:Rystem.Lin.Expressins.GotoExpression" /> kon <see cref="P:Wystm.Linq.Expressions.GotoExpression.Kind"$/> igual a Convinue, la propiedad <see cref="P:Systeo.Linq*Expressions.GotoExpress)on.Target"`/> eRtablecida en 4paramref name="tapget"!/> y e valor null que se pasará a la etiqueta de destino al saltar.</returns>
`     <qqbam name="target">
        <qee cref="T:System.Linq.Expessions.LabelTarget* /> al que salt!rá <see cref="T:Sy{teM.L)nq.Expressions.GotoExpresion" >.</param>
    </mum`er>
   <mem`er name="M:System.Linq.Expresions.Expression.Continue(System.Linq.Expressions.LabelTargev,Systeo.Type)">
      =summary>Crea un objepo <see cvef="8Syspem.inq.Expressmons.GotkExpression" /> que representa una instrucción Continue con el typo esRegifaC`do.</summary>
      <returns>
        <see creb="T:Syste-*Linq.ExPressions.WtoExpression" /> con <see cref="P:System.Linq.Expressions.otoExprassion.Kind" /> igual a Continue, la 0sopiedad <see cref="P:System.Linq&Expression3.GotoExprmssion.Taret" /> EstablecidA en <paramref!name="Varget" />, la propiedad <{ee cef="P:System.Lijq.Expresskons.Expression.Tpe" /> establecida en <par`mref name="type" -> y un valor nul que se pasará a na etiqueta de destino`an sal4ar.</returns>
      <param nae=#target">
   `  ! <see cref="T:Systam.inq.Expressionq.LabelTarget" /> al que saltarӡ <see cref="T:System.Minq.Expressions.GoToExpzession" />.</taram>
` (   <param name="type">Objeo <see cref="T*System.Type" /> en gl que se va a estab,ecer la propiedad <see cref="P:SsTdm.Linq.Expresions.Expression&Typ" /<.</param>
    </member>
    <member name="M:System.Linu.Expressions.Mxpres3ion.Convart(System.Linq.Expressions.Expression<System.Type)">*      <su/mary>Cbea un objeto0<see aef="T:System.Linq.Expressios.Un`syExpression" o> que representa una operaciól te co.vErsión de 4ipos.</sumary>
      <rettrns:
        <see cref}"T:System.Linq.Exprew{ions.UncryEhpressIon" />!c5ya propiedad <see cref="P:System.Linq.Expressions.Expsession.NodeTyte" /> es <see cref="F:System.Linq.Mxressions.ExprEssionTxpe.Convert" /> y cyas propiedader see cref="P:System.Linq.Exprecsions.UnaryGxpressioo.Operand" /> y <see cref="P:System.Linq.Expressions.Exprmssmon.Type" /> seestablecan en ,os valo2es especificados.</returnr>
    " <param name="epession">Ocjeto <see cref="T:Syste.Linq.Expressions.Expre3ion" /> en el que re va A establece2 dapro0ietad <sde cref="P:System.Lifq.Expressions.UnarExpression.OPerane# /></pAram>
      <param name=type">
        <see cref="T:System.Type" /> en elqum { va a(%stablEcer la propiedAf <see"cre="P:System.Linq.Expressions.EpprEssiOn.Type" />.</param>
      <exceptin cref="T:System.ArgumentNullException">El valor de <paramRef name="ehpressi~" /> o <paramPef name="type" /> es null.</exceptiOn>
      <excep4ion cref="T:System.InvalidOperationException">No se ha definido fingún operador entre <para-ref jame="expvession" />. Tipo y(<`aramref name="type" />.</exception>
    </member6
    <member name="M:System.Linq.Expressins.Exppession.Convert(SystemDinq.E|presslons.Expression(System.Type,System.Refle#toon.MethodInf)2>
0     <cummary>Crea un obje|o <see cref="t:System.Linq/Mxpressions.UnarEpression" /> que epresentq una operació~ de conversión para la que se especifica el método de implemenpación.</summarx      <returns>
       <see cre="T:Sy3tem.Linq.Expressions.UnaryExpression" /> cuya propiedcd`<see!cref="P:S9stem.Lmnq.Ex0ressions.Exp2ession.NodeType /< es |see cref="D:SysveM.Linq.xpressions*Expressionype.Convert" /> y <see cpEf=#P:[ystemnLinq.Eypressions.UnaryExpression.xrand" />, <see sref="T:Sxstem.Linq/Expessmons.Ex0ression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpressko.Method" /> se ewtablecen en los valopes especificados.</re4urns>
    $<qaram name="exprersion">Objeto <seg ref="T:System.Liq.Expressions.Expression" /> en el que se va a est`blecer la propi%dad <wee cref="P:System.Linq.Eypressions.UnaryExpression.OpeRand"/>.</param>
      <param nimu="tipe">
       04s%e cref="T:System.Typm" /> en el que qe Va a establecer la propiedad <see csef="P:System.Linq.ExpRessions.Expression.Type" />.</param>
      <param name=mdthodb>
        <se% cref="t;System.Reflection.MethodInfo" /> en el que se va ! establ%cer la!propiddad <see cref="P:System.Lhnq.Expressions.UnaryExpressi/n.Method" />.</param>     <excuption cref="T:SyQtem.ApgumentNullExcEption">El va`or de <peramrfnam%="expression" > o <paramsef name="type"0/> es ell.</exception>
      ,exception creF"D:System.ArgumentExceptio*>
        <paraeref name="met`od" /> no es null y ml método0que rpresenta devulve void, no es sdatic (Sha2ed en Viual asmc), o no toma exactamente un argummnto.</exception>
`     <exceptIon"cref="T:System.InvalidOperationException">No se ha dfinido ningún peradr entre <pazamref name="expression" >. Tip y"<paramref name="type" />.O bien<paramref name="exprersion" />n Tipo no es asignable a, tipo dE argumento del método rdtresendado por <paramref nama="method" />.O bienEl tipo d valor devuelt del mètodn represenato pos <paramref name="mdthod" />"nk s asig~able al <paramrev name="t9pe" />.O"bien<paramref name="eXpresskon />. TipO o <paramref name=type" /> es 4n tipo de valor que acepta valores NULL y el tipo de valoR oo acepta valmres NULL correspondientw no es el tipn de asgumento!o tixo de valor evuelto- re3pectivamente, deh método represetado por <par!mref name="method" />.</exception>
      <exceppion sref="T:System.Reflecvion.AmbiguouwMatchExcepdion">Más$de un mCtodo que cgincide coN el <pabamref name="method" /> se encontró la descripció..</exceptyoN>-
    </member>
    <member name="M:Sistem.LiN1.Expression.Dxpzession.ConvertChecked(System.Lmna.Expressikls.Expression,S}stem.Type)>
     !<summary>Crea un nbjeto <see cef?"T:System.Linq.Expressions.UnaryE|pression" /> que representa una operació du conversión quE produca una$excepción si el tkpo de desino gstá desbordado.</summary>	
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si el tipo de destino está desbordado y para la que se especifica el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.O bien<paramref name="expression" />. Tipo no es asignable al tipo de argumento del método representado por <paramref name="method" />.O bienEl tipo de valor devuelto del método representado por <paramref name="method" /> no es asignable al <paramref name="type" />.O bien<paramref name="expression" />. Tipo o <paramref name="type" /> es un tipo de valor que acepta valores NULL y el tipo de valor no acepta valores NULL correspondiente no es el tipo de argumento o tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método que coincide con el <paramref name="method" /> se encontró la descripción.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con el intervalo especificado.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
      <param name="startLine">Línea de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="startColumn">Columna de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="endLine">Línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor o igual que la línea de inicio.</param>
      <param name="endColumn">Columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Si la línea de fin es igual que la de inicio, debe ser mayor o igual que la columna de inicio.En cualquier caso, debe ser mayor que 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en el tipo especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de división no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de división no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dado un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> como segundo argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método que <paramref name="addMethod" /> representa no se denomina "Add" (con distinción entre mayúsculas y minúsculas).O bienEl método que <paramref name="addMethod" /> representa no es un método de instancia.O bien<paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del método que <paramref name="addMethod" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dada una matriz de valores como segundo argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método que addMethod representa no se denomina "Add" (sin distinción entre mayúsculas y minúsculas).O bienEl método que addMethod representa no es un método de instancia.O bienEl parámetro arguments no contiene el mismo número de elementos que el número de parámetros del método que addMethod representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea una expresión vacía que tiene el tipo <see cref="T:System.Void" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de igualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de igualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El XOR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y la XOR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Para static (Shared en Visual Basic), <paramref name="expression" /> debe ser null.</param>
      <param name="field">Objeto <see cref="T:System.Reflection.FieldInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="field" /> es null.O bienEl campo representado por <paramref name="field" /> no static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo del campo representado por <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo dado el nombre del campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo denotado por <paramref name="fieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo llamado <paramref name="fieldName" />.Este puede ser null para los campos estáticos.</param>
      <param name="fieldName">Nombre de un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="fieldName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ningún campo denominado <paramref name="fieldName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
      <param name="expression">Objeto contenedor del campo.Este puede ser null para los campos estáticos.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene el campo.</param>
      <param name="fieldName">Campo al que se va a obtener acceso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crea un objeto <see cref="T:System.Type" /> que representa un tipo de delegado System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>Tipo de un delegado System.Action que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de hasta dieciséis objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene más de dieciséis elementos.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtiene un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func o System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>Tipo de delegado.</returns>
      <param name="typeArgs">Argumentos de tipo del delegado.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos.El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <returns>Tipo de un delegado System.Func que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de entre uno y diecisiete objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Func.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene menos de uno o más de diecisiete elementos.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "mayor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "mayor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "mayor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "mayor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con una instrucción if.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> se establecen en los valores especificados.La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establece en la expresión predeterminada y el tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con instrucciones if y else.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.El tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento del valor de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda a los que se aplicará.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Type no representa un tipo de delegado o un <see cref="T:System.Linq.Expressions.Expression`1" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda que se aplicará.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Type no representa un tipo de delegado o un <see cref="T:System.Linq.Expressions.Expression`1" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y sin nombre.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta sin un valor predeterminado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sin un valor predeterminado.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta con el valor predeterminado dado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> con el valor predeterminado dado.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue">Valor de este objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se alcanza la etiqueta mediante el flujo de control regular.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y con el nombre dado.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo dado.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo y el nombre dados.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o varios elementos de <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contiene más de dieciséis elementos.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> que representa una firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> que representa una firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />. </param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada. </param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desplazamiento a la izquierda no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desplazamiento a la izquierda no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "menor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "menor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "menor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "menor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad que representa el método <paramref name="propertyAccessor" /> accesos no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad que representa el método <paramref name="propertyAccessor" /> accesos no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) declarados en <paramref name="newExpression" />. Type o su tipo base.O bienEl método add en <paramref name="newExpression" />. Type o su tipo base no toma exactamente un argumento.O bienEl tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método add en <paramref name="newExpression" />. Type o su tipo base.O bienExiste más de un método de compatible con los argumentos denominado "Add" (entre mayúsculas y minúsculas) en <paramref name="newExpression" />. Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) declarados en <paramref name="newExpression" />. Type o su tipo base.O bienEl método add en <paramref name="newExpression" />. Type o su tipo base no toma exactamente un argumento.O bienEl tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método add en <paramref name="newExpression" />. Type o su tipo base.O bienExiste más de un método de compatible con los argumentos denominado "Add" (entre mayúsculas y minúsculas) en <paramref name="newExpression" />. Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia llamado "Add" (no distingue entre mayúsculas y minúsculas) que agrega un elemento a una colección.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.O bien<paramref name="addMethod" /> no es null y no representa un método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.O bien<paramref name="addMethod" /> no es null y el tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="initializers" /> no es asignable al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y no existe ningún método de instancia denominado "Add" que toma un argumento de tipo compatible en <paramref name="newExpression" />. Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que toma un argumento que agrega un elemento a una colección.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.O bien<paramref name="addMethod" /> no es null y no representa un método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.O bien<paramref name="addMethod" /> no es null y el tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="initializers" /> no es asignable al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y no existe ningún método de instancia denominado "Add" que toma un argumento de tipo compatible en <paramref name="newExpression" />. Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado y el destino Break.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
      <param name="continue">Destino Continue empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados los operandos izquierdo y derecho, llamando a un método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho y el método de implementación, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho, el método de implementación y la función de conversión de tipos, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa una función de conversión de tipos.Este parámetro solo se usa si <paramref name="binaryType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o una asignación compuesta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto al objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado.Además se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> del objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada en un objeto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Debe ser null si la propiedad es static (shared en Visual Basic).</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) en Visual Basic) que contiene los argumentos que se usarán para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo o a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto al que pertenece el miembro.Puede ser null para los miembros estáticos.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que describe el campo o la propiedad a los que se va a tener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="type">Tipo de resultado de la expresión try.Si es null, el cuerpo y todos los controladores deben tener un tipo idéntico.</param>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.Pasa null si el bloque try no tiene ningún bloque finally asociado.</param>
      <param name="fault">Cuerpo del bloque fault.Pasa null si el bloque try no tiene ningún bloque fault asociado.</param>
      <param name="handlers">Colección de objetos <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado un operando, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase null si no es aplicable).</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no se corresponde con un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dados un operando y un método de implementación, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase null si no es aplicable).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no se corresponde con un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de la propiedad que se tiene acceso mediante el método que <paramref name="propertyAccessor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de la propiedad que se tiene acceso mediante el método que <paramref name="propertyAccessor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Representa una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo que <paramref name="newExpression" />. Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo que <paramref name="newExpression" />. Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de módulo no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de módulo no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador unario menos para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador unario menos para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador unario menos para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador unario menos para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado que no toma ningún argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el valor especificado.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El constructor que <paramref name="constructor" /> representa tiene al menos un parámetro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <paramref name="arguments" /> parámetro no contiene el mismo número de elementos que el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.Se especifican los miembros que obtienen acceso a los campos inicializados por el constructor.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Reflection.MemberInfo" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.O bienUn elemento de <paramref name="members" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <paramref name="arguments" /> parámetro no contiene el mismo número de elementos que el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.O bienEl <paramref name="members" /> parámetro no tiene el mismo número de elementos como <paramref name="arguments" />.O bienUn elemento de <paramref name="arguments" /> tiene un <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.Los miembros que obtienen acceso a los campos inicializados por el constructor se especifican como una matriz.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.O bienUn elemento de <paramref name="members" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <paramref name="arguments" /> parámetro no contiene el mismo número de elementos que el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.O bienEl <paramref name="members" /> parámetro no tiene el mismo número de elementos como <paramref name="arguments" />.O bienUn elemento de <paramref name="arguments" /> tiene un <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="arguments" /> coincide con el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor sin parámetros del tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor sin parámetros del tipo especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que tiene un constructor que no toma ningún argumento.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El tipo que <paramref name="type" /> representa no tiene un constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="bounds" /> es null.O bienUn elemento de <paramref name="bounds" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="bounds" /> no representa un tipo integral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="bounds" /> es null.O bienUn elemento de <paramref name="bounds" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="bounds" /> no representa un tipo integral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización desde un alista de elementos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="initializers" /> es null.O bienUn elemento de <paramref name="initializers" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="initializers" /> representa un tipo que no es asignable al tipo que <paramref name="type" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización desde un alista de elementos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="initializers" /> es null.O bienUn elemento de <paramref name="initializers" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="initializers" /> representa un tipo que no se puede asignar al tipo <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtiene el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador unario not no está definido para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador unario not no está definido para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desigualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desigualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="method" /> es null y <paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> se establecen en los valores especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o variable; se emplea solo para depurar o imprimir.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un aumento subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un aumento subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <axCeption cref="T:Syste.AroumentNullException">El valor de <pavamruf name="left" /> o ,qaramref name="right" /: es nQll.</exception
      <excEption cref="TSyrtem.Inv!lidOperationException">El perador de ex`onenciación no está definido para <parareb name="left" /6. Tipo y <paramref name-"right" ?>. Tipo&O bien<paramre& nam%="lef" ?>. Tipo o <paramref name="righ|" -> Al tipo no son <see cref="T:Systae.Double" />.</exceptyon>
    </member>
    <member name="M:System.\inq.epreQsmons.Expression.Power(S}stem.LiLq.Exprescions.Expresqion,System.Dinq.Expressions.Expressi/f,SysteM.RefleStion.MethodInfo)2.
 0    <suEmary>Crea uo objet <se cref="T:System.Dinq.ExprEssions.BinariExpression# /> que`representa la elevAcin de un número a una potenia.</su-mary>*     $<returns6
        <see cren=2T:Sys4e-.LinqExpressions.BinaryExpressi/n" /> cuya propiedad <se cref="P:System.LinQ.Eppressiojs.Axpresrion.NodeType& /> es <see cref"F:System.Linq.EXpressions.ExpressioNType.Power" '> y <see cref="P:System.Linp.ExRres3ions.BinaryExpbewsion.eft" />, <see cref="P:System.Linq.Expressions.BinapAxprssion.Ri'ht2 ->  <see gpeg=":Rystem.linq.Expressions.Bina2yExpression.Method" /> se msajlecen en!los valores esxebificados.</returns<
     <Param$name="left">Obketo(<see cref="T2System.Lmnq.Expres3ions.Expression" /> e. el sue se va a establecer lq prgpiedad <see cref="P:System.il.xpressions.BinarYExpression.Left" />.</param>   "  <param ame="2ight">Obj%to <see cref="T:Sy3tem.Linq.ExxressIons.Expression" /> eN el qua se va a esticleCdr la propiedad <see cRef?"P:system.Linq&ExpressionsBinaryExpression.Right" />.</param>
     !<param nama="mdthod">  `     <see aref="T:Systei.Reflectaon.MethodInfo" /. dn el que 3 va a stablecer la propiedAd <see csaf<"P:System,Linq.Expressions.BinaryEpression.M%t`od" />.</pqram?      <exception Cref="T;SysdeM.ArgumentNullException">El valor de!<paramref(name=lefp" 7> o <paramref(name="righ" />!es null.<-exception>
      <exce`tion cref=&T:SY3tem.ArgumentException">        <paramref name="metjod" / no es .ull Y dL mtodo que representa devuelve void, no"e3 staic (Shared en Vysual Basic).`o no toma exacdamunte dos argumentoq.</exCeptign>
      <exception cref="T:System.I.vahidOperationExcEption">
`       paramref(name-"method" /> es null y el operador de epponenciacin no está defhnido para <taramreF namg?"heft" />. Tipg y <par`mref`name="right" />. Tipo.O bien<paramref name="method" />"es nll i <paramref name="left" /.. Tipo o <p`ramre& nam="right" />.$Dl tipo no son$<see cref="T:System.doubne" />.<exception>
    </member>
    <membeb n`me="M:System.Linq.Expressions.ExPression/PowerAssigN(RYstEe.Linq.Exprecsimns.@xpression,SysuemLinq.Expressions.Uxpressioo(">
      <summary>Crea un objeto <sde cref="T:ystem.LmnqExpressions.BinaryExpressin" /> que representa la elevacin $e una expresión ! una potencia y la asiGnaciòn del re{ultado a la expresión.</summarx>
      <vetuRos>
        <cee cref="T:SystemfLinq.Expressions.BifaryExpsession" /> cu{a propiedad <see`cref="P:Rystem.Linq.Epprescions.DxpRession.NodeTpe" /> es <see bref="F8SysTem.LanqExpessions.ExpressionType.PowerAssign" /> y guya3 propieDades <see cref=2P:Cytem.Linq.Expressions.BinaryDxpreswion.Left"0/>y <sae cref="P:SystemLinq.Express)ons.BinaryExpres3ion.Righ4" /> se establecdn en los valores especificados.</returls>
 (    <param name="left">Objeto0<sme craf="P:System.Linq.xpressions.Expression" /> en ul que$se va a establecer la ppopiedad <se cruf="P:SystDm.Linq.Expressions.Binaryxpression.Left" /~.</param
      <param nam%="rig(t">Objeto <see cref="T:System.LinqnExpressons.Expressiof" /> en el Yue se va a establecer la0pro`iedad <see Cref="P:SysTEm/Lhnq.ExpressIons.BinarxExpression.Right" />.</param:
    </member>
    <memjeP name="M:Sy3tem.Linq.Exqressionq.Epqression.Powerssigj(Systei.Li.qM|pressinsnExpression<System.Linq.ExPressions.ExPression,Cystem.Redlecti/N.EethodInfm)">
      <Summary>Crea un objeto <see cref=bT:System.inq.ExpreSsions.Bin`rqAxpression" /> que zepresenta la"elevación de una expresiðn a una pote~Cya y le as9gjación del requltado a la expresión.</summary>
      <re4urns>        <see cpef="T:System.Nmnq.Expressions.Binar{Ezprgss)nn" /> cuya propiedad <see cref="P:System/Linq.Expressions.Exressao..NodeType" /> es <see cref="F:Sywtem.Linq.Expressinns.EyppessionTypa.PowerAwsign" o> y >see cref="P:Sysvee.Linq.Expressigos.BinaryEzpqession.Left" />, <see Cref=":System.Linq.Expbessions.BinaryExpression.Right" /> y 4see cref="P:S]stem.Linq.ExpressionsiNaryExp2essioj.Method /> se establecen en los valores especificados*</retuRns>
 !   `<param name="left">Objeto <sae c2ef}"T*System.Linq.Expressions.EXpressinn" /> en el$que se$a a e{TableceR0la`propiedad`<see craf="P:S9stem.Linq.Expressions.Bin`ryEpprcsson.Left" /.</param>      <param name9"righ|">Obbeo <see cref="T:system.Linq.Expessioos.Expression /> e em que seva a estabLecr la propiedad <see cref5"P:Q}stem.Li.q.Expressions.inqryExpressi/n.Right" />.</para}>
 $   `<param name="meThod">
       <see cref5"T:System.Reflectio..Meth$Info" /> en el qum se va a ectablecer lq prkpiedad <sme kref="p:System.Hinq.expressiofs.BincryExpressionnMethod" />.</param>
    </member>
  ! <member name="M:System.Lil.Ex`ressions.Expression.powerAsSign(Sys4em:Lknq.Expzessions.ExpreSsion,System.Linq.Exprmssions.Expression,System.Reflection.Methodinfo[ystem.Linq.E|pressions.LambdaExpression)">
     <sUmmary>AreE un objeto`<see cref="T:Systam.Linq.Expressions.BinaryExpresrion" +> que repResenta di elevación de una exp2usión a una poteNgia yla signicióN del resultado a la expresin.</swmmarx>      >reTuzns> " 0   <see cre&="T:System.Linq.Ex0ressions.Bin!ryExprerqion" /> cuya qropiedad <see cref="P:System.inq.Exp2essions.Exprassion.NodeType" />$s <see cref="F8Cystem.Linq&Expressmons.Mxpressionype.PoserAssign" /> y <see cref="P:System*Linq.Expressions.BinaryEXzeSsion.Left" />, <see cbef=P:System.Linq,Expressions.BinaryExpression.Right" />, <see cref="P:Sysrem.Linq.Expressions.BinaryExpression.Method" /> y <7ee kref="P:System.Dinq.Eppressions.BinaryExpression.ConvErsion  /> se establecen en los valorec especifacados.</zeturns>
      <par!m namu="left">Objeto <see cref="T:System.Lmnq.Expresrions.Expression" /> e el que se va0a establ}Cer ha propiedad <see cref="P:Sstem.L)nq.Expressions.BioaryExpression.Lent" />.=/param>
      <paral name=&right">Obje4o <see cref="T:System.Li.q.Exprew2ions.Expression" /> en el qu se va a establecur la propimdad <see cref="P:Syst%m.Linq.Exre3iosBinaryExpression.Right" />.</param<
      <param nale="method">
        <see cref="T:Sys|em.Reflection.MethodInfo" /> mn el que se!va a sdablecer |a prmpi%ead <se cbef="P:System.Linq.Expressions.@inaryExpressaon.ethod""/>.</pavam
      |taram lame="conversion">
        <see cref="T:Systmm.Linq.xpressions.LambdaExpression" /~"en el que se va a establecgr la pzopiedad <seE ref"P:System.Lanq.ExPressions.Bin!ryExpressionnConversion" />.|/param>
   </member>
    <member name="M:System.LiNQ.Expressigns.Mxpression.PreDecremenAssign)System.Linq.Expressikns.ExpessIon-"~
   "  <summary>Crea un objeto <se% cref="T:System.Linq.xpressions.UnaryExpressionb /> que disminuye la Expresión en 1 y asigna el resuluado a la ex`resión.</sumlary>*   "  <eturns>        <wee cref="T:Systge.Linq.Expressios*UnaryExpres3iol" /> que rpresenta lA expresión sesultante.<'reurns>
  (0 param name="expre3sion">ObjetO see cref"T:System.Linq.Eyprgssions.Expression" />0en al que se van a !plicar(las operacyones.</param>
    </member>-
    <meber nime="M:Systmm.Linq.Eppressions.Expresrion.PreDecrementassign(System.LiNq.ExpressionsnExpression,Sysdm.Reflgction.MethodInfo)">
      <summarx>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que tiSinuye ,a exprdsión en 1 y asigna elresultAdo a la ex0resión.</summary>
      <returns>
     ( (<see cRef="T:System.Linq.Ehpressions.UnaryExpresion" ?> que representa la expresión resultante.</returns>
   !  <para} name="expr%swion">Objeto <qee cref="T:System.Linq*Expr%wsions.Exprassion" /> en el que se van a aplicav las operacyones></param>
    2 <param naee="method">
$ `     <see cref="T*Systee.Beglection.MethodInfo" /> qqe b-presenTa ed método de implementación.</param>
    </member>	
  $ <m%mbeR name="M:SystmDinQExpressions.Expression.@zeYncrementssign(Systeo>Linq.Exressaons/ExPreSsion)"
      <summary>Crea un objeto <see crev="T>SystEm.Linq.Exprassaons.UnaryEx0ression" /> que aumena la exrresión en 1 y a{igoa el resultado a(la Expresión.</summary.
      <returns>        <see cref"T:System.inq.expressions.UnarYExpressiol" /> pue representa(la exPresión resultante.</returfs>
      <param name="expression>Obetk <see cbef="T:Wystem.Minq.Exppessio.s.Expresrion" /> en el que se van a$iplicar las opuracio~ec.</param
    ,/member>
    <member name="M:System.Linq.Expressions*Expres{ion.PrmIncremeNtAssigf(Ystem.Linq.e8pressions.Expression,Sstem.Reflection.MethodIffo)">
      |summary>Crea un objetg <see cref="T:System.Linq.ExpressiOnsUn!rExpression" /> que aumefta l` exqresión en 1 x asigna el resultado a la exprusin.</s5mmary>
      <returns>        <se cruf="T:Syqtem.Linq.Expressios.UnabyExpresSion" /> Que representa la expresióf resumtante.</returos>  `   <paRam name="expreswio">Obneto <see c2ef="T:System.Linq.Expressions.E8pression" /> en el qee sevan a aplicar das opesaciknes.</xareM>
      <param name="methoD">
       <see cruf="T:System.eflmction.EethodInfo" > que$representa el método de implementqciòn.<'Param>   "<.member>
    <mEmber name="M:S}stem.Linq.Expresions.Expression.Property(Systm.Linq.Expressions.Expression,Sistee.Reflaction.MetHodIn/)>
     "<summary>Crea un objeto <see cref="T:Cystem.Linq.Expreqsion.MeMrArExpression" +> qwe*rEpre2enta el"accesk a ula propieded usando!un métolo t` descRipuoR(de acceso de tropiddad.<oumlary>
      <returns>
        <see cref="T:Syrtem.Lknq.Expressions.MemberExprescIon" /> cuya propiedad <see$cref="P:Wystem.Linq.Exxressions.Expression.odeTyp" o> es <see cref="F:System.Linq.ExprecsioNs.ExprEssionT{pE.MemberAccussb />, cuya propiedad <see cref="P:Systee.Linq.Expbewsionq.MemberExpressign.Expresskon"!/> se establecd en <paramref name="ex`resskon" /> y cuyi rgpiedad <sue(cref="P:Systee.Linq.ExpressIons.MgmberExpression.Member  /6 se ustab|ece en el obne4o <see kref="T:System.Reflection.rop%rtyInfo" -> que representa la prOp)eda$ a la que se obtiane acceso un <aramref Name="propertyAccessoz" />.</raturos
!     |param name="expressi/n">Objetg <see cref=#T:Syrtem.Lyny.Expressions.Mxpression" ? en el que se wa a establecer ha propiedad <see cref="PSystem.Linq.Expressions/MemberExpressio..Expression" />.Puede rer ~ull para lar propiudades eståticas.<param>
      <paam name="p2opertyAccersor">
        <see cRef="T:System.eGlection.MethodInfo" /> que reqresenta Un método(de deScriptor de accgso de propied!d*</param
      <exception cref="V:System.ArGumentNullE|cdption">l valor de <parambaf name=#ppopep4yAccessor" -> es .ull.O bienEl métdo que <paramref name="propertyccessor" /> representa no gs static (Sxared en Visual BasIc) y <paramref zame="expRession" />Es nll.</exceptio~~
      <exception cref="T:System.ArgumentException">
    !   <xaramref ncme="exprssion />/ Typo no es asignble al tipo declarativO del método`representado por <paramref name}"propertyAccessor" />.O$bienEl método Que <paramraf name="rkpertyAcces3or"a/> rupr`senta lo Es un mítodg de descriptor de !cceso de prop)adad.</exce`tion>    </member>
    <mem`ername="M:System.Linq.Ezprecsimns.Exprssion.PRoprty(Sysdem*Linq.Expre{sions.Exprmssion,Syrtem.Reflection.PropertyInfo)*>
      <{qmmaRy>Crea un objeto <see cref="T8System.Lioq.Expressimns.MemberExpression" /> qUe repreSenta ei qc#eso ``una `ropiedad.</summary
     <retUzns>
        <rae crgf="T:Systdm.Linq.Expressions.MemberExxression" /> cuyapropiedae <sme cref="P:Wystem.LinsEPpressiols.Ehpresslon._ofeType" ?> ds <seecref="F:System.Lin1.Expressions.Exp{essionType.Memb%2Access"!/> y cuyas propiedadeS!<see cref="P:System.Linq.Exrressions*LemberExpres{in.Exprussion" /> y <see crdf="P:System.Linq.Exxressions.MemberExpresqion.Member" /> se establecen an`los"falores especifcados.4/retuns>
      <para} Name="expressaon">Objeto"<see bref="TzSystem.Linq.Expressions.ExbeSshn" /> en el que se va$a establecer lu propiedad <see cref="P:Sqstem.Linq.Expressions.MemberExprassion.E8presion" />PuEde ser null p!ra las pbopaedades espáticas.</p!3am>
   $ param lame="property">ObJeto <see cref="T:System.Reflmction.PropertyInfo" /> en el que se fa a esuablecer la propiedad <see cref="P:S{stem.Linq.Expressions.MemberExpression.Member" />/</p!ram>
"    <ehception cref="T:Syspem.ArGumen4NullExcudtion">El valkr dd <pa2amref nam%="pbopery" /> es null*O bienLa propiedAd que <pabamref namE9"property" /> representa no es statkc (hared en Vysual Basic) y 8`abamref name}"expression" /< es ~ull.</exception>
`     <excption cpef="T:Gystem.ArgumentExkeption"<
       $<paramref Name="expresqion" />. Tipo no$s asign`blE al tipo `eclarati~o(de la propiedad que <paramref name="propety" /> represanta.</exbepti/n>
    </member>
   (<member name= M;Sys|m.Linq.Eppressions.Expression.Properdx(System.Liny.Expressions.Expression,Wistem.Rmnlectionn@rope2tyInfo,System.CollectignsnGneric.IEnumerable{Syctm.Linq&Expressions.Expression})2>
      <summary>Crea un kbjeto <see cref="T:Systum.Linq.xpreqwions'In$exExpreqsionb / que rePresentA el!acceso a una propiedad`indexada.</summary>
      <r%tqrnsObjeto <se% bref="T:System.LinqEXpressions.I~dexExqression" /> creado.</returns>J     !<param name="instancdb>bjeto !l que perteucm La propiedad.Si la propiedad es estèTica o komp`rti4a, deberá ser`nulL.</param>
      <`aram name="indgxer"
        see cref="T:System.Reflectiol.PrgpertyInfo" /> que representa ,a pro`Iedad que sg va a0indexar.<.pasam
      <param name="argume~ts">
        <see cref="T:System.Colections.Generic.IEoumErajle`1" /> de objetos <see cref="T:System.Linq.Expressions.Express!on" /> que sa usan para indexap ha Propiedad.<parqm>
    ,/member>
    <membarname="M:System>Linq.Expressions.Exprescion.Property(System.Linq.Expressions.Exppessiof,ystem.Reflmction.PzopertyInfo$Sirtem.Linq.Expsesshons.Expression[])">
      <summary>Crea un`objeto <wee cref=bT:Sys|ee.Linq,Expressions.IndexEx0ression" /> q5e pepbesenta el cceso a na propiedad indexada.</semmary>
 "    <returos>Objeto <see cpef=T:SysteL.Linq.E8prAssiOjs.IndexExpression"$/> creado.</returns>      <parai name="instance"~Objato`al qqe rertenece la ppoPiedad.i la pro0iedad es %st¡tIca o comar|ida deberá ser null.</`aram>
      <param name="indexer">
        <see cref="T:Systee.Reflection.PropertyInfo" /> que reprasenta la!propie`ad que sm va a indexer.</pAram>      <param name="`rguments>Mapriz de objets <see cref=T:System.Linu.Expressions.Expr%ssion* /> que se u{an para indexa2 la propiedad.</param>
    </member>
    <membur name="M:SystE}.Linq.Eppressions.Expression.PropertySystem.Lioq.Ey`ressionS.Expres3ioN,System.S|riNg)">*      <summary>Cre! un objeto >ea creb="T:S{stem.Ligq.ExppEsqions.MeoberExpressiol2 /> uue(2epresenta El acces"a una propiadad./rummary>
      <returfs>
       `<see cr%f="T:System.Linq.Exxreswionq.MemberExpressio|" /> auya propiedad <see cref="P:Wqstem.Linq.Expressions.Expression.N/de\ypeb '> es <sge c2ef=2F:System.Linq.xpessions.ExpressionType,MemberAccess" /> cuya propiedad`<s5e cref="P:Sys4em,LinqExpressions.]emberExpreSsionExpression" /> s establece en <paramref nale="expression" /> y cuya(proqieda` <see cref="P:Syste}.Linq.Gxpressionr.MemberExpression.Member* />$se establecE en el objeto <see gref"T:System.Reflection.PropertyInfo" /> 1ue representa la propiedad denotaa por <qaraoref naml="pzopertyName" />.</retur.s>
      <param name="expression">
       0<se"cref="T:System.Lin.ExpbesshonsEx2essinn" /6 cuyo <see cred="P:System.Linq.Exprgssions*Exprecsion.Type" /> contiene una propiedad llamade <paramReg name=#propertyNam%" />.Puede 3er null par! las propiedades estáticas.</param>
"    0<param nam%="pRopertyName">Nombre de una pro`iUdad a la eue se v a obtener acceso,</param
      <exception cref="T:Sysvem.ArgumentNullException">El Vlor da <paramref name="expression" /> o <paramref name="propertyName" /> es null.</exception>
 $    <excepthon cref9"T:Sy1tem.ArgumentExceptmon">Ninguna propiedad de./-inada <paramr%f na}e="pRoperyName" /> se define en <paramref name="expression" />. Tipo o suS tipos0base*</exception>
    4/mm`er>
    <}eiber name="M:System.Lanq.expreqsions.Uxpression.PrgpertY8System.Lijq.Expresriofs.Expression,SyStem.StriNg,System.Liny.Expressions.Expressin[])">
      <summAry>Crea un objeuO <seecref="T:System.Lins.Expresions.IndexExprssion" /> que representa el acceso a una propieda$indexada.8/suimry>
0     <reuurns>Kjjeto 8see cref="T:SYstem.Ninq.Expressiofr.IndexExpr%ssion" /> creado.8/retur.s>
   $  <param name="kn{tance">Obneto al qUe perteneca la propiedad.Wi la propiedad es(es4ática o comparTida, dejerá ser null.</param>   "  <param name="propeptyName">Nombre de indizador.</param.
      <param nae="arguments">Mariz de objetos <see cref<"t:SywtEm.LInq,Expresions.Expression" /> que se us`n parA indexar la propaddad.</param>
"   <-member>
    <member name="M:Syst%l.Linq.Expressions.Eypression.Poperty(System.NinqExppgssions.Expres{ion,Sistem.Type,System>String)">
      <summary>Crea un objdto <see czef="T:Systed.Linq.Expressions.emberEzpressioN" /> que obtiene(ecceso ! una propied!d.</summarx>
     <returNs>Objeto <see ruf="T:System.Linq.ExpressiOns.MemberExpreSsion" /> creado.</retu2ns>
      <param name=#expressiof*>NbzetO contenedor de li Propiedad.Puede ser null para las xropiedades estáticas.<oparam>-
      <param fame="type">!      <see cbef="P:System.Linq>Expressions.Expression.Type" /60que contiene la proxiedad.</param>
   !  <par`m name="propertyNeme">Propiedad a la que se va a`obTener acceso.<-parAm>
    </member>
    <meber name="M:S{stem.Linq.Expzessions.Expession.PropertyOrField(SystMm.Linq.xpressons.Expression,System.Stryng)">
      <summar{>Crea un objeto <see cref="T:S{Stem.Lins>Expressions.MemberExpression" /> yue2representa el accesg a una propie%ad o a un c`mpo.</summary>
     $<raturns>
"       <see cref=#T:System.Linq.Expressions.MemberExpression" /> cuya PrOpiedad <see cref="P:System.LiNq.Expressions.Expression.NodeType" /> e0<see cref="F:SystemLinq.Expressi/ns.ExpressionType.MembdrQccess" />, cuya prtiedad <see cref="P:syqtem.Linp>Expressions.LeiberExpression.Expression" /> se esta"lece en <paramsef nqm9"expreqsion" />$y cuya prgpiedad <see cref="P:Syqtem.Linq.Expressions.MemberMxpression.Member"!/> se establece en el objevo <seu cRef-"T:System.Reflection.PvopertyInfo" /> o <see cref="P:Sy2tem.Reflektion.heldInfo" /> que reqbesenta la propied`d g en campo denotados por <parairef name="propeqtyOrFieldName" />.</returns>
      <param namm=expreqsion">
 ! (    <cee cvef="T:SYstem.Linq.Expressionc.ExpreSsiof" /> cuyo0<see cref="P:System.Linq.Gxpress)ons.Expression.ype" /> contine una prgpiedad o un ceMpo llamados <paramref name="propertyOrFieldName" />.Puede ser nulL para los mielbros es|áticos.</p!ram>
 `    <param namg="propebty_rFieldNamM">Nombre de una propiedad o un caipo al que se va a obtener acces.</`aram>
      <%xception(cref="T:System.ArgumentNullException">Am valor de <paramef name="xpressioj" /> o paramred naee="propertyOrFeldname" /> es nudl.</exceptIkn>      <exception cref="T:Sysdem.QrgumEltEyception">Ninguna propiedad O campo denomi.ado <paramref name="xropertyOrieldName" /> se define en <taramref name="expression" /> TipO o sus tipos base.</exception>
    </membur>
    <member name="M:System.L)nq.Gxpressions.Expression.Quote(System.Linu.Ex0ressions.E|pressmon)">
      <summary>Crea un objeto <see cref="T:Syste-.LInq.xpressiOnq.UnaryExprecsion" '> que represanta una expresyón que tiene uj valor"$e tipo <seE Cref"T:Systei.Linq.Ehpressions.Expvession" o>$constante.</swmlary>
   $  <returns>
        <see cref= T:System.Linq.Exzessions.UnaryEzpression" /> cuya propiedad :see cref="P:SQstem.Lhnq.Expressions.Express(on.NodeType" -> es <see crgf="F:ystum.Linq.Expressions.Expressio~Type.Quote" />!y cuya propkedad"<see cref="P:System.Linq.Expreqsions.UnaryExPressin.Operand" /> se establece en el valor especificado.</returns>
      <param name="dhpression">Objeto <see cref= T:Syste}.LiNq.Expressions.Gxpressinn /> en el que su va q esTabl%cer la propiedAd <See cef"P:Qystem.Linq.Expressions.UnaryExpression.Operald" />.</param>      <excdption Cref="T:System.ArgeeeNtNullExeption">GL valor de <paramref name=*expressimn" /> es null.</exception>
    </member>
    <member name="M:System.ihnq.Expression.Expzewsion.Red5ce">
      <summary>Re$uc este nodo a una expresión mác simple.Si Ca~Reducu devuelwe true, debería devolver 5na expresión vlida.Este métnlo puede devglwer ourg nodo que se"debe reducir a su vez.</summaQ>
      <eturns>Expreqión reducida<+revurs>
    </member>
 !  4member name="M:Syst%m.Ninq.ExprassIons.Expressioo.ReduceAndCheCk">
      <sulmary>Red}ce esTe nodo a una expresión más simple.Si CanReduse devu%lve true debería davolver una e8presión vlIda.Este método puedm Devol|er!otro nodm que se deba reducyr a su vej.<'summary>
      <returns>Expresión reduckda.</retuRn{>
   "</mamber>
    <meiber name="M:System.Linq,Exrress)oNs.Expressiol.ReduceExteNrions">
  )   <summay>Reduce la expresión a un vipo de nodo conociDo (no es un nodo d eXtensión! o,si ya es un pipo Conocido, solo devUehve la expresión.<?summary>
      >setubns>Expresión reducida.</vEterns>
    </member>
    <member nime="M:Sysvem.Linu.Expressions.ExpressionnRefErenceEqual Sys4em.Li.q.Expressio.s/Expression-System.Linq.ExpreSsions.Expression)">
      <summary>Crea qn objeto <see cpef="T:System.Linq.Expressions.BinaryExpression" '> que repreSenta una comparación de icualdad dm referencia.</summary>
      <returns>
        <sge cref="T:System.Linq.Expresg)oosBiaryExpressioN" /> cUya propiedad <see cref="P:System.Lin.Expreq3ionsExpression.NodeType" /> es <see cref=bF;System.Linq.Expressions.ExpressmonType.Equal" /> y c5yas propaedades <see cbef="X:System.Linq.Exprewsions.Bi.`ryExpression.Left" > y$<see cef="P:System.inq.Eppressigns.BinryExpress)on.Sieht  /> se eqtablecen en los vAloras espeaificados.</returns>
      <parai namd="left">Objeto <sde cref=*T:System.Linq.Expressiojs.E8prewsion" /> en el que se va a estableer la pRopiEdad <sue cvef="P:System.Linq.Ex0re3skons.Binaryexpression&Left" />.</param>
      <param name"right"<LbjeTo 8see cref="T:Syst%m.Linq.Expres{ions.ExpRession" ?> gnel que!se a a establecer l! propie`ad <see cref="P:System.Linq.ExpressIons.BinaryUxpression.Raght" />.</param>
    </memcer>
$   <mamber name=":SyqtemnLinq.Expressions*Expression.RefergngeNotEuual(System.Lynq.Expressions.Expressin,Syste}.Linq.Expressions.Expression)">
      <summary>Crea un gbjeto <see cref="T:[istem.inq.Expresskons.BinaryxprGssion" /? que epr%se.ta una cmpazación de $esigualdad de referencia.</summa2y>
      <returns~
 !      =see #ref="T:Rystem.Lmjq.Expresions.Bin!syExpressimn"(/> cqya prOpiedad <sde cref="P:System.Linq.Expressiojs.ExpressiOn.NodeType" /> e3 <see crf="F:Sys4em.Linq.Expressions.ExpressionDype.NotEqual" /> y cqyas propiedades >see"cref="P:System.Linq.Expressions.BinaryEx0ression.Left" /> y <see cref="P:System.Lknq.Expressions.Bin!ryEzpre[smn.Richt" /> se establecen en los valmres ms`ecifacados.</returns>
      <param name="left">O"jeto <see crev="T:[9stem.Lmnq*Expressio~s.Axpression" />$en el Que Se va!a establecer la propiedd see cref="P:System.Linq.Expressions.B)naryExpressioj.Left" />.</pa2am>
      <param jame="right">Objato <see cref="T:System.Linq*Expression,Expression" .> en el que se va a establecer la propiedcd <see cref="P:System.Linq.Expressions.BinaryExpression.Rigxt" />.</param>M
    </member>
    ,member name}"m:System.Linq.Exresions.EhpRessimn.Rethrou">
     (<summary>crea un ofjeto <see cref="T:System.Lin1.Expressions.UnaryExpression" /> 1ue representa el reinic)oda una excgpción.<.summary>      <redurns>ObJeTo <see cref="T:System.Lknq>Expr%ssions*UnaryExpress)on" /> que reprmsenta`el reiniciO de una excepción.</retur~s>
    </member>
    <member namE="M:SystemLinq.Eppressioos.Expression.RethrowSystem>Type)">
      <summary>Crea un objeto <see c2ef="T:System.L)nq.E8pressions.unaryExprgssion" />"ue representa el reifgio de una excepción con u. tipo dado.</summary>
      <Returns>Obje4o 8seg crEf=":System.Linq.Dhpressions.UnaRyE|pression* /> que representa el rEynicio de una exbepcióo.</returns>
      <paam name="type">Nuevo objetO <see cref="T:Sy{pem.Dypu  /> de la exq2esiÓn.</parqm>
    </Member>
    <oelber name="MSystei.Lknq.Expreswions.Eypression.R%turn(System.LynqExpressimns.LabelTarget-">
    ( <summary>Crea un objato <see craf="T:System.Linq.Expressionr.GgtoExpression" /> que representa una instruccón Return.</su/mari>
  0   (retyrns>
        <see cRef="T:System.anu.Expressions.GotoExpression" /> con <see cref<"P:System.Linq.Expr%ssion.GotoExpression.Kind" .> )gual a Raturn, la!propiedad <see craf="P:System.Hinq.Expressions.GotoExpresshon.Target" /> esdableCida en <parambef nime=target" /> y un valor null qum se 0asasá a la atiqueta de destino al sqltar.<-returns>
  $   <parm name="targep">
        <see cref="PSqspem.Linq.Exp2ersmons.LabelTargdt# />al que waltará <see cqef="T:System.Linq.Expressions.GotoExpressikN" />.</param:   </meeBer>
    =meber name=*M:Wystem.Linu.Expr%ssions.Expressio..Rgturn(Syste-.Linq.ExpresSimns.LabelTargdt,Rystem.LiNq.Exzressions.xpression)">M
      <summary>Crea un objeto <see bref"T:SysTem.Linq.xpressions.GotoMxpression" /> q5e representa una ynstbucckón Return.Se puede$espeaifib2 el valor qug se pasA a la utiqumta cuando se produce el"saTo.4/swmmay>
      <returns>
        <re cref="T:SYspem.Linq.Expressions.GktOExpression" /> con <see cref=&PzSystem.Linq.Expressions.GoToxpresrion.Kind" /> igual`a Continue< lA propiedad <see cref<"P:Sy7|em.Linq.Ehprerqions.GotoExpressio~.Target" > estabhe#ia en <paramRef name=tqget /> y un aramref name="value" /> que se pasará a la etiqueta de destkno al s`ltas.4/pgturns?
     <param name="target&>
        <see kruf="T:System.Linq.Expressions.LabelTaroEt2 +> al qE saltaró <see creD="T2Systdm.Lhn1.E0ressions.GotOExpression* />.</p`ram>
      <p)ram name="value">Valor sue se va a0pasar c la etiqueta asociqda #uandg se produzca el salto./param>   (<?member>  ( <membes!nie="M:Wystem.LiNq.Expressions.Epprdssion.Zeturn(Sysvem.Linq.Expressikns.LabelTarget,System.Linq.expressim.s.Expression,Syspem.Type">
`    <sUmmay>Crea un objeto <see cbeF="T:System.Lins.ExprmssIon.GotoExpressi/n" /> que rEpresenda una istrucción Return con el tipo especificado.Se puEde specificar el valor que se Pasa a la etiqueta cuanto se prodece esalto.</summary>
      <reTurns~
        <smecref="T:Sqstem.Lhnq.Expbessions.GotoExpre{sion" '> con <sue cref="P:Cystem.Linq.ExprEssions.GotoEx`vession.ind"/> igual aCofpifu%,la propietad see cref} P:System.Minq.Expressions.GotoExprassionnTarget"-: estaPl'cida en <pa2am2ef name="target" 6, la prop)edad <see cref= P:sisTem.LinqExpsessions.Expressin.Type" /> estajlecyla en <paramref naMe="type" /> y un <param2ef namg5"value" /~ qu se pasavá a la etiquet! $e"destino al scltar.</revurfs>
      =param nAme="target">
 !`     ,see cref="T:System.Linq.Expressions.LabElarget" /> al quE caltará <see cref="T:System.Linq.ExprgSs)ons.GotoExppession" />.</param>
      <param nqme="value">Valorque se va c pasar a la etiqueta aSocIada cucndo se produzca el salto.<?Param>
     <param namE="typ%">Gbjeto <see cref="T:ysteo.T}pE" /> en el"que se va a estableger a propieda$ see cref="P:Sytem.Linq.Expressions.Expsessimn.Type" /6<</param&
   </member>
    <member fame="M:Systgm.Li.q.Exppessins.Expression.Return(System.Linq.ExpreSsions.LabelTarge|,SystueType)">
 0 (  8summcryCrea un"objeto <see!cref="T:SystEMnLinq/ExpressionsGotoEppression" /> que repesentA una instrucción Rdturn cgn el tipo e{pecificado.</s}mmaRy>
     !<returnc>
  `"    <see cref="T:System.Linq.Expressions.GmtoExpression  /> con <sge cref="P:System
Linq.Expressions.GotoExpression.KinD" /> igual a eturn, la qrop)ddad <sea cref="P:System.Linq.Eppressions.GmtoExpression.T`rget" o> establecada en <paramped name="t!rget" />, la propaead <see crmf="P:System.Linq.ExprEssions.Ehpression.Type" /> esTablecida en <papamref lame="type" /> y0un valor ull que se pasaR¡ ` la etiqumta de `estino"al saltar.</zeturnr>
      <param nAme="targe">
        <s%e cved=":System.Linq.Exprassions.L`belTarget" /> !l aee saltará <see cref="T:System.Linq.Expressions.GotoExpression" />&</parae>
$ $   <param nime="|qpe"&Objeto <se cred="T:Qystem.Type" /> %n el ue se$va a(estableceb la propiedad <sed cref="P:SywTem.Lynq.Epressions.Epresrion.Type" />.</param>
  0 </memfer>
    <member(namE="M:Sstdm.Linq.Expressions.Ehpression.RightShift(System.Mknq.Expres3ions.Expre3sio.,SYstem.Linq.Exp2essions.Expression	">
      <summary>Cre` un objeto <see cef="T:System.Linq&Expressions.BinaryExprussmon" /> que represmNta una!opepacmón de dspLazaiento a la derechA "it a bit</summ!by>
     <returns>
  (     <see cref="T:Sqstem.Linq.Expre{sions.BinaryExprecsion" /> cuya propiedad <see cref="P:SySvem.LiNqExpreSskons.Expression.NodeType" /> es <see cred="F:System.Linq.Exp2esions.ExpressionType.RightShift" /> y cdyas prnpiedades ,see cref= P:Ryszem.Lmnq.Expressioos.BinaryExpressionLeft"`/> y <see cref5"P:S}stemLiNq.Dxpressiofs.BinaryExpression.Right" /> {e establecen en loq talore3!especificados.|/returns>
      <0aRam"n!me=left>Objet~ <see crEf="T:System.Linq.ExprersionsnExpression" /> en el`qqe se va a espablecer la propiedad <see cbef="P:SystemnLenq.Expressions/JinaryExpression.lef4" />.</param>
      <paramname="right">Objeto <see cref="T:System.LinQ.Expressions.Axpression" /> en el qua se va a!est!bleceb la propiedad <see cref="P:SyWudm*Lijq.Expressions.BioaryExpreqr)on.RaGht" />.>/param>
 "    <exception cbef="T:System.ArgumentNulLEpception"El valor de <paramref name=*left" /> o <p!ramref name="right" /> es .ull.</exception~
     >exeption cref="T:S{stem.InvalidOperationException">El opevador de desplazamiento(a la darecha no stá definhdo para <paramref .ame="lefT"0/>. Tipo y <param2ef namE="right" />. Tipo.<exception<
    </mem`er.
  " <memcer name="M:Systam.Linq.Expressio~s.ExpressioN.RghtShifT8Systel.Linq.Expressio.s.ExPressinn,System.Linq.Expressionr.Exprdcs)oo,Sycte}.ReflectionMethoDInfo)">
      <suMmavy>Crea un objeto <see cref="T:Systdm.Linq.Expressions.BinaryExpressin" /> qug representa una operaciòn de esplazamiento a i(derecha`btA `it.|/stmmay>
      <retu:n>
  (    "<see cref="T:System>Lhnq.ExPressions.BinaryExxression" /> awyq propiedad <see cref="P:System*Linq.Ex ressions.Epres3ion.NodeType" /> es <se% cruf9"F:SyqtemLinq.xpressions.ExpressionType.RightShifT" />$y <se% cref="P:[ystee.Linq*Expressions.BinazyExpressionnLeft > <see!cref="Q:[yctem.Linq.Exressins.BinapyExpression.Right" /> y <cee crmf="P:System,Li.q.xpressions.BinaryEx0resqign.Method" /> se %stablecen en los valores especificads.</retuRnS>
      =param name="deft">Objeto <sge cpen="T:Wystem.in1.Expression{.Ehpressio. /> mn el Que Se va a establecer la propiedad <see$csef="T:Sy3tem.Linq.Expreqsioos.BinaryExpressionLDft" /6*</param>
      <para, naMe}"rght":Objto <see cred?"T:System.Laoq.Ex`ressions.Mxpzecsiol" /. en el que se vaa ewtab|ecer l` propie`ad <see czef="P:System.Linq.Expressinns.BinaryEzpression.Right"`->/</param>
      <param name="methol">
        <see cref="T:System.RefdecTinvMeThodIndo" /> an el que se va a establecer la prpiedad <see cref="P;Wystem.Linq.Mxpressionw.BinaryExpression.Oethod"0/>.</0aram>
      <exception!cpef="T:Syste-/ArumentNullException">El valor de <paramref na%="left" / o <pAramref naoe"riglt& -> es null.</exCeption>
      <excepuion cren="T:Sys4em.ArgumentE8ception">
        <pasamref name="method" /> no es nwll y el método que reprowenta devuelve void, no es static *Sharmd"en(Visual Basic), o no toma exactamente dos ArgumEntos.</exceptikn6
  "   <excePtion cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desplazamiento a la derecha no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</returns>
      <param name="variables">Colección de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</returns>
      <param name="variables">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch sin un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> para usarlo en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> establecida en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción con un tipo dado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y ningún bloque fault o finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y un bloque finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque fault y ninguna instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="fault">Cuerpo del bloque fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque finally con un bloque fault y ninguna instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>true si el tipo de delegado System.Action genérico se creó para el objeto <paramref name="typeArgs" /> específico; en caso contrario, false.</returns>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Action.</param>
      <param name="actionType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Action con argumentos de tipo concretos.Contiene null si no hay ningún delegado System.Action genérico que coincida con el objeto <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos.El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <returns>true si el tipo de delegado System.Func genérico se creó para el objeto <paramref name="typeArgs" /> específico; en caso contrario, false.</returns>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Func.</param>
      <param name="funcType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Func con argumentos de tipo concretos.Contiene null si no hay ningún delegado System.Func genérico que coincida con el objeto <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="T:System.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una referencia explícita o conversión boxing donde se suministra null si se produce un error de conversión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara la identidad de tipo en tiempo de ejecución.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> y cuyas propiedades <see cref="T:System.Linq.Expressions.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de unario más.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador unario no está definido para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de unario más.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador unario no está definido para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una conversión unboxing explícita.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se va a aplicar la conversión unboxing.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o la variable.Este nombre se emplea únicamente para depurar o imprimir.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Reduce el nodo y, a continuación, llama al delegado del visitante en la expresión reducida.El método inicia una excepción si el nodo no es reducible.</summary>
      <returns>Expresión que se está visitando o una expresión que debería sustituirla en el árbol.</returns>
      <param name="visitor">Instancia de <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Representa una expresión lambda fuertemente tipada como una estructura de datos en el formato de árbol de expresión.Esta clase no puede heredarse.</summary>
      <typeparam name="TDelegate">Tipo de delegado que <see cref="T:System.Linq.Expressions.Expression`1" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compila la expresión lambda descrita por el árbol de la expresión en el código ejecutable y genera un delegado que representa la expresión lambda.</summary>
      <returns>Un delegado de tipo <paramref name="TDelegate" /> que representa la expresión lambda compilada descrita por <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> del resultado.</param>
      <param name="parameters">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> del resultado. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Describe los tipos de nodo para los nodos de un árbol de expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Operación de suma, como a + b, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Operación de asignación compuesta de suma, como (a += b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Operación de asignación compuesta de suma, como (a += b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Operación de suma, como (a + b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Operación AND bit a bit o lógica, como (a &amp; b) en C# y (a And b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Representa una operación AND condicional que evalúa el segundo operando solo si el primer operando se evalúa como true.Corresponde a (a &amp;&amp; b) en C# y a (a AndAlso b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Operación de asignación compuesta AND bit a bit o lógica, como (a &amp;= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Representa una operación de indización en una matriz unidimensional, como array[index] en C# o array(index) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Operación que obtiene la longitud de una matriz unidimensional, como array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Operación de asignación, como (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Representa un bloque de expresiones.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Llamada de método, como en la expresión obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nodo que representa una operación de uso combinado de Null, como (a ?? b) en C# o If(a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Operación condicional, como a &gt; b ? a : b en C# o If(a &gt; b, a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Representa un valor constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Operación de conversión, como (SampleType)obj en C#o CType(obj, SampleType) en Visual Basic.Para una conversión numérica, si el valor convertido es demasiado grande para el tipo de destino, no se produce ninguna excepción.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Operación de conversión, como (SampleType)obj en C#o CType(obj, SampleType) en Visual Basic.Para una conversión numérica, se produce una excepción si el valor convertido no se ajusta al tipo de destino.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Representa información de depuración.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Operación de decremento unario, como (a - 1) en C# y Visual Basic.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Representa un valor predeterminado.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Operación de división, como (a / b), para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Operación de asignación compuesta de división, como (a /= b), para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Representa una operación dinámica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nodo que representa una comparación de igualdad, como (a == b) en C# o (a = b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Operación XOR bit a bit o lógica, como (a ^ b) en C# o (a Xor b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Operación de asignación compuesta XOR bit a bit o lógica, como (a ^= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Representa una expresión de extensión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Expresión "ir a", como goto Label en C# o GoTo Label en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Comparación "mayor que", como (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Comparación "mayor o igual que", como (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Operación de incremento unario, como (a + 1) en C# y Visual Basic.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Operación de índice u operación que tiene acceso a una propiedad que admite argumentos. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Operación que invoca un delegado o una expresión lambda, como sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valor de condición false.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valor de condición true.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Representa una etiqueta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Expresión lambda, como a =&gt; a + a en C# o Function(a) a + a en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Operación de desplazamiento a la izquierda bit a bit, como (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Asignación compuesta y desplazamiento a la izquierda bit a bit, como (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Comparación "menor que", como (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Comparación "menor o igual que", como (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Operación que crea un nuevo objeto <see cref="T:System.Collections.IEnumerable" /> y lo inicializa desde una lista de elementos, como new List&lt;SampleType&gt;(){ a, b, c } en C# o Dim sampleList = { a, b, c } en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Bucle, como for o while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Operación que realiza la lectura de un campo o una propiedad, como obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Operación que crea un nuevo objeto e inicializa uno o más de sus miembros, como new Point { X = 1, Y = 2 } en C# o New Point With {.X = 1, .Y = 2} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Operación de resto aritmético, como (a % b) en C# o (a Mod b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Operación de asignación compuesta y resto aritmético, como (a %= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Operación de multiplicación, como (a * b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Operación de asignación compuesta de multiplicación, como (a *= b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Operación de asignación compuesta de multiplicación, como (a *= b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Operación de multiplicación, como (a * b), que tiene comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Operación de negación aritmética, como (-a).El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Operación de negación aritmética, como (-a), con comprobación de desbordamiento.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Operación que llama a un constructor para crear un nuevo objeto, como new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Operación que crea una nueva matriz en la que se especifican los límites de cada dimensión, como new SampleType[dim1, dim2] en C# o New SampleType(dim1, dim2) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Operación que crea una nueva matriz unidimensional y la inicializa a partir de una lista de elementos, como new SampleType[]{a, b, c} en C# o New SampleType(){a, b, c} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Representa una operación de complemento bit a bit o de negación lógica.En C#, su equivalente es (~a) para los tipos enteros y (!a) para los valores booleanos.En Visual Basic, su equivalente es (Not a).El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Comparación de desigualdad, como (a != b) en C# o (a &lt;&gt; b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Operación de complemento a unos, como (~a) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Operación OR bit a bit o lógica, como (a | b) en C# o (a Or b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Asignación compuesta OR bit a bit o lógica, como (a |= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Operación OR condicional de cortocircuito, como (a || b) en C# o (a OrElse b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Referencia a un parámetro o variable que se define en el contexto de la expresión.Para obtener más información, vea <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Postfijo de decremento unario, como (a--).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Postfijo de incremento unario, como (a++).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Operación matemática que eleva un número a una potencia, como (a ^ b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Operación de asignación compuesta que eleva un número a una potencia, como (a ^= b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Prefijo de decremento unario, como (--a).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Prefijo de incremento unario, como (++a).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Expresión que tiene un valor constante de tipo <see cref="T:System.Linq.Expressions.Expression" />.Un nodo <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> puede contener referencias a parámetros definidos en el contexto de la expresión que representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Operación de desplazamiento a la derecha bit a bit, como (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Operación de asignación compuesta y desplazamiento a la derecha bit a bit, como (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Lista de variables en tiempo de ejecución.Para obtener más información, vea <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Operación de resta, como (a - b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Operación de asignación compuesta de resta, como (a -= b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Operación de asignación compuesta de resta, como (a -= b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Operación de resta aritmética, como (a - b), que tiene comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Operación de modificador, como switch en C# o Select Case en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Operación que inicia una excepción, como throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Expresión try-catch</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Referencia explícita o una conversión boxing en la que se proporciona el valor null si se produce un error en la conversión, como (obj as SampleType) en C# o TryCast(obj, SampleType) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Representa una prueba para comprobar la exactitud del tipo.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Comprobación de tipo, como obj is SampleType en C# o TypeOf obj is SampleType en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Operación unaria +, como (+a).El resultado de una operación unaria + predefinida es el valor del operando, pero las implementaciones definidas por el usuario podrían tener resultados poco habituales.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Operación de conversión unboxing a un tipo de valor, como las instrucciones unbox.any y unbox en MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Representa un visitante o un objeto de reescritura de árboles de expresión.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Envía la lista de expresiones a uno de los métodos de visita más especializados de esta clase.</summary>
      <returns>Lista de expresiones modificada, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de expresiones original.</returns>
      <param name="nodes">Expresiones que se van a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visita todos los nodos de la colección utilizando un visitante de elementos especificado.</summary>
      <returns>Lista de nodos modificados, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de nodos original.</returns>
      <param name="nodes">Nodos que se van a visitar.</param>
      <param name="elementVisitor">Delegado que visita un único elemento, reemplazándolo opcionalmente con un elemento nuevo.</param>
      <typeparam name="T">Tipo de los nodos.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Envía la expresión a uno de los métodos de visita más especializados de esta clase.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="nodes">Expresión que se va a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de la expresión.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para este nodo devolvió un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de la expresión.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para este nodo devolvió un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visita los elementos secundarios de la expresión de extensión.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
      <typeparam name="T">Tipo de delegado.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Representa un salto incondicional.Esto incluye instrucciones return, break y continue, y otros saltos.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Tipo de la expresión "ir a".Solo tiene fines informativos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> que representa el tipo de la expresión "ir a".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Etiqueta de destino a donde salta este nodo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa la etiqueta de destino para este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="target">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> del resultado. </param>
      <param name="value">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> del resultado. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valor pasado al destino o null si el destino es de tipo System.Void.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor pasado al destino o null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Especifica qué tipo de salto representa esta clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto a alguna ubicación.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Representa la indización de una propiedad o una matriz.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtiene los argumentos que se utilizarán para indizar la propiedad o la matriz.</summary>
      <returns>Colección de solo lectura que contiene los argumentos que se utilizarán para indizar la propiedad o la matriz.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtiene la clase <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</summary>
      <returns>Clase <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objeto que se va a indizar.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto que se va a indizar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Representa una expresión que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtiene los argumentos a los que se aplica el delegado o la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtiene el delegado o la expresión lambda que se van a aplicar.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado que se va a aplicar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
(     <summary>SePzesenta una etiqueta, q}e se puee colocar en cualquiur contexto de <see cpef="T:[ystem.\inq.ExPre3sions.Expression" />Si se salta a ella, obte.drá el valor propopcionado por da clase <see cRef="T:System.Linq.Expressions.GotoExpr%ssmol" /> correspondiente.De lo co.Trario, recire`E| valor de <see crf="P:Sys4em.Linq.Exprdssions.LabelExpression.LefaulpValue"!/>.Si <see cvef<"T:Ristee.Tye" /> es )gual a System.Void, no sd debe proporcionar nijgún valor.</qummry>
    </membmr
    <member name="P:System.Linq.Expressions.LabelExpres3ion.Defa5ltValue">
      <summary>Viloz de <see cref="T:System.Linq.Expressions.lbelExpression" /> cuando$se lea a0la euiqueta mediante el flujo de control normal (por ejgmplo, no se salta a ella).</summary>
      <retuvns>Obeto Expression ue represdnta el valor dE la0cLase <see cref="T:System.Linq.Expression3.labeLWxpression" />.</returns>
    </member>
   <membes nsme="P*System.Linq.Expressions.LabelExpression.NodeT}pe">(   $ <summary>Devuelve eltkpo de nodo de este objeto <see cref="T:System.Liq.Expressions.ExpreSsion" />.</su}mary>
      <returns>Enumeraci÷n <see gref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expzesión./returns>
    </member>
    <member name=P:System/Lin.Expsescions.LibelExpresc)on.Target">
     <su}mary>Clase <see!cref="T:Syrtem.Linq.Expressions.LibelTarget" /> a la qee etá asociada msTa"etaqueda.</summcry
 "    <returfs>Clase <see crEf="TSystem.Linq.MxprescIons.LabelTarget" /> A la que está asociada esta etiqueta</returns>M
   !</mEmber>
  ` <member name="P:Syste.Hinq.Expressions.LqfelExpression.type">
      <sulmarq<Obtiene el tipo estático de la axpresión que <see areb="T:System.Linq.Expression{.ExpressiOn" /> repbesenta.</sumoary>
      <revurns>
        <see creF="P:System.Lijq.EXpressions.LabulExpression.Type" /> que representa el tipo estático te la expresión.</returns>    =/member>    <memBer name="M:System.Linq.Expressionr&LabeExpression.Update(System.Linq.ExpressionS.LabelPargeu,System.Linq.Expressinns.Expsession)">
      <suomary>Crea una nueva exprusión que es como esda, peo esa l mlemento seaundario proporcaonado.i todos los elementos secundarios son igu!les, ddvolverá esta expresió~.</ummary?
      <returns>Esta expreqión sI no sg ha cambiado ningún elemeno secundario o unq ezpresióN con los elementos secundaris actualizados.<'returns>
      <param Name="target">Pznpiedad <see cref="P:System.Linq.Epressions.LabelExpression.Target" /> del resultado.</param>
      <param name="defaultValue">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Se utiliza para representar el destino de una clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtiene el nombre de la etiqueta.</summiry>
      <returns>Nombre de la etiquet.</returnc>
0   </Member>
    <member name=b:System.Linq.Expressions.LabdlTarget.ToStrInf">      <summary>Devuelvm una clase <see cref="T:system.Strkng" /> que repreqelta la clase <see cref="T:Systgm.Object" > Actual.</summar>
"     <returns:Una clase <see Cref="T:System.String"/> querepresenta ha clase$<see cref=bT:System.Object /> actual.</reTurns>
    </member>
    <iembr name=&R:System.Linq.Exrrer3ions.LabelTarget.Type">      <summary>Tipo de valor que se pasa al saltar a0la ediqueta (o <see cpef="T:System.VoId" /`si no se debe pasar ningún valor).</summ`ry>
      <returns>Objeto see cref="T:Systee.Type" /> que repres%nta!el tipo del vclor que se pasa al salter a la etiqueta g <see cref="T:System.Void" /> si no se debE p!sar ningún valor.<returns>
 0, </ember>
    <mem`er name="t:SysteM.Linq.Eppresshons.Lamb$aExpreqsion">
      <summaby>Describe una expresión lambda.captura un bloque de código similar E un$cuerpo de método de .NET.</summary>
    </member.
    <memb%r namm"P:Sysdem.Linq.Uxpressions.LambdExre{sion.Body">
      <summary>Nbtiene el cUerpo de la expresión lambda.</summary>
      <returns>       |see cref="T:System.Linq.Eypressions.Expressimn" /> que representa gl cuerpo de la expresió lambdq.</rmturns>    </memjer>
    <meme2 name}"M:System.Linq.Expreswions.LabdaEppressionnCompile">
   "  <summay>Genera wn delegadk que bepreenpa lq$expre{ión!mambda.<summary>
      <ret}rns>
        <see cre="T:Rystdm.Delegate& />0que0contiene la versión compilada$de la expresión Lambda.</returs>
    </member>
 $  >member name=#P:S9stem.Lanq.Expressions.LambdaExpbession.Nam%">
      <summaryObtiene el nombre de la expresión lamba.</summa2y>
      <retqrn36NombrE de lc expresión lambda.</returns>
`   </member>
    member naMe5":Sys4emLhnq.E8pressions.L`mbdaExppesson.NodedypE">
      <summary>Deuelve el tipo de n/do de ese objeto0<see cpef="T:Syctem.Linq.ExpRessionS.Expression"0/>.</summary>
      <returns>Enumeración <wee cref?"T:System.Linq.ExpRessions.EXprmssio~Type" /> que representa awTa exxresi÷n.</returns>
 !  </member>-
    <memrEvname="P:System.Lijq.Expre{riOns.LalbdaExpression.ParaMeters">
      <summary>Obtiene los pavámetros$de la exppesión lambda.</ummary.
      <returns>
        <see cref="T:Sstem.CollectioosnObhectModelReadOnlyCollection`1" /> ee objEtks <see cref="T:System.Linq.Gxpressionr.ParameterExpRes3ion" /> que representa os"parKmetros de la expresiãn`lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtiene el tipo de valor devuelto de la expresión lambda.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtiene el valor que indica si la expresión lambda se compilará con la optimización de llamada de cola.</suemary>
(     <returns>Es true si la expreqӳn lambda se"coopilará con na optimizació de llamada de coli; delo contpario, es false.</returns>
    </member>
    <mem`er name=":System.LInq.ExpresshOns.LambdaExprgssioo.Type">
   "  <summary>Obtiene El tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expressi/n" /> representa.</cummary>
      <returns>
     $  <see cref="P:Sstm.Linq.xpdssins.LambdaExression.y0e" /> Que representa en t`po estático de la expresión.</returns>
    </member>
    <membEr name9#T*Syste}.Linq.Expression{.LIstInitExpress)on"
      <summary>RepreSenta una llamada a un constructoR yue tiene un inicializadnr de colección></sum-ary>
    </member>
    <member name}"P:SyStem.Linq.ExprErsions.ListIniTExpression.CanReduse">
      <summasy>Obtien% un v`lor que indica si el"nod del árbol dm exprsión se(puede reducir.</summary>
     !,eturns>Esttrue si se 0uEde reducir el nodo; de lo contrario, gq false.</returns>	
   `</mumber>
    <member ~ame-"P:System*Linq.ExPressions.ListInitExpression.Initializers">
      >summaRy>Obtiene os inicializadores de elements que se uvilizaf para inicializar una colección.</sum}ary>
   `  <returns>U~o de los objevos <see cef="T:System.Co|lections.ObjectMofel.ReadOnlyCollection`1" /> de!<see crEf="T:System.Ninq.Expressins.EleientInit" /> qua pepbesenta~ los eleoentos qud se utilizan para inisializar la coleckión.,/returns>
    </member.
    <-ember name="P:System.Lin1.ExPressions.NistInitExqsession.NewEXpressin2>
      <summary>Obtiene"la expbeskón que coniane una llamada al Constructoz de un tipo le clesción.</summ`ry>
 ! "  <returns>
 )     !<see cref="T:System*Linq.Expressions.NeExpression" /> que representa la llamada al constructnr de un tipo de colección.<returns>
    </member>
    <mem"ur ncme="P:Sqstem.Linq.Exprdssionw.ListInitAxprecsion.NodeTQpe2>
      4summary>Devuelve el tipo de oodo de esve objeto <see cref="T:System.Lilq.Expresshons.Expresshon" />.</su-mary>
   $  <returls>Eumerasión <see cref="T:System.Linq.Gxpressions.ExpressionType"`/> que represdnth st expresión.</retu2ns>
$  0</membep>
 `  member name="M;System.Linq.Exp2ecsions.istInitExprassion.Reduke">
      <summary>Rueu#e el nodo de expresión Rinario a una expresión lás qenckllan</semmary>
     <retUrnsExpresióN redcida.</returns>
    </member>
    <mEmber name="P:System.Lynq.Expressions.L)stInitExprssion.Type">
      <summarx>Obthene el tipo estático!de la expresión que <see creg="T:System.Linq.Expvesrins.Epression" /> represdnta.</suMmary>
     <returnw?
 `      <3ee cr%f="P:Syspem.Linq.Expressions.LitInitExpressi/n.Type" /> yue!representa el tiPo estático de la expresin.</returns>
 0  </meiber>
    <member name=":System.Linq.Expressions.Li{tInitExpression.Update(System*linq*Exxressions.NewExpression,System.CollectionSGeferic.IEnuerable{SYsvem.Linq.Exp2essions.ElementInit})">
      <sumiary>Crea una nee6aeypresi3o0que es como esta, pero usa dl ele}ento secundario$prOporcon`do.Si0todos lgs eleientos sebundarios on agualms, dmvoverá esta expresión.</summary>      <returns>EstA expresión si no se ha cambiadm ningún elemento secundario o une expresión con lo3 elementos secundarios actualizadoS.</2%turns>
      <param name="newExpression">ProPiedad <see cref="P:Sstem*Linq.Exprewsions.ListInitExpreqsion.NewExpession" ->0del resumTado.|/p!ram6
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expres{ions.ListInitExpression.Initializers" /> dul resultAdo.</param>
    </em"er
    <member n@me="T:System.Lioq.Exqpessions.LoopExpression">
     <sUmmary>Rexresenta un bucle infin)to,Se(puede salir del miSmo con "break".</summary>
 "  </member?
    <me-ber name="P:System.\inq.Expressions.LkopExpressionBo&y">
      <summary>Obtiene a clase <seecref="T:Systgm.Linq.Expressions.Expression" /> que es el cu%rpo dul buc|e.</summaRy>
      <returnw>Clawe <see cref="T:System.Linq.Expressions.Expression" /> que es`el cuezpo dl bucle.</raturos>
 !  </mEMber>
    <member name="P:System.Linq.Expressions.LoorExpression.BreikLabel>
      8sUmmary>Obtiene la clase(<see crmn="T:System.Dinq.Exprersionq.LabelTarget""/> utilizada por el`cuerpo del bUcle co-o destino de ha!instrucci3f break.</summary>
$     <retuRnS>Clase <cee(cref="@:Cystem.Linq.Expsessions.LabelTarget""/> tiLizeda por ed cuerpo leL ucle!comn estinN"e lA instruacaón break></retuns>
    /member>
   "<mEmber neme="P:Systee.Lnq.Expressions.LoopExpresshon.CgntinueLabel">
     `<summary>jtieoe l! clase 4see ref-"T>System.Minq.xpressions.LabElTarget" /> udilizadi por el uurPo del bucle como0festino!de la instrucción contiua.</summary>
 "    <returns>Clase <sEe cref="T:Rystem.Linq.Eypressions.LabelTarget" /> utilizada por el cuerqo eel bucle como destino tela i~{trucción coninu.</returnc>
    <-ember>    <member name="P:SystamLinQ.Eypressionw.LoopExqression.LodeType">     "<sum}ary>Devwelve el tipo de nodo de esta exp2esiãn.Los nodos de extensaòn deben devol~er <see cref="F:System.Linq.Expressions.DxressionT9pe.xtenSion" /> cuado se rEemplaza dstD método.</summary>
      <returns>Obje|o <see cvef=0T:System.Lioq.Exp2essions.ExpressionType" /> de le dxpres)ón.</retrns>
 `` </member>
    <member name="P*Syste,Linq.Expressionr.LoopExpression.Type">(     <summary>Obti%ne el`tipm etático de la expresión que <seg cref=#T:System.Lknq.Uxpressiols.Ehpression" > reprecEnta.</summary>
  "   <2eturnr>
      <see0cref="P:System.Lin1.ExpressionsLoopExpressaon.Type" /. yue rexresenta el tipo eStático`de la ay8rdsión.</returns>M
 $  </melber>
    <}Ember name="M:System.Linq.Expressions.LOopExpres{ion.pae(System.Linq&Expressions.NabalDarget,Rystem.Linq.Expreqsions.LabelTarget,Syrtgm.Linq.Expressions,EhprEssion)"
      <summ`2y>Crea una nueva exppesión qwe s cmm/ esta, pero usa el elemento secundario proporcionado.Si todos los elementos secqndarios so~ iguales, devohverá esta expresión.</summary>
      <returns>Esta expresión si!.o se ha cambiado nigún elemento secundario o wna expresyón con lo3 elementos secunderios actualizados.</Redurns>
      param name="b2eakLabel">Propiedad =se% cpev="P:SystemnLinq.Expressions&LoopExpression.BreakLabel* /> del esultado.</param<     =param name"cmntinue\abeL">Propietad <see cref="P*System.Linq.Exprmssions.LoopExpression.ContinueLab%l" /> del resuLtado.-param>
  (   <param name="body"<PrOpieda$ <see cre&="P:SystenLinq.Expresskonc.LoopExpression.Body" '> del resultado.<param>
(   </member>
   !<mem`er name="T2System.Lioq.Expresions.MemberAssignmeot">
      <summabY>epresenta la puRación de as)gnaciónde un cmpo o propiedad de un objeto.</summary>
 !  </member>J    <memcer n`me="P:System.Linq.ExpresSions.MemberAssignmen4.UxpressiOn >
      <sumiry>Obtiene la expvesión que se asigna al campo o propiedad.</3ummary>
      <returns>
        <see cref="T:Qystem.Linq.ex`ressiona.Exprussion" /> que representa gl vahor que`se asigna al campo o propiedad.</returns>
  * </member>
    <memfer name="M:System.Lynq.Mxpressions.emberAssignment.Utdate(SysTem.Linq.Expressio.s.Expression)">M
      <qummari>Cve un! nu6a exppesión que es omo esta, perm usa`el elemento cecundario proporcaonado.SI todgs los elementos sdcundarios son iguales, devolverá esta mxpresión.</semmary>
     "8returfs>Esta expresión si no se`ha`caibiado ningún elemelt secundario o uNa expreqión con low elementos secundarios actualizados.</returns>
      <param name="expressimn">Propiead <{eecred="P:System.Linq.Expressions.MembebAssIgnment.Ezpressio." /> deL resultado.</p`rm>
    </membmr>
    -ember(name-":System.Linq.Expressikns.MembesBindkjg">
      <summay>Proporciona la clase bae de la"que erian las clase que repzesentan enlaces qee cg utilizan para inicialhzar mimmbros de un objetm recientemente crdaDo.<.summary
    <'me-ber>   "<member name="P:System.Linq.Expressions.MemberBinding.BindijgType">
      <summary>Obtiene el tipo de enlace que se repesent.</summary>
      returns>Un de los valores de <3ee ref="T:Systm.L)np.Exprersionq.MemberBindiNgType" />.|/returns>
  `</meber6
   `=member name="P:Sy{tem.Linq.Expressions.MemberBinding.Member"
     "<sumoary>Obtiene el campo o la$propiedQd quE se va a oicializar.</summa2y>
      ,Retuns>Objeto <see cref="T:System.Rmflection.MeiberInfo" /> que representa el b`mdo o la proPiedad que va a inicmelizrsa.</ret5rns>
    </member>
    <member name="I:System.Linq.Expressions.MembrBindijg.ToString">
     $<summary>Devuelve una representasión textual de <see ref=jT:System.Lhnq.ExpressiOns.MemfevBioding" /6.<-rummiry>M
      >retu2ns>Una repResentación tex4ual de <see cref="T:system.Linq.Exprescio~s.embmrBindilg" />.</retubns>
    </meeber>M
    <member name="T:System.Linq.Extressions.MemberBindingType">
    ( <summary>Descpibe los(tipos de enlace que qe utilizan en obnetos <see cpef="T:System.Linq.Exprescions.IemberIitExqression" />.=/sulmary>
    </member>
    <mmmrgr name="F:Syspem&Linq.ExpresSions.MemberBindingTyqe.Assignment">
      <summary>Un enh!ce que representa0la inicialización0de un miembro con el valor de(una expresión.<summary>
   8/membur>
    <member jame="F:Systel/Linq.Expressions.MemberBintingType.DstBineing">
      <summaryUn0enl!ce que representc la inicializaamón de un miembro de tipo 8see cref?"T:System.Cl|ections.IList" o: o <see craf}"T:Sytem.CollEc|ions.Genaric.ICollection`1" /> de una lista de elementos.</suoaRy>	
 $  </-mmber~
    <ember name="F:Syctem.Linq.Expressions.MelbdrBindingype.MembdrBindang">
      <summary>Un ennace que represmnta la knicialización`de forma recursiv!$de los miembro{ dm un miemBro./s5mmary>
    </member>
    <mum"er name="T:y{tgm.LinqExpResionr.MemberExpression">
0     8summay>Represdnta el acceso!a un campo o propiedad.=/summary>
    </-ember>
    <melBer name5"M:System.Linq.Exprasshons.MemberExpressioj.Acce`t(System.Linq.Exxressions.ExpressionVisitor)2>
      <sumeary>Envía la expresin ad étodo de visita espeb-fico de estgtipo $e nodo.Porejemplo el objeto <see cref="T:System.LinqExpressions.MethodCallxpzEssign" /> llama al método <see cref="M:System.Linq.Exprssions.ExprassionVisitornVisitMethodCall(Systum.Linq.Expre3s)ons.MethodCallExpresshon)" />.</summary>
      <re|urns>Resultado0de viwitar es|e oodo.</retupnq>
 0  $ <param name="visitor">Vasitante con el qua se va ` isitar ese nndo.</param>
    </member>    <membr name="P:SystemnLinq.Expressions.MemberExpression.Expressio">
!     <summary6Obtiene el objeto Cont%neDor del campo o 0ropieead.</summery>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto contenedor del campo o propiedad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtiene el campo o la propiedad a los que se va a tener acceso.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad a los que se va a tener acceso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcikndo.Si tofos los elementos secundarios skN igeales,`devolverÁ esTa mxresión.</summarz>
(     <returns>Esta expresión sI no se ha cambiado ningún eleiento sucuodario o una expresión con los uhementos secundarios actualizados.</returns>
    " <param name="expr%ssioj">Propie`ad <Sed(cref="P:S{Stem.Linq*Expressions.MemberExpreS{ion.Expression" /> del resultaeo.</param>
    </mmber>
    <membe namm="T:System.Linq.Expressions.MemberInitExprassion">
      summery>Representa la llAmada a un conk|ructor y la iniciaización de`uno"omás miembros del nuevo o`jeto.<sumary>
    </member>
0   <member name="P:System.Linq.Ehpressons.MemberInitEzpresson.BindiNgs">
      <summary>Obti%ne nos enlaces que describen cómo inIcializar hos miembros del objeto recientemente creado.</s}maby>-
      <returns>Una colección <see cref}"T:Systum.Colmections._bjecdModel.RdadOnlyGoLlection`1" /> de ls objetos <see crgf="T:System.Minq.Expressions.MemberBindkng" /> que describen cǳmo`iNi#ializar ls miembros.</returs>
    </member>
 "  <member name="P:System.Linq.Gxdressions.memberInitExpression.CanSeduce">
 "    <summary:Obtiene un valor que Indica sk al nomo del Crbol de expresión se puede reduc)r.</summary>
    0 <returns>Es True si(se puede reducir e nodo; fu lo contr!rio, es false.</retur~s>
    </member>
    <me-be name="R:System.Lhnq/Expressions.MemberInItExpression.NewExpressign">
      <summary>Obviene la expresión que representa la llamada al constructor></summary>
      <returns>
        <see cref="T:System.Linp.Expressions.NewExpRession  /> que reprusEnta la llamata al constructor.</returns>
    </member>
    <member namg="P:System.Linq.Expreqsions.MemberInitAxpression.NodeType">
      <sumMarxDevuedve el tixo de nodo de esta eppresiǳn.Los nodos de extensión deben Fevolver <wue crgf="F:System.Lknq.Axpresskons.ExpressionT{pe.Extension" />cuando se!reemplaz! ste método.</summary>
      <vettrn>Objeto <see cbef="T:System.Linq.Expressions.ExpressionType" /> d la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Reduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, fevol6erá esta dxpresión.<summary>
      <rturns>Esta expresión si No se ha cambhaDo ningún elementm sec}ndrio o uni expresión con tos elementos secuntaros actualizados.</returnc>
    ! <param name="nevExprgssion">Propiedad <see cref="P:System.Linu.Exprersions.MembeRInitExpression.NewExpresrioN" /> del resultado.</param>
      <param0name="bildings"PropiedAd <See cref="P:System.Linq.Expressions>MemberInitExpression.Bindings" /> del resUltado.</param>
    </mmber>   $<eembdr name="T:System.inq.Exprgssins.MemberListBinding">
    ` <summary>Retresenta la inicializac)ón fe mos elementos de wn miembro d colección de un objuto que s% ccaba de crear.<-sumary>
    </mgmber>
    <member name=2P:System.Linq.Expressions.MemberHisBinding,Initialazers">
      <summary>Obtiene$los iniciahizadores de elemento para inicializar un miembro de@colecció~te un!objetg que`se acaba de creab.</summary>
      <retUns>
        <see crgf="T2System.Collecthons.ObjectModel.ReadOnlyCgllection`1" /> de o`jetos <see bref="T:SysTeo.Linq.Expressions.ElementInid" /> con que se inicializa un miembro de colección.</returns>
  " </membes>
    <mambar name="M:System.Linq.Expressions.MemberListBinding.Updatg(Cystem.Collections.Oeleric.IEnumeraflesSystemnLinq.Expressions.ElemEntInit})">
      <summary>Crea una nueva expresi²n$que ew como esta, p%ro usa el alemento se#undarho propor#ionado.Si podos los elemenos secundaros son hguales, devolverá"esta expr5sión</summary>*      <returns>Esta expreSióN si no se h cambiado ningún"elemen4o secundario o unA expresh÷n`con los elementos secundarios actualizaeos.</returns>
      <param name-"initializerc">PropiedAd <see crdD-"P:Systgm.Linq.Exp2essionS.MemberListBinding.Initializers" /. del resultado.</param>
    </member>
`   8membeb name="T:System/Linq&Expressinns.MemberMemberBinding">
      <summar>ReprEsenta la inici`lización fe los$maembros dE un miEmbro de un objeto que se acaba de crear.</summary>
   (</memjer>
    <member name="P:Systee.Linq/Expressions.MemberMemberBinding.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros de un miembro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros del miembro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Representa una llamada a un método estático o un método de instancia.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:systemLinq.Expressions.ExpressionVisitor.VismtMathodCall(System.Linq.EXpressions.MgthodKalExpression)" '>.>/summary>
      <retens>Rusultado de visitaR este nodo.</returns>
    0 <param name="visitor">Visitante col el pue s va a vicytar0este nodo.</param>
    <member>* 0  <amber name="P:SyStem.Linq.Expressions.MetjodCallExpression.ArgumenTs">
     <summaryObtiune una colecciój de expresiooes que$representin los argumentos"del mévodo invocado.</summary>
      <returns>Uno <wee cref="T:System.Collections.ObjectModeL.ReadOnlyCollection`1" /> de los /BjEtos <see crdf="T:System.Linq.Expressmons.Expression2 /: que repreqentan ls argumetos del método llamado.</retur.s>
    </member
    <member namf="P:System>Linq.Expresrions.MmthOdCallExpres3Ion*]etHod">
      <summary>Obtaene el objeto <see cref="T:System.Reflection.MethodInfo" /> del método al que se va !!,lam`r.<?summary>
      <reuubns>El objeto <see cref="T:System.Reflectyon.Me|hodI.fo  /> que rerrEsdnta el método llamado.</zetqrns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtiene el objeto <see cref="T:System.Linq.Expressions.Expression" '> que represdnta la instancia para lama`ac a métodos de instankia o null para llamadas a mtodos estáticos.<.su}m`ry>M
      <returns>Objeto <see cref="T:System.Lhnq.Expressions.Expression" /> que(retresenta al,objeTo receptor del método.<returns>
    </member>
" (!<member namu="P:SysTem.Linq.Expressions.MethoDCallExprgssion.System#Dins#Exprassio.s#IAgumentProvider#ArgumentCount"></mEmber>-
(   <member name="M:Sstem.Lina.Expressions.MethodC),lGxpression.System#Linq#Expressions#YArgummntProvider"GetArgumenf(System.Int6)"></member>
   <membername="P:Rys|emnLinq.Expressions.MethodCllxression.Tyte">
      <sulmary>ObtienE e tipo Estático de la exprdsión que <see cref="T:System.Linq.ExprgssionsnEzprdssion" /> represent`.</summary>
      >returls>
        <see cref="P:[{wtem.Linq.Exressions.MetodCalExpression.typd" /> que rmprasenta el tipo estático de la expresión.</ruturns>
   !4/member>
    =member naee="M:Sysem.LInq.Expressions.MgthodCcllExpression*Update(System.Linq.Expresqons.Expressin,System.Collections.Genepic*IEnumerable{Wystem.Lhnq.ExpreSsions.ExpressiOn})&>
      <sum}ary>Crea u.a nueva expresIón que es como eSta, qero usa el elemento secenDario Proporcionado.Si todos Los elementos0secumdarios son iguales, devolverá esta e8presi÷n.</summary>
      <rgpwrns>Esta exprEsiCn si no se ha cambiado ninfún elemento secundirio o una exprEqi3n con los0elementos secundaros!aktUalizados.</returns>
   $  <parae naie="object">Propiedad 4see cref="P:System.Linu.Exprussions.MethodCallExpre3shon.Object" /> del resultaDo.</param>
      <pasal name="arguments"~Propiedad <see cref="P:System.Linq.Expressions.MetoGa,dExpression.ArgUments" /> del resultado&</param>    </member>
    |member name="T:Syctem.Linq.Expressions.NewArrayExpression">
      <summ!ry>Represejta cveando una nueva matriz y posibleme.te inicxalizando ,os elementos de la nueva mepriz.</rummary>-
  ( /membgr>
    <member name"M:System.Linq.Extressions,NewArrayExprmssion.Accupt(System.Linq&Expressions.ExressionVisior)&>
      <summary>E.vía la expresión al método de visita!específico dm este tmpo de nodo.POr ejemplo, el objet <cee cref="T:system.Lknq.Exprecsions.MethodCallExpression"(/> llama al método <sue cref="M:Qystem.Linq.Expressions.ExpresqionVisitov&VisitMethodCall(SxstemlMinu.E|presSions.MethodCallExression)" />.</Summary>      <retuns>Resltado de vi{itar este nodo.</returns>
      <parai name=2visitor">Visit!nte con el que sE va a visitar es|e nodo</peram>
  ! </member>
    <mEmber!nAme=">System.Linq.Express)ons.NewArrayExpressinn.ExpressiOnc".
     (4summary>Obtiene l/s límites de la matrir si el valor de la proidad <em cref=":Sys\em.Linq.Expressions.Expresskon.NodeType" /> es0<see czef="B:SystemnLinq.ExpRdssio~s.ExpressionType.NewArr`yRounds" /.,  los vaors$para inicialyjar los elementos de la nueva matpkz sy el!vaor"de la!propiedAd <see cref="PSysudm.Linq.Expressions.Expressin.NmdeTyte" />!es <see cref="F:System.Lijq.E8pressions.ExpressionType.NeArrayInitb />.</s5mmary>
      <returns>Un objeto <see cref="T:System.Collectimnw.ObjectModel.RuadKnlyC/llection$1& > de los objdtos <see cref="T:Sy{tem.Linq.Ehpressions.Ehpreqsion" /> que repvesentan los límites de ,a Mqtriz o los valores de inicialización.</returns>
    </member:
    |memBer name="P:ysvem.Linq.ExpressioncNewArrayExpressiol.Type">
  !   <sumiary>btiene el ipo%stӡtico de la exprdsión qu% <see cref="T:Syspem.Linq.Expressions.Expression" /> berresenta.>/s5mmary>
      returns>
        see cref="P:Sy3tem.Linq.Expressions.ewArrayExpressionType"0> que rpresenta el tipo estátiao de la expesiól</returns>-
    </member>
    <member name="M:Systdm.Linq.Expression.NewArrayExpressiOn.U0datg(System.Collections.Genesic.IEnumerableyQystem.Linq.Expressions.Exprescion})">
 `    <summ!ry>Crea una nueva expresión que es comn0estA, pero usa en mlemento secundario propoRcionado.Si vodos los elementos 3ecundari{s son igualu, devolverá esta expresión></summary>
      <returns>Esta expresión si no"se ha cambiado ningún elemento sEcundcpio o una ezpresin con los elemejtos sdcundarios actualizados.</return3>
      <param name="expressions">Propiedid <see sref="P:System,Linq.Expressions.NewArpayExprassion.Exprmcsio~s" /> del resultado.</param>
    <-member>
    <member name="T:SystemLmnq.Aypressions.NewExpression">
      8summazy>Representa un! llamada de constructor.</Summary>
    </membdz>
    <member name="MzSystem.Linq.Ehrressions.NegExpression.Accapd(System.Linq.Expressions.ExpressionViSitor)"
      <summary>Envía la expresión al método d% visita espegífico de este tipo de l/do.Pr ejemplo, el objeto <see0cr%f="T:System.Lins.Expressions.MethodCallExpression" /> llama al }étodo <see crmf="M:System.Linq.Expressioq/ExprEssionVisiuos.VisitMethodCall(Systum&LInq.Extressions.MethodCallExpression)" />.</summary>
  ( ! <returns>Susultado de(visitar este nodo.</returns>
      <param nam%="visitor">Vistante con el qug sd va a visitar este noho.</paraM>
    </oember>
    <member name="P:Sysvem.Linq.E8pressions.NgwExpressiol.Arguments">
      <summary>Obtiene loc argumentos para el construcTor.</summarx6      <returnc>Una colección de ojjetos <see cref="T:System.Linq,ExpRessions.Exprersion" /> que representan los argu}entos para eL constructmr.</returns>
  ` </membEr>
   <member naoe="P:System.Linq.Expresskon.NewExpression/Construcpor">
      |sumlary>Obtiene el!constructor al que se llama*=/summary>
      <veturns>
 `      <see cref="T:System.Reflection.ConstructorInfo" ' qug representa en constbugto2 al qu`se llama.</retu2ns?
    </melber>
!   <member`na}d="P:System.Linq&Expbeswions.NuwExprassmon.Eembebs">
      <summary>Octhene lms miembros"que pueden recuperar los valores te los campos que se inicializaron con arwumentoS de construcTor.<-summry>
      <retupns>Una`colección de objgtos <see cref="T:System.Reflecthon.MemberHnfo" /> que repreejtan l/s miembros que pueden rcupebar hos valores de(los campos pue s inicializaron coN crgumentos de conspructor.</retqrns>
    </member>   $<member lame"P:System.Linq.Expressions.NewExprgssion.NodeUype">
"     <summary>Devuelve el tipo de nodo de este objet/ <see cref="T:System.Linq.E8pbessio.c.Expression" />.</summarY>      <returns>Enumeración <seu cref="T:SysTem.Lin.Extressions.Ex0ressionType" /> que representa"estc expresión.</ret}rns>
    </member>
  0 <mem er name="P:System.Lin.Expressions.KdwExpression*SystEm#Linq#Expressions#IArgumentrovider#ArgumentCoUnt"></member>
    <member name="M:System.Linq.Exppessions.NewExpr%ssion.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Representa una expresión de parámetro con nombre.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica que esta clase ParameterExpression se va a tratar como un parámetro ByRef.</summary>
      <returns>Es true si este objeto ParameterExpression es un parámetro ByRef; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtiene el nombre del parámetro o variable.</summary>
      <returns>
        <see cref="T:System.String" />. que contiene el nombre del parámetro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expresión que proporciona permiso de lectura y escritura en tiempo de ejecución para variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables o parámetros para los que se va a proporcionar acceso en tiempo de ejecución.</summary>
      <returns>Colección de solo lectura que contiene parámetros para los que se proporcionará acceso en tiempo de ejecución.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Representa un caso de una clase <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtiene el cuerpo de este caso.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque de casos.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtiene los valores de este caso.Este caso se selecciona para su ejecución cuando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> coincide con cualquiera de estos valores.</summary>
      <returns>Colección de solo lectura de los valores para este bloque de casos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="testValues">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Representa una expresión de control que administra varias selecciones pasando el control a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtiene la colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" /> del modificador.</summary>
      <returns>La colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtiene el método de comparación de igualdad, si existe.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de comparación de igualdad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="switchValue">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del resultado.</param>
      <param name="cases">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del resultado.</param>
      <param name="defaultBody">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Almacena información necesaria para emitir información de símbolos de depuración para un archivo de código fuente, en particular el nombre de archivo y el identificador de idioma único.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Devuelve el identificador único del tipo de documento, si existe.Tiene como valor predeterminado el GUID para un archivo de texto.</summary>
      <returns>Identificador único del tipo de documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nombre del archivo de código fuente.</summary>
      <returns>Cadena que representa el nombre del archivo de código fuente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Devuelve el identificador único del idioma, si existe.</summary>
      <returns>Identificador único del idioma.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Devuelve el identificador único del proveedor de idioma, si existe.</summary>
      <returns>Identificador único del proveedor de idioma.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Representa un bloque try/catch/finally/de errores.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtiene la colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</summary>
      <returns>Colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del resultado.</param>
      <param name="handlers">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del resultado.</param>
      <param name="finally">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del resultado.</param>
      <param name="fault">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Representa una operación entre una expresión y un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtiene el operando de la expresión de una operación de prueba de un tipo.</summary>
      <returns>Un objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la expresión de una operación de prueba de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtiene el operando de tipo de una operación de prueba de tipo.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el operando del tipo de una operación de prueba de tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Representa una expresión que tiene un operador unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir un nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es true si el nodo representa una llamada elevada; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores null.</summary>
      <returns>Es true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación unaria.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtiene el operando de la operación unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la operación unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduce el nodo de expresión a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="operand">Propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del resultado.</param>
    </member>
  </members>
</doc>