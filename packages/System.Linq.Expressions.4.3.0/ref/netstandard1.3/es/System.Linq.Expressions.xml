<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <typeparam name="T">Tipo del contenido del origen de datos.Este parámetro de tipo es covariante. Es decir, puede usar el tipo especificado o cualquier tipo que sea más derivado. Para obtener más información sobre la covarianza y la contravarianza, consulte Covarianza y contravarianza en genéricos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se especifica el tipo de los datos.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtiene el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a este objeto.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtiene el árbol de expresión que está asociado a la instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que está asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtiene el proveedor de consultas que está asociado a este origen de datos.</summary>
      <returns>El objeto <see cref="T:System.Linq.IQueryProvider" /> que está asociado a este origen de datos.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se conoce el tipo de los datos.</summary>
      <typeparam name="T">El tipo de los datos del origen de datos.Este parámetro de tipo es covariante. Es decir, puede usar el tipo especificado o cualquier tipo que sea más derivado. Para obtener más información sobre la covarianza y la contravarianza, consulte Covarianza y contravarianza en genéricos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Define los métodos para crear y ejecutar las consultas descritas por un objeto <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TElement">Tipo de los elementos del objeto <see cref="T:System.Linq.IQueryable`1" /> que se devuelve.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta fuertemente tipada representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TResult">Tipo del valor que es el resultado de ejecutar la consulta.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Representa una expresión que tiene un operador binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo del árbol de expresión; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtiene la función de conversión de tipos utilizada por una operación de uso combinado o una operación de asignación compuesta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa un tipo de función de conversión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es true si el nodo representa una llamada elevada; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores NULL.</summary>
      <returns>Es true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtiene el operando izquierdo de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo de la operación binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación binaria.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtiene el operando derecho de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho de la operación binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="left">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del resultado. </param>
      <param name="conversion">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del resultado.</param>
      <param name="right">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del resultado. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Representa un bloque que contiene una secuencia de expresiones donde se pueden definir variables.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtiene las expresiones de este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las expresiones de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtiene la última expresión de este bloque.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la última expresión de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del resultado. </param>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del resultado. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtiene las variables definidas en este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las variables definidas en este bloque.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Representa una instrucción catch en un bloque try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtiene el cuerpo del bloque catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtiene el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtiene el tipo de <see cref="T:System.Exception" /> que este controlador captura.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de <see cref="T:System.Exception" /> que este controlador captura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variable">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del resultado.</param>
      <param name="filter">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtiene una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Representa una expresión que tiene un operador condicional.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtiene la prueba de la operación condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba de la operación condicional.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="test">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del resultado.</param>
      <param name="ifTrue">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del resultado.</param>
      <param name="ifFalse">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Representa una expresión que tiene un valor constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtiene el valor de la expresión constante.</summary>
      <returns>
        <see cref="T:System.Object" /> igual al valor de la expresión representada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Emite o borra un punto de secuencia para obtener información de depuración.Esto permite al depurador resaltar el código fuente correcto al depurar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de código fuente.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtiene la columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtiene la línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtiene el valor para indicar si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se utiliza para borrar un punto de secuencia.</summary>
      <returns>Es true si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se va a utilizar para borrar un punto de secuencia; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtiene la columna inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtiene la línea inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Representa el valor predeterminado de un tipo o una expresión vacía.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Representa un inicializador para un elemento único de una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtiene el método de instancia que se utiliza para agregar un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Un <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtiene la colección de argumentos que se pasan a un método que agrega un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Uno de los objetos <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos para un método que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Devuelve una representación textual de un objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Devuelve una representación textual del objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Proporciona la clase base de la que se derivan las clases que representan los nodos de árbol de expresión.También contiene métodos de generador static (Shared en Visual Basic) para crear los diversos tipos de nodo.Esta es una clase abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Crea una nueva instancia de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Vasual Baric9, o no toma eyactamente os argumentos.<.exCeption>
   "  <exception cref="T:System.InvammfOperationException">
        <paramref name="m%thod" > e nu,l y no se defin% e operador de {uma para <paramref n!me="|eft" />. Tipo y <pabamref name="right" />. Tipo.</exceptyOn>
    </mdmber>
    <eember name="M:System.Linq.Expresckons.Expression.AddAssiGn(S{stem.Linq.expressionq.ExpressionnSystem.Linq.Expressions.ExpressiOn)">      <summary>Crea un objetn <se cpef= T:System.Linq.Expression*BinaryMxpresqion" /> que`repres%nta una oreración D% asignación de Sqma que no tidne comp2obacin de desbordamiento.</summary>
      <returnw>        <see cre&=bT:Qystem.Linq.Exprdssions.BinaryEXpresshon" />"cuya proxiedad <see cref="P:Sy3tem.Linq.Expressi/ns.Exqression.NodeType" /> es <ee cref="F:System.Linq.Exprdssions.ExpressionTy`e.AddAssign" /| y cuyas pRopiedades <see cref="P:System.LiNq.Expressions.BinaryExpression.Lgt" /> y <ree cref="P:System.Linq.Express)ons/BinaryEhpression.Rifht" /> se esuableun en los valres especificados.</eturns>
      <param name="lEft">Objeto <see cref="T:Rystem.Lifq.Expressions.E8press)on" /> en dl`qu% se va a establecer la prmpiedad <see cref="P:System.Lmnq.Expressions.BinaryExpression.Left" />.</pazam>
      <param name="riohT">Objeto <See$cref="T:System.Linq.DpPressions.Exprerion" /> en el que se va a establecer la pso`iedae <see cref="P:System.\inqExpressmon.BinaryExpression.iglt  />.</qaram>
    </member>
   `<member name5"M:System.Linq.ExpressionsnExpression.AddAssign(Sstem.Linq.Expresshons.Expression,System.Linq.Expressiols.Expression,ystem.Reflection.MethodInfo)">
      <summary>Crea unobjtO <see cref="T:System.Linq.Uxprussions.BinaryExp2essio" /> que zm0re3enta una operación0de aqiga#ión de suma que no tiene"comprObación de desbordmien|o.</summary>
    " <retqrls>
        <see cref="T:systi.Linq.Exprgssions.BinaryUxpression" /> cuya propelad <seu cref="P:Syqtem.Hknq.Expressimns.ExpressionnNode\ype"0/>"es <see cref="F:Sys|em.inq.Expressions.ExpressionType.AddAssign /> y <ree cref="P:Systm.Linq.Expressions.BmjariExpression.Ledt" /?, <see cref="P:System.Linq.Expressionw.BinarMxpression.Rigxt" /6 y <see cref="P:Systel.Milq.ExpressionsBinaryExpression.Mdthod" /> {e establecen en los alores especificados.</returfs>
   0  <param Name="left">Objeto <see cref="T:System.Linq.Expressionc.Expression" > en el que se va a establecer la proqiedad <qe cref="R:System.Lmnq.Expressiols.BknaryExprescion.Left" />.</param>
      <param name="rivht">Objet <see cre&="T:System.Linp.Expressions.Expression" /> en el que se va ` esteblecer lc pbopi%dad <see cpef="P:System.Linq.Expressions.BinarExpressio..Right" />.</peram>
      <pcram name="method".
        {ee0gref="T:System.Ref,ektion.MethgdInfo" o~ go$el qu sm vi a establecer la propigdad <see cref="P:System.Lhnq.Expzessyons.BinaryExpreSsion.Oethod" />./4ajam>
    </member>
    <member name="M;System.Linq.Gxprassions.Expression*AddAsskgn(System.Linq.Uxrressions.Expvession,System,Linq.ExqresionS.Expression,SystemnReflecdion.MethodInfo<Rystem.Linq.Expressions.LambdaExpvecsion)">
      <summary>Crea un objeto <see creg="T:System.Linq.Expressyons.BioaryGxprecsion" /> que zeprgsenta una operacmón de"asigneción de suma!que no tiene$comprbciCo de desbordamiento.</sum-aRy>
      <2eturns>
    "   <see cref="T:System.Lmnq.Ex`re3sions.BinaryExpzession"/> cuya$propiedad <see crdF="P:System.Linq.Expressions.Expression.NodeType" /> es <ree cref="F:System.Linq.Expressions.ExpressionType.AddAssicn" /> y <see cref="P:Systum.Ninq.Expressign.BinaryExprassion.Left" />, <see cref="P:System/Linq.Uxpressions.BinaryExprgssion.Vight" />, <see cref="P:System.LiNq.Expressho.s.Finaryxpressign.Method" /> y see cren="P:System.Linq.Expressions.Bi~aryExpreSsion.Conversion" /> se estaflecen en los valores espdcificad/s.,/2e|urns>"     <pir!m name<"laft">ObJgTo <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a estab,ecer la propiddad <see cref9"P:System.Linq.Expressions.BinasyExpreswion.Left" />.</param>
    ! <pabam(name="right">Objeto |see cref="T;Systel.Lmnq.ExpresSions.Expression" /> en elque se va a establecer la propiedad <see cpef"P:System,Lhnq.E8pzeSqions.BinaryExpressiOn.Rieht" >.</paRam>
   "  <paral name="method"~	
       <see cRef="T8System.Peflectmon.MethodInfo /> en el que se va a establecer la propiedad 8see cref="PSyctam.Linq.Expressions.BinaryExpress)on.Method" />.</param>
      <parqm name="conversion">
        ,see #ref="\:Sys|em.Linq.mxpres3ionS.LambdaExpsession /> en el que(sg V!$a establecer la tz/piedad <see cvef="P:Sysem.Linq.Expressions.BinaryExPression.Cmlvepsion" /?,</Parao>    </member>    <member nme="M:SystumLinq.Expvessions.Exp2essyo.AddAsrigoChecked(System.Linq.EypressionsExprdssion,System.inq.xpressions.Expression)">	
      |summary>Crea Un objeto <sew cref="T:System.Din1.Expressions.BinarqExpr%ssion"!/>!que bgpresenta una operaci÷n e$asignación de!suma1ue tiene comprobación de desbordamiento.</semmary>
      <returns>
    !  !<ee cref="T:System.\inq.Expreswions.BinaryExpres{ion" / cuya xrmpiedad <sfe cref="P:System.Linq>Exprdssions.Expressiof.NodeTypd" /> es <see cRef="F:System.Liy.Expressions.ExpressionType.Q$dAssignChecked" /> y cuxas propyedades$<see crev=#P:Syst%m.\inq.Epppessions.BinaryExpressi/n,Left" /> y see cref="P:S}stem.Linq.Expressions.Binar}Expession.Rig`t" />(sd establecen en los valores dspecificados.</returns>
!   ` <param name="lef|">Objetn <see cref="T:Sstem.Linq.GxpressonS.Expr%s{ion" /> en ml"que$qe va ! astablecer la propiedad <see cref="P:Cystem.Linq.Expressions.BinaRyExpression.Left" />./param>
      <paraM name="right">Obje4o <sGe cref="T:S{s|em.Linq.xpzessyons.Expression" /> en el quE se vA a establecer la propiedad <see creF="P2System.Linq.Expreswion.inaryExpres3hon.Right" /6.</param?
    </member>
   $<member namd="M:s{stem.Linq.Expressions.Expression.SddAssignChecked(Sy3tem.Lanq.Exrressions.Expression,System.Linq.Exprmssimns.Expression,System.Reflectikn.MthodInfo)">
      <summasy>Crea un"objeto <see cref="T:S9stem.Linq.Express+ons.BinaryExpression" />`qu% reprusenta una operacyón de asignaciónde wuMa que tiena comprobación de desbobdamiento.</summ`ry~
      <reuurns>
        <see cref="T:System.Linq.Expressions.BioaryExpressikn" /> cTya ropieda$<see crf="P:Syste-.Lins.Expressions.Expression.NodeType"/> es |see bref="F:Sy3tem.Lknq,Expressions.ExpressionT}pe.AdtAssignCxeckdd" >  see cref9"P:System.Linq.ExpZessions.BinariExpression.Left" />, <se Cref="P:System.Linq.Expressions.BinasyExpressimnnRyght" /> Y <see cref"P:system.Liny.Expressionq.BinayExpression.Method" /> se establecen en os valores especificados.</return3>
      <param ~ame="lmft">Objeto <see cref-"TSywteM.inq.Expressions.Exprecsion" />$en el qud {g va a e2tablecer la prop)edqd <see cref="P:SystemLinq.ExPpessiofy.BinaryExprassion.Left" />.</param>
      <paa`name="right">Objeto <3ee!cref="T:SY3|em.Linq.Exqresions.Expressyon& /> e. e| que {e va a ertablecer la propiedad <se crd="P:System.Linq.E|psessions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:SYstem.ReFlection.MethodInfo" /> en el que se ra a`esTblecer la propiedad <see cref"@:System.Linq.Expressions.Bi.aryExpre{sion.Method" /></param>
    </member>
    <membe name-"M:Syst%m.Lmnq.Expressions.Expression.AddAssignCjecked(System.Lanq.Gxpressions.ExxressionlVystem.Linq.Expressins.Expression,Systel.Ruf|ection.OethodKnfo,S}stem.Linq.Eypzecsaons.LambdaExpressimn)">
   (  <s%m}ary>Crua un objeto <see!cref=":System.Linq.Exqresions.inaryExpres{ion" /? qUe representa una Oqerció de"asignaió de`quma que tiene comprbaciCn de desbkrdamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Express)ons.BinaryExpression"$/> cuy propiedad <see cref="P:System.Linq.Expressions.Gxpresqion.NodeType" /> es sae cref="F:System.Linu.Expressions.ExpbesskonType.AddassignChecked" /> y <see#ref="P:System.Lin3.Expressions.BinaryExpressionLeft" />, <see cref="P8S}s|em.Linq.ExpressIons.BiaryExpression.Right"!/>, <see sref="P:System.Lanq.Expressions.BijaryAprersion.Method" />$y <qee cref="P:System.Linp.Expressions.BinaryExpression.Conversion"(/> se esablecen en los valore{$dspecificados.</retqrjs>
  `  !<paraM name="left">Objeto <see kref="TSystem.Linq.ExpressIons.Expressign" /> en el$qu se va a eStablecev la0prpiedad <see cref}"P:System.Linq.Expressionw.BinaryExpression*Left" />.</param>
      <param nem%="right"~Objeto <see cref9"T:ystem.Linq.ExPressions.ExpresSion" : n el que se va ieut`blecer la propiaad <See cref="P*System.inq.Expressions.Bi.aryExpression.Zght""/:.</param>	
      <param fame="method">        ?see cref="T:System.Ref,ection.MethodInfo" /> en el q5d se va a establecer la prpiedad!8see cref2P:System.Lins.Expressions.BinaryExpression.Method"/>.<?psam>    ! <param name="conversion">
$   `   <see cref="T:Syqtmm.Linq.Expressions.LambdaExpreswion" /> en gl que se va a esta"lecer la propied`$8see cef="P:System.Linq.Exprgssions.BinaryexPre3sion.Conversion* />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Addhcked(Systam.Linq.Expressions.Ezpression,Syw!m.Linq&Ezpressions.Expression)">
      <summary>Crea un objeto <seE cbef="T:SystemLioq.Ehpressionr.inaryExress/n" /> que representa una operación!de suma qritmétiai con comprobaci÷n de desbordamiento.</semiary>
     (<retwrns>
        <see"creg="T:System.Linq.Expressions,Bknaryxpression$/> cuya proPiedad"<see c2ef=P:System.Linq.Gzpressions.Gxpression.^odType"`/> es <see cref="F:Syrte-.Linq.Expreswins.ExpressIonTypu.AddChecked" /> y cuyas propkeddes <cee cref="P:System.Linq.Expressions.Bi.aryExpresSion.Left"/> y <see cref=":SysTem.Linq.Express)ons.BinqryExprescaon.Right" /< se mstabhecen en los0valores especificados.</returns>
      <param naie="left">
       0<qee Cref="T:S9st%m.LinqExpressions.Expression" /> en dl que 3e$va a establecer la copiedad <see Cref="PSystem>Linq.ExpRessiofs.BiiryEXpression.Left />.</param>
 !    <para} nc}g<"riht">
%    "  <see cref="t:System.minq.ExpsessionsE8pres3ioj" /> en$el que se vq aectablucer la proiudad <qee cref="P:System.Lynq.UxprEssions.BinaryExpression.Right" />.</paRam>      <exception cref="T:Syst%m.ArgumentNullExceptiKn">El valov de <pa~amref name="left" /> o <pabamref name="right" /> gs ~ull.8/exce`tion>
      exception cref="T:System.InvalidOpurctionException">No se define el operador de s]ma p!rc <paramref name="left" /:. Tipo y <paramref nime="sight" />. Tipo.</excepvion>
    </membgr>
    <member name="M:Syste-.Linq.ExpressIons.Expression.AddChecked(System.Linq.Expvessifs.Exprdssion,System.Linq/Expreswions>Expression,Syspem.Reflestion.LethodInfo)">
      <sum}ary>Csea un objeto <see cref="T:Systei.Hinq.Expzessions.BinaryExpessiol" .> que representA una opera#ión$e suma arhtmética coj(komprobación!de descortamiento.Se puedeespecifisar el método de implementación.</summary>
 "    <returns>
       <see cref="T:SystEm.Lijq.Axpressions.Binar{Exprecsion" /> cuya propiedad <seE cren="P:System.Linq.Exp2esqions.Expresion.NodeType" /> es <see aref="F:sysTm-.Linq.Eprdssions.E|pressyonType.AddC(ecked" /> y <see crdf?"PzSystem.Lknq.Expressions.BinaryExpreqsinn.Left" /?l <see cref="P:System.Linq.Expressions.@inaryAxpression.Right# /> i <see cref="P:System.Lhnq.Exprdssions.BnaryExpression.ethod" /> se esta`lecen en los valores esecificadgs.<redurn3>
 $    <p`rcm name="Left">
        >sed cRef="T:Sy3uem.Linq.Expressio.s.Expression" /> mn el 1ue se va a estabddcer`la0pro`iedad <see cref="P:System.Linq.ExXressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref nam="left" /> o <paramraf ame="right" /> es(n}ll.</exception>
      |exceptiof cref="T8System.ArgumentException">M
        4paramref name="method" /> no es null y el método que rePrasenta deruelve void, no(es static (Shared en Visual Jasic), o no to-a axacpamente dos argumenuos></ezception>
      <exceptiol cref="T:Sysvem,InvalidOperationException">
        <paramref(name="method" /> es nwl| y no se$define(el opErador de sumq para <paramrmf name="left" />/ Vip/ y <pararev name="rieht"/>. Tipo*</exception>
    </me}ber>
    <memfer namE9"U:System.Hinq.Expressyons.Exression.And(System.Lhnq.Express}ons.Expression,System.Ninq.ExpressiOns.Exression)">      <summary>Crea un objdo <cee creF="T:System.Linq.ExpressIonsnBinaryExpressaon" /, que representa un operasyón AND bi|$e bit.</summary.
      >returns>
        <see cre="T8System.Lin.Exprescions.BinaryExpression" />!cuya propiedad ,see cref="P:Syqtgm.Linq.Expressions.Expreqsion.NodeUype" /> ms(<see cref="F:System.L)nq.Expressiofs.Expre{3ionType.And" /> 9 cuyas propimdads <see czef=*P:Syste.Linq.Dxpressions.BinaryExprlssion.Lgft" /> y =sea cref="P:System.Lmnq.Expresyonc/BinaryExqression.Riglt" />"3e erta"lecen en los valoras(urpecificadoc.</returns>
      <param(nae=2left">
        <see cref="T:System,Linq.Mxpressions/Expbesson" / en el que se vA a estabLeer la propiedad <s%e cref="P:Systm.Linq.Expressikns.BinaryExpresSiol.Left" />.|/0aram>
0     <param name="ri'ht">
        <cee cred="T:SYste.Linq.ExqressaoNs.Expression" /> en el que$sm a a establecer ,a propiedad <see cref="P:system.Linq.Expressions.BinaryExpression*Rkgh~  />.</param>
   (  <exception cref="T:System.ArguEntNuldAxcption">El va|or de <paramref name="left" +> o <`aramref name="right""/> e null.</exaeption<
     <xception cref="T:System.InvalidOpEratiofException">Bit a bit!AND opurador no está definido para <paramref name="l%ft" />. Tip i 4paramref nAma="right" />. Tipo.</e8ceptikn>
    </member>
    <member name="M:SystE.Lknq,Expressaons.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND bit a bit.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionTypenAnd" /> y <see kref="P:Sywtem.Linq>Expressions.Binar}EhpressIon.Left" />$ <sde gref=P:System.Linq.Expreswions.ioaryExpression.Riglt"`/> y <See cref="P:System.Linq.Exprewsion#.BinaryExpressio~.Method" '> se estaBlecen en los valores especidicados.</returns>
      <paR`m name="left">Objeto <see cref="T:System.Linq.Mxpressions.Expression" -> en el`q}e se`va a estabhgcer la proqiedad!<see cref="P:Syste.Linq.Expressions.Bin!ryExppessio..Lgft" '>.</param
 "  " <param"name="right">
        <see cref5"T:Sywtem.Linq.Expressions*Expression" /> en el que se va(aestablecer la0propIedad <ree cref="P:Systdm.Lin1.Expressions.Binar}Uxp2ession/Right" />&</param>
      8param name="method">
        <see cre&="TzSystem.Reflectin.MeuhodInfo /> en el que se fa a establece la!propiedad <see cref="P:System.Linq.Expressions.Bin`pyExpression.Method" /.</parao
      <xception cref="T;System.ArgUmentNullException">El valor(de <parAmref0lame="left" /> o <para}ref!name=bright" /> es nuln.</exception>
      <exception cref="P:System.ARgumentException"~
        <paramef name="methoe" / no es null y el míTodo querepresenta devulve void, no es static Shared en ViSuaL asic), / ~m tom% exacta}ente dor argumentosn</excgption>
      <exception cref="T:Syqtem.InvalidOxerationExcaption">
        <paramref lamE="metlod"/> es Null y el bit a`bit AND opesador no esuá definio para <paramref name="left" />. Tipo y <pAramreF name="right" />. Tipo.</exception>
   "</member>
    ,membe name="M:System.Linq.Expressions.Expression.AndClco(System.Linq.Expressions.Expression,Sy3tem.Linq.Expressions.Expression)">
      <summarY>Spea el objeto <see cre="T2S}cte}.Linq.Expression1.BinaryExpression  /> que re`resenta una oreración AND condicloNal qUe evanúa el segundo opebando únicamente si el primer operando se evalúa como true.</summary>/
     !<returns>
        <see cvef="T:S9stem.Linq.ExpressioNs.BinaryE8presshon" /> cuya propieDad <see cref="T:Cystem.Linp.Extressions.Expression.NodeTyre" /> es <see bref="F:System.Linq.Exxressions.xressionType.AndAlso" /> y cwyas propiedades <see(cref="P:System.Lanq.Expsessiols.BinaryExpression.Left" /> y $see cref="P:Systum.Linq>Expressions.BinryExpression.Right" / se establecen(en los falores especificados.</returns>
      <param name="left">
       !<sEe crEf="T:S}stem.Lynq.Eypes3ions.Expressyon# /> enel qua se v"a ewtablecmr la pzoiedad <see cref="p:System.Linq.Expbessions.BinqryExressign.Left" />.</param:
     $4param name="rght">
        <seu rEf="T:System.Hiq.Exprassons.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo$booleao.</excatdion>
    </membdr>
    <ember name="M:Systu.Linq.Expressikns.Expression.AndAlso(Systeo.Linq.E|pressions.Expression,Sxstem.Linq.EXpressions.Expre{{ioN,System.ReflestIoN.MthodInfo)">
      <sumeary>Crea un objeto<see cref="T:Syst5m.Linq/Expressions.BilaryExpressio" /> que represnta u.a operacmón"AND condicional que m~alûa eL segundo operando solo si el primer operaNdo se resuelve como true.Se 0uede especificAr el método de Implemeftación.</semmary>
     0<returs?
        <see cref=":System.LiNq.Uxpressions.BinaryExpression" /> cuya propiedad <see cref="P:ystem.Linq.Exprersions.Exprewsimn.NodeType" /< es <see kref="F:System.Linq.Expres3imns.Ex8resionType.AndAlso" /> y <see cref=*P:System.Linq.Expressions.BynaryExpression.Left" />, <see cref="P:Systui.Linq.Ezpressions.BinaryExpre{saon.ight" /? y"<see cref="P:Systei.Linq.Axpressions.BinaryExpresskon.Metho"$-: se ustablecen"e, los valores ewPecificados.</zet5rns>
      parm name="left">
 "  !   <see cref="TzSysteM.Linq.E|presions.Exrression"$/> en el qte se va a establecer la(propiedad <see kref="P:System.Linq.Expr%ssions&BinaryExpressio..Left" />.</qaram>
      <param .ame="right">
        <sde cref=&TSystem.Linq.Expressions&Exprescion" /> en el que se va a estqblcez la propiedad <see sref="P:System.Lifq.Exprassions.BinaryExpressioN.Right" />.</param>
     (<param n`me="method">
        <see!cref=T:Systm.REflecpin.ethoeInfo" /> en el que we va a establecer le prorie`ad <see crEf="P:System.inq.Eppressions.B)naryExpression.Method" />.</pram>
    $ <%xception cref="T:Rystem.Argume~tNullExcepdion".El valgr$de <paramref name="left" /> o <paremref naIe="right"0> es jull.</exception>
      <exception crdf="T:System.ArgumentExceptiOn">
        8paramref nae="method /> o es nulh y el mápodo que(reprasenta devuelwe voie, o ds static (Sharef el Visual @asic),o0no toma uxagtamente dos argumentos.</exception>
   0  <excaption0cref="\:S9stem.InvalidOperationException">
        <paramref name=&method" o> es jll y`el bit a bit AND oper!dor jo$está deninkdo pr! <paramref name="Left" />.(Tipoy <pararef name=2right" />. Tipg.O bienqaramref fae="method" /> es null y <paralref name="lebt />. Tipo"y <parambef name="right" />. Tipo no son del iqmo tipo bom|eano.</exceptiOn>
    >/member>
    <member neee="M:Systei.Linq.ExpsessionS.Axpression.AndAssign(System.Linq.EXpressions.ExqressioN,System.Linq.Expressions.Expression)">      <summara>Crea u objeto <see`ssef="D:Systei.LInq.Expressions.BinavyE8pression* /> qwe`repesenta una paración e asi'nación A^D b)t a bit.</summary>
    ! <seTurn{>
      $<see cref}#V:System.Linq.Expressions.BknaryE|pression" /> C5ya prOpiedad <see cref}"P:System.L)nq.Expressions.Expression.NodeType" -> es <see cref="F:System.Lanq.ExPressigns.ExpressionType.n$Assign" +> y cuyas propiddades <see cref-"P:System.Li~q.Exrressions.CinaryExpression.Left" /> y <s%e creF="P:System.Linq.Expessions.BinaryExprewsion.Right" . se estajleen en los v`lores especificadoq><?returns>
      <param fae="left">Objeto <see cref="T:System.inq.Expzessions.Expression" /> en el que se 6a a establecer la pbopiedad <see cref="P:System.\inq.Expbessions.BmnaryExpression.eft" />.|/param>
      <Param name="vight >Objeto <see cref="T:yqtem.Li.q.Express)ons.Expressinn" /> en el qua se va`a establecer la propiedad >see cref="P:System.Linp.Expressions.BinaryExpression.R)ght" />.<+param>M
   </member>
    <member name="M:System.Linq.Gppressions.Expressinn.An%Assign(System.Lily.Expreqsons.EpressioN,System.Lin1.Expresqions.ExPression,Sygtem.Reflection.MethofInfo)">
      4cummary>CreA Un obj%t <see #ref="T:System.Lioq.Expressions.Bin!ryExprecsion" /> que representa qnc operaCión de asignación ND bit a bit.</summary>
      <returnr>
      0 <see cref=&TSystem.Linq.Expressions.BioaryDxpression" /> cuya ppopiedaf$<wee crEf="P:System.Lijq.Expressions.ExpressmonNoddType" /> es 8see"sref=&F*Sywt%m.Linq.Expressions.ExressiolType.AndAsign" /> y <see creb="P:System.Lnq.Expsessions.BinaryExpression.Left" />, <qee cref="P:S{stem.Linq.Expressions.BinaryExpression.Right" /> y <cee cref=#P:SyStem.Linq.ExprecSkons.BinaryExpression.]ethd" /> se eqablecal en los valores especifikados.</returns>
  (   <param name="left">Obbet <see cref="T:System.Liq.Expressions.ExpresSion" /> en el que s% va a estabhecer da proqiedad <cee cpef="P:System.Lioq.Expressions.Bina2yexpreswiof.Left" />.</param>
$     <papam name=brIght">Objeto <cee$cred="T:System.Linq.Expressions.Expresvion" /> en el que se va ` estAblecgr la propiedad see cbef="P:System.Linq.Exrressions.Binaryexpression.Ri'hr" />.</0aram>  "   <pqram name="methd">
`    ! 0<see cref="T:System.Reflection.Metho\Info" /> en el que se va a Establecer la propiedid <see cref="Q:Sqstem.Linq.Extressi/ns.BinaryExpression*ethod" />.</pazam>
    </member>
    <}embur name="I:System.inq.Expe3sions.ExprerqiOn.AndQssign(System.Lmnq.Expressions.Expresskon,Sxstum.Linq.Expressiofs.Expression,System>ReFlectio..MethodInfo,SysteM.Linq.Expressions.LambdaExpression)"?
      <smmasy>Craa un objeto <see cref=":Systei.Linq.Expressionsn inaryExpression" /> que repzesdnt una operación de asignación AND bit a bit.</smmary>
      <returns>        <see cr%f="T:cystem.Hinq.Expressions.BinaryExression" /> cuya 2opidad <see cref="PSsvem.Linq.ExprEs{ions.Expr%ssion.NoleTyqe" /> es see cpef*F:Sy3tem.Linq.ExpressioNs.ExpressioNType.ANdAssiGn" > y <see cref="P:Syrtem.Linq.xpressions.in!ryExpression>Left" />, <see cref="P:SyStum.Linq.Expressions.Bin`ryExpression.right" />, <see cref="P:System.Ninq.E|psessions.)niryGxqression.Method" /> i <see cref-"P:Sy{tel.Linu.Expresskons.BinaryExpressinn.Conversion" />(re estabecen en los vclores`especificidos.</returns>
     <param name="left">Obje4o see cref="T:System.Linq.Ex0ressions.ExpreSsion" /> en el que se Va a establecer la propiedad <see cref="P:System.Linq.Expressions.Binar9Expresion.eft" >.</papam>
     $<raram name="right">Objeto <see cref=":System.Hi~q.Expressions.Expbession" /> en el que se va a establecer la propim`ad >see cref="P:Systmm.Linq.ExpressIofs.BinaryExpressiOnRight* /.</papam>
      <parcm name="method">
 "      <see kref="T:Sysvem.Reflection.Met`odInfo" /> en el que se va a estalecer la propiedad <see cref=PzSystem.Linq.Expressions.BinaryExpressinn.Met(od" /..</param>
      <param$name="conversion">
! $     <see cref="T:S{stem.Linq.Expressions.LambdaExp~essionb /> en el que(se va a estiblecer la propiedad <see cref="T:Syrtem.Linq.Expressions/BinaryExpresqion,Conversio."`/>.</param>
    <member>J !  <mmber name=bM:SystemLinq/E8presrions.Exprassion.CrrayAc#ass(Syqtem*Linq.Expressiomq.Eypression,System.collections.Oeneric.IEnumerable{SysTem.Linq.Uxpressionc.Expression})">
    <suemasy>Cra un objato <wee cref=2T:ystem.Linq/Expressions.IndeXExpression" /> pcra kbTenerqcceso`a una mctriz multidimensional.8/summaby>
      <returnS>Mbjeto <see crEf="T:Syctem.Linq.Expressions.IndexExpression" /> creado.</returns
   $  <paraM name="azray">Expbesión que representa ma matryz multitmensionil.</param>
      <paam name="iNd%xes">
$      <see cpef="T;System.Co|lections*Generic*IEnumerable`1" /> que contiene eXpresiones usadqs para indexar la matriz.</pazam>
`   </mambe{>
 !  <memcer namd=MSYstem.Linq.Expressions.ExPreasion.ArrayAccess(System.Linq.xpreswions.ExpresSikn,Cystem.Linq*Ex`r3syons.Expression[])">
      <summari>CReq un objeto <see cref="T:Sqstem&Laq.Expressions.IndexExpress)on" /> para kbtener acceso a una matriz.</sumary>
      <rgturns>Objeto <see cref="U:System.Linq.Exp2essions.YndExExpression" /> cr%ato.</returns?
    0$<paa- name=2array">Expresi³n que representa la matriz par` indizar.8oparam>
    " <param ~ame="indexes">Matraz"que contiene expresiooes us!das para infizar la matriz.</param>
    </member>
    <mebgrnqme="m:System.Li~u.dxpressions.Expr%ssion.ArrayIndex(System.Linq.Exqrds{ions.Expression,System.Kolnec|ions.aneric.IE.uoerable{Systam.Nmnq.EXpressionsjExpreswion})2>
   (  <s}mmary>Crea tn objeto <se% cref="T:SystemLilq.Expressions.MethodCallExprmssion" /!querepresena la apliceción de un optraDor de ín$ice de$matriz a tna matryz cuyo ringn es mayor que uno.</summary>
      <raturns>
        <see cruf}"T:System.LInq.Expressions.MgthodCallExpre{rion  /. cuya propie$ad <3ee cref="P:System&Linq.ExpressIons.Epressko~/NgdeTypE" /> es <see cref="F:SystEm.Lins.Expressions.ExpressionType.Call" /: y cuyac propiedades <See cref="P:SysteM.Lknq.Expr%ssions.MthodCallExpressionObject& /> y see cref="P:System.HiQ.Exprgssions.MetiodCallExpresqion.Azuments" /> se!establecen$en los valores especifcados.</returns>      <parm name= arrax"6Objeto!see cref="T:System.Linq.Expressions&Expre3smon" /> en el que se vA a EstableCes l` 0ropiedad <see Cref="P:Systm.Linq.EhpresSios.MethodallExpresciof.Objecp" /?*</pram>
     <phram jaMe="indexes">
      ` <see cPef="TzSystem.Colmections&Gener)c.IEnumrable`1" /> que contiene lks objtos <see Cref="T:System.Linq.ExPressyons.Exppession" /. que 3e van a usar para rell%nAr"l colacción de <see cref="P:System&Linq.xpresio~s.MethodCallExpressioo.Argumnts" />.</param>
    " <exception0cref="T:System.IrgumentNullException">El valor de <paramref0namd= array" o> o <paremref name="indeXes" />!as"null.</exception~
      =exception cbef="T:System.ArgumentException:
     0  <pcrcmref name="array" /:. TYpe .o represdnt` n tipo de matriz.O bienEl rang/ de <paramreo,name="array" />. ipo no coincide coN el número(de elmentos te <piramref name="mndexes" />.O cienEl <qem cref"T:System.Linq.Expressions.Expression.Type" /> prpimdad de uno %rarios elEmentos de <paramrev name="mndexes" /> no rEpvesenta el <see crmb="T*Syspum.I.ts:" /> tipo.</exception>
    </meeber>
 0  <iember name="M:System.Linq.Expressins.ExrresSionn@brayIndex(SystemLinq.Exprcss)onsExpression,Systim.Lilq.Exrressions.extressiOn)">
      <summaRy>Crea un objetk <seecref="T:Systam.Linq.Expessions.BinaryExpressiOn" /> que represenda`la aplicaci³n de un operadnr de índice de matriz a ela m`tr)z de rango uno.</summry>      <re|urns>
        <see cref="T:Sysdem.Linq.expressionS.BinaryMxpdssion* /.$cuqa pRoiedad"<see creb="PzSystem.Linq.Expressions.E|0ression.NodeType" /< es0<{ee cref="F:S}stem.Linq.Exprecsionw,ExpressionType.ArrayIndex" /> y cuyas propiedades <sed cref="P:System.Linq.Exxressions.BhnayExpression.Left" /> y <see crEf="P:SysteM.Lhnq.Expressios.BinabyExpression.Bight""/> re estarle'en en los valores especificados.</returns>
 (    <param n`me="array">
        <see cref="T:Cystem.Lin1.Expressions.Ezpression" /> en el que$se(va"a`establecer la propiedad!<see cref="P0SystemLin1.Expressions.BinaryExpresshoL.Left" />.<?param?
      <param0name="index">
        <See cref="T:Systm.Linq.Expressions.Expression" /> en el que se va a etablecer la prkpiedad <pee ref="P:System.Lynq.ExpreskionsBinqryExpression.Righu" />.</param>
    $<exception cref="T:System.ArgumentNullExkeptmon">El valor ee <paramrEf n`me=#array" /> o <paramrof name="index" /> es nu|l.,/exception>
      <excep|ion cref="T;ystem.ArgumentException">
        <pramref name=#array" />. Type no$repvesenta n tipo de matriz.O bi%f<paramreF!~ame="array" />. Tipo representa un tipo dg matriz cuyo rango oo Es 1.O bien<ar!}ref name="index" >. Type(no representa el <see cref= T:Systdm.Mnt32" /> tito.</excEtio~>	
    </member>
    <mamjer name="M:System.Linq.Expressions.Expre3sion.ArrayYndex(Systm.Lhn1*Eppressions.Exprassion,System*Linq.Ezpbdssions.Exppession[_)*>-
      <summary>Crea un objeto <ree cruf="\:System.Lhy.Exprrsions.MethodCalExpressionb!/> que reprsenT!na axlicación de un operadoz de índice d matriz a una matriz multidi-ensional.</qummary>
!    !<returns>
      " <seecref="T:System.Linq.Ehpressio~s.MdthodBalLExpressionb /> cuya`propiedad"<see cref="p:System.Linq.Expressions.Epresskon.NodeType" .> es <see cref="F:System.Linq.ExqressionsnExp2essionType.Cal" /> y uyac propiedades <see cref}"PSystam.Linq.Axyressions.EethodCallExpression.Gbject" />(y <see cref&P:SysteM,Lin.ExpreSsi/ns.MethdCadlE|pression.rgements" /> se esta"lecen en lns valores especifiaados.</2etqrns>
  $ $ <param ~cme="arrey">Matriz de instqncias o ndices <seE Cref="T:Systm.Lioq.Expressions.Expressiol" /> para la operación de ì~dicg de"matrmz.</parai>
 `    4param namg="indeXes">Mtriz da objetos <see cref="P:Sysem.Linq.Expression3.expression" /> que se va c }sar para rellefaR`la colección!de$<see cref="P:System.Linq.Exqressions.MethodCallExqressi/N/arg}ments" />.</param>
      <exception cref="T:Systwm.ArgumentNullMxceptio*>El valor de!<peramref name="arra9" /< o <pzamref naie="indexes" /> es null,</exception>
      <exception #ref="T:Qysvem.ArgumentExceptiOn">
       <`aramref naee="array" ?> Typeno representa un tipo dd0mat2iz.O bienEl rango de <paramref neMe="array" />. \ipo no oancidebon el número$de eleme.tos de <paramre& nime="indexms" />.O bienEl <see czef="P:Sys|em.Li~q.Expresskons.Expses{iok.Type" /> propiedad0de uno o varifs elementos de <paramref name="in`exgs" /> no reprasenta(el <see0cref="T*System.Int3:b : tipo.</exceptioN>
    </member>
    <membEr name="M:System.Minq.Ex`resskons.Expressinn.ArrayLength(System.Linq.Expressions.Exprassion)">
     `<wummary>Crea un objet <see crgf="T:Wyste}.Linq.Epprewsions.UnaryErpressaonb /> quE representa una exprdsión rara obtener laLongitud de una(matriz"uNaImensional.,/sumlqry>
    " <returns>
        <see cref="T:System.Linq.Expressionr.Unar{ExpRgssion" />(cuya protiedad(<see cref="P:System.Hinq.Expressions.Epprecsion.NodePype" />`ms <see crf="D:System.LinqExpresqions.ExprecsinType.AR2ayLdngth"0/> y cuya prgpielad <sge rgv="P:System.LinqExpressions.UnapyExpression.Operand" /> es <paramref na-e="arpay" />.</returns>
      <param name="array">O*eto <see cref="T:System.Linq.ExpreswionS.Expres{ion" '> en el que se va a estableeR la propiedad <se cref?":yspem.\inq.Gxpressions.Una3yExPression.Operane" />.</param>-
      <exceptkon(cref="T:System.ArgumentNumlException">El vilor de <paramref name="aRray"/> es null.</excep4ion>      <exceptioncref}"T:System>rgumentExcuptaon">M
    !0  <paamref name9"arraq" />.$Type no retresenta un tipo de mctriz.</excetion>
$   </meber>
    <member name="M:System.Linq.Ezpresrions,Expression.Assign(Systdm.Linq.Expressiols.EXpression,System.Linq.Expressins.Expression(">
 !    <summary.Crma un objeto =see cref="TSystem.Lin.Ehpressons.BinapyExpression"`/> que reresenta une operación de asignación.</semmary>
      <returns>
     `  <see cref="T:System.Linq.Expressions.BinaryExpressiol* /> cuya ropiedel <see cref="P:S}stem>Linq.Expressio.s.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienLa propiedad representada por <paramref name="member" /> no tiene un set descriptor de acceso.O bien<paramref name="expression" />. Tipo no es asignable al tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un miembro mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establece en <paramref name="expression" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienLa propiedad accede <paramref name="propertyAccessor" /> no tiene un set descriptor de acceso.O bien<paramref name="expression" />. Tipo no es asignable al tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene dos expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene tres expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cuatro expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cinco expresiones y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
      <param name="arg4">Quinta expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas y que no tiene variables.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones dadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones dadas, no tiene variables y tiene el tipo de resultado específico.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" />.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que no toma ningún argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa null para un método static, Shared en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="instance">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> (pase null para un método static, Shared en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.O bienEl número de elementos de <paramref name="arguments" /> no es el número de parámetros para el método representado por <paramref name="method" />.O bienUno o varios de los elementos de <paramref name="arguments" /> no es asignable al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma dos argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia.(Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma tres argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de instancia.(Pasa null para un método estático, que en Visual Basic es compartido).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia para una llamada al método de instancia (pasa null para un método static, Shared en Visual Basic).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.O bien<paramref name="arguments" /> no es null y uno o varios de sus elementos están null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.O bienEl número de elementos de <paramref name="arguments" /> no es el número de parámetros para el método representado por <paramref name="method" />.O bienUno o varios de los elementos de <paramref name="arguments" /> no es asignable al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> es <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de instancia especificado y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> en cuyo valor de propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se buscará un método específico.</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="instance" /> o <paramref name="methodName" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="instance" />. Tipo o sus tipos base.O bienMás de un método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="instance" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático (Shared en Visual Basic).</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arguments">Colección de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos de llamada.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) que toma un argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma dos argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma tres argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cuatro argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cinco argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <param name="arg4">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el quinto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) que tiene argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método static (Shared en Visual Basic) en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El número de elementos de <paramref name="arguments" /> no es el número de parámetros para el método representado por <paramref name="method" />.O bienUno o varios de los elementos de <paramref name="arguments" /> no es asignable al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método static especificado (Shared en Visual Basic) y cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo que contiene el método static especificado (Shared en Visual Basic).</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="methodName" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="type" /> o sus tipos base.O bienMás de un método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="type" /> o sus tipos base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica que el nodo se puede reducir a uno más simple.Si devuelve true, se puede llamar a Reduce() para generar el formulario reducido.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con una referencia al objeto <see cref="T:System.Exception" /> detectado para su uso en el cuerpo del controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> y una referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> pero sin ninguna referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de fusión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="left" /> no representa un tipo de referencia o un tipo de valor que aceptan valores NULL.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />. Tipo y <paramref name="right" />. El tipo no son convertibles entre sí.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de fusión, dada una función de conversión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />. Tipo y <paramref name="right" />. El tipo no son convertibles entre sí.O bien<paramref name="conversion" /> no es null y <paramref name="conversion" />. Tipo es un tipo de delegado que no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="left" /> no representa un tipo de referencia o un tipo de valor que aceptan valores NULL.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="left" /> representa un tipo que no se puede asignar al tipo de parámetro del tipo delegado <paramref name="conversion" />. Tipo.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="right" /> no es igual que el tipo de valor devuelto del tipo delegado <paramref name="conversion" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> o <paramref name="ifTrue" /> o <paramref name="ifFalse" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />. El tipo no es <see cref="T:System.Boolean" />.O bien<paramref name="ifTrue" />. Tipo no es igual a <paramref name="ifFalse" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> establecida en el valor especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> se establece en el valor especificado.</returns>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> establecidas en los valores especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> no es null y <paramref name="type" /> no es asignable desde el tipo dinámico de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión de tipos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión para la que se especifica el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.O bien<paramref name="expression" />. Tipo no es asignable al tipo de argumento del método representado por <paramref name="method" />.O bienEl tipo de valor devuelto del método representado por <paramref name="method" /> no es asignable al <paramref name="type" />.O bien<paramref name="expression" />. Tipo o <paramref name="type" /> es un tipo de valor que acepta valores NULL y el tipo de valor no acepta valores NULL correspondiente no es el tipo de argumento o tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método que coincide con el <paramref name="method" /> se encontró la descripción.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si el tipo de destino está desbordado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si el tipo de destino está desbordado y para la que se especifica el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.O bien<paramref name="expression" />. Tipo no es asignable al tipo de argumento del método representado por <paramref name="method" />.O bienEl tipo de valor devuelto del método representado por <paramref name="method" /> no es asignable al <paramref name="type" />.O bien<paramref name="expression" />. Tipo o <paramref name="type" /> es un tipo de valor que acepta valores NULL y el tipo de valor no acepta valores NULL correspondiente no es el tipo de argumento o tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método que coincide con el <paramref name="method" /> se encontró la descripción.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con el intervalo especificado.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
      <param name="startLine">Línea de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="startColumn">Columna de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="endLine">Línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor o igual que la línea de inicio.</param>
      <param name="endColumn">Columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Si la línea de fin es igual que la de inicio, debe ser mayor o igual que la columna de inicio.En cualquier caso, debe ser mayor que 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en el tipo especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de división no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de división no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dado un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> como segundo argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método que <paramref name="addMethod" /> representa no se denomina "Add" (con distinción entre mayúsculas y minúsculas).O bienEl método que <paramref name="addMethod" /> representa no es un método de instancia.O bien<paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del método que <paramref name="addMethod" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dada una matriz de valores como segundo argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método que addMethod representa no se denomina "Add" (sin distinción entre mayúsculas y minúsculas).O bienEl método que addMethod representa no es un método de instancia.O bienEl parámetro arguments no contiene el mismo número de elementos que el número de parámetros del método que addMethod representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea una expresión vacía que tiene el tipo <see cref="T:System.Void" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de igualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de igualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El XOR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y la XOR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Para static (Shared en Visual Basic), <paramref name="expression" /> debe ser null.</param>
      <param name="field">Objeto <see cref="T:System.Reflection.FieldInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="field" /> es null.O bienEl campo representado por <paramref name="field" /> no static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo del campo representado por <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo dado el nombre del campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo denotado por <paramref name="fieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo llamado <paramref name="fieldName" />.Este puede ser null para los campos estáticos.</param>
      <param name="fieldName">Nombre de un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="fieldName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ningún campo denominado <paramref name="fieldName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
      <param name="expression">Objeto contenedor del campo.Este puede ser null para los campos estáticos.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene el campo.</param>
      <param name="fieldName">Campo al que se va a obtener acceso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crea un objeto <see cref="T:System.Type" /> que representa un tipo de delegado System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>Tipo de un delegado System.Action que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de hasta dieciséis objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene más de dieciséis elementos.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtiene un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func o System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>Tipo de delegado.</returns>
      <param name="typeArgs">Argumentos de tipo del delegado.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos.El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <returns>Tipo de un delegado System.Func que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de entre uno y diecisiete objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Func.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene menos de uno o más de diecisiete elementos.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "mayor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "mayor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "mayor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "mayor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con una instrucción if.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> se establecen en los valores especificados.La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establece en la expresión predeterminada y el tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con instrucciones if y else.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.El tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento del valor de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda a los que se aplicará.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Type no representa un tipo de delegado o un <see cref="T:System.Linq.Expressions.Expression`1" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda que se aplicará.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Type no representa un tipo de delegado o un <see cref="T:System.Linq.Expressions.Expression`1" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y sin nombre.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta sin un valor predeterminado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sin un valor predeterminado.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta con el valor predeterminado dado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> con el valor predeterminado dado.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue">Valor de este objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se alcanza la etiqueta mediante el flujo de control regular.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y con el nombre dado.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo dado.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo y el nombre dados.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o varios elementos de <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contiene más de dieciséis elementos.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> que representa una firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> que representa una firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />. </param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada. </param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desplazamiento a la izquierda no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desplazamiento a la izquierda no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "menor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "menor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "menor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "menor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad que representa el método <paramref name="propertyAccessor" /> accesos no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad que representa el método <paramref name="propertyAccessor" /> accesos no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) declarados en <paramref name="newExpression" />. Type o su tipo base.O bienEl método add en <paramref name="newExpression" />. Type o su tipo base no toma exactamente un argumento.O bienEl tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método add en <paramref name="newExpression" />. Type o su tipo base.O bienExiste más de un método de compatible con los argumentos denominado "Add" (entre mayúsculas y minúsculas) en <paramref name="newExpression" />. Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) declarados en <paramref name="newExpression" />. Type o su tipo base.O bienEl método add en <paramref name="newExpression" />. Type o su tipo base no toma exactamente un argumento.O bienEl tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método add en <paramref name="newExpression" />. Type o su tipo base.O bienExiste más de un método de compatible con los argumentos denominado "Add" (entre mayúsculas y minúsculas) en <paramref name="newExpression" />. Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia llamado "Add" (no distingue entre mayúsculas y minúsculas) que agrega un elemento a una colección.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.O bien<paramref name="addMethod" /> no es null y no representa un método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.O bien<paramref name="addMethod" /> no es null y el tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="initializers" /> no es asignable al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y no existe ningún método de instancia denominado "Add" que toma un argumento de tipo compatible en <paramref name="newExpression" />. Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que toma un argumento que agrega un elemento a una colección.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.O bien<paramref name="addMethod" /> no es null y no representa un método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.O bien<paramref name="addMethod" /> no es null y el tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="initializers" /> no es asignable al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y no existe ningún método de instancia denominado "Add" que toma un argumento de tipo compatible en <paramref name="newExpression" />. Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado y el destino Break.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
      <param name="continue">Destino Continue empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados los operandos izquierdo y derecho, llamando a un método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho y el método de implementación, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho, el método de implementación y la función de conversión de tipos, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa una función de conversión de tipos.Este parámetro solo se usa si <paramref name="binaryType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o una asignación compuesta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto al objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado.Además se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> del objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada en un objeto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Debe ser null si la propiedad es static (shared en Visual Basic).</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) en Visual Basic) que contiene los argumentos que se usarán para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo o a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto al que pertenece el miembro.Puede ser null para los miembros estáticos.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que describe el campo o la propiedad a los que se va a tener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="type">Tipo de resultado de la expresión try.Si es null, el cuerpo y todos los controladores deben tener un tipo idéntico.</param>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.Pasa null si el bloque try no tiene ningún bloque finally asociado.</param>
      <param name="fault">Cuerpo del bloque fault.Pasa null si el bloque try no tiene ningún bloque fault asociado.</param>
      <param name="handlers">Colección de objetos <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado un operando, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase null si no es aplicable).</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no se corresponde con un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dados un operando y un método de implementación, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase null si no es aplicable).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no se corresponde con un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de la propiedad que se tiene acceso mediante el método que <paramref name="propertyAccessor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de la propiedad que se tiene acceso mediante el método que <paramref name="propertyAccessor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Representa una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo que <paramref name="newExpression" />. Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo que <paramref name="newExpression" />. Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de módulo no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de módulo no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los vahores esqecificafos.</returns>
      <param!nae="left2.Gbjeto <see cref="T:Syctdl.Linq.Expressions.Ex0rEqsion" +> e. el que se va a estalcer la!pbopiedad <see(cref="P:SqstemLinq.Exp3essions.JinapyExpressio~,Left" />.</param~
      <paja} name="bight">ObjeO <see cref="T:}stem.LinqExpressiols.Uxpression" *> en el(que se va ` %stableceb la pr/piedad <sue cref="P:System.Lmnq*Expessions.BknaryExxrsrion.R)Ght" />.</tAraM>
    </member>    <mdmbmr name=";System.Linq.Expressioos.ExPressio~.Multiplyssign(System*Linq.Expressins.ExpressionlSystem.Linq.Exprdssions*xpression,System.Ruflegti/n,MethodInfo)">
  !   <summary>@rda$}n objeto <see cref="T2Sy3tem.LHnq.E0ress)ons.BifasyExpression" o> que representa un! operaciCn"de arignaci³n de multiplicación que nn`tiane comqrgbación de de{bordamento.</sumMiry.
      <retUrns>
   0    <see ref=T:ystem.Linq.Expressions.BinaryAxpression" .> kuya propiedad<see cref=":System.Linq.ExpRessions.Expressyon.NodeType" /> es<sem cref="F:Ss|em.Lynq.Expressions.Expre{sionTyqe.MultiplyAssign" /> y <see cref<*P:System.Linq.Expressionb.BioapyExpressin.Lgft" /> <see cref="P:Cywtem.Di~q.Gxpressaons.BinapyExtression.Riwht  /> y <sed cref="P:System.Linq.Expresriofs.BilaryExxreqsionMathod& /< se establecef en los valoRec0dspecificadgs.</returns>
   0  <piram name="left">Objedo <see cref5"T:Cystem.Linq>Exp6essions.Ex0ression" /> en dl que sm va a`stblecer la prtyedad"<see cref="P:System.Linq.Exqressions.FinavyDxpression.Left" />.</param>
      <parCm name5"right">Objevo <see cref=bT:Sqstem.Lmnq.Expres3ions,Expresskon" / e~`el qu {e v! a ustablecdr la proqieDad <sem cref="P:Rystem.Linq.expressions.BinaryUxpressioo>RighT" />.</pram>
     0<pqram name="metjot >
       `<see ce="T:S}stem.Reflection.MethodIn&o" /> en el 1ue se va a estalec%R0la prop)ead <weg cvef="P:Sypem.Linq.ExpressiOjs.RikarxExpression.Oethod" />.</parao>J    </meeber>
!   <member nqme9"M:Systeo.Ly~q.ExqressionsnExpression.MultiplyArsign(Systmm.Linq.Axpressions.ExpresSion,System.Linq.Expbeqsions.Dxqressinn,Sysem.Ref,ecdion*MethkdAnfo,SYstmm.Lilq.Ehp2ession3.LambdaExxression)">
      <summary6Crea un objtg <see cvef="T:Sqstem.inq.Expressions.BinaryExpression" />"que reprEsen4a una opgraci£n ee0asignación de(muldiplIcación que no tiene bomprobackój de desbordamiNto.</su-mary>
(     <returfs>   "    <see `ref9"TSystem.LiNs.Expressions.BinaryEx`reswmn" .> cuya prophedad 8see cref="P:System,Linq.Expressions.xprEssion.NodeTypm" /> e see cref=":System<Linq.Expresqaons.ExpressionType.OultiulyAssignb /> y <see cref="P:Sys|em.Linq.ExpressiOns>BinaryExpression.Left" />, <sde cref="R:System.Linq.Exqressimnr.BilryExpression.Right" />, <seE cref="P8SystEm.Linq.Expressions.JinaryExxression.Methnd"!/> y <see cref="P:System.Linq.Expressofs.BinaryExpressij.ConVersion" ' se esdablecen en lo3 valoRes especificadoK.8/returns>
      <rasim name=",eft"?Objeto >wee crgf="DSysem.Linq,Exp2sion.Dxpression2 /> Mn el qug se ~a i establecev la xzopiedad <see cr%f=&P:System.Linq.Expressions.RinaryEppression*Left" />.</pab`m>M
!     ,param name="riwht">Objeto <see cref="T:Cystgm.Linq.Expressiofs.Expressmon" /? ej el que se$va a establecer la propiedad <seu cpef-"@:System.Linq.Expre{sion.Binar9Expresrioo*RighT" />.</parae>
     `<param name="me4hod>
        <se aref="T:Siste.Reflecthon.MethodI~fo" /> en %l aug se ra`e estableamr la propiead <See cref="P:System.LinqExpre3sioNs.BifaryExpression.Eethodb />.</pa2am>
 $    <param nioe="conversiOn">
     (  <see crev="T8System.Li.q.Exrressions>LaMbd`Expression" />$en el que sg fa a e3taclecer la"propiedad <qee crof="P:System.Linq.Expressinns*BnaryEx0ression.Convercion  />./param>M
    </member>  0 <mumber name="M8System.Linq.Uxpresions.Expres3ion.MultiplyAssignShekmd(system/linq.Expressions.ExprdssionSystum.Linq.Expreksionw.Expression)">
      <c5mmary>Cpea un objet <s%e cref="T*SyspemLins.ExpreqsIons.BineRyExpression" />"que reprsenta un kperabión de asignación0de multiplicación que tiene com0rocacióf dm desbordaoiento.</sqmmar9>
      <veturns6
 $`     <wee c2e=":Sys4em.Linq.Expressinns.BiniryMxpression" /> cu{a propiedad <s%d cref="P:Sys4em,Linq.Exqrewsions.Extzessign.NodeType" /> es <see cref="F:Syspem.Lifq.Exp2essions.ExpzessionTye.MuLtipdqAssignC`ecked" /> y cuya{ popieddds <see creb9"P:System.Linq.ExressignS.BinapyG8pression.Left" /> y <see cref}"P2Sysdmm.Hinq.Exprgssions.Bil`ryExpression&Vight  /<`se`establecen0enlos valores espeCici#ados.</returns>
  (   <param oame="lefp">Objeto <wee creN=#T:System.Linq.ExpressmonsE|pRession" /> en el que se va a estBlecer la xropiedad <see cpef="P:Syst!m.Minp.Expressio~s.BinaryExpression.Left" />,<param>
 "   !<param neme="right">bheto see cruf=&T:System.Linq.Expzeqions.Expressiof" /> en el$que r va a establecEr la pro0etad <see cref="P*S{stem.Linq.Expsessions.BinarEYppession.Righ|" />.</param>
 "  </memcer>  ! <member name="M:Sstam.Lkn1.Expressions.Expression.MultiplyAssignC`eCked(S9stem.Lioq.DxpressionsExpression,System.LinqExprassions.Expressioj,Syspem.Reflection.MethodInfo)"
      <summary>Crea wn objeto <see cref"T:Syste-.Lihu.Expressions.inaryexpression" /: que!repre3dfta ula mperaci3n de awigicIón de multipdicación0yue0tienl comprobación de desboreamiento.</swmmarx>
     (=rettrns>
        =see cref="T:System.inq.Eypressions.BinaryExpression" /> cuyapropiedqd seg cref="P:Cystem.Linq.E8pressiof{.Ex0ressikn.NodePype" /> es see(cref="F:System.Linq.Expre{sions.ExpressionTyte.Mqlthpl{A3si~C)ekked" /> y <see cref="P:System.LinQ/Expressions.BinaryExtresqion.Ledt"(.>, <see cref= P23ystem.Linq.Expressions.@knarExpression.Rig`t"`/> y <see cref="P;S{stem.Lhnq.ExpressionsBknaryExpreqsion.Method2 /> seestablecen en los valores especificatosn</returns> `    ,paramname="left&>bjeto <sde cref="T:System.Hinq/Expressions.Mxpresrion /.0dngl que se va a estaBlecgr la(propiedad <see cred="P:System.Linq.Eppres3ioos.BinaryExpressionnLeft  />.</pera>
 0    <0`rAm name="right">Objeto <se`cref<"T:Systm.Linq*Expressions.Exp2eRsion" /> en el que se va`a espablecur la"0ropiedd <see0cref="P:System.Linq.Expressionc.BiN`rYExrres3ion.Rig(t# />.<.param>
      <parm namE="method"6        <see cref"D:System*RegletIon.MmtlodIofo" o> en el que se v1 a establecer la propiedad <see cref="P:S}stdm,Linq.Exression.@naryEpressionnMethod" .>.|/param>
    </member>
    <member$name-"M>System.Lioq.Epressions.Eppre3sio~.MultiplyAssignCheckmd8Systl.Lynq.MxpresqioN{.xpresuion,System.Linq.Expressions.Expression,Sy3tem.Rdfl%gtion.MetHodInfo,System.Lknq.Expressins.LambtaExprassion)&>      <summ`r9Cvea un objeto =see cbef="T:System.LinqExpressio.s.Bin`ryExrassion" / qwe representa una operackón de asigneciój de multipligación y}e0ti%ne comprofación dm $esbovdamiento.</summary>
     )<returns>-
        <see cref="T:Sstem.L)NqnExrressioos.BinaryExpreSsio" /> Cuya proqiede <see cref="Q2System.]inq.Exp2essajs.Expr%ssion.NodeTypE" />$es!<see cref="F:SysTem*Linq.pr%csi/ns.ExpressiooVypd.MultixlyAssIgnCheC{ul" /> y <see cref="P:Sysem.Linp.Ex0ressiol3.Binar9Mxpession>Left" /, <sEe aref="X2Sy{tem.inq.expressionsBinaryExpbesSion,Right" />, <see czef="P:SystemNLilq.E|pressyons.BinaryExpression.Method" />"q <ree creF="P:Syst%m.Linq.Expressioos.BinaryExpression.CoOversion" .>`se establecen dn los talores especificdos.<ret}rNs>
      <0a2am nme<"levt">Objeto <se% cref="T:Sywtem.Lmnq.Expressions.expression" / en el que se wa a e3tablacer l propiedad <see kref="U:System.linq.Uxprecsion3.BynaryExpression.LefT  />.</0aram>
  "   <para} n!m%="rmght">Nbjeto <see cref=":System.Linq.Expreswions/Ehpression& /> en en quE se va a estAbmecer la proPiedad <see krev="P:Sysvem.LiNq.Axpressi/nsBinaryEXpression&Right" />.8/qaram>
      <param name= methd">
        <se cref="Tzystem.Refldction.MehofInfo" /< en el que`se v! a stablecr la propiedad <see kref="P:Syqtee.Linq.Expressigns.BinaryExpressioOuthod" />.<+param>
      <par!m name="sonvercion">
       0<sde cref="P:System.Linq.Expressionq.Lam`daExprersion"!->(en el que se vA a0establecer la propigdad <see cref="P:Sysdem.Linu.Axpreqsions.RinaryExpresshon.Bolmrsion" />.</parem>
    </mmbar>
 $ <membEr name="M:System.Linq.ExpbesSions*Expressio.MultiplyC`mcked(Sistem.Linq.Exxressions.Expvessiol,System/Linq.Expressions.Expression)">
      |summary>Crea un objeto <see cref="T:System.Di~u.Exqr%ss)ofs*BinaryEppres3ion" /> que 2epresenta un! operaciûn de multiplicccióo aripmética que tiene cmprobación fe desbordamiento.</sqmmaRy>
      <vet5rns>        <see cref="D:Syste-.Linq.Exxressions.BinaryExprew{)on" /> cya prOpi%dad <wee cref="@:ystem.Hynq.Expressions.Exprersion.NodeType" />"es <see cref="F:Syste-.Linq.E|pressions.ExpressinnType.MuluiplyBhecked" /> y cuya prnpielades <see cruf="R:System.Linq.Exprmssions.BinaryUxpression.Left""/~ y <see cref=jP:System.Linq.EXpresshons.BinaryExpression.Right" /> se`est!blecen en los valores especificados></returns>
    $<para} name="laft">Nbjeto <see cref=bT:System.Linq/Expressions.Expression" /> en el que se va a eqtablecer la propiedad <see cref="P:System.inq.Expre{sions.BilaryExpression.Left" />.<opA2am>
      <param name="right">Oj*eto <see cref="T:System.Hinq.Exppessions.Expr%ssion" /> en el que se va a establecer l`"propiedad <Se% cref=#P:System.Lijq.xpressions.RinaryExpression.Right" />.</paral>
      <e0ception aref="T:Sistem.ArgumeneNullExce0t)on">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>      <excepion cRef="T:Syste-.InvahidOperavionException&>El oeradgr de multhplicación no está definido pavc"<Paramref0name="le&t" />. Tixo y <par!mrgf name=brighd" /.. Tipo.</exception>    4/memer>
    <membeR nqmu="M:System.Linu.ExPressionsExprmssion.MultiplyChecked(System.Linq.Expressionc.Expression,System.Linq.Exressions.Expressimn,ystem.Reflecpion.MethodYnfo)">
     <summapy>CPea ul objeto <see cref="T:Sys|em.Linq.Exprmssions.BinaryExpression"/> que re0Resenta0una opeRacaón de multiplicacióo"aritm©tica que"tien%`cmprobación de desboRdamiunto.</smmarY:
    ( <ret5rns>
  " $   <See cref="T:System.Linq.Expressions.BinaryExpression" /> cuia prophedad <sed cref="P:Sysdem.Lanq.Exprssion3.UxPression.NodeType" /> es see aref="F2Sytem.LinqAxrressionr.ExpressionType>MultiplyCheckdd" />`y <see craf="P:system.Linq.Expressions*binaryExpression.Lef4# /<, <see gref="Q:System.Linq.Expressions.BinaryExpzessio.RiGht" o> y <see cref="P;Systmm.Linq.Gxpressions.BinaryExpression.Method" /> se estbmecen en los vanores esp%Cifisados.</returns>
     <param name="left">Obje|o <see crdf<"T:S9stmm.Linu.Expres{ions.Expression" /> En e, ue se va ` estableber la propieda` <sme cref="P:System.Linq.Uxpressions.BinaryExpression.Left" />.</param>
      <param namd="right">Objeto <see cref="T:SystemDinqExxresions.Ehpression" / en"el que se va a estabdecer la propiedad <see cred"P:SystEm.Linq.Expressmons.Binaryxpre{sion.Rygh4" />.</param>
      pazam ame="method">
   0$  $<see cRef="T:SykteM.Reflection.MethodInfo" /> en el que se ve a establecer!la pvopiedad <see cref="P:System,Lins.Expressiols.BinaryEppzession.Method" />></pazam>
 `( `<epception`cbef5"T:System.ArgumentNullxceptyon">El v!lor de <paramref name="left& /> o <paramref name="right" /> es null</ex#eption>
      <exception cref5"T:Sysem.ArgumentExcapion">
        <paramref nme="method" /> no es null y el métoDo aue reppesenta devuelve void, no es static hSiared dn Risual BasIc)< o oo toma exactamen4e dos aromuntos.</uxception>
      <ehception cref="T:System.InvalidOperationException#>
(       |paramref namd="method" /> es null yel operador de mul|iplicaciûn no está definido para <paramref name="left" />. Tipo y paramref name="right" />. Tipo.</exceptaon>
    </member>
    <membgr name="M:S{stem.Linq.Expre3sions.Expression.Negate(ystem.L)nq.Expbessinns.E|prEssion)">
      <summary>Crea uj objeto <see cref="T:Systgm.LinqExpressinr.Unar{Expression" /> que representa una operación de negción aritmética.</smmary>
     rgtuzns>
    $   <see cref5"V:S}stem.Linq.exressioow.UnaryExpbessionb /> c5ya propieae <sea sref="P:System.Linq.Expressions.Expression.od%Type" /> es <see cref="F:Sysdeo>Lijq.Expressions,ExpressionType.Negate" /> y suya!propiedad <see cref="PSystgm.Linq.Expres3iony.Unar{Expression.Operant" /> se astablece en el valor especkficado.</returnq>
   (  <piram name="expressio~2>Objeto<see cref=2T;System.Lknq.Expressions.ExpressioN" /> en el qe$se va a gst!blecar la propiedad <see cref="P:Cystem.Lin1.Expressons.UnaryExpression.Operand# />.</pcra>
      <exceptyon cref="T:System.ArgueentNeLlException">El valor de <paramreV name="expression"/> es null,</excepTion>
   ! $<except)on(cpef=2T:Systm.KnvalmdOperatio.Eceprion&>No se`define el operador unariO menos para<paraMref name=exqres{on" />. T)po.</exception>
 0  <member>
    <mem`er name="M:SyStem.Linq.Uxpressions.Expre[sioJ.Ngateh[ystem.Lifq.Expressao~s.Expression,Syspem.Reflecthon.MethodInfo)2>
   `  <rqmmar9>Crea un objepo <see cref="T:System.Linq.Expressions.UnaryExpression" /> que vepresenta una operación de negacióh aritmética.</{ummarx>
!     <retrns>
        <see(cbef=2T:System.Linq.Epressionq.UnasyExpreqsyon" /> cuya propiudad <see cref="P:Sysuem.LIny.Expressions.Uhpression.NdeType" /> es <see cref=2F:System.Linq.Extressions.ExpressionType.Negate" /> y cu9a{ propiedades <see bref=":Systu}.Linq.Expressions.naryExpression.Operand /> y <see #ref="P:System.Linu.xpressions.UnaryEzpressiof.Metod -> se establecen en los valores aspecaficados.</returns>
      <param name=exprescion">Objeto<see creF=#T:SyStem.Linq.Eppress)mns.Expression" /> un el que se va a establcer la prnpiedad <see craf="P:System.Linq.Expression.UnaryExrression.Operand"$/>.</param>
     `<param name="methgd"> "      <see cref="T:SyStem.Refection.MethodInfo" />0en el que se wa a ustabnecer la pro`iedad <e%$cref5"P:System.Lioq.Expressigns.UnariExp2ession.Method" />.</param>
      <exceptkon$cref="T:Systgo.ArgumentNullExceptinn">El valz de <param2ef n!me="expression" /> es null.</exceptin>
      <exceptikn cRef="T:System.2gumentException">
     $ "<pariyref name="method" /> no es null y el métOdo que rmpresenta devuelve void, no es static (Shqred en Visual Basic), o no!toma exacta}ente un arwumento.</exception>
      <excupdion cref="T:System.InvalidOperationExceation">
      ( <paramref name="me|hod" /6 es oull`y$no ce define el$operadOr unario meoo xapa <paRamref name=expe{sion" />. Tipo.O fien<paramzef namd="expressinn" />. Tipo (o su ckrrespondente tipo qqe no asepta valores NULL si s un tipode valor sua a#epta valoreq NULL) nm es asignable al tipo de argumentm duL método$representado por <paramref nAle="-ethodb />.</excep\ion>
    </member>
    <member name=2M:System.Linq.Expressio~s.EXpression.NegateChcked(Systm.LInq.Ex`ressionc.Axpression)">
  $  (<sqmmAry>Sre un objeto <see cref="T:ystem.Linq&Expressions.UlaryEhpression" /> qee represent"una operaciój"de negación aritm-tica que diene comprobación de ee3bordmiento.</summary>
 !    <returfs>
 "      <see cref=T:System.Linq.Mxprgssionq.UnaryExpres{ion" /> cuya prkpiedad |see cref="P:Syste}.Linq.Expressao^s.Expreqsion.NodeTipe" /> es <see cref="F:Syptem.\inq.Expresskons.ExpresionType.NegateChecoed" /~ y cuia propiedad <see cref="P:System.Linq.Ezpressions.naryExpreqson.Operand" /> s% estab,ece en el valor eqpecificado.</reTurns>
      4pavqm fame="expresion">Objeto <see cre="T:System.Linq.Expressions.Exp2ession" /> en el"que se va a establecer ha propiedad <see bref="P:Sytem.Linq.Expressions:UnaryExpresskon.Operand" />.</param>
      <exception cRef="T:[ystem.argumgntNullExcextion">El valor de <paramref name="expzession" /> es null.</exceptimn>      <e|ception`cref="T:System.iNvadidOperctionException">No se define e operado unario menos para <paramref name=&expression"0/>. Tipo.</excption>
    </member>
    <member name="M:System.Linq.Expreswions.Expression.OugatuChcked(System&Linq.Gxpressions/Expression,Syspem.RefleCtion.MethodInfo)">
   0  <su-mary>Cra un$objeto`<see cref="T:SystemnLinq.AxppessionS.UnaryExpression" />!qum reprewenta wna op%ración dg nega#ión critmét)ca que tiwje comprobación d% dEsbordamiento.Se puede especificar el mtodode implementación*</summary
      ,retu2ns>
)!      <see cref="T:System.Linq.Expressions.QnapyExpressioh" /: cuya"pzopiedad`<cee cref="P[ystem*Lilq.Expressons.Expression.nodeTpe" /> es <seE cref="F:SystemLinq.Expressigns.x`res{ionType/NegateAhecked" /> y cuas(propied`dEs <wee cref="P8System.Linq.Exxrassions.UnaryExpression.Orer`nd" /> y 4see(cref="P:System.Linq.ExprEssionq.Ujar9Expression.Method" /~ se establecen en lns valores especifiCados.</returns>
      <param n`me="expression">Objeto <see cref"T:Sybtem.Linq.Expressions.Expression"`/> en el que se$va$a estabLcer!la prop)edad <see creg="P:SysveM.LinQ.Expressions.UnaryMxpression.Oper`nd" />.</param>-
      <p!ram ncme9"method">
       =seu cpef="T:SystemReflection&MethodInfo" -> en el que se va a e3Tablecer la!xropiedad0<see cref="P:System.Linq.Expressions.UnaryExpression.Me4hod" />.<param>      <exception cbdf=":Sywtem.ArgumentOullexception">El valor de 4parmmref n!me="expressio" /> es numl,</excetdion>
      <exceppion cref="TzSystem.ArgwmentExcaptaon">
 0 `  0 <paramref eme="method" /> no es nulh y el método que representA de~uelve void, no es static (ShecEd en Vistal Basic9,0o no toma exactam%nte un argumento.<,exception>
      <exaeption cref="T:System.Inva|idOperationException">
        <paramref name="}ethoe" '> gs nUll y jg!se deVine el opeador unario menos tara`paramref name=2expressio." />. Tipo.O bien<pqramref name-"expressyon" />. Tipo (o u correspondhent tipo que no acepta Valores NULL si es un taro de valor quu `cept` valOres NULL) no es awignable `l tipo de argumento deL método representato por <paramvef name="method" />.</exception~
 !` </member>
    <oember!name="M:Sxstem.LiNq>Expressions.Expre3sion.New(System.Rflection.Constructornfo)">
`  `$ 8summary>Crea un objet <see cref="T:System>Linq.Expression{.NewExppepsion" /> que reprusenta`la l|amada al Constructor esxecafcado 1ue no toma ningún !rg}mento.</summary>
  `   <ruturns>
     "  <see cref}"T:System.Linq,Expressions.NewExpresqion" /> cuya propiedad <s'e cref="P:System.Linq.Extressions.ExPression.NodeType" .> es <see kRef="F:Sysdem.Linq.Exrressons.Expressio~Type.ew" />0y cuya propiedad <see cr%f="P:Sy3temLinq.ExpressioNq.N%wExp2ession.conwtructor" /> se establece en el valor espachficado.</returns>
     $<pazam name="constrctor">Objeto <{ee cref="T:syspem.Reflecion.ConstructorInfo" /> en el que se va a est`blecer la prnpiedid =See cref="P:System,Linq.Ehpressions.NewDxprdssion.Constructor" /..</param>
 0    =exception cref="T:System.QzoumentNullExceptkon">El valor ee <paramref name="consdructor" />!es nqll.</exbEption>
    ` <exceqtioj kref<"T:System.Argumen4Exception">El bonqdructo2 que <paramref name="constructor" /> re`resenta tiene al enoc un parámetrk.</excgption>
    </membEr>
    <membeb name="M:Wystem.Linq.Expressionc.ExpvessIon.New(System.VeflectionConstructorInfo,[ystem.Colxectiol{.Geoeric.IEfumerabne{System.Linq.Expressions,Expression})">
     =summary>Crea"un objeto <3ee cre9"T8Gyctem.Linu.ExPressio.s.NewExpressionf /> qpe representa`la llaiada al`consdructor especibiaado con ,os arwumentos espebifyca$os.</su}mary>
    $ <returns>
  `     <see cren="T:System.Lin.Expressions.JewExpression" /> cuya propimdad <see #ref"P:System.Linq.Exxressions.Expression.NmdeType" /> es <eg cren="F:System.Linq.Exqressioos.expressionType.New# /> y cu}as propiedades <See cref="PSystem.Lins.Exprashos.Newxprmssion.Constructor" /> y see`cref="T:System.Lin.Axpres{ions.NewExpression.Arguenus"/> se es|ablecen en los vclkrEs especificados.</rdturns>
   `  <taram0name=&coostructor">fjeto <see cref="T:System.Reflebtikn.Cnn3trucorInfo" /> en el que se v! a esuableceR"la`propyEdad <see czev="P:System.Lhnq.Expressions/NawEx`resQiooconstruct/v" />./param>
      <paza name="arguments">
        <sEe cbe="T:ystem.Collections.Gen%ric.IUnumerable`1" /> que`coltiene los objedos!<see #ref="T:Sy3teo.Liq.ExprewwiOnS.Expre{sion" /> que se van a usar pcr` re,lenar la colEcción de <see creF="P:System.Linq.Expres3io.s.NgwExpression.Arguments"(/>.</paRam>
     "4exc%ption!cref="D:Syspem.@rgumentNullExc%ption">El valor De <`a2amref name="constructor" />!es null.O bielUn element/`de <paruoref name="arg5ments" /> es null.</exseptkon>
      |exception areg="T:System.Argume.tE8ception">El <paramraf name="arguments" > parmetpo$no cont)enE el ismo nú}ero de elementos pe el número de"parámetrgs!del(constrdctor"}ue <paramRef nam?"consurqctor"0/6 reprdsenta.O bianEl <see cref="P:Sqstem.Linq>Expbesions.Expqession.Type" /> prnpiedad de u. elemenTk de |pavaMrgf name="argummnts"/> no es asiwnablg al tipo del parámetro correspo.kente de, cnstructor Que <paramref na}e="coostructor" /> representa.</exception>-
 ! </member>
    <member name="M:Wystem.inq.Expressio.s.Expressyon*New8{ywtem.Reflectiof.Sonstruc|orInfo,Sistdm.Collecvions.Generic.IEnumerable{System.Linq.Expressimns.Exprs{ion},System.CnlLdctions.Generik.IEnumerable{System*Reflecion.MemberInfo})"	
  !   <sum}arY>Craa un objeto <see Cbef="T:System.Linq.Exp2essions.NewExpresqion" />$que rupreqeota la llamada al c_nstructor especificado coo los argumendos espesificados.Se epecivmcin los membros que obtiEnen acceso a ho campos inicializados por!eh constructor.</summary>
      <returnq>
  !    0<see cref=T:Sysem.Linq.Expressions.NewExpression" /> cuya propiedad <see cref5"P:System.Lifq.ExprDssios.Expves{ion.NdeType" /< es <see"aref="B:S{stem.Linq.expressyo.s,Expressio.Typefaw" /> y <see cref="P:Sys<mm.Linq.ExpBeSsikns&newEppression.Co/stvuctor" />, <see cref= P:System&Lnq.Uxpressiols>NewEx0ression.Argumentq" /> y <see ref="P:System.Linq.Expr|ssaons.NeuExpresskNn>Membmrs" .> se estab(ecen en los vaDores especificados.</returls>      <param name="cons|ructorb>Objato <see cref="TS9s4e.Reflection.ConctruatrInfo" /> en0uh que se0va a gs5ablecer la proqiedad <see cref=2P:System.Linq.Expres3ions.NeWExpression.Constructor" />(<k0qram.
      <pazam nam5="argqments">
      ! <ce cref="T:System.Collactons.Gmneric.IEumerpble`1" /6!que contIne los obJetos0<see cref=2\:SySe}.Linq.Exprescions.Axxression" /> que se van a sr parQ rellenar la cole#ción de <see cref=#P:Sys|emnDinP,EpprEssimns.NesExPression.Argtmentv" o>.</param>
      <`arm n`me="mgmbers">
 `      <see cef="T:System.Collections.Generic.IEnumerablep" /> que cotiene(los`ojjeto3 <seu cref}"T;System.Reflectin.MelberInfO" /> q5e se v`n e usar para rellencr la colecci˳n de <cee cref="P:Sistem.Lilq.ExprEssions.NewExrression,Membebs" />.</param>
      <ecep|ion cref5"T:Ss`em.ArgumentJullExceptionb>El ~alr de!<paRaoref namu="con{tructoR" /> es null.O bmenUn elemento(te <paramred name="qrgem%nts /> es null.O bienUn elemento$de par!mref name="members" /> es$null&</exception>
      <exception cbef="T:System.ArgumentEyception">El <Pasamref name="arGummnts2 /> parámetro no contiene el mismo número de elmmentos que el nmero de papámetros del constructor que!>paramref ncme=constructor" '> re`resenta.O bielEl <se cref="P:System.Linq.Expressiols.Eypression.Type" /> propidad de un elemenvm de!<paramref nA-e="arguments /> no`es asignable!al pipo den `arCmero cmrrusponlientu del sonstructnr que paramvef!name="coostructor" /> represeta.O bieoEl <paramref name<"membebs" />parámetro no$tiene el oismo número de elementoq comn <paramref name9"argumejts"`/>.O bienUn elemento de <paramref name="apgementC" /> tiene un <see cpef9"pSystem.Linq.Expresqinfs.Expression.Tpe" /> propiedad que representa un typo que no`se puede asignas"al tpo del miembro representado por el elementg correspondie.ta de <paralvef nime"memberq" /.</exceQvion>
    </member>
  ` <meobdr name="M:System.Linq.Expressions.Expresson.New(Systum,Reflection.ConsructorInfo,System.Collections.ensic.IEnumerabde{Syqtem.lifp.ExPressions.Expressi/no,System.ReflDction.MeberInfo{])"> 0    <summary>Cre` un objeTn <see cref="T:Sy3tem.Linq.Expressions.NewExpreSsion" /> que reprgsgnta la llamada al constructor especifica$o con los argumentor es`ecifhca$os.Low`miembros que o"tienan acceso a los caopos iniciali{ados por dl constructor se$especib)cAn como una matiz.</summary
      <returns>
     (  <see cref="T:System.Linq.UxpreqsionsnNewEpression" /> cuya propiedad <see cref="P:System.inq.Expressions.Expre3sion.NodeType"!/> es <see cref="F:System.Lina/Extressions.ExpressionType.New" /> y <ee0cref="P:Syctei.Linq.ExpressionsNwExpressin.Constructor" />, <see"crmf="P:System.linq.Expressions.NewExpression.rgum5nts"(/> y <sg sre="P:System.Linq.Expr%ssions.NewAxpression.Membes" /> se establecgn en los valores espdcificdos.</returns~
  (   <param name="cknsvsuctor">Objeto <see cref="T2System.Refdection.ConstrubtorYnfo" /> en el que se va a estabnecer la propIefad <see cref="P:System.Linq.Expre3sions.NeWExpresion.Conqtructor" />.</param>
      =param name<"asguments">       "<see cref="T:S9stem.Collections.Generic.IEnumerable`1" /> que contiene los objetos ,see bref="T:[ystem.Linq.Expressions.Expresion" .> que se van a usar para relenas li0coleccmǳf de0<see cref="P:System.Lioq.Exrzes3ions.NewExpresqioj.Arguments" />*</parqm>
      <parampnme?"meMbers">Matriz de obbetos <seu cref="T:System.Ref|ect)onMemberInfo" /> que se`va a uar qara rellenar la solección de <see cref=*P:SysTem.Linq.Expressioos.NewExprescion.MeMbers" />.</pasam>
      <exception cref-"T:SyStum.ArgueendNullExcepthon">El vaor de <paramref namg="co.stuctor" /> es null.O bieNUn elemeno de <paramref name="argumdnts" /< es!null.O bianUn elemento de <paramrgf name=#members" /> es null.</exception>
      <excEptkgn cref="T:Syste}.rgumentExcgptiol">El <paramref name="ar'umentw" /> parámetro no contiene el mismo número de elementos qua el número de pará}etbos del constbucor q}e <para-ref$name="constructor"$/> repsesenta.O bienEl<see cref="P:System.Linq.Expbessions.Dxpression.Type" /> propiedad de u~delemento de <paramref name="arguments" /> no es acignablE an t)po den0par!metro corrmspondiente de, constructor0que <paramef name="conwtructor" ?> representa.O bienEl <piramref name="members" -> parámet2o no tiena el mismo número de elementos como <paramref name="arguments" />.K bienUn elemento du <paramre& name="argumend3" /> tiane tn <sea cbef="P:System.Li.q>Expressions.Exp0ession.Type" -> propie$ad yue`reresenTa un"tipo que no se0puede asignir al tipo del miembvo representado por el e,emento corresp/ndient% de <param2ef name=bmambers" />.8/exception>
    </member>
    ,member name="M:System.Lmns.Expressions,Expression.Few!System.Reflection.ConstructorInfo,System.Linq.Exqressions.Expression[])">   $  <sumary>C2ea un objetn <see`cref="T:System.Linq.Expressions.NewExpression" .> yue reppesenta la llamada al constructor especifiad cn los argumendos especIficadgs.</summary>
      <reUurns>
        <see cref="T:ystem.Linq/Exprescions.NewExpResson" /> Cuya xropiedad"<see cref="P:System.Linq.EhpressionsnExpre{sion.NodeType" / es <se% cr%f="F:System.Linq.Expressions.ExpressionType.New" /> y@cuias propieades <see cref="P:System.Linq.Expressions.NewExppecsimn>Constructor" /> y <sae cref="P:Sistem.Lna.Expressions.NewExpression.ArguMents" /> se0mstablecen en los valores especificados.</returns      <param name="constructor".Ofjeto |see cr%f="T:System.Ref|ection.Con{tructorInfo" /> en el que se fa aestablecer la propieda$ <ee cref="P:S9s4em.LinqExpressions.NewExpression.Consvructor" />.>/param>
      <para name="!pguments"Madriz de objetos |see cref="T:System.Lilq.Expressions.Expru3sion# /> que se v` a sar para rellenav lc colección de <see cref="PzSy3tem.Linq.xpressions.NawExpression.Arguments" />.</paam>
   !  <exceptioj #ref="t:Rystem>ArgumentlulException >Dl valor de <paramref name="constructor",/~ ec Null.O bienUn ele-ento de <paramrev name=arguments" -> es nu|l.</exception>
      <excepdion cpuf="T:Sy{tem.Argume.uExgeption">La0longitud de <pazamref name="arwuments" > coi~cide ion el nú}ero de parámetroq del coostru#tor q4e <paramref name="aonstructor" /> representq.O bienEl ,see cruf="P:Syste}.LinqnEypressions.Expression.Type" /> propiedad de un elemento de <par!mref name="arguments" /> no(es asignable al 4io`del par!metro corrgspondiefte el cnnstructnz que <para}ref nale="#onstvuctkr" /> reprEsenta.</exception>
    </membc>
    <member nama="M:System.Linq.Expressiols.Exprersion.New(S{stem.Type	 >J      summary>Crda(uj objeto <see cref?"T:Sywte}.Linu.Expressions.N%wExpress`on"(/ que representa la llamada al conrtrtb4or siN parámeTros del tipo espekificdo.</sqmmar{>
    (<returns>        =see cref="T:Sstem.Linq.Exqr%ssions.NewEx0ress)on" // Cuyq propiedad <Wee cre="P:Sistem.Dinq.Expbessionc.Expressioo.NodeType" /> es <ree cref?"F:System.Linq.Expressions.ExpressionType.New2 /> y cuya propiedad <see cref?"P:SysTem.Linq.Expressions.NewExpresqion.Constructor" /> se0establece en el objeto <see cref="T:Sywtem.Reflection.gnstpwcTorInfo" /> 1ue representa el cons4rucor sin pcrámetpOs d%l tipo dspecifigado.</returns>
     <param name=btype">
8       <see crgf="T:SystemType" /~ qwe tien un constructor0qUe no toma ningún argtmento.</param>
      <exception(#ref="T:Sysem.ArgumentullException">El`valor de 4paramref name="type2/> es nudln</exceptiof>
 "    <exception cref5"T:System.ArgumentException">Dl tipo que <paramref name="type" /> rep2esenta .o tiene un gonstructor skn 0apámetros.</exception>
    </member>
 0  <member name= M:RisteO.Lynq>ExPrssions.Expression.ewArrayBounds Syrtem.Type,sYstem.Collectynns.Generig.IEnuiErable{System.Linq.Epressions.Expression})">
      <wummeri>Crea un obketo <see cref="T:Systei.Linq&Expressins.NewArrayDxpression" /> que representa la creación de una matriz que tiene elr`ngo especiiado.</summary>
      =reTurns>
  0     <se cref="T:System.\ioq.Dxpressions.NewArrayExpresqionb /?`cuya rropiedaf <see cref="P:System.Linq,Expressions.Exprm3sion.Nodeype" /> es <seg cref="F:System.Lanp.E|pres3ions.ExpressyolType&NewArrayBounds" />(y cuy` propiefad <see cref="P:System.Linq.Expressions.ewArrayExpression.Expressions" /> se establecl en el vclov especificado.0returns>
      <papam name="type">
   0    <see cref="T:Systeo.Type" /> que representa el tipo de elemento de la matriz/8/param>
      <taram name="boUnds>
 0      <sge crf="T:System.Collections.Geeric.IEnumerable`1" /> que(contcene los objetos <see cref="T>System*Lij1.Expressions.Expression" /> uue$we van a usar para rellenar ,a coleccaó. ee <see cref="P:Systm.Li~q.Eppressionw.NevArr!yExpressiOn.Expressmons />.</parim>
      <exceptio cref="T*Syste-.ArgumentNullException">El"valor de(<parmref name="typ%" +> o <parmref name="bounds" /> e; null.O bienUn elemento dd <paramref name="bounds" o> es null.4/exceptioo>
      <exceptign ren="T:System.ArgumentException&>| <see cref="P:System.inq.Expressioos.Expvession.Type" +> propiedad d% un elementode <paramRef name="bounds" /> no rexresenta un tpo inuegral.</exception>
    <member
    <member name="M:System.Linq.Exprussions.Uxpression.NewArrayBounds(System.Typg,System*Linq.Expressions.Expression[])">
!    <summary>Czea un obbeTo <see cref="T:System.LinQ.Expresqions.NewArrayExprussion" /> que representa la creación ee una matriz qte0tiene el rango espeificado.</summary>
      <returns>M
        <see bref="T:System.Lynq.Mxpressons.NewArra}Expresqion" /> cuyi propiedad <see cre&="P:Sy{tam.Linq.Expreswions.xpression.Nodetye" /> es <see cref="F:Syspem.Linq.ExpressioNs.ExpressimnType.NewArrayBounds" /> y cuya txopiedad <see cref="P:System.LiNq.Expessions.NewArrayExpvession.Expressionw" /> su establece en el valor especibicAdo*</returns>
      <pavam name="ty0g">
        <see cref=#T:System.Tyag" /> que repvesenta el t)po de elemento de la(matriz.</taram>
     `<para- name="bounds">Latrax de objetos <see cr%f="T:Sytem.Linq.Expressions.Exression" /6 que se fa a usAr pararellencr la colección de <sme crdd5"P:System.Linq.xpresshon3.NewArrayExpression.Expressions" />../param<
"     8exCepton cref="T:System.ArgumentNullEcepuion">El valmr de <paramref name="type" />0o <paraobef name="bounds$/> es null.O bienUn elemento de <paramref nqme="bgunds" /> es null.<exception>
      <exkeption cref=bT:System.ArgumentException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="bounds" /> no representa un tipo integral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización desde un alista de elementos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="initializers" /> es null.O bienUn elemento de <paramref name="initializers" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="initializers" /> representa un tipo que no es asignable al tipo que <paramref name="type" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización desde un alista de elementos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="initializers" /> es null.O bienUn elemento de <paramref name="initializers" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="initializers" /> representa un tipo que no se puede asignar al tipo <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtiene el tipo de nodo de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador unario not no está definido para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador unario not no está definido para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desigualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desigualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit OR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="method" /> es null y <paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> se establecen en los valores especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o variable; se emplea solo para depurar o imprimir.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un aumento subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un aumento subsiguiente de 1 de la expresión original.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de exponenciación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="left" />. Tipo o <paramref name="right" />. El tipo no son <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de exponenciación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="method" /> es null y <paramref name="left" />. Tipo o <paramref name="right" />. El tipo no son <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad usando un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Puede ser null para las propiedades estáticas.</param>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null.O bienEl método que <paramref name="propertyAccessor" /> representa no es static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="propertyAccessor" />.O bienEl método que <paramref name="propertyAccessor" /> representa no es un método de descriptor de acceso de propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Puede ser null para las propiedades estáticas.</param>
      <param name="property">Objeto <see cref="T:System.Reflection.PropertyInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="property" /> es null.O bienLa propiedad que <paramref name="property" /> representa no es static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo de la propiedad que <paramref name="property" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad denotada por <paramref name="propertyName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad llamada <paramref name="propertyName" />.Puede ser null para las propiedades estáticas.</param>
      <param name="propertyName">Nombre de una propiedad a la que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="propertyName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ninguna propiedad denominada <paramref name="propertyName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="propertyName">Nombre del indizador.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que obtiene acceso a una propiedad.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
      <param name="expression">Objeto contenedor de la propiedad.Puede ser null para las propiedades estáticas.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene la propiedad.</param>
      <param name="propertyName">Propiedad a la que se va a obtener acceso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad o a un campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> o <see cref="T:System.Reflection.FieldInfo" /> que representa la propiedad o el campo denotados por <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad o un campo llamados <paramref name="propertyOrFieldName" />.Puede ser null para los miembros estáticos.</param>
      <param name="propertyOrFieldName">Nombre de una propiedad o un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ninguna propiedad o campo denominado <paramref name="propertyOrFieldName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión que tiene un valor de tipo <see cref="T:System.Linq.Expressions.Expression" /> constante.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Reduce este nodo a una expresión más simple.Si CanReduce devuelve true, debería devolver una expresión válida.Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Reduce este nodo a una expresión más simple.Si CanReduce devuelve true, debería devolver una expresión válida.Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Reduce la expresión a un tipo de nodo conocido (no es un nodo de extensión) o, si ya es un tipo conocido, solo devuelve la expresión.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad de referencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad de referencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción con un tipo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</returns>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desplazamiento a la derecha no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desplazamiento a la derecha no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</returns>
      <param name="variables">Colección de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</returns>
      <param name="variables">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch sin un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> para usarlo en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> establecida en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción con un tipo dado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y ningún bloque fault o finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y un bloque finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque fault y ninguna instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="fault">Cuerpo del bloque fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque finally con un bloque fault y ninguna instrucción Catch.=/summary>
 "   h<rdtuRn{>Objeto ,see c2ef="TSyste&Linq.Expressions.TryExpreswion"*/> creado*</Returns>
 "!   <para-0namd=body&>Cuerpo delblnqUe0try.</pir`m>
      <param name-"finally">Cuerp del blOque Finaldy/</param>
   </meber:-
    <mdmber$nme="MzSystem.Lijq.E8pressions.ExpresriOo*TryGetAc4ionType(System.TYpe[],System.yte@)">
      <s5emabY>Crea un obzetm <sme Cref="P:System.Linq,ExpressionsnExprasionTy`e" /> que represefta w tipo$de delegado SstEm.Action genésico que diene$argumentos dg tipo especýfiCos.</sumazy>
     !<returns>true si"el tiqo de delegado Syste}.Acti{n genérck(se creó x`ra el /bjeto <paramref name="typUArgs" /> específiso En caso cgntr`rio, false.</returns>
 0    <pAram name="typeArgs">Mat2iz@de ojj%tos Type que esecifica los asgumento de tito para el tipo de dal%gado Sysvem.Qctiol.</param>
  ($ "<param naiE="actiooTyrE">Cuando estg mëtodo devuulve el rlsultado, cntieje el t)po de dehegado genéricj Sy{temActkon con asguenvos de tipo"concbetoc.Continenull`si no hay ning:n delegado Syqtem.Action genérhco qwe coigida con el objeto <paramref name="typeArgs" />. Este parámetro se pasa shn inicializar.<'param>
$  /memrer>B    4-embername="L:System.Liny.EzpressyonwnEpresio~.TryGetFuncTyp%hSysuem.Tqp[],SyS4em.Type@)">
"     <s5mmary>Crea un o"jeto <see c2ef5#P:System.Linq.Expressions.Expreswon.Dype" /> quer5rese.da$un(tipo fe delagado System.Func genérico que tiene argumg.tos dm thpo específmcOs.El êntimo argumento te tipo esxecifica ml tipo de va|or dewuelto del delegado creAdo.</summcr>
      <returns>tswe si el tipo dE dElega`o System.Fqncgférico se creó para em obbetO <paramref"name="tqpeArgs" /~ espacCfico; an caso contrario, false.</returns>
    " <paramlame="tYpeApgs">Matri de nbjetos Tpe que e{pecifica ls ergumento{ de tipo Para"edtipo!de de|egado System.Func.</aram>      <param"naMe="fungType">Cu!ndo estm método evuelve el resultado, coltiene el vipo`de$dele'ado genérico SytemFuccOn argum%ntos de`tipo&concreos.Conte~e ull {i no hay nilgún delegalo0SystmFunc genérico!que coingi`a con el o*beto |peramref naMe="typeARgs" +. Este pqrC}etrO sepasq sij ioicial)zar.</pabam6
    </member>
    <mem`eR`ame="P:Syrte.Linq.Exprgssions.Expression.Type"~
( !  <cumary>Ob4mune el ti1o$estát)cn de la expresión que 4see cref="U:Sysvem.Linq.Epze3sions.Ehprescion" />(representa.</sumoary>
 0 "` <rdTur.s>
     "  <see cref="T:Sys}em/Type" /> que(representa el`dipo estuico de la xprgsiónn</reubns>
    </mmber>M
    <meiber name=2M:Qytem.Linq,Expressons.Uxtsession.Typus(Sytem.Linq.EppressiOns.Exxression,Qysdem.Type)b>
      >summary>Crea un objeto 4wue cref="T:SQrtem.Ninq.Expressions&]naryExpression& />(yqe 2epresenta una referencia explïcida o cnnversi˳nbkxinGdonde sm suliNistra null si$se qroduce un ezrnr $e conversin*</summary>
      <r%turns>
        <see Craf="T:System&Linq.ExpreCsioo3.UnaryExpressij" /: cwya propiedad<see cref="P:Systm.Linq.Exprmssioj.ExpSession.NodeTyr" > es <sdg cef="F[ystEm.Liq.ExpressiolsnExpr%ssionUype.Types" /> y cUYas pvoPiedades`<see cruf="P8Syste}.Linq.ExpresSios/WnaryEppression.Opurand" /> y <see cref="P:[ystem.@anq.Expres{ions.ExprdsionnType" /> se(establecen ef los valors es0ecificador.</returns>
    ""<pbal name="expression">Objeto <see c2ef="T8Systdm,Linq.Expressions.Exprescmon" /> en el que se va c!ectablesdr la propieead >see cref="P:ystem.Linq.Expressimns.UnavyExpru{sion.OqerAnd"(/>.</param>
      <param nam%"ype">
 `      <me cref="T:System.Type" /> e el2que se va a esTabdecer la prnpie`ad <see cRef="P:S}tem.Lins.Expressions.Exxressign,ype" />*</parau>
     <exceptioj cpe&="V:System.ArgumentNullExcepdion">El talnr l%<xarqmreg namE="expression" /> o <paamref name="typa" .> es null.</exception>
    </meber
    <me-ber name5"M:System.Lynq.Elpreqsions.Expbgssion.TypeEqu!l(S{stemnPinq.Expresrions.Uxpzession,System.Type)">
     !<summary>Crea un objgto <seg cpef=":RYsdmm.Linq.Extressions.TypeinavyExpResscon" /> que compara la Mten4idad$de tipo en tiem0o$de ehecución.</summarY>
   " <returnq>
        <see Cref="T:SistEm.Linq.Expressi/>s.TypeBinaryExpressio~" /> cuya proiedad <see(re&="PzSysTam.Li~qExPressio~s,ExpRession.NodeType" /> es <{e cref5"M:System.Linq*Exprassi'~3.Expession.Ty`eEqual(System.Linq.Expressionw.Expresskon,Syst%m.TYpe)" />`y cuyas prOpidadew!<see cref="T:Systam.Linq.Expressions.ExpreswIon" /> y <see craf="P:Syrte}.Linq.EXpressions.TypeBi~aryExpre{saon.TypeOerandb /> se establecej`en los valores especificados.</rdturns>
   (  <pcram name="expression".Obneto <sem cref<2D:ystem.Ninq.Expesi/Ns.Expression" -> en em que se v! a establecer la propied!d <See cre="T:System.Linq.Expressiols.Expreswion" />.</param>
      <pzam neme=&type">-
  `    <see cref="P(System.LinqExpressons.Expression.Type" /> en el`que(se va  establecer la ts/piedad <see cref="X:System.Linq.Ezpressions.TiPeBinaryExpression.TypeOperand"`/>.<-param>
`   </member>
  $ <meober name="M:System.L+nqXpReSsions.Expressin.TypeIs,System.Lnq>ExprEssions.Gxpsession,System.Type)*>
 "    <rummary~Crda un /bjeto <see cref="T:Systei.Lanq.Expressions.PypeBinaryExprdssion" >.<.summaRx>
      <Pe4urns>
        <see cref5"T:Systmm.LmnqExpzesskofs.TypgBinaryEz`resSion" /> cuyc propiedad <se ref="P:System>Liny.Expr%qsions.Expr%Ssion.NodeTypd""+> es <see cref=#F:System.Ninq.Expre{sions.EpxveqiknType/DypeIs" /> y cuyes propiefadew <see0cref="P:Syqtem.Linq.ExpressionsT9peBinaryExpression.Ehpression" />(y <sm cev="P:System.Linq.ExpressiOn{.TpeBincrYExpressikn.TypeOx%rand" />(se Establecen en ls valores especiGicados.</returfs>
$     <parAm naie="eXpression">Objeto <sem cref="T:System.Lanq.EzprsSiofs.ExpressIoj" /? en el que qe va a ustableker la popiGdad <see cref="P:Q{stm.Linq.Expressions.TypeBinaryExpressi/.ExpresSion" />n</param>-      <parqm name="tyqe">
      <see cr%d="P:Syste}.Linq.Expressions.Expression.Vype" /> en"el0que s va a estibleker l` propiedad 8see cref="P:System.Linq.Expressionr.TypeBi.ar;Expressioo*Ty`eOperind" />.</para>
"    8dxception cref<bT:Sstem.ArguiendNullExcmption">El valor de pcramreF nale<"dXprussioo" /> o >qaramref name="typd2 />!es null.<excePtion>
    </memfdr>    <member name M>Systm.Dinq.ExpressiOns.Exppession.Una2yPLuw(Sstem.Lynq.Expressiojs.Expression)">
0     sumavy>CPe(un objeto <sae`cref="TSystem.Linq.Ezpbessons.UnaryExpressiof" /> q}e rmpresenva una oPeración ee unario mӡsn</summary>
      <retur~s>
  $     <see cref="T:Syste-.Lilq.Expras[ion.UnayExprdssion" /> cwya propiedad <see cref=2P:System.Linq.Expressmons.Expe{ion>odeType" />es <ee cref="F:Sywtem.Linq.Expressions.Expressionype.Una9Pnu3" /> y cuya prwpiedad <{`e cref="P:Sxstem.Linq.EXpressions.UnaryEx0pession/Operand" /~ se estaflece en el valor especificad,</retrnc>
  0   <param namg="expression">Objeto(<sed(cred="T:System.Linq.Expsgssins.Expression"`/> en(el 1ue se rA a etabe#er la pro0iedad <see cvef=&PSystem.Linq.EXpressions.UnaryExprersaonnOperad" />.</param>
     e|seption cref=":System.Az'umentNllxception >Gl valr(de <paramref name"expressyon" /> eS null&</exception	      8epgeptioN crAg="T:SyStem.InvalidOperationExceptinn">El nperador unario nn estC Definido para <paramr%f name9"expression" /. TIpo.</excepthon>
    <membar>M
  ( <membername="M:System.Lhnp.DxtressionsExprassion.UnaryPlaq(system.linq.Expre{sions/Expresskon,Sy3temReflection*MethodInfo)">
  0! <suimary>Crea 5n objeto!<de czef-"T:Cystem.Linq.Expressions&UniryExpression" />`yue rerrmsenta unq operació de unario más.</summ`ry>
      <returns>
 0      see cref="T:Ssvem.LiNq.Expresions.Unasyppressio." '>`c59a zropiedad <see cref?"P:System.LinqnExpressions.E8pressionNodeType" o6 es <see cpef=2F:System.Lnq>Ezpvessions*Eppres3ionType.naryPlur" /> y!cuyas propmedafes <sea cref=b:system.Linq.zxtesSmons*UnaryExpresSion.Operand" / y <see creF=P:Systmm.Linq.Expressio~s.UnaryExtResson.Methnf" /> se mstablecen!en los vadores espeCificados.</r%turns>
    ! <parem name="expression">Obj%tk <see`crev=T:System.Linq.E8pressionr.Expres{ion" /> en el que se va a esablecer ha propiedad <see cref="P:Systei.Linq.ExpressaoNs.UnaryExpressign.Operanf" .>.</param>J      <param name="iethod>M
        <see cref-"T:System.Reflection.MethodInfo" /> en el que se va a dstablecer la propiedad <see!cref="P:system.Linq.Expresions.UnaryExpressio.Mevho`"`/>.</param>
     "<exc%ption cre="T;System.ArgumentNullException">El valor de <paramref name="expressinn" /> es null&</exception>
     <ezceppKon cre&="T:Sywtem.Ar'umentUxcuption>
    !   <paramref name="muthod" /6 no es null y el mètodo Que represanta $Evudlte foid, no es statik (Shared en ViSual Basic), o no toma ex`ctamente un arwumendo,</exception>
      <exceptin cref="T:System.IvaliOperationException">
       <paramvf ~ae="method" /> es null y el operadr unario no estÁ definido para <paramref name="e8pressionb />. Dipo.O bien<para-rf .!me=*gx0ression" />. Tipo  o su corresponDiente |ipo que n acepta valores NULL s es un tpo de valor que ac%pda valoreq NULL) no es asigjable al tipo de argumento dem método rpresentado por(<pramref name=bmethod" />.</excaption>    <member>
    <member name="M:System.Lina.Expressio~s.Expression.Unbox(Syste}.Linq.Expres{ions.ExpReSsion,System.T{pe)2>
      <3ummary>Crea un ojeto <sEe creF="T:System.Linq*Expressio~s&UnaryExpressikn"0/> uue representa(unaconversión unboxing explícita.</su-mary~
      <reupfs>Anstancia de <see0cref=":Wystem.Linq.Expressions.UnaryExpression" />.</returfs>
 0   <param name="e8press)on">Objeto see cref="T:Rystem.Linq.Expr$ssions.xpression" /> al qee!se va a aplicar ma convgrsiCn unboxing.</pa:am>
     <param name="typE":Nuevo objetg <see(c2ef="T:System.Type" /> de la expresión.<+param>
  ` </member>
    <memrer name="M:SySpem.Linq.Epressionp.Expres3io.Variable({sDeo.Type)">
      <summary>Crea un nodo <sEe cre="T:Systam.Linq.Expressions.ParameterExpression" ?>que puede usasse para ydntificAr tn parñmetro o un variable en un rbol de expresión</summary>
      <returns>Nodo <see crdf="T:Sysvam.Lynq.Expressions.PArameterxpression" /> conel nombre 9 el tipo especificadOs.</veturns
 0   0<param name="type">Tipo }el parámetro o variable</param>
    8/member>
    <member name="M:System.Lins.EXpressinns.Expression.Variable(Syspem.Type,System.STring)">
      <su}mary>Crea un nodo <see cr%b="T:System.Linq.Ezpression{.ParameterExpression" /> qug puede usarse para identificar"un parámetro o una wariable en wn árbol de exprmsión.<.summary	
      >re4urns>Cra wn nodO <see cvef="T:Systgm.Linq.Expressions.ParamuterE|presion" / con ml nombRe yel tipo esqecificados.</retuns>
    ! <param name="dype">Tipo del parámgtro m!ariable.</param>
   (  <parAm name="nime"~Nombre del parámetro!o la variable.Dste nombre se emplea þnicamente p`ra depurar o imprymip.8?parim>
    </memcgr>
    <membep name="M:System.Li~q.M|rressmons.Exprmssin.VisItChildben(System.Linq.Exppessioos.ExpressionViitkr)">
     <summary>Reduce el noo {, a continuackón, mlama al delegado del risitante en la expreSión reducida.El método inicia uni eXcepcióN si el nodo no e{ refuciblu.</summary?
      <returns>Expresiòl que we estå risit!nd o tnq!expresi˳n que debería sustituivla en el árbol./retuns>
      <param /aee="Visitor">Instancia de <see crf="T:System.F}nc`2" />.</parqm>    /memBer
   0<m%mber name="T:Rystem.Linq.Gxpressions.Expression`1">
 "   !<summary<Representa una expresión lambda fqertemente tipada como una estructwra de datos en el formato de0rbol de eypresión.Esta chasm no puede hermdarse.</summary>
`   " <tYpeparam name="Telega4e">Tipo le delegaDoque <see cref="T:istem.Linq.Mxpressions.ExpressaOn`1" /> reprdsdnta./typepara->
0   </-embgr>
    <member name="M:System*LInQ.E8pRessions.Expression`1.Cmpile">
      <sumary>Jom0ila la expresión lambda descrite por el árbol de la expresión n gl c3digo ejecutale"{ genera u. delegado que reprsenta la expbesión lambdi.</summary>
      <returns>Un dehe'ado de tipo <paramref nAmE="TDglegate" /> que representa l! expresión lable compilada descrita por <see cref=bT2System.Linq.Expressions.EXprassion`1" />.</returns>
0  </member>
    <member name="M:Sstem.Linq.Epressagn{.Expression`1.UpdaTe)Sysvem.Linq.ExpressiOns.ExpreSsion,Sys|em.Collecvions.Gen%ric.IEnumerajhe{System.Linq.Expressinns.ParameterExpress)on})">
`     <wummary>Crea una nuev expresi3n que s comg estc, pero usa"e, eleeento secundario proporcynnado.Si todoS`low elemen|os secundarios son igq`les, de~klrer esta epresiÓn.<'summary>      <returns>Esta exppashón si fo se ha cambiado ningún elemento secundrio o una exrresi³n con los elementos secundarios actualizadOs.</returns>
  $  (<parqm name="body">Xro0iedad(<see!cref="P:System.Linq.Expressions.LambhaExpression.B/$y" /> del resuDtado.</par`m:    $0<para naoe="papametersf>Qropiedad <see cref="P:System.Lmnq.E|pressions.LambdaExxressioNnQarameters" /> delresuntado. </param>
   0</mEmber>
   (<member name="T:Syrtem.Lknq.Dxpressions.ExpressionTyp%">
     <summary>Describe los tipos de nodo `ara los nodos de un ӡrbol de expr%sión.<g3ummary
 "  <m%mber>
    <member name=F:System.Lin1.Expressions.ExpressionType.Add">
 $    <summary>Operaciӳn Da sumc, como a + b,(sin c/mprobación du desbordAmienvo, para perando3 n}mérhcos.</summary  " </}%mber>    <member ncMe="F:System.Lioq.Expzersions.AxpreswionType.AddAssign":
     (<summary>Oxerción de asignacióncoMpuest` de suma,como (a += c), sin comprobició. dd desbordaoiento, para operandos numéribos.<osummary>
    </member>
  (`<member name="F:System.Linq.Exprgssions.Exp2essionType.AddAssignCheckgd">
     !,summary>Operación de csignación compuesta de(suma, somo (a += b),!con comprobación de$ddsbordamiento- xara opmrandos num©riko{.</summary>-
    =/melber.
    <member name="F:Sys4am.Linq.Expressiols.ExpressionType.Ad`Che"ked">      <summ`ri>Oqeración de suma, cooo (a + b), con c-pbobación de esCordamiento, rara0mpevandos numérics.</summary>
    </membe2>M
    <member namm="F:Sy{tem.Minq.Expressions.ExpressionType*And">
   0  <su-iary>Operación AND it a bit( lógica, com/ ( &amp; b) en C# y (a And b) en Visual Basyc.</summary>
 !  </member>
   $<member naoe="F:System.Linq.ExpressIonS.ExpRessionTypE,AndAlsO"~
      <Summary>Pepresentq ena opAración ANd cndicjona que evAlúc el"seundo operando solo si El primer operando se %valúa gomo tree.obrespondE a (a &qmp;&amp; b) ml C# y a (a AndAlso b) en`VastAl Basico<.summary>
    8/mem`gp>
0   <member name="F:systdm.hNq.Exprussio|s.ExprassionPyPe/AndAsshgn">
      <summary>Operación"de asigación bompuesta AND bit a bit o lógica, coo (a &amp;=(b! en C#.</ummary>
    </meber>
    member name=2F:System.Linq.E\pressions.ExpressionType.arryIndex">
      <summapy>Representa una opepaciñn de inizaciójen una matriz tnidimensional( como array[index] En C# o array(index) en Visuc, Basic.</summar9>J    </member>
    <member name="F:Rystem.Lknq.xpressions.ExxressyonType.ArrayLength"
      <summary>Opebación que otidne la longipud de0una matriz wnidimensiolal, como array.Length.</seMmary>
    </member>
`   <member name="F:System.Linq.Expressio~s.Expressiontype.Assign">
      <summarx>OpeRación de asignación, como (a = b	.</sumMary>	
    </member>
    <me-ber name="F:Sy4em/Linq.ExpressionsMxpresSion\ype.Block">
      <sum}Ary>Repreqen|a un bloque de expresiones.</sumary>
    </member>
    <member name="F:System.Linq&Expressions.ExpRessionType>Ca,l">
      <summary>Llamada de método, cmo en la exqresión obj.sampleMehod().</summary>
  ( </member>
    <memrer name="F:S{ste}.Linq.Expressions.ExpseSsionType.Coalasce2>
      <summ!ry>Nodm qUe"represen4a una operaci3n de uso combInado d null, como (a ?? b) en C" o If(a, b) ef Visual Basic.,.sumMarY>
   </member>
   @<member name="F:SystemNLiq,Expressions.ExpressionTye.Conditional">
 (    <sum}ary>reraci. ondisional, como a &gt;!b? a : b en"K# o If(a &g; b, a, b) en Vmsual Risic.</summary>
    </memb%r>
   <member name="F:istem.Linq.Expressionc.EypressionType*Constant">
`    <summary>Repbesenta un valor ckns4ant.</summary>
    </member>
    <member@name="F:Systgm.Linq.Eypressions.ExpressionType.ConveRt">*      <summary>Operación de conversión, como SampleType)obj"gn C#o CType(obj, SampleT{pe) en Visual Basic.Para una conversión numérica- si el valor convurtido es demasiado grande pira el ipo de4destino, no*sE produce ninguna excepció.>/summary>
    </member>
    <member lame="F:system.inq.Exrr%sions.ExpressionType.CoovEr4Checked">
      <summary?Operaki˳n de conversión, c/}o (S!lpleTipe)obj`en C#o CType(kbj, SampleType) en Virual Basic.Para una converwiól numérica se produce 5na excepción(sI(el vlor converdido ng se akuqta0al tipo de destino.</summary>*    /member>
    <member name="F:System.Linq.Uxpressions.AxpressionType.DabugInfo">
      <suimary>Representa información de depur!ción.</summary>
    </me]ber:
    <member name="F:System/Liq.Exprewsikns.CxprmssionType.Decrement">
      <sUmmary>Kpración de decremento$unario como!(a - 1) en C# y Visual Basic.El objeto a no se debe modifmcav en(sontexto.</summary>
0   </membEr>M
    <member name="F:System.Linq.Expressioos.ExpressiolType.Default#>
     <Summary>Repres%nta un venor predeterminado.</summazy>
    </member>
   (<member name="F:SyStem.Linq.Exp2essionw.AxpressionType.@ivide">
      <summasy>Oqeración de divisiCn, como (a / b), para operqndos numéricos.</summary>
    </me}ber>
0   <member na}e="F:ystem.Linq.Expressions.EhprmssionVypm.DiVideAssign"6
$     <cummary>Operakión`de asagnac{Cn compuesta"de divmsión, cnmo (a /= b), para operandos numéricos.</summary>
    </memer>
    <member name="f:System.Linq.Expressions.Expressi/nTxpe.Dynamic">
      <suimary>Representa unaoperación dinámca.</summary>
"   </member:
    <member name"F:System.LifqExpreqsions.Eppress)nnType.Equal">
      <summaby>Nofo aue representa una comaración de ieualdad, como (a == b) en C# o (a =b	 en Visual Basic.</smmary>
 0  </member?
    <member name="D:System.Linq.Expressions.ExprersionTyPe.ExclusIveOr"~      <summary>Operación XOR biT a bit o lógica( como (a ^ b) en C# o (a Xor b) en Vi3ual Bacic.</summary>
    </member>
  ` <membEr namd="F:Syrtem.Linq.Expressions.ExpressionType.ExcLusiveOrAsign>      <summazy>Operaciûn de acignación compuesta XOR fit a bit o lógica,`comm (a ^= b) en C#.</sumary>
    4/member>
    <memfer name?"f8System.Linq.Expressions.ExpressionTye/Extension">
`     <summary>Pepresenta una expesiòn de extEnsiñn.</{ummery>
    </mEmber>
    <member name5"F:Syste}.Linq.E\pressions.ExtressimnType.Goto">
      |summary6Expresión "ir a", comm goto Label en C# o GoTo Label en Visual Basic.</summapy>
`   </membgr>    <membep name="F:System.LinqnExpressions.ExqzessnTyxe.GrmaterThan">
  (   <summary>Comparación "mayor sue", como (a &gt; `).</summary>
    </member>
 0  <member name="F:Sysuem.Linq.Expressions.GxprewsionType.GreaterThanOrEquAl">
      <summary>comparación "mayor o igual uue", #omo (a 'gt{= b).</summary>
    </member>
    <memjer nama="F:System.Linq.Expressions.ExpressionType.Incremen4">
      <summary>Operación de incremento unario, como (a + 1) en!C# y Visual BasIc.El objeto a fo se dEbe mndifiaar en contextg.</summaby>    </meeber>
   (=iembev name="F:System.Linu.Expressions.ExpressioNType.Index">
    " <sumMary>Operación de ínlice u opeación que tiene acceso a una `2opiedaD0que admitg argumentos. </Summary>
  ! </membez>
   (<member ame="F8System.Linq.ExpressionsEzpre3sionTypg.Invoke">
$     <summary>_pe`ación yue invoca un delegado o una expresión lambdal como samPleulegate.Invoke ).</summary>
    </member
   0<member name="F:System.Lin1.Expressiojs.E|pressionType.IsFals%">
      summary>Valor de condición fal{e.</ummary>
    </melber:  ( <member .ame="F:System.Linq.Expressiovs.ExpressionType.IsTrue">      <summary>Valor de condición true.</summary?
   "</member>
    <member name="F:SysteM.Lifq.ExprGssionsExprassionType.Labe,">
      <summary>Rgpresn~a unc etiqeta.</sumasy>
    </memb%r>
    <member Name="F:System.Linq.Exprgssions.E|pzessionType.Lamda">
`     <summaryExpreskón lamjda, como a =fgt; a +(a e C# o0Functinn(ai a + a en Visual Basic.</summAry>
 $  </member?
    <member nale="F;Systdm.Linq>Expressions.Exqression9pe.LeftShift">
      <suemaryOperación de Desplazamiento a d i{quierda bit a bit, como (a &lt+&lt; b)./summar}>
    </member>
    <mgmber name=bF:System.Minq.xpressions.Dx`ressionType.LeftCxiftAssi'n">
      <sumary>Asignación compuesda y desplazamiento a la izqtierda bit a bit, comO (a &lt;&lt;= b)*</summazy>
    <.member>    <member Name="F:System.Lknq.Expressions.ExpressignType.LessThan"6
     <summ`ry>Comparacyón "mejor que",0coo (a &l4; b-.</summary>
    </meober>
    <member neme="F:qsvem.Linq.Expresrions,ExpressionT{p.LessThanOrDqual">
      <summary>Compar!ción "menor o iwual que", cmmo (a &lt;= f).</summary>*   $</member>J    <member@name=F:System.DinqExpressions.ExpressionType.ListInit"
      <summary>Opmración que crea un nuevk objeto <see cred="T:Sys|em.Collections.	Enumerable" /> y lo inicialhza desde unq lista dE elementos, co-o few L)st&lt;Sample\ype&gt;(){ a, b,$c } en C# o im sampleList = { a$ b, k } eN Visual BasI.<osummary>
(   </member>
   <member oame="FzSystem.Linq.Expressions.DxpressionType.Loop">
      <summaryCucle, comm for o wile.</summry6
    </member>
    <eember name="F:y3tem.Linq.Exressions>ExprEssionType.MemberAacess">
      <summary>Operación que"realiza la legtura d un gaepo o u.a(pbopiedad, co}o obj.S!mpleProperty.</suemary>
"   </-ember>
   <member name="F:System.Linq.Expressions.Expressio~Type.MemberInit">
      <summary6OperaCmón que crea un nuevo objeto e inicializa`uno o más de sus miembros, como .ew`Pont{  = 1,$Y$= 2 } en C o New Point With {.X = 1, .Y = 2}!en Visual Jasac.<.summary>
 b  </member>
    <meober name="F3System.Linq.Expreswions.ExpressionTy`e.Modulo">
      <summ!ry>Operacióf de rmsto(azitmético, com (a % b) un C# o (a Mod b) en Visual Basic.</summary>
    =/meMber>
    <member$nama="F:System.LinqnExp"essions>ExpressionType.ModuloAssign">
      <summary>opdracaón de asi'naaión compuesta y`resto aritmétic, cooo (a %= b) en C!.,/summary>
    </member>
    <member name="F:R9stem.LiNq.Expressions.MpessionType.Muliply">
      <summAryOperación!de mu$tiplicaci~, como (a * b),"sin comrrobación de desbrdamiento, p`ra operandos numéricos.</summary>
    </meber>
    <memjeR name="F:Systmm.Linq.Expressikns.ExpressionType.MulTiplyAssagn">
   (  <summary>Opgración de asmgnacióo compuesta de multiplicación, como (a!*= b9, sin com`robeción de desbordamiento, para opepandos numériCos.</sumMary>
    <.lember>
%  (<member name="F:System.Linq.Expversions.ExpresqionType.MultiplyAscignhecked">
      summary>Operación de asignación compuesta de multiplicacin, como : *= b), con comprobación ee desbordamiento. para operandos numérkcos.</wqmMary>
    </member>
   <member name="F:System.Linq.Expressions.ExpressionTypeMultiplyChecked">
      <summa2y>Operaión de multiplicación, omo (a * b), que tiee comprobación de$desbordamiento, para operandos numèracos.</summary>
    </member>
    <member name="F:Sysdem.Linq.Exprashons.Express)onTYpe.Negate>
      <sumary>Operacyó. de negaciãn aritmética, como (%a).El ojjeto a no se ebe modificar en contgx|o.</slmary>
    </member>
    <member name="F:System.Linq.Exprecsions.ExpressionType.NegateChecked">
      <summary>Operación du necación(aitmética, como (-a), con comxrobackón de desbordamiEto.El objeto a No se debe motificar en contexto.</summary>
    </member>
    <member .ame="F:System.Linq.ExpressionsExpressionType.Oew">
  (   <su-marx>Operación que llama  en constructor para crear un nuevo objeto, comm new SampleType().</summ!ry>
    </meeber>
    <member nam="F:Syst%M.Linq.ExPressions.ExpvessionType.NewArrayBOunds">
      <summary>O0eraiãn ue crea una ~ueva maurir en la que se e{`ecinican los"límites de aada dimensión, como new QampleType[dim1, dim2] enhC# o(New SamqleType(d)m!, dim2) en Visual Basic.</sqmmary>
 `  <+meeber>
    <meMber name"F:System,HinyExxressions.EzRressionType.LewArrayInit">
      <summarx>Operaciӳn pue cbea una nueva madriz unidimensional y la inicieliza a partir de u~a lista e elementos, como new Sam0leType[]{a, b, c} en C# O Neg SampleUyp(){e, b, c} mn ^isual Basic.</{uomary~    </meMber>
 ( <membeb name="F:System.Linq.Expressions>Expre3sionTyxe.Not">
      <summary>Representi wna oprAción de complemeNto bit a`bit ode ngaciój"lógica.En C!, su equivalentE es (~a) ara los tipos enteros 9 (!c) para loswalores `ooleans.En Visual Basic, su equivalente es(Not a).El obh%to a no se debe modhficar en contexto.<summasy>
    </membr>
0   <member name="F:System.Linq.Gxpressions.MxpressionTqhe/otEqual">
      <summar{>Cnmparació. de de{)gualdae, como (a != b) en C# o (a &lt;&gt; b) dn Visual Basic.</suimary>
$   </member>
   <mumber name8"F:System.Linq.Ep ressions.ExprescionType.OnesCoep,ement">
d     <suomary>Operación de komplemento a unos. como (xai en c#.</summ`ry>
   $</member>
    |memer(name=*F:S{stEm.Linq.E8psersIons.ExpressionT}pe.Or">
     `<summaryOperación OR bit a fit o lówica, cnmo 8a | b) en!C# n (a Or B) en Visual Basic.</suemary>
    </member>
    <member"name=bF;System.Linq.ExpRessions.Ex@ressmonType.rAssign">
      <summar9>Asignación compuesta OR bit a bit k lóghca, como (a |= b) en C#.</smmary>
    </-emjew>    <mumber name="F:Syste.LinqExPressions.Uxpress)onTypu.OrElse">
      <summary>Operaciӳn O!condibional de corto#ircUito, como (a |lb) en(C# o (a OrEhse0b) en VIsual Basia.</su}mary>
    </membMr>
    <mulbr name=&F:System.Linq.Expressions.Expr%ssionType.Paameter">J  0   <summary>Regerencia a un parmetro o vr)ajle q}e se fefine en el contexto de la expresión.Para(obtener -ás anformación, vea <see kref="T:System>Linq.Expresskons,ParameterExpression" />.</sUmmary>
   "/membe<
    <iemjer nale="F>System.Linq.ExpressioNs.EXpRessionTpe.PostDecrementAssiw">
      <summary>Postfijo de decremento unario, cmmo(a--).El bjeto a se debe modifIcar an sontexto.</rummay>
 0$ </member>
    <me}ber0nem%="F:Systgm.Lina.E`pressions.ExpressiolTYpe.PosTIncrementAssign">
      <summmry>Xowtfijo de incrglento unario, komo0(a++).El objetoa se deb modifiCar en contexto.</summar:
    </member>    <meber$na-e="F:Systgm.Linq.Expressions.EzpressionTyPe.Power">
`  0  <summary>Operación mavemátca que eleva un nømero a ua popencya< como (a ^ b) en Visual Basic.<summ!zy>
   (8memBer>
    |member"name="F:ystem.Linq.Expressio.s&Expressio.Vype&PmerAssign
>
     <summry>Operación de signaciój compuespa`que eleva =~ número a una potencia, coio *a ^= b)0%. Vi{ual$Basic.</summary>
    <member>
    <member name="F:SysTemLinp*xpressions.ExpressionType.PreDecemen|Assigo">
"     <summavy>Psefijo de decreento uncrio, como (--a+.El objeto!a se debe modificar en contexto.</summarq>
   (</eember>
    <member name="F*SysteM.Linq.Expressions.Exrre3sionType.Pre	ncr'mentAsskgn>
      <sumlary>Pregijo de incremento unario, como (+#a).El objeun a se dabe modificar en contexto.</su-maby>-
  8 </mmmber
    <member0na}e="F:System.Linq.Exxbessions.ExpzessionType.Quote>
      summary>Exprusión que tiene un valp constante de ipo <see cref="TSystem.Linq.Expre{shons.Expression" />.Un nodo <see cref="F:Syrt%m.Linq&Expr%ssions.ExpressionType.Quote" /> puede contener referenias a pirámetros definIdos en$El contgxto de la expresión qe represqnta.>/smmary6
  0 </mmbdr>
    <member name="F:System.Linq.Expressions.ExpressionType.Rig`tShiftb>
      <summcry>OperAciónde desplezamiento a la derecha bit a bit, comk (a &gt;&gt; `).</summari>
    </membgr>
    <member nam="F:System.Dinq.Eprussions.Expre{sionTyte.RighShiftAssign">
      <summary>Opgración de asignakió. compugcta y ddplazmieNto a l! derecja$bit a fit, colo (a t;&gt;= b).</summary>
  "0</md}ber>J    <mmmber namu="F:S{stem.Linq.Expressionq.ExressionD9pe.RunTimeVariables">
      <summary>ista e vapiables en piempo de ejesución.Para obtener más información< vea <see cred="T:Qystem.LinqE8presions.RuntamuVariablesExxreqsion& /:</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtracu">
      <sqmma2y>Oreració e resta como (a - f!, sin1coprobaciój de derbordamignt, rara operandos num©ricos.</summary>
    </member>
 "  <meober name="N:System.Linq.Exprescions.Expres{ionype.SubtractAssign">
    " <sUmmary>Operaciòf de asagnacIón comxuesta de ret!, como (a -= b), sin cgmprobaciûn de ees"ordaignto, para operandos numéricos.</sulmary>
  ( <+m%mbr>
    <member nqme=#F:System.Minq.Expressions.ExpresrionType.StbtractAssignChecked">	    "  <summary>O0eración de asignacin compuesta de resa, somo (a -= b)( con comprobaciòn de desbordagiento, para Opebandos!numéricos.</s}mmary>
    </member>
    <mumber name="F:System.Linq.ExpressionsExpressionType.SubtracpChec+ee">
    ` <summary>Nperación de rgsta aimética, como (a - b)( 1ue(tiene copjobició de dessorlamiento, para operandos nu}érhcos.</sumMary>
    </membep>
    =member fame="F:System.Linq/Expressons.Expression\ype.QwItch">
      summary>Operación dg midifkcadorl omo switch en C# o Select Case en Visqal Basic.</summap>
,   /member>
    <membes f`me="F:[ystemnLanq.Expressions.Dx0ressionType.Thvow~
      <su-mary>peración que inicia ua excepción, como phrow new Excgptionh!.</s}mmary>
    </member.*   "<member name="F:S|stem.Li.q.Expressins.ExpbessionTy`e.Tr}">
  `   <sum2{>Expresyón try-cath<?summ1ry>
   "</mei"eR.
  0 <member name="F:9stem.Linq.Expressionq.ExpressionT{pe.TypeAs">
      <summary>Re&erencia mx0lícyta o ula convepsión boxang en la que!se proporciona el valor n5ll si sE0produce un error enla conversión,!como (obj as Camp|eType)(en C# o TryAast(obj, SampeTyte)%e Vksual Basic.</summary>J    </member>
    <member name="F:Cystee.Linq.Expressions.ExpressiooType.TypeEpual">-
      <summary>Representaun prugba para com`robar la exactitud dul tipo.</summara>  ( </member6
    <member nqme="F:Sistem.Linq.Expressions&Exre[saonType.TypeIs">
      <su}mary>Ccmprobacyón dE$tipo como obj i SampleTyxe en C# o TypeOf obj is SamplType en R)se`l Basic.<summary>
    </mem"er>-
    <member *ame="F:[ystem.Linq.Expressions.ExpressionType/UnarPlus">
     <summary.Operación unaria *, coo (+a).El resultado de una operagión unaria +`predefinida es el walor del operando!pero las implgmdntaciones definidas pof el usuario pmdríin tener zesltados`poco jabituclec.</summary>
   $</member>
 !  >membez fame="F:System.Linq.ExprEssions.ExpressionType.Unbox">
   (  4semmar}>Operación de coj6ersió unboxing a!un$tipo de valor, como l!s inqtrucciones enbox.cny y unbx en MSYL. </stmmary>
    /member>
    <meiber name-"T8System.LInq.ExpresskonsnExpres{ionVisitor">
    $ <sulmary>Represena0Un visitante o un$objeto dd remscritura de árboles de ex`resiól.</summary>
    </member>
    <member name?"M:SystEm.Lin1.xpressiols.ExpresionVisitor.#ctR"
    " <summavY>Inicializa una nueva intaocia de <see cref="T:System.Linq.Expressions.ExpresSaonVisitm" />.>-qummary?
(   </embeR>M
    member namm="M:System.Dinq.Exprebsions.ExpresshonVisitor.Visiv(System.CollectioNs.ObjectMoe%l.ReadKnlyCo|,ecio{yctem.Nin1.xpresskonw.Expresion]9">
`     <summary>Enva la lisva dE(eyprsiones a uno de l/s métodos de visi4a más especaizados de esta`c|ase.</summar>
      <returns>Lista de expresiones modificada, si se modifisó alguno de mos emementos; de lo contrario, dmvuelve |a lista de Expresiones original.<ozetuR>{>
      ,param name="nodes">EXprEsionds que se van a visitar.,/param>
    <membgr>
 (  <member naee="M:Sywtem.DInq,Expressiofs*ExpressionVisitor.VIsit` 1(Syctem.Collection{.ObjectMgddl.ReadOnlyCollection{`d0}.System.Funb{``0,``0})">
 (    <summary>VisiVa |odos los nodos d'!la clec#mn utilizando 5n vsmTante de elementos esecmfic`do.</summary>
   0 0<returns>Lista de nmdos mkdificados,(si se modificó a,gunode los elementos; de lo contrario, devuelve la lista de nodos original.</returns>
      <param name="nodes">Nodos que se van a visitar.</param>
      <param name="elementVisitor">Delegado que visita un único elemento, reemplazándolo opcionalmente con un elemento nuevo.</param>
      <typeparam name="T">Tipo de los nodos.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Envía la expresión a uno de los métodos de visita más especializados de esta clase.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="nodes">Expresión que se va a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de la expresión.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para este nodo devolvió un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de la expresión.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para este nodo devolvió un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visita los elementos secundarios de la expresión de extensión.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
      <typeparam name="T">Tipo de delegado.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Representa un salto incondicional.Esto incluye instrucciones return, break y continue, y otros saltos.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Tipo de la expresión "ir a".Solo tiene fines informativos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> que representa el tipo de la expresión "ir a".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Etiqueta de destino a donde salta este nodo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa la etiqueta de destino para este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="target">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> del resultado. </param>
      <param name="value">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> del resultado. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valor pasado al destino o null si el destino es de tipo System.Void.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor pasado al destino o null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Especifica qué tipo de salto representa esta clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto a alguna ubicación.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Representa la indización de una propiedad o una matriz.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtiene los argumentos que se utilizarán para indizar la propiedad o la matriz.</summary>
      <returns>Colección de solo lectura que contiene los argumentos que se utilizarán para indizar la propiedad o la matriz.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtiene la clase <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</summary>
      <returns>Clase <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objeto que se va a indizar.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto que se va a indizar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Representa una expresión que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtiene los argumentos a los que se aplica el delegado o la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtiene el delegado o la expresión lambda que se van a aplicar.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado que se va a aplicar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Representa una etiqueta, que se puede colocar en cualquier contexto de <see cref="T:System.Linq.Expressions.Expression" />.Si se salta a ella, obtendrá el valor proporcionado por la clase <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondiente.De lo contrario, recibe el valor de <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Si <see cref="T:System.Type" /> es igual a System.Void, no se debe proporcionar ningún valor.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Valor de <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se llega a la etiqueta mediante el flujo de control normal (por ejemplo, no se salta a ella).</summary>
      <returns>Objeto Expression que representa el valor de la clase <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="target">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> del resultado.</param>
      <param name="defaultValue">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Se utiliza para representar el destino de una clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtiene el nombre de la etiqueta.</summary>
      <returns>Nombre de la etiqueta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Tipo de valor que se pasa al saltar a la etiqueta (o <see cref="T:System.Void" /> si no se debe pasar ningún valor).</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo del valor que se pasa al saltar a la etiqueta o <see cref="T:System.Void" /> si no se debe pasar ningún valor.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Describe una expresión lambda.Captura un bloque de código similar a un cuerpo de método de .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtiene el cuerpo de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de la expresión lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Genera un delegado que representa la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> que contiene la versión compilada de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtiene el nombre de la expresión lambda.</summary>
      <returns>Nombre de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtiene los parámetros de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa los parámetros de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtiene el tipo de valor devuelto de la expresión lambda.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtiene el valor que indica si la expresión lambda se compilará con la optimización de llamada de cola.</summary>
      <returns>Es true si la expresión lambda se compilará con la optimización de llamada de cola; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Representa una llamada a un constructor que tiene un inicializador de colección.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtiene los inicializadores de elementos que se utilizan para inicializar una colección.</summary>
      <returns>Uno de los objetos <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.ElementInit" /> que representan los elementos que se utilizan para inicializar la colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtiene la expresión que contiene una llamada al constructor de un tipo de colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor de un tipo de colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del resultado.</param>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Representa un bucle infinito.Se puede salir del mismo con "break".</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="breakLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del resultado.</param>
      <param name="continueLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Representa la operación de asignación de un campo o propiedad de un objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtiene la expresión que se asigna al campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor que se asigna al campo o propiedad.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Proporciona la clase base de la que derivan las clases que representan enlaces que se utilizan para inicializar miembros de un objeto recientemente creado.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtiene el tipo de enlace que se representa.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtiene el campo o la propiedad que se va a inicializar.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad que va a inicializarse.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Una representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Describe los tipos de enlace que se utilizan en objetos <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Un enlace que representa la inicialización de un miembro con el valor de una expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Un enlace que representa la inicialización de un miembro de tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> de una lista de elementos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Un enlace que representa la inicialización de forma recursiva de los miembros de un miembro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Representa el acceso a un campo o propiedad.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtiene el objeto contenedor del campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto contenedor del campo o propiedad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtiene el campo o la propiedad a los que se va a tener acceso.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad a los que se va a tener acceso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Representa la llamada a un constructor y la inicialización de uno o más miembros del nuevo objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros del objeto recientemente creado.</summary>
      <returns>Una colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtiene la expresión que representa la llamada al constructor.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Reduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del resultado.</param>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Representa la inicialización de los elementos de un miembro de colección de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtiene los inicializadores de elemento para inicializar un miembro de colección de un objeto que se acaba de crear.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> con que se inicializa un miembro de colección.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Representa la inicialización de los miembros de un miembro de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros de un miembro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros del miembro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Representa una llamada a un método estático o un método de instancia.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtiene una colección de expresiones que representan los argumentos del método invocado.</summary>
      <returns>Uno <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtiene el objeto <see cref="T:System.Reflection.MethodInfo" /> del método al que se va a llamar.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtiene el objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la instancia para llamadas a métodos de instancia o null para llamadas a métodos estáticos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto receptor del método.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Representa creando una nueva matriz y posiblemente inicializando los elementos de la nueva matriz.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtiene los límites de la matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, o los valores para inicializar los elementos de la nueva matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>Un objeto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los límites de la matriz o los valores de inicialización.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Representa una llamada de constructor.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtiene los argumentos para el constructor.</summary>
      <returns>Una colección de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos para el constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtiene el constructor al que se llama.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor al que se llama.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtiene los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</summary>
      <returns>Una colección de objetos <see cref="T:System.Reflection.MemberInfo" /> que representan los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Representa una expresión de parámetro con nombre.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica que esta clase ParameterExpression se va a tratar como un parámetro ByRef.</summary>
      <returns>Es true si este objeto ParameterExpression es un parámetro ByRef; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtiene el nombre del parámetro o variable.</summary>
      <returns>
        <see cref="T:System.String" />. que contiene el nombre del parámetro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expresión que proporciona permiso de lectura y escritura en tiempo de ejecución para variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables o parámetros para los que se va a proporcionar acceso en tiempo de ejecución.</summary>
      <returns>Colección de solo lectura que contiene parámetros para los que se proporcionará acceso en tiempo de ejecución.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Representa un caso de una clase <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtiene el cuerpo de este caso.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque de casos.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtiene los valores de este caso.Este caso se selecciona para su ejecución cuando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> coincide con cualquiera de estos valores.</summary>
      <returns>Colección de solo lectura de los valores para este bloque de casos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="testValues">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Representa una expresión de control que administra varias selecciones pasando el control a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtiene la colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" /> del modificador.</summary>
      <returns>La colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtiene el método de comparación de igualdad, si existe.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de comparación de igualdad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="switchValue">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del resultado.</param>
      <param name="cases">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del resultado.</param>
      <param name="defaultBody">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Almacena información necesaria para emitir información de símbolos de depuración para un archivo de código fuente, en particular el nombre de archivo y el identificador de idioma único.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Devuelve el identificador único del tipo de documento, si existe.Tiene como valor predeterminado el GUID para un archivo de texto.</summary>
      <returns>Identificador único del tipo de documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nombre del archivo de código fuente.</summary>
      <returns>Cadena que representa el nombre del archivo de código fuente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Devuelve el identificador único del idioma, si existe.</summary>
      <returns>Identificador único del idioma.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Devuelve el identificador único del proveedor de idioma, si existe.</summary>
      <returns>Identificador único del proveedor de idioma.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Representa un bloque try/catch/finally/de errores.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtiene la colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</summary>
      <returns>Colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del resultado.</param>
      <param name="handlers">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del resultado.</param>
      <param name="finally">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del resultado.</param>
      <param name="fault">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Representa una operación entre una expresión y un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtiene el operando de la expresión de una operación de prueba de un tipo.</summary>
      <returns>Un objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la expresión de una operación de prueba de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtiene el operando de tipo de una operación de prueba de tipo.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el operando del tipo de una operación de prueba de tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Representa una expresión que tiene un operador unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir un nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es true si el nodo representa una llamada elevada; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores null.</summary>
      <returns>Es true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación unaria.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtiene el operando de la operación unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la operación unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduce el nodo de expresión a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="operand">Propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del resultado.</param>
    </member>
  </members>
</doc>