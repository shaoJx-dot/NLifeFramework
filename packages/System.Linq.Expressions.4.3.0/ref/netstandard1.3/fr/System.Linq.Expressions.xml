<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Représente le résultat d'une opération de tri.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Représente le résultat d'une opération de tri.</summary>
      <typeparam name="T">Type du contenu de la source de données.Ce paramètre de type est covariant. Autrement dit, vous pouvez utiliser le type que vous avez spécifié ou tout type plus dérivé. Pour plus d'informations sur la covariance et la contravariance, consultez Covariance et contravariance dans les génériques.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données n'est pas défini.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtient le type des éléments retournés lors de l'exécution de l'arborescence d'expression associée à cette instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente le type des éléments retournés lorsque l'arborescence d'expression associé à cet objet est exécutée.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtient l'arborescence d'expression associée à l'instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.Expression" /> associée à cette instance de l'interface <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtient le fournisseur de requêtes associé à cette source de données.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryProvider" /> associé à cette source de données.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données est connu.</summary>
      <typeparam name="T">Type des données contenues dans la source de données.Ce paramètre de type est covariant. Autrement dit, vous pouvez utiliser le type que vous avez spécifié ou tout type plus dérivé. Pour plus d'informations sur la covariance et la contravariance, consultez Covariance et contravariance dans les génériques.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Définit des méthodes destinées à créer et exécuter des requêtes décrites par un objet <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TElement">Type des éléments du <see cref="T:System.Linq.IQueryable`1" /> retourné.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête fortement typée représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TResult">Type de la valeur qui résulte de l'exécution de la requête.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Représente une expression qui comporte un opérateur binaire.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si le nœud d'arborescence de l'expression peut être réduit, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtient la fonction de conversion de type utilisée par une opération de fusion ou d'assignation composée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur.</summary>
      <returns>true si le nœud représente un appel levé ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns>true si le type de retour de l'opérateur est levé vers un type nullable ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtient l'opérande gauche de l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche de l'opération binaire.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtient la méthode d'implémentation pour l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Réduit le nœud d'expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtient l'opérande droit de l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit de l'opération binaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="left">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> du résultat. </param>
      <param name="conversion">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> du résultat.</param>
      <param name="right">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> du résultat. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Représente un bloc qui contient une séquence d'expressions où les variables peuvent être définies.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtient les expressions contenues dans ce bloc.</summary>
      <returns>Collection en lecture seule qui contient toutes les expressions contenues dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtient la dernière expression contenue dans ce bloc.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la dernière expression contenue dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> du résultat. </param>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> du résultat. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtient les variables définies dans ce bloc.</summary>
      <returns>Collection en lecture seule qui contient toutes les variables définies dans ce bloc.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Représente une instruction catch dans un bloc try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtient le corps du bloc catch.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtient le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtient le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Retourne un <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variable">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> du résultat.</param>
      <param name="filter">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> du résultat.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtient une référence pour l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Représente une expression qui comporte un opérateur conditionnel.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtient l'expression à exécuter si le test a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtient l'expression à exécuter si le test a la valeur true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtient le test de l'opération conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test de l'opération conditionnelle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="test">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> du résultat.</param>
      <param name="ifTrue">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> du résultat.</param>
      <param name="ifFalse">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Représente une expression qui a une valeur de constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtient la valeur de l'expression constante.</summary>
      <returns>
        <see cref="T:System.Object" /> égal à la valeur de l'expression représentée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Émet ou efface un point de séquence pour les informations de débogage.Cela permet au débogueur de mettre en surbrillance le code source correct lors du débogage.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtient la colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtient la ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtient la valeur qui indique si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence.</summary>
      <returns>True si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtient la colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtient la ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Représente la valeur par défaut d'un type ou une expression vide.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Représente un initialiseur pour un élément unique d'une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtient la méthode d'instance utilisée pour ajouter un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtient la collection d'arguments passés à une méthode qui ajoute un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments d'une méthode qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Retourne une représentation textuelle d'un objet <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Représentation textuelle de l'objet <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fournit la classe de base de laquelle sont dérivées les classes qui représentent des nœuds d'arborescence d'expression.Contient également des méthodes de fabrique static (Shared en Visual Basic) pour créer les divers types de nœuds.Il s'agit d'une classe abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND au niveau du bit.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="method" /> est null et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau multidimensionnel.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="array">Expression qui représente le tableau multidimensionnel.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des expressions utilisées pour indexer le tableau.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="array">Expression qui représente le tableau à indexer.</param>
      <param name="indexes">Tableau qui contient des expressions utilisées pour indexer le tableau.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang supérieur à un.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.ouLe rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang un.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="index">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="index" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.ou<paramref name="array" />.Type représente un type de tableau dont le rang n'est pas 1.ou<paramref name="index" />.Type ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau multidimensionnel.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="array">Tableau d'instances <see cref="T:System.Linq.Expressions.Expression" />, index pour l'opération d'index de tableau.</param>
      <param name="indexes">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.ouLe rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression permettant d'obtenir la longueur d'un tableau unidimensionnel.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> et la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> est égale à <paramref name="array" />.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égal à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> et dont <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLa propriété représentée par <paramref name="member" /> n'a pas d'accesseur set.ou<paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un membre à l'aide d'une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> a la valeur <paramref name="expression" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLa propriété accessible par <paramref name="propertyAccessor" /> n'a pas d'accesseur set.ou<paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient trois expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient quatre expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
      <param name="arg4">Cinquième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui ne prend aucun argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.ou<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d'instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale (passez null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.ou<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d'instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.ouLe nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.ouUn ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend deux arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance.(Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend trois arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance.(Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.ou<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d'instance.ou<paramref name="arguments" /> n'est pas null et un ou plusieurs de ses éléments sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.ouLe nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.ouUn ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> est égale à <paramref name="instance" />, dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'instance spécifiée, et dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> dont la valeur de propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> fera l'objet d'une recherche de méthode spécifique.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> ou <paramref name="methodName" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="instance" />.Type ou ses types de base.ouPlusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="instance" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique (méthode partagée en Visual Basic).</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arguments">Collection de <see cref="T:System.Linq.Expressions.Expression" /> qui représente les arguments de l'appel.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode static (Shared en Visual Basic) qui prend un seul argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant deux arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant trois arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant quatre arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant cinq arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <param name="arg4">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode static (Shared en Visual Basic) comportant des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode static (Shared en Visual Basic) à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.ouUn ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode static (Shared en Visual Basic) en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode static (Shared en Visual Basic) spécifiée, et dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type contenant la méthode static (Shared en Visual Basic) spécifiée.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="methodName" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="type" /> ou ses types de base.ouPlusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="type" /> ou ses types de base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indique que le nœud peut être réduit à un nœud plus simple.Si la valeur retournée est true, Reduce() peut être appelé pour produire la forme réduite.</summary>
      <returns>True si le nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec une référence à l'objet <see cref="T:System.Exception" /> intercepté pour une utilisation dans le corps du gestionnaire.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" /> et une référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body">Corps de l'instruction Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" />, sans référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour la suppression d'un point de séquence.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour le nettoyage d'un point de séquence.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion, à partir d'une fonction de conversion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.ou<paramref name="conversion" /> n'est pas null et <paramref name="conversion" />.Type est un type délégué qui ne prend pas exactement un argument.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> représente un type qui ne peut pas être assigné au type de paramètre du type délégué <paramref name="conversion" />.Type.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> n'est pas égale au type de retour du type délégué <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> ou <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type n'est pas <see cref="T:System.Boolean" />.ou<paramref name="ifTrue" />.Type n'est pas égal à <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</returns>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> n'est pas null et <paramref name="type" /> ne peut pas être assigné à partir du type dynamique de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion de type.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion pour laquelle la méthode d'implémentation est spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.ou<paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.ouLe type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.ou<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible et pour lequel la méthode d'implémentation est spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.ou<paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.ouLe type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.ou<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> avec l'étendue spécifiée.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
      <param name="startLine">Ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure à 0.</param>
      <param name="startColumn">Colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure à 0.</param>
      <param name="endLine">Ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure ou égale à la ligne de début.</param>
      <param name="endColumn">Colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Si la ligne de fin est la même que la ligne de début, elle doit être supérieure ou égale à la colonne de début.Dans tous les cas, elle doit être supérieure à 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> comme deuxième argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par <paramref name="addMethod" /> n'est pas nommée "Add" (non respect de la casse).ouLa méthode représentée par <paramref name="addMethod" /> n'est pas une méthode d'instance.ou<paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par <paramref name="addMethod" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un tableau de valeurs comme deuxième argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par addMethod n'est pas nommée "Add" (non respect de la casse).ouLa méthode représentée par addMethod n'est pas une méthode d'instance.ouarguments ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par addMethod.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addLethod""/>.</except)on>
  $</member>
    tmem`er name?"M:S}ste-nLinq.Expses{ions.Expressk.Emp4y">
     "<summary>Crée qne e8presshon vide qui a le$dype <see creb=b:SysteM.Void" />.</stmmary>
     <returns
        <seg cref="T:Sstem.Linq.Dx`ressions.Defaultuxpressionb />0dont la prkpriété <sme cref="P:System&Lanq.Express)ojs.ExpressioN&NodaType" /< est égale à 8see creb="F:System.inq.Dxpressions.ExpressionType.Dgfault" /> et la protriétí <see cref="P:System.Hinq.Expressi/nS.ExpRescion.TypE" /> est égale à <see creb="T:System.Void" />.</returns>
    <member>
    <member name="M:SyrtE/.inq.Expres3ions.ExprdSsion.Equal(SyStem.Linq.Epressions.Expvessio.lSystem.Lin.Exressiojs>Expression)">
      <smmary>Crée un <see cref="T:System.LinqneXpressios.BilaryExrre{sIon" /. q5i re2résente une coearaisn d'égalité.<.summary>
   0  <rterns>
   0   <see creb=T:System.Linq.Expressions.inaryEpre3sion"$/> $ont la propriCt˩0<see czef="P:System.inq.Exprussions.Expression.NodeType" /> eSd éga,e`à <see Cref=":SyStem.Linq.xpressions.ExpressinnType.Eaual" /> ev dont les pzopriétés <qed creb="PSystem.Lin.ExpreScions.Binaryxprewsion.Heft" /> et 4see cref="Q:System.Lynq.Exprussions.BinarxExpression.Rmgjt" /> ont les valewsq 3xécifies.+revurns>
    " para}"name<"luft&>
"       <see cred="T:Syspem.Dinq.Expressions.Uxpression" /> uquel la(proxriété <see red-"p2System.Linq.Expressions/BinaryExpressin.Lef`" /> doat$Être é'ale.</p!sam>
     <param name="right">
        8see crEf="T:System.Linq>ExpressiOns.Expressin" /> auqugl la propriété <seG cref="P:Syctel.Lifq.Expressiojs.Bi.arqExpression.Ri'ht" /> doit útre égale.,/param>J      <exc%ption cref="T:System.ArgumentNullException">
     (  <paramref name="left" /6 ou <paramref nam="right"/>!a l! valeuR nul.</exc%ption~
      <exception cref="T:[ysem.I/valifOperationExceptio~">'otǩzateur d'égalité n%est pas dáfini pour 8param2M name="let" />.ype et <Parhmref name="2ighT# />Type.|/exkeptIof>
`   </member>
   0<membar ~ame="M>S9stem.Linq.Expressions/Expression.Eqwal(System.Lknq.ExpreSsions,Epvassion,Cstem.Linq.Exrrgssionw.Exp2essIon,Sysuem.Bonlean,SystemnReflection.MethodIlfo)">
$     <sumgary>Crée!un <see cref="T:S9spem.Linq.Gxpress)ons,BIlazyExpression& /> qui représente uNe comparaicon d'égahité.La mthode"d'impléentation peut tre spécifiém.</wummary>J      <returns>
        <see creb?"T:Syrtem&Liny.E8pression.BinayEypressiof""/> dont la psOpriété0<see cref="P:Sytem.Lijq.Exprecsions.EXpressio~/NodeVyre" /> %ct ˩gale à <see cref=*F8Systdm.Lknq.Expresshons:GXpressionType.Equam" /> et dont les propriétés <see crmf="PSys4em.Linq.Uxpressions.BinaryExprdwsion.Lenv" />, <see cren="P:Siste}.Linq.Expressions.BiNaryExpression.Rightb /?, <see crf="P:System/Li.a.exprgssions.BinaryExtrescI/n.IsLiftedToNuld" /> et <sem cref=*P:System.Linq.Expressions.BinaryExpre3si/n.Method" /> ont lgs valeurs spácifiées.</returns>
      <xaram name="left">
        <se% cref="T:SySuem.Linq.ExprEssions.ExpressioN" /> auquel la!propriété <see cref="P:System.Linq.Mxpressions.BinaryExpression.Left" /> doit être égale.<+Taram>     <paa-"name="right".
!       <sUe cref&T:System.Minq.Gxpressioos<Expression" /> auquel la pp/priédè <see cref="P:Syqtem.Linq.Expressions.BiniryExression.Ri'ht /> do)t êtra égqle.=/param> $    <param name="liftToNull">true pour avfecter à <see cref=":System.LInq.ExpressionsnBiNaryExPzession.IsLiftedTNull" /> la valeur trte ; false pour abfecTgr à <seg cref?"P:System.Linq.Expressioos.BinaryExpression.IsLiftedToNull" / la valeur false.</peram>
      <param nam%="meTod">
        <see cvgf="T:System.ReflEbtion.MedhoeMnfo" /> auq5ml la prkpriété <see cref="P:ystee.Linq.Exppecsio.s.BinaryExpvessmon.Method" '> doit être égaLe.</param>
      <exception!cref="T:System,ArgumentNullExCgption">
  $    $|paramre name="let" /> ou <paramrefname="riglt /> a |a valgur null./excepthon6
$     4ex#eption cref="T:System.ArgumebtExceptio~"~
!      <raramref name="method /> n'est paq null et la lthode représentée retourne Void, n'est pas static )Shared en Visual Ba{ic) ou ne prend pas deux arguments eXacTemenp.</excepTion>
      <exception cbuf<"T:System.InvalidOperationExseptIn">
        <rapamref jame="method" />!dst nqll et n'opérateur d'égalité n'esp`pas définI pour <paramref name="left" />.Type et <peramref name="right" />.Type</exception>
    <?member~
    <member$namd="M:System/L)nq.Mxprassions.Expression.Exclu{iveOr(System.Linq>Exprescons.Expression,System.Linq.Expreswions.Gxppession)">
  0  <summary>Crée n <see cref="T:Syspel.Linq.Expression3.BijarqElpressio" /> qui représente une opératmon XOP`au nvequ du bid, enutilisant op_EpclusiveOr pour les types fáfinis"par l'utilisateur.</summary>-
      <retqrls~
   !   <see cred="T:System.Lknq.ExpressiofsBi|aryExpression" /> dk.t na propriété |sde0cref="P:System.Linq.xprecsiojs.Exp2eswion.NodeTypeb /> ewt égale C <sed"cref="F:Syqtum.LinqnEx0ressions.ExpveswkonTxpe.ExclusiveOr" /> et dont les propriCtès <see cref="P:Wyrtem.LilqnExpressions.BinaryExpressi'n.L%ft"(/>`et <see cref="P:Sysvem.Linq.Expressioos.BinarYExression.Right" . ont les!talewrs sq©cifiées.>/revurns>
      <pavam name="lgft">
        <see(csef="T8System.Hinq.ExprecsioNs.Exprdssi/n" /> awqu%l na proprIété <See cref="PRystem.LiNq.Expresions.BinaryExprussion.Left"$/ doit êdre égale<opar`m>  !   <param nime=2right">
 `      <sme cref5"T:Systel.Linq&Expres;ions.Exxr%ssion* /~ auqwel0li propriété <sge cre=2P:System.Linq.axppesshons.Bijaryxpresrion.Rght" /> doit être éGile.</param>      <excepion cref="T:System.ArgumentOullEXceptI/n>
       <paramref name?"left" .> ou!<pazamref name="righv" .> a l vqlewr null.</exbeption>
 (    <exceptioo cref="T:System/MnvalidOperationException">D'opèrateur OR n'es| pas dé&ini pour <Paramruf name=&l%ft" /..Ty`e(et para}ref nam="right" />.Type.<n%xceptiof>
    </member>
    <meober nae="I:System.Linq.ExPressions.Ezp2ession.EzclusveOv(Syst%m.Linq*Expressons.Expresshon,Systum,Linq.E|prercio~r.expression,Sys|e.Ruf,ectin.MethndInfo)">
      <sU-mary>Crée un >3ee!cre&="T:ystem.Ninq.Exqrgssions.Bi~aryExpzussion" /? qui reprsentm une Opǩration XOR au"nkveau du bit, en utilhsand op_ExclusivdOr por les types dǩfinis rar Lguuiliateur.La mùthodg d'impl)mentation peut$être spécifié%.</summary>
      <retuvjs>
        <sae #reF="T:System.LkNq.Expr}ssions.BinaryEzrresrioj" /> dont ,a `poxriétө see cvef="P:System.Linq.xpreSsi~s.Expression.NodeType" /> ast égAle à <see craf="F:CystemnLina.Mxpressions.EppressiknT9pe.ExcmwsireOr" /> et dont les tboppié|és <see cref="P:Sys|emMinq.Expressions.BinaryE|qressioN.Left" />, <see czef="P:S3te-.Linq.ExprgssiOns.@ijaryEXpression.Rk'xt"/> et 8see0cpeb="P:Syqtem.Linq.Expressiojs.RinaryExpression.Method"/>!ont"les vAldtrs spécfiées.</returns>
      <param nama9"ledt">
      " <cem cef="T:System.L)nq.Expressions.Exprecsion" +> auquel lc propriété <see cref="P:Syst%m.Lina.EXpressions.JinaryExpressin.Nefu"!/> doiT être ©galen</param
      >paai namu="raght">
  $  (! <see cref="T:Systee,Linq.E8prgssions.Expressqon& o> auquel(la protziété <see cref"P:Rysuem.Linq.Expresshons.BinaryExpRession.Right2 /> doit être égale.</pAram>
     <pram nau="mutod">
!"      <see cref="T:SystEm.Zefmection.Methodifo" /6 auquel lc propriété`4see csef}"P:System.\inQ.Eypres{ins.FilariEypressiOn.Mathod" /domt être(égale.|/paral>
   "0 <exception crug="T2Sysuem.ArgumentullExcepthon">
        <qeramref name="lf|" > ou <paramreb na}E="righT" '> a la va,ewr fuln.</exception>
 !!   4exgeption csEd="U:Sycdem&Ar'umentException >        <paramvefname="me|hgd" /> n#est pas lull %t la mí|hodu zeprésenëu retouRn% vnif, n'ert pas static (Shapef n Visual$Basic) ou nepren$ pas dgux arguents mxactement></excepton|
      <excep|ion!cref="T:S9stem.I~validOperationException">
       $<piremref name="method" /> est nunl et l'o`éraveur XOR n'est"pas dé&ini poUr <paramref name="left" >.Type at <paalref na}e="righu" />.Type.</excep4ion>
   </mem"er>
    <iember name="M:Systum.Lnq.E8psgssions.Expre3sion.ExclusivuOrA3sign(System.Linq.ExpressionS.Mxpression-Systam.Lnq.ExpRecsions.Expression)"~
 `    <summary>Crée un <see cref=&T:RystemLinq.Expressions.BinaryExpression" /> qui représente uNe opération d'assigna|ion XR au nive!u lu bit( en utilisan| opOExclusiweOr pour nus types dCfiniS par l'tiliqateur.</summary>
      <returns>
        <see cref=T:Syst%M.Linq.Expvessions.BiaryExpressioj  /> dont la propriét 8su cref="P:System.Lijq.Expressionw.Expre3sion.N/deType" /> est ègale à <see csef="F:Systum.Liq/Exprassions.ExprgssionTipe.UxclusiveOrAssigN" >"et dont les propriétés <see cref="P2Sysdem.Linq.Expressionw.BinaryExpression.Left" /> et <see cref=P*System.Linq.ExprEssions.BinaryExprus3ion.Rkght" /> ont les valeurs qpé#ifiées.</returns>
     <par!m name="lgt">
        <see cref="D:Syspem.Linq.E8pressions.Expression"!/> auquel la prOpritÉ 8see$cref="P:Systam.Li~q.Expressions.BinaryExpression.Left" o> doit être égale.</para>
   $  <pram nqme="right">
       <seekref="T:Systea.Lin}.Extressi/ns.Expression" /> auqueL la proprité <see creg="P:System.Linq.Expressions.BinaryExpression.Right" /< dnit être égale.</param:
    </mamber>
    <member namd="MSystemLhnq.Express)ons.Exprdssion.ExclusiveOrAssign(System.Linq.Exrression.Expression,System.LinqnExxressions.ExRrersioo$System.Reflection.EethodInfo)2>M
4     <summary.Crée un <see cref="T?System.Linq.ExpressIons.BinaryExpressioN" /> qui représente une pération d'assigNation XOR au niveau(du "it, en utilisant op_ExclsiveOr po5r les |y`es définis par l'utilisapeur.</summary>
      <returns>
       <se% cref9"Tsystem.Minq.ExqressioNs.BinaryExpression" /> dont l! propriété(<SeE cruf="P:System.Lin.ExPressis.Expression.Nodeyp" +. est égale à <see cref="F:System.Linu.Exprdssions.ExprmssioType.ExclusiveOrAssign" /> et dgnt les propriét)s <see cref="P:System.LiNq.Expressions.BinaryExpressiOn.Ledt" />, <see Cref= P:Systgl.Li~q.Ezpressions.BinaryE|prssioj.Righ4# /> et <see cred="P:Gystem.Linq.Expressions.BlnaryAxpreqsion&Mmuhod" />0ont les valeurs {pécifiée*</returns>
      <paja- name="left">
        <see cref="T:System.Linq.Expre3sions.Expression" /> auquel la propriét© <see Cref="P:SystEm.LI~q.Expracsiofq.BinaryMxpreqcion.Heft" /> doit êtve`égale.</param>
      <parAm name="richt".
        <s%e!cref="T:Sysem.Lin.Expressions.ExpRession" /> auquel la propriété <see cref="P:System,Linq.Expressioos.BinaryExpression.Righu" +> $oit êpe égale.<param>
      <param name="mehod"
   (  ( <see cref"T:Systdm.Veflectin/MethodI~&ob /> auquel la propriété <Se% cref="P:System.Lina.XPressions.BinaryExpression.ethod& /> doit Ctre égale.</`aram>
!   </member>
    <member name="M:Sstem.Linq.Expressio.s.E|pressio.Exclu3iveOrAs{ign(System.inq.Ex0ressiols.Expressio.,System.Linq.Exprewsions.Expressiol,Systm.Reflestign.Met(odInfo,S9stem.Linq.Exprewsions.LambdaEzpresrion)">
      <sUmmary>Crée un <sue cref="T:Systgm.LiNq.Expressions.BineryExpression" -> qui rep2é{ente uoe opération d'assignation XOR au nive!u du bit- %n utilisant op_Exclu{iveK2 pouz les types définiS `ar l'utilisateur.>/{ummary>
 0 (  <returns>
  !     4sme cref=T:Sys|em.ilq.Expressions.BinAryExpresion" />`dont la propriété <see cref="P:Sywtem.Linq.Express)ogsnxpresqion.NodeTipe" /> est égAle à <see cref}F:System/Linq.ExpresSions.ExpressonT9pe.EyclusivaOrAsskgnb /> et dmnt les qropriãtés <qee c{ef="P:System*Linq.ExpRessimns,Binaryxpression.Left" />, <seE cref}"P:SysTem.Linq.Exprewsions.B)naryExrression.Right" />, <see cref="P:Systgm.Lijq.ExpresSions.BinaryGxpression.]ethO$" /> et <see cref="P:System.Linq.Expbessions.BinaryExpressi/n.Cgnverskon" />$oot le valeurs qpésifiëes.</ret5rns.
      <param name="deft">
     (  <see aref=";Sywdem.Linq.Expbeswins.Exprmssion" /> auquel la proprhété <see cref="P*system.Linq.Expsessions.BinAr9Expression.Left" /> doit être égale.</tarqm>
      <param$name="right">
       $<see cref="T:sy3t%m.Hhnq.Expressions.Expressikn" /> auquel lapropriétө!<see cref="P:System.Linq.Ex`ressimns.JinaryExpresion.Right" /> doit0âtre égAle.</parem>
      <pazam0name="method">
        4see sref="System.redlection.MatlodInfo" /> aqquel la propriété <see kref="P:System.Linq.Expvessions.@inaryEXpRessionMdthod" /> doit ître égale.</p!ram>
      <param name="convrsion">
        ,sem cref}"T:SysteM.Linq.Exqreqsions>LambdaExxress)on" /> auquel la propriétǩ <see0cref="P:SystemLinq.Exprespions.BinaryExPression.Convgrsion" /> doit être ég!la.</param?
    </membmr>
    <memfer namm="M:System>Linq.Expressions.Expression.Gield(System.Linq>Exprssons.Ex`ression,SysTem.Reflection.FieldIjgo)">
      <summary>Crée un!8see cr%f="T:System.Linq.Exrressiofs.Memberexpsessio~" /> qui représente l'accès à un champ.</summary>
      <returns.
        <ree craf="T:System.Linq.ExprecsiOns*M}iberEpressaon" />dont La tropriété =3ue cref="P*System.Lnq.Expressaons.Exression.NodeType" /> gqt gale à <see"cr%f="F:System.Linq&Expressions.ExpresciolType.MembgrAccess" />"et dOnt les proprités <se ref="P:System.Linq.Expre#sions.MumberExrreswIon.Expression" /> et <see #ref-P:ystdm.Linq.Expression3.Memburxprescion.Mmmer" /> ont nes valeurs spécifiées.</returns>
 "    <param name="expression">
  !  !  <See cref="T:System.LInq*Expressions.Expression"/> auquel la propviété |sae!cre5"P:System.inq.Expressions.MelberExpression.Expression" /> doit êvrm égale.Pour ctatic (Shabed en Visuan Basic), <para-r`F name="expression" /> doit être null.</pqram>
  `   <param0name="field">
   !    <sde sref="T:System>Reflecd)on.Field	nfo" /> auquel l$proxriété <see$cref=*P:SyStem.Dinq.Expressionr.EemberExpression.Member" /> e/iv ˪tre Cgale.</param>      <exceptaon cref="TSystem.ArgumentNullExcePtion">
        <paamref name="field"/> a la valeur nulj.uLe k`amp représenté par <pasamre& name="field" ?> n'est pas static (S`rgd mn VisUal Bac) dt <pazamRef`nale<"expresrion" /> est jull.</exceppion>
$  (` <eception cref="T:System.ArgumentException">
        <Paramref name="exPression" >.Type ne peut pas ître assigné au type de déclaratio. du champ rexrésen4é par <paramrmf name="field" />.</exception>J    </member>
`   <meMber name="M:Systel.Lilq*Expresskons.UxpressioonField(System.Linq.Expressions.Expression,Syctem.String)"
     $<suemary>Crée un <see cpef="P:Cyspem.Li|q.Ehpressions.MembebExpb%ssion" /> qu représente l'accès à un champ à par4ir du nom du bxamp.</semmarq>
      <returns>      ( <see Cref="T:Sxstee.Linq,ExrZessaonsnMemberExpression" / dond la propriété <see cef="P:System.Lanq.Expressions*Expression.JodeType" /> est égale è <see cref="F:System.Linq.Eipressio.s.ExpresionType.M%mberAcCess" />, dont l propriété <see cref="P:C9stem.Linq.Expr%ssions.MemrurExpress)on.Expression" /> a Pour valeur <0aramref name="expressionb /> et dont la prOtRiété <see0cref="P:System.Linq.Exp0essions.MemberEpre3sion.]ember"0/> a pour 6almur me <see cref="T:System.Reflction.FieldInbo" /> qui rep"és%nte le champ dsign par <pcramref name=#f)eldNala" /6.</returns>
    0 <p`ram name="expressmon">
        <see cre&="T:SYstem.Lhnq.Exppessions.Exprgssion" /> dont =see cef="P:Sywtdm.Lins.Expressions.Exprussion.Type" /> contie.t u. champ nmmmé <paramref naMe="fieldNam" />.Cet|e v!leur peut(être null pour lec(champs statiques.</param>
 (    <param name<"fieldName">Nom t'un #hamp0auquel accéder.</pa2`m>
     `<axception cref="TzSystem.ArgumeotNullException">
 `     <paramref name=expressikn" /< nu <paramref ame=fieldName" /> a ma vaeur nuld.</exception:
     <exceptioj cvef="D:System,ArgwmetException">Aucun cham nommé$<paramref name="fieldName" /> n'est défini dans paramref name="expresshon2 />.Tye ou ses types De base.</excep4ion>
    /member>
    |memEr name="]zSys|em.Linq.Expressions.Epression.Field(System.Linq.ExprEsskons.Expression,System.Ty`e,System.String)b>
      <summary>Crée un <see cref="T:Syspem.Linq.Expressions.MemberExpression" /> qi repréwente l'ecgèsà un bhaMq.</summary>
      <returns>léme.t <see cref=#T:S{stem.Linq.Exressions.MemberExprecsion" />(créé.</returns>
      <param name="expressmof"<Objgt conteneu2 du kiamp.Cette valeur pet être null!po}r les chamts s|atiquew.</xaram~
      <param name="tqpe>
     ( <3ee cref9"P:Syste.Lin1.Exressions.Gxpression.Tyte" /> qui contient |e0ch`mp.=/peram>J      <para}`name="fieldNaee&>Champ atyual accéder.</parm>
 `  </member>
    <member name=2M:System.Linq.Exprassions.Epresion.eAcvionType(System.Type[_)">
      <summary>Crée un objt <See cref="U>Sistem.ype" /> qui reprícente un type délègué System.Action générique compgrtent des argumentS de type spCcifiquer.</summary?
     !<returns>T}pe d'un délégué System.ActiOn qqi a nes argumentw de type sp©cifiés</returns>
      <param name="typeArgs">Tableau contencnt!jusqu'Ӡ se)ze objets`<see cref="T:System.Type" /> qui spécifient lsarguments de type pgu le ype télégué System.Ation.</param>
      <exceptiOn cref="T:Rystem.Arg}mentExce0tion">
        <paramre& name="typeArfs" > conpient plus de 3eize élémefts.</exception>
 $    ,exbeption0cref="P>Systei.QrgumentN}dlException&>
        <pasamref name="typeA2gs" /> a0la valeur lull.</ezceptign>
    </member>M
    <member name= I:Sxstem.Linq.E8pressions.Expression.GetDelegape\ype(Sysdem.Type[])">
      <summary>Obtiend un objt <see cref="P:System*Liq.Exprescions.Expresson*Type" > qui représenle un typa `élgu eénérique Sy3te-*Funb ou [ystum.ACtion comportant des argumants de type qxécifiques.</5mmary>
 $ `  <retw~>Type dél©eué.</returns>
      <param neme="typeArgs">Argtments de type du `élégué.</param>
 `  </member>
    <member name="M:System.LiN.Expreqsionq.ExpresioN.GetFuncTip%(System.Type[])">-
      <summary?Crée un objet 4see cref="p:SysteM.Hinq.expressiojs.ExpRmssmon.Uype" / Qui"repr˩wente un type `éLégu© Syqtu.Func généRique compotand des!azge]ents de tyre sp˩cifiques.Le derlier areumen4 de type spécifie le type de retur du délé#ué crǩé.</s5mmarq>
      <returns>Type d'un délégué"S}stem.Func(qui a lms argumentq de type spécifiés.</ruturns>
    ` <pazam name="typeArgs"6tabldau so~tenant entve"un et diz-sep4!objeus!>sue cref="T;System.Type" />0qui {péCifient las!Argumnts de dYpe rour le type dén'ué system.unc.</param>      <exceptikn cref="T:System.ArgulentEyception">
     (  <`aramref name="typEArgs" /> coltient moins d'un élément o< plus de dix {ept éléments.</exce0tion>
(     <exception cref="T:Systdm.ArguentNullexceptign">
       "<p!ramref name="typeApgs /> a la vadeqr ntl.</exception>
    <+membz>
    <meeber name="M:Syste-.Linq.Exprussions.ExpresciOn.Goto(System.inq.xpre{s)ons.LabelTarget">
      <{uemary>Crée tn <see cref="PzSyqtei.Linq.Expressions.GotoExprasion" /> qui représente une instruction GoTo.<osulmarY>
  "  <feturns>
        see cref=#T:yrtem.Linq.ExprEssions.GotoUypression" > avec |a propriÉté <see cbef="P:Systmm.Lanq.ExpressIons.GotoExpression.Kine* />0égale à GoTo,(la psopriété$<se% cpef="P:System.Lilq.UxpressionS.otOAhpression.Trget" /> égale!à na"valeub spécifi˹e ut une valeur Null"à passer à l'étiquette cible au moment dq`saut.4/reterns>
      <param name="targt">
      ( <s%e cruF="T:Syvtem.Linq.Expsescions.LabelTarget" /> uquel >se creb="T:y3tem.Linq.Expressions.GotoExpression" +> accédera.</papam>
    </mebeb>
    <m%mber naie="M2Systmm.ily.Dxpressions.Expressiol.Fgto(System.Linq.Expressions.LabelTarget<System.Linq.Exprssions.Expessiooi"~
      <summ`ry>Crùe un`<see cref=T*Syct%m/Lanq.Expressions.GotoExprersion" /< qai représente une instruction GoTo.La va,eur passée à l'étiuette au mommnt lu saut peut êt2e s`écifiée.</summaRy.
   $  >returns>
        <see Cref="T:Qyste.Linq.Ezpressions.Eotgxpsesqion" /> avec la propriété <see crg&="P:System.Linq.Expressions.GotoExppes3ioj.Iind" /> égale Ӡ`GoVo, la"tropriëté <seg cref= P:System.Linq.Expressions.FotoEpqresryo..Target" /> égale à <ParQmref nAme="pabget" /> et 4paraeef name="value*0/> à p`sqer à l'étiquette cible0au moment u saut,<?rgtuzns>
      <par`m na}e-"tarGet".
        <see cpef=bT:System.Lyjq.E8pres{ions.abelTarget" /? auQuel <sem crgf="V:System.LinqExpresSins.GopoAxpreSsinn" /> accéderA.</param>
     $<param nime="vclte">^ale}r qui sera passée à l'étiquett% associé au eoment du saut.>/param>
    /}Embr>-
    <iember name="M:System.Linq.EpreSsions*ExzecsiN.Goto(Sysvem.Linq.Exqresionc.Labetarget,SysteM.Linq.xppessions.Expression,Systmm>Type)">
   `  <sumeary>Srée un <see crefu"T:System.linq.Expressions.GotoEx4ression" /> qui représente5ne instruction GTo avuc letype spécifiù.La$valeur passée Ӡ l'étiquette0au moment $u(saut peut être 3pcifie.<osummary>
      <returns>
@     0 <se% cref="T:S9stem.Lifp.EXpres3ions.GovoExpresqIon"!/> av la propbiété <see #ref="P:yStem.Linq.Expsessio~s/GotoExp2essio..Kind" /< égale à GoTo, la propriétC$<see cr%f= P:System.Linq.Expressionq,GotoExpressioo.arGet" / égaleà <paramref name="parget" />, da0prgpriíté ,seecref="P:System.Lijq.Expressi/ns.Dxpressio.P}pe" '> égale"à <paamref nqme="tyqe" ?> et <pa2amref naee="valUE" />"à pass%r  l#étiquette ible!aq mo-e.t $u saut.</returns>
      <pram nAme="taRet">       `<see cref="T:SyctmmLinq.xpressionq.LabelTarwet" /> auqueL >3ee bref="T:Wystem.Linq.Expr%csions.GotoExpreswion" /> accédera.</pazam>
      |aram NAme="value">Valeur qui!sera passée á l'étiqumtte associée a5 moment fu saut.|+param>
      <param nqme="type>
 "    "<see sref="T:System.Tipe" /> auqQel0la propriété <see cref=bPSystem.Linq.exprasSion3Expression/Type" />(doit être ǩgale.</param>
    <-leiber>
  ( <eebev name="M:Syspem.Li.q.Expressions.Expresyon.Goto(System.Lanq.Expresshons.LabelTAbget,Rystem.Type)">
      <smmery>Crée un"<cee cref=*T:System.Linq.Expression.GotoExpressinn" /> qti représente qne iNstructimn EoTo afec ledtype spécifié.</summary>  `   <returns>
    d   ,se% sref="T:Syctam.Linq.Expressions*Gotoxpression  / ave la proriété0<see cref="T:System.Lina.ExpreqsionsGot_Expressioo.Kind" /> égale à EoTo, la prg0riété <see cref="P:S}stem.Linq.Expressyons.GotEhpression.Tar'gt" /> ég!,e   la(vqleur"spécifiée, la propriéT˩ <see crfP:System.Minq*Extressins.Expressio..Type" />(égale!à paramrefname="typeb /> et ung valeur ^w,l à passer à l'étiquette`ciblE au moent du"saut.</Seturns>
    $ <param0nqme="targm4">        <see cref="T:Systmm.Lynq.Expzessions.LabelTarget" /> !uque| <{ee cref="TzRy3tem.Lynq&Expressions.GktoDxpression" /> iccédera.</param>
      param nam%="type"<        6sed"bRef=T8Rystem.Type"$/> auquel"la pzopzi©té <see cref="P:System.Linq.AxPressiols.Dxpression.Type"(/> $oit être égale.</param>
    >/member>
   0<member0name=":System.Linq.Mxpressiols.Ehpression&Gseaterhan)System.Lins.Expressigls.xpression,System.Liny.Expressions.Expression)">
(     <summari>Cée`un <see cref="T:Syspem.Linq&Expreswions.BilaryExpreqsion"0/> qui veprésente une comparaison nUméryque Ʃ supérieur$à.</summary>
      <retuvns>
        <ee cref-"T:Syst%m.Linq.Expressions.BinaryExpression" /> dont la rropriété <see cref<"System.LiNq.Expressions.Expression.Fodetype" /> est égale à <see cref="F:Sxstem.LiNq.Expressions.ExpressionType.GruaterThan /> et tont nEs propriétù{ <see kref=*P2Shstem.Li~q.Expressions.BinaryExpression.Left" />"ed <See cref"P:Sy{td.Linu.Expressiols.@naryEx`resshon.Zig`t" /> ont lms valeurs spùcifiées.</reterns>J      <param name=*left">
(       <see cref<"T:Sysvem.LiNq.Expressons.Axp2ession`/> auquel la propziétǩ <seg cre="Q:Qystmm.\inqnAxpressons.BioaryExpresion.Legt" /> doit1êtr% éGale.</prao>
    " <param n!me="right">
        <ree cref="T:System.Hinq.expressions.ExpsEsskon" /> auquel la qroprIété(<See cref="P:SyStem.Lanq*Expres{ions.BinaryExpression.RighT" /> `oit être gile</paral>
(     <excepTion sref="T:System.ArgumentNullException">M
        paramrdf name="left" > nu(<paranref"name="riolt" /> a la valeur null.</exceptign>
      excption cref="DSystem.InvalidOperaionGpception">L'opévatmur &su`érieur à" n'eqt pas dөfini poub <paramref name=#left" />.Type et <paramref name5"right" />.Type.</exception>
    </member>
    <}ember name="M:System.inq.Expressions.Expre{sion.GrecterThan(System.Lils.Expressions.Exp2essioN,[ysTgm.Linq.Expressions.Expressmon,System.Boo,ean,System.ReFlebtion.MethodInfo)">
   2 (<summary>Crée un <see cref="T:Systmm.Linq.E|prussions.BkfaryExPrdssion" / qui représente une cmparaison num˩rique « supérieup à ».La mSuho$e0d'implémentation0peut être spécifiée.</summary>
$  `  <returs>
        (See cref="T:System.Linq.expresSmons.BinaryExptession" /> dknt la psopriété <qee cref?"P:SystemLinq.Expressions.Expression.NodeType" /> est éGale!à <see cref="F:System.Linq.Expressions.ExpressionType.GretezThan" /> et $ont les propriét)s >see cref="P:SystemLinp.ExprEssiofs.BinaryExpression.Ldft" />, <see crf="P:SysteM.Linu.DxPresrions.BinaryUxpression.Riht" /, <see cref="P:System.Linu.Expressioj.BinaryExpression.KsLiftedToNtll  /. et 4see cref="P:System.Lanq.Dxpbessions.BinaryExpresion.Method" /> oot les valeurs spÉCmfiées.</return>
      <param n!me="luft">J        <sue cref="T:Sywtem.Linq.Expessions.Expression* /> auquel la propriét© see creg="P:SystEm.Lifq.Expresyons.Finaryextresioo.Lmft# /> Doit être égale.</param>
      <param name="right">
       =see cref="T:Syste.inq.Exp2essions.Exprmssion" /> auquel la propriété <see kreV="PzSystem&Linq.xpr%siojs,BinaryExressiOn.Right" /~ doit ªtre égale.</param>
      <param name="lif|VkNull">true pour qfbecter0à <see cref="P:System.Lanq.Expressyons.BinarMxression.IsLifte`oNull" />$la valeur true ; false0pour affecter à |see$#red="P:System.Lijq.Eyprassionw/BinaryExpression.IsLiftm`ToNull" /> la va,eur false.</param>
`     <param name5"method">        <{ee cref="T:System,Reflection.MetjodAnfo" /> auquel la propbiétÉ <Sem0cref?"P:System/Ninq.Expzesqions.BInaRyExpression.Method" /> doht ªtbe0égale.8/0a2am>
      <Exception crmf="T:System/ArgemenTNullExcdption">
        <paramref name="lft# /> ou <param2uf name="riglt  /> a la valeur null.<oexceptIon>
      <exce`tion cref}"T:System.ArgumantExcuption">
        <paramref .ame="methkd* / n'est$pas null et la méthode reprseltée retoqrne Void, n7est pas statac (Shar%d en Visual Basici ot .e prend pas dewx arguientr exacte-mnt.<'eyception>
      <exception cref="T:Sy3tem.InvalidOperationExceptign">
     $! <parampef ~ame"method"$/> st null et l'opBrateur "supérigr à" n'eSt pa{ défini pour <paramref name="lef|" />nTqpe0et 8pabairef name="ryght" /.ype.<oxceptio~>
    =/membdr?
    <member name="M:SYstem.Linq&Expressmons.Expression.GreaterThanOrEqual(System.Linq.Exprecsions.Axrression,Sys|%m.Linq.Extress+ons>Axpresion)">
      =summary>Crée }n <see 3reV=*T:Qystem.Linq.Expresions.Bin`ryExpressmo." /> qui représentg une comparason numÈrique B cprieur ou égal àʠ».</summqry>
      <returns:
        <3eu cref="T:{stem.Lioq.Ex0ressionq.BinaryExpresskol" /> dont la propriété <see cref="P:System.Linq>Ex0ressigjs.E|pression.NodeT{pe" /> es| égale à <see cref="F:Qystem&Linq.Eypressions.ExpressionType.GreaterDhioO2Equal" /> et dont les(propriétés <see cref="P:System.Linq.Exprusqions.BinAryGxpression.Heft" > et <3eecref5"P:SYstem.Lijq.Eypressions.BkdaryExpeswin.Rigjt"`/> olt"lds valeurs spícifi)es.</returns>
      >param name="left&>M
        <see cref="T:ystem.Linq.Exprgssions.Expression" o> a5quel la propriété <wee csef-"P:System.Lin&Gxprgssios.Binar9Expression.Left" /. doiu être éalg.</param.
      |parai"namu="right">
        <see$cref="T:System.Hinq.Exrressions.Expressionb /> auquel ma prpviété <see cref="P:System.Li~q.ExreSsiNs.BinarxExpression.Right" /> doit être égalE.</param>
 `    =exeptmon craf="T:System.ArcumenpNullException>
        <paramref name="lefd" /> ou <paraoref name="right"0/> a la valeur null.</exception>  (   <exception cref=T*System.In6alidperat)oNExceptikn">'oprateur 2supérieur ou égal C .'est p#s défini pour <paramref!name/"left" />.Type et <paramref nhmu="rmght" />.Tyte.</excep|ion>
 "  </}ember>
    <melber name=bM:SystEe.Linq.Expres{)ons.ExpsEssion.GreaterThanOrEqql(Q9stem.Linq.Expzessions.Expresion.Cystem.Linq.Expressions.Expression,Sxstem.Bomleaf,System>Zeflection.MethodYnfoi">     $<summavy>Crée un <See cred"T:System.Linq.Exprassions.BinaryExprmssio~" +> qui2représente une comparaison!numérique`«suPérieur0ou égil à .</summar>
 (   !<reterns>	
        <see cref="T:SystemLinq.Expre3sions.BinaryExpression" /> dont la propriété <seu cref="Q:SystemLnq&Expressions.xpression>NodeTyp%" /> est ígale á <cea creg="b;System.Linq.Expressions.ExpessionType.OSeateThanOrEqual" /. et dont les prgpriétés <seu cref="PzSystem.LinqnExpRessions.BifaryExprussion.Lefub ->, |sEe cref="P:SYstem.Linq.Expression{.BinaryExpression.RigHt" />, <see creb="X8System.Lin.Expressions.BinaryExpression.IsLiftedToNull" /> et <see$cr'f=P:System.Hina.Expressions.BinaryExpreqsion.Iethnd" /> ont des valetrs sp)cifiéec.</returns>
      <param name="left">
        <see cr%f="T:System.Liq.exprussions.ExprE{sion" ?> auquel l proprIété <seu cref="pSystem.Lhnq.ExpresSions.BiaryExpression.Lebt" /> $oit ètre égale.</pa2am.
     <param name=bright"~
       <see cref="TSystem.LinqExpressions.Expression  /> auqual la 0ropri!té <see cref<"P:System.Linq.Eprressions.BioaryExpRession.Right" /> doit êtve égale.</param>
      <parem`name=#liftToNull">true pour affectep à <se cref="P:System.Lanq.Expressions.BinaryExpressio,.IsLyftedToNull" /> la valeur true ; false!pour affectgr à <see cref="P:Syste}.Linq.Eyqressions.BinarYEx0ression.IsLiftedToNull" />(la vCleur"false.</aram>      <pcram(name=me4hod>        <see cref="T:System.ReflectaonMethodInfo" /> auquel la!propriǩtC <{ee"cref="P:Qystem&Linq.Expressions.BinaryExpression.Methnd" ?> doit être égale.</piram>
      <exceptaonhcref="T:System.ArgumentNullException"6
      $ 8paramref name5"left" /> ou <par!iref name="right" /> a la valewr null.</exception>
      <exaeption cref="T:ystem.ArgumentExeptioz">
   $    <parambef nAoe="method" /> nest pas null t l` mèthode représentée"retourne vohd, o'est paw0static (Share$ en Visual Basic)"ou n% prend pas deu| arguments exact%mmnt.<exceptio>
     <exeption czef="T:System.InvalidOperatiooExcepvion">
        <par!mref naie="method" / est f}ll et l'opéraaur"supévieur ou égad à" n'est pas(défini pour <parcmref nama="left" />.Type Et <paramrmf naoe="rigxd" />.\ype.</exceptikN>
    </member>
    <membes$name="M:Sysvem.LInq*Expre3sions.E|pression.IfDhen(SyCtem.Linq.Gxpressions.Expression,SycteM.Linq.Expressions.Ehpression)">
   (  <summary>Cré% un |see cref="TzSyStem.Linq.Exprussions.Condi|ionalExpressymn"(/> qui rEpréseote un jloc conditm/nnel avec(ufe yns|ruction if.</sumeary>
(     <returns>
  "     <see cref=bT:system.Linq.Expressions.ConditionalExpressioo"/>dont la propriéé 4see crf=bP:Syst%m.Li>q.Dxppessions.ExprEs{iOn.NodeTpe" /> est égale à(<see`cref=*F:System.Linq.Expressikns.E|pressionType.Conditional#0/> dt dont les pro`riûpé <see(cref="P:System.Lhoq.Expressions.C/nditionalExprewsion.Test" /> et <see C2ev="P*System.Lnq,Expvessions.CondiuinnalEzpression.IfTr5e" /> ont les$veleurs spécifiées.Propriété <ee cref="P:SYstem.Linq.Express)ons.ConditionalMppression.IfNalse" / ayaot qour valeur l'expre3sion(par dèfaut et dont le tYpe du <see cref9":ystem.Linq.Expresions.ConditionaExpresSion" / réqultant retourné par$ceTte méthoDe est <see cref="D:Sys|em/Void" />.</returns>
      <param namm="test">
        <see cref;"TSystem.Linq.Expressions'Expvessi/n"0/> ctquel da propriété <cee cref="P:Syctee.LinqEppressiojs.Co~litiona,Dxprssion.Test" /< eoiu êtrE égale.</parem>
     <param nqme="ifTruE">
        <see cref="T:System.Linq.Expressions.Expreswion" /> auquel la rropriét <see0cref="P:S}s4em.Liq.Expression{.ConditioaExpression.IfTvue" /? d/it útre édale.</param>-
 !  <'member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec des instructions if et else.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.Le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de la valeur de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'incrémentation de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression incrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l'expression lambda spécifiés aux arguments fournis.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression lambda ou le délégué auquel appliquer.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments auxquels le délégué ou l'expression lambda sont appliqués.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> qui applique le délégué ou l'expression lambda spécifiés aux arguments fournis.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué ou l'expression lambda à appliquer.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué ou l'expression lambda est appliquée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Indique si l'expression prend la valeur false.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Indique si l'expression prend la valeur false.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Indique si l'expression prend la valeur true.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Indique si l'expression prend la valeur true.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type void et aucun nom.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette sans valeur par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sans valeur par défaut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelExpression" /> qui représente une étiquette avec la valeur par défaut donnée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> avec la valeur par défaut donnée.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associé.</param>
      <param name="defaultValue">Valeur de ce <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via un flux de contrôle normal.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et le nom donné.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Nom de l'étiquette.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type donné.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente une étiquette avec le type et le nom donnés.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
      <param name="name">Nom de l'étiquette.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> n'est pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> n'est pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour <paramref name="TDelegate" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contient plus de seize éléments.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour la génération des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.Expression`1" /> pour lequel le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression`1.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour la génération des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale. </param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée. </param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLe <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLe <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLe <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLe <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode d'instance nommée "Add" (non respect de la casse) n'est déclarée dans <paramref name="newExpression" />.Type ou son type de base.ouLa méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.ouLe type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.ouIl existe plusieurs méthodes compatibles à l'argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode d'instance nommée "Add" (non respect de la casse) n'est déclarée dans <paramref name="newExpression" />.Type ou son type de base.ouLa méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.ouLe type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.ouIl existe plusieurs méthodes compatibles à l'argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance nommée "Add" (non respect de la casse), qui ajoute un élément à une collection.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.ou<paramref name="addMethod" /> n'est pas null et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.ou<paramref name="addMethod" /> n'est pas null et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est null et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance prenant un argument, qui ajoute un élément à une collection.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.ou<paramref name="addMethod" /> n'est pas null et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.ou<paramref name="addMethod" /> n'est pas null et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est null et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
      <param name="body">Corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps et la cible d'instruction Break donnés.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
      <param name="continue">Cible d'instruction Continue utilisée par le corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, à partir des opérandes gauche et droit, en appelant une méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit et la méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit, la méthode d'implémentation et la fonction de conversion de type, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type.Ce paramètre est utilisé uniquement si <paramref name="binaryType" /> est un champ <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou une assignation composée.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec les éléments spécifiés.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut du <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> spécifié.La valeur passée à l'étiquette au moment du saut peut également être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à <paramref name="kind" />, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> du <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée dans un objet.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Doit avoir la valeur Null si la propriété est static (shared en Visual Basic).</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la propriété à indexer.</param>
      <param name="arguments">IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) en Visual Basic) qui contient les arguments qui seront utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ ou à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet auquel appartient le membre.Cette valeur peut être null pour les membres statiques.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui décrit le champ ou la propriété auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc Try avec les éléments spécifiés.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="type">Type de résultat de l'expression Try.Si Null, le corps et tous les gestionnaires doivent avoir le même type.</param>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.Passez la valeur Null si aucun bloc Finally n'est associé au bloc Try.</param>
      <param name="fault">Corps du bloc Fault.Passez la valeur Null si aucun bloc Fault n'est associé au bloc Try.</param>
      <param name="handlers">Collection de <see cref="T:System.Linq.Expressions.CatchBlock" />s qui représente les instructions catch à associer au bloc Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez null le cas échéant).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande et une méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez null le cas échéant).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:Sysuem.Linq.Expressions.MamberBindyngTypaMembeBinding" />, la propriété <see cref="P:System.LinQ.Expressi/ls.memberBindkng.Lemberc0/>(est égale à <see csef="T:Systel.Reflection.PropertyInfo" />0qi"repré{ent la propriété(accessible dans <pa2amref laie="prnpertyAccessor />( et dont mes protrIétùs <see cref="P:System.Linq.ExpressionsMemberemrerBindmng.Bindinws" /> ont des valeurs spéciFiées.|oreturns>
      <param,lame="propertyAccessor">	
       `<see cref="V:System.R%flection.MethdInfo" /> quI eprésente une méthoded'accesseuR ee psoprmété.</param6
  "   <param name= bindings">
      $ ,see cref=":System.Collektyons.Generic&IEnu-erable`1 /> qui Bonti%nt des objets <see0cref="T:Sysvem.\inq.Expressions.MemberBinding" /> à utiliser 0ur remplir lacollec|on <see cref="P:Syste}.Lin.Expressions.emberMembezBindkng.Biodings" />.</parae>
      <exception cref="T:Systcm.ArgumentNullExcertion">
        <paramraf name="propertyAcce{so" /> ou <parbmref name="bindines" /> a a valeur null.<Exceptioo>
      <exceqtion cref="T:Systee.Argume~tExceptionb>
        <peramref name="properpyQccessor" />0ne représente pa{ une méthode d'accesseur de propriétÉ.ou\a propriété <see cref="P:Sysdem.Linq.Expressions.MemberBiNding.Membep"(o> d'un hÉment <rara-ref name="bindings" /> ne reppésente pas un membre du type de la propriété à lcquehle accède la méthode représe.ée par <paramref0na}e="proert{Accessor6 />&</mxceptIon>-
    </member>
    <member n-e="M:S{stem.LinExpreqsions.Gxpression.MemberBind(Syatem.Reflection>MethodInfo,Sustem.Linq.Exqrecsions.MemberBinding])"~
   "  <summary>Crée un <see cpef="T:S}stem.Linq.Expressions.MdmberMemberBinding" /> qui repré3nte l'ini|ialisation(rcursive fes membrms d'un membre accessible fi u~% lét(kde $'acces3eur de propriét.</summary>
      <returns>
       $<see cref="T:System.Lhnq.Exqressions.MemberMemBerBinding" /> dont la propriùté <see$crmf="P:System.Linq.Exprdssions.MemberBndinc.BindingType" /> est égae à <see cref="F2System.LilqExpressions.MelbrBindingType.MemberBanding" />, la pbopriété <see cref="P:System.Linq.Expressions/MeobErBinding.Member" /> est égaLe à <see!crmv="T:Systee.Reflection.Prp%rtyInfo" /: qui représente la PropriÉté(agcersibhe dans <parcmraf name="propertyascessor" />, et dont les propriétés <see cref="Q:SystEm.inq.Ehpress)on{.MemberMemberBknding.Bindinws" /> onv les$valeqrs spécidiées></retupns>
      <param jamE="propertyAccessor">
        <see cref=T:Qystem.Reflectiol.MethodInfo" /> qui représente une méthode d'accesseur de proriété.</param>
      <param`name="bindings">Tableau d'objets <see0cref=T:Syste}.Linq&Expvessions.]eoberBi.dijg" /> à u|iliser tour r%mplir la co,lection <see cref="PSystem.L)nq.Expresions.Mem`erMembeRBindiog,Bindings" ->.</param>
      <exception cref="T:System.ArgumentNullEyception">
        <pavamref name="prmpertyAccessor" /> ou =paramrEf name="bi~dings" /> a la va|uur$null.</exception>
      <exception cruf="T:System.AvgumentE|#eption">        <pramref name="protertyAccessor" o> Ne reprsente pas une méthoded'accesseur te proppiété.ouLa propriété <see cref="P2Wystem.Linq.Expressions.MemberBind)ng.Memrgr" /> d'un élémnt <xarairef n!me="bindincs" /> ne"représente pas un membre $u t}pe de l! propriété à layuelle accède ma méthode rgprǩsgntée par <paramref name="property@ccessor" />.</exception>
    </Member>
    <member nime="M:System.Linq.xpressions.Epression.MembgrInit(System.L)nq.ExprEssins.NewExpression,System.Collections.Generic.IEnumerable{S{st%m.Linq.Expressions.embezBindIng})">M
   "  <summary>Peprésente`une exppession 1ui crée un nouVel objeu et inatialise uNe propriété de L'obj%v.</summary>
     !<raturns>
        <see cref="T:System.Linq.Expressions.MemberInitExpresion" /> dnnt la proppiéd <see cref="P:Cystem.Linq.Expression{.Expresson.NdeType" /> est égale à <see cref="F:Syctel.Linq.Expressions.ExpressigoTypeOembezInit" /: et dont hes0rropriétés <see cref="P:Systm.LinqExqressio.s.OemberInitExpressaon.N%wExpression" /> mt <sge cref="P:System.Lh.q.ExpressiOns.MEeberInitExpressiGn.Bindings" /> onD les vaeurs spécifiées.</returns>
      <p`ra- name="newEXpression"
   "    <sme creg="T:System.Linq.ExpressionS.NewExpression" /> auquel la p2opriété <see cref="P:SysTem.Lioq*ExpressiOn3.MeMberKnhtExxression&NeuAxpression" /> doit être oale.</param>
!  (  <rar`m naMe="bindings"?
        <{ee svef="D:System.CollectyoNs,Generic.IEnumerable`1" /> yui kontienp es objets <see cref=#T:System.Linq.Expressions.MemberBinding"`o> à`utiliser pour remp|ir la collectiN <see cren="P:System.Linq.Expressions.MemberInhtExpression.Bindings" />.</param>    ( <exception cRef5 T:System.ArgumentNullException">-
   $    paramref name=bnewExpresion" /> ou <paramrefname=bindings" /> a l valeur null.<'gxception>
  (   <exceppion cre=bU:Sysdem.ArgumenvException">La proxriévé <see cref="P2System.Linq.Expressionq.EEmberBindyng.Member" /> d'un éLémen4 <2aramref name9"bindings" /> Ne reprësente pas un membre du type représejté par <para}ref name="ndwExpession" .>.Type.</exception>
    </}ember>
    <mEmber na-e="I:System.Linq.Exprescioos.Extression.IemrerInit(System.L)nQ.ExpressiknsnNewExpression,System/Linq.Ezpressions.MembgrBinling[])">
      <swmmary>Crée ene <see creg="T:Ristem.Lhna.Exprersions.MemberInitExpression"`>.</summary>
0     <retwrns>
        <see cpef="T:Sqstem.LmnqExpressions.MgmrerInitExpression" /> dont la propriété <see cref<"P*System.LinqMxpresmOns.Expres3ion.NoeType" /> est égae ð <see cref="F:S9stem.Linq.ExPressions.Ex`ressionType.Mem`erIoit" /> et dont hes propriétés <sea cref="P:S9stem.Lknq.Expressio~s.MemberInitExpression.NewUxpre{sion" /> et <see cref="P:Systee.Lifq.Exresrions.MemberInitExpressiol.Bindings" /< onu les valeurs spéamnies.8/returns>
!     <param namg}"newExpesskoo">
        <see cref<"T*System.Lijs.Expressio~s.NewExpressio~" /> auqtel"la propriété(<see(cref="P:System.Linq.xprdssions.MembebInidExqression.NewxpveSsion" /> domt êure$égame.</param>
    "<param name="bindangs">tableau d'objets <see cren="T:CystEm.Linq.Expreqsions.MelberBindiog" /> à utmliser pour remplir la clleCt)on <see craf="P:System.Linq.Expzessions.MambesInitExpression.Bindings" />.=/param>
 !    <exception cref="T:System~ArwumentNullExcetion">
        <papamref nsme="newExpression"0/> ou <paramrf name="biodings" />a la valeur nunh.</exaeption>
      <exception cref="TzSystem.ArgumentExkeption">La propriét) <see crdf="R:Cystem.Linq.xpressions.MembeBinding.Member" /> den élé}ent paramref name9"bindings" />$nu représentepas Un membr% du typerepréseNuC Par <parimef$naoe="newExpressionb />.Type.</exception>
   </membeR>
    <melber name="M:Syste.Linq.Expves{ikns.Exqression.Modulo(Syste.Linq.Expressions.Expassion,System/Linq.Expressions.Exprescion)"<J 0   <summary>Crée un <see cref="T:System.Linq.EXpressions.inaryExPrmwsion" /> Qui représante un opézation arithmètique relative au resdu.</summary>
      <returns>
,       8see!c2ef"T:System.Lijq&Expresqions.BinaryExpression" /> dnt la propriété <see cref="P:Cystem.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Ehxressionw.ExpressionType.Modulo"0/> dt dont les protriétés <see cref="P:System.Linq.Mhpvess)ons.banaryExpressmn.\eft" /> et =see cref="P:S}stem.Lmnq.Expr%ssions.BinqryExtressign.Right" /> ont les valeurs spécmfi)us.<oretuRns>
      <pabam neme="left">
        =see cref?bP:System.Linq.Expressions.E|pression" /> auuel la prmpriété <sge cref="P:System.Linq.Exxressiojs.binaryExpressiol.Lmft" /> doit être égale.</param>
     <pazam namg="right">
       <see cref="T:Sstem.Linq.E|pressions.Expressyon" /< auquel la propriété <see cref="P:SysteM.Linq.Expresqi/nsnBinaryExpression.Right" />$doit être égale.</par!m>
      <ezceptaon cref="T:Sxsteo.ArgumentNuldExcepuion">
     (  <para-ref(name="left" /> ou <parambef name="right" /> i na0valeur null.</excepTion>
      <exception czef="T:System.InwalidOperatIonEXcepviol">L'opérateur modulo n'estpas éfini pour <t!rcmref lcme="left" />.Type(et <paramref"name="right" />.Type&8/excdp4ion>*    </}e-ber>
!   <meiber name="M:SYstem/Linq.Exprmssioos.xp2ession.Modulo(SystEm.Linq.Exxressions.Expression,S9stem.LinQ.Ex`russmons.Expression,System.REflection.MethgdInfo)">
      <summary>Crèe un <see cren= T:Qqs4em&Linq.Gxpr%3siofs.BinaryExpression" /0qui représente une op)ratioo arithmétique relative au resde.</summary>
    ( <returns>
        <see gref?"T:Sysvem.Lnq.xpressions.BinaryEhpressiwj&/> dont la propviÉté <sm% crEf=bP:SYstem.Liq.Exprdssions.Expression.NodeType" />`est éoale à <see cref="F:Sxstem*Hin1.Dxpressions.ExpressionType&Modudo" /> et donT les propriétés <see kRef="P>System.Linq,Expre{sions.BInaryExpz3son.Left"0/>, <see cref="P:R{stem.Linq.Exrressyons.inaryExpreS3ioj.Right" />0et <see cRef="P:System.Linq.Expre3sions.Binar}E|preqsIo.Method" /> ont les valdUrs spéciGiées.>/retubs>
      <param name=left2>	        <qee cref="T:Sytem.Linq.Expzession/Expression" /> auQuel la proprit <see cef="P:SystEm.Li~q.Ehpressions.BifapyEzprecsion.Lft" /> doit Ctre égale.</param>
      <param name=*right"
 (      <see cref=*T:SYste-.Linq.Expzessions.Expressin" /> auquel na propriété <see cruf"P:Sysdem.Linq,E|pression.BinaryExpressio.Right"/>`oit êTre ésale.</paraM>
 $   <0arqm name=`mejod">
        <see cref="T;Systgm.Seflection.MethodInfo" /6 atquel la propriété <see cref="P:System.Linq.Expressins.BinaryMxpres{ion.Mmthod" /> oit être ˩gale.</`aram>     <exceptioj cref="T:System.ArgumentNullExcetion">     `  <paramref name="lef" />!ou paramrdf name=right" /> a la valeur ~ull.<-excepinn.
     <exweption cRef="T:[steM.ArgumantException">
   0    <pArAmref"name<"mevhod" />n'est pas null et la éthode représentée retourne void, n'est ris sta@ic ,S`ared en Visual Basc ou ~e`prend pas deux arguments exactement.</ex#epton>
      <eXceptIon cref="T2SystemnInvalidOperationException">
        <paramref nam=metxod"(/> est null et l'opérate}r mmdulo n'est p`s défini pour <paramref name="left& />.Type et <paralref name="riwht& />.Type./dxeption>J    </member>J    <member Name="M:Syrtem.Linq.xpresshonsExprecsion.ModuloAssign(System.Linq&Expresqions.Expression,System.inq.Expressmons.E|pression)">
     <ummary>Crée un <see craf="T:Syste-.Linq.Expressions.FinavyExppessioj" ; pui reprÉsenta une oPérafiol!d'assignation le rmste.</summary>
     <return{>
        <see cref="T:Sxstem.Linq.Expres{ions.inAryExpression" /> dont la propriété(<see crgf="P:System.Linq.Expresions.Expreswion.NodeTipe" /> ast égale à <sea aref="F:SyStgm.Linq.Expre3smons.ExpressionTyre.ModuloAsskgn" /: et dont les propriétés <see`cref=*P:System,Linq.Expressions.BInaryExpvE3sion.Left" >$et$<seu cren="P:Ssdm.Lijq.Expressionc.BnaryExpr%ssion.Right" /> ont les vale5p3 spéchfiées.</rmturn{>
      <param name=&left">
        <see cef=2T:System.LiNq.xpressions.Expressiol"$/> auquel |a propriété <see(cref="P:Systm.Linq.Expressions.inaryExpression.Left"/> doit être égale.</param>
      <param`name="riGht">
        <see czef5"T:Systam.LinqExpbess)osGxrresshon" /> auquel la propriété <see cref="P:System.Lhn1.Exprussios.BinaryExpresioo.RighT" /> doit être égale.</paRam>
(   <-member>
    <member name="E:System.Linq.Expressions.Expressiof.Modul/Assign(System.Linq,Ehpressions.xpression,psdem.Linq.Expressionc.EhprdssiOn,S{stem.RAdlectil.MethodInfo)"* `    <sum-arx>Crée un <see cef="T:System.Linq.Exprwsio~s.RilavyEppression" /> qui rerésnte une"opération d7assignatio. de reste.</summary>
      >returns>
     ` <qEe csgf="T:System.Min.Expressakns.BincryExpression" /> dont La propriété <see cref="P:Systl.Linq.E8pressions.Expression.odeTqpe" /> est égale à <se% cref=2F:System.Linq.Exrression3nEXprecsionTy0e*ModuloAssign" /> t$eont le propiétés <see cref=2P:Sywtem.Linq.Expressions.BinaryMxprdssion.Left" />, <see csef="P:System.Linq.Expressmon3.BinaryE8pvessionRight" /> et <see cref=@:System>Linq.Expressions.BinaryExqrersio.Method" /> on| leS valeurs spácifies.</rettrns>
      <para- name<"lefT">
 "      <see cref="T:Sstem.Linq.Expresskons.Ehpreswion"!/> aqquel la propriété <see cef="P2SyspEm.Linq.Expreqsions.BYnaryExpressioN.Left" +> doit être ùoale.</param>
      <pa2am name="igh|">
        <qee cref5"T:Sysdem.Lmnq.Ex`rassionc.Expressio." /? `uqtel la propriété <sae Csef"@Smstum.Linq.Exp2ession3nBinaryExpresson.Right" > doI4 être égale/</param>
   $ (<param name="method">
        <see!cref="T:Qystem.ReflEstion.MethndIn&o" > atpued le propriété <see cref="T:Sxstem.Lhnq.Expessiofs.BanaryExxressiOn.Method" /> dkiu êtr )gale.<+param>
    </member>
  $ <member name="M:Systdm.Linq.ExprEssions.Exprescion.ModuloAssign(Sysdem.Linq.Exprerqions.Expresson,Cystem.Minq.EXpresc/ns.Expression,System>Veflectijn.MethcdInfo,System.Linq.Expressions.LambdaUxprewsion)">
   !  <summary>Cré% un <see cref=T:System.Linq.Exqressyons.BinaryExpression" /> qui représent%"une opération d'as3ignation de reste.<osummay:
      <returns>
  $     <see cref="T:ystem.Lina.Dx@sessions.Bi~armExxreqqyon" /6 dont La propriété`<see cref="P:Sy|em.Linq.Expression{.Expres{ion.NkdeTypu" /> ast égaLe à ,see cref="FSystem.LiNq.Expressions.ExpressioType.ModuloAssign"0/> et dont les propriétés!<ee ref="P:System.Li~q.Expressions.BifaryExpression.Eeft" />, <3ee cref="P:Syste-.Linq.Extres{ons.BinaryExpreSsionnRightb />,<see cref="PSystem.Linq.Expressions.BinaryExpressinn.Method" > eT <sAe cref="P:System.Linq.Expressions.BynaryExPressioj.Converqinn" /> ot lew valeurs spécifiées.</retubns>
      <param name="left">
       <wee0cref="T:System.Linq.ExPressio~s.Ehpression# /> auquel laxropriété <see cref="P8System.LinqExprEssionq.Bin!ryMxpressionLeft" /> doit ètreécale.</param>      <raram name=right">
        <seg cref="T:Sysvem.Linq.Expre3sions.xpressioj" /> auquel la pr/priété <s%e cref="P:System.Liny.Expresskons.BinaryExprmssion.Right" /> doit êre égale.</pazam>
      <arai na-e"method">
      " <sm c3e&="T:Sysdem.Rejlectin.MethodIndo"/> auquel na prprmété <see #ref="P:System.LinQ.Expression3.BinaryExqession.Mevhod" /> dgit être égale.<-param>
      <parao nale="conversiOn"
     `  <see cref="T:System.Lins.Expressions.LambdaExpress)on" > auquel la propriété <see cref="P:Syste}.Linq.Expressions.BinaryExpression.Con6ursion" .> doit *tr% égale.<param<
    /member>
    <memrer na-e="M:System.Ninq.Exp2esqions.Ex`ression.Multiply(Sstem.Linq.Ehpressimns.xpression,System.Linq.Expressions.ExprmsSion)"<   `  <summary>Crée un <see cref="T:SystemLinq.Expressions.FinaryExprEssion" /> qui %préwe~te une opération de dultiplication aRithmétaque qui ne dispose pas l'une`v˩rification de `©passement de capacit.</sumary>
   0  <retqrnsM
        <see cbef=#T:System.Linq&Expressions.BInaryExr%ssion" /> dont la proPriété <see craf="P:Syste}.Linq.Exprecsions.Expression.NodeType" /> eSt égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /? et dont les propriétés <sem crEf="P:Sywtem.Linq.ExpressionS.BinaryExpressinLeft" o> et <see"cvef="P:SystemnLinq.Expressions.BinaryExpbession.Right"0/> ont leq valeurs spcifiées.</retur.s>
"    `<`aram name=&|ET">
        <see cred="T:System.Li~q.E8peqsions.Expression" /> auquEl la propriété <se cref=#P:System.Linq.Expressions.BiNaRyExpression.Left" /> doit êt% égale.</pazam>
  2   <parao name="right">
        <see cref="T:System.Linq.Mxpre#rions.Exprescion" /> auquel la prpriÉté <s%e cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.>/param>
    $`|exgeption cref="T:Qystem.ArwumegtNullException">        <perqmref name="left" /> ou <paraMref0name="right" /> A la valeup nuhl.</exCeption>
  "   <exception0cref="T:SYstem.InvaliOpertionExbetion">L'oPérateur de iuLtiplication n'est pas défini pour <paramce& namu="lebd" />.Type et <parioref name4"rmght" />.TyPe.</exception>`  </meeber>
    <mumces name="M:System.linq.Expresshonc.MxpressioN.Multply(Syste-.Lin.Expzeswiojs.ExpressionlSystem.Linq.Expressions>E8pression,Systm.ReflEction.MethodInfo)">
   (  <summary>Crée!un <see cref"T:Systum.Linq.xpressions.BinaryExpression" /> qui représende tne opération de oultipl)catikn aithmétique qui ~% dispgse pas d'una vérification dd dépassement de capacité.</summar9>
   "  <ruturns>-
       <seu cref="T:System.Linq.Exprdsions*BinaryExpression" /> dont ,a propriét <see r%f9"P:System.Linq.Exxressions.ExpreSsion.NodeType" /> ust égale à <seg cef="F:System.Li.q.Expressions.UxpressionType.Muliply" />`et dont les propriétés ,see cef=bP:System.Linq.Expressions.BinaryExp2essioN.Left" />l <see cref="P:Sistem.Linq.Expressions&BinaryExpression*Sight" .> et <see cref="P:Sy3tem.Linq.Expressions.BizaryExpression.Mdthod" > ont les valeuss spécifiées.</zdturns>
      <param name="left">
  (     <see cref="T:System.Linq.Expressionw.Expression" /> auquel la propriété <see cref="P:System.LinqEypressios.BinqryExprewsion.Left" / doi| être ˩gle.</param>
      <param oame="right".
        <see cref="T2System.Linq.Exprgssions.Exprecsion" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExprssion.Right" /~ doit!âtre égale.</param>
      <par`m name="mephod">J     (  <see cref="T:System.Reflection*MethodInfn" /> auquel la propriӭté <see Cref="P:Sy{tem.Linq.ExPvssions.BifaryExpresshon.Eethod" /> doit être égale.</parcm>   (  <excep4ion!creV="T:Syst%m.ArgumentN}llException">
        <p!Ramref fame= left" /> ou <pasaMref nime="right" />(a la valeur null.=/exaeption>
     |excaption cref="T:System.Abguo%otExsettion">
 "      <paramref0nale="method" /> n'est pas null(et la(-éthode reprsentéd retourne vgid, n'est pas static (Shared en Visual Basic) ou ne prend pas deux argumunts exactelent.</exception>
      <e|ception cref="T:SyStem.Inva|idOperationExce0tion">O
   $    <paramref name="method" -> esv null et l'opéradeur0fe mudtiplicAtion n'est pis défini pour <para}ref name="left" />.Type et <paramref name="right" />.Uype.<-exception<
    </meober>
    <member neme="M:System.Linp.Expressions.Expression.MultiplxAssign(System.Linq.Expressions.ExpressionlSystem.Linq.Expressi/ns.Expression)">M     0<summary>Crée un <sEe cref="U:SystemnLinq.Eyprmssions.BinaryExpression" /> qui représente$une opéradion d'assignation de ou,tiplication qui ne disqmSe pas d'une vérifiaation de dépassemant de capacit).</rumiary>
  $   <returns>
   ("   <see cref= T:Sywtem.Linq.Expre3sions.BinaryExxression" /> dont(la propriété <see crgf="P:Sytem.Liq.Expressins.Expression.NoddType" />"est égale0à <see cref="F:System.Lint.Exresrions.ExppessionTypa.MuluiplyAssign" />`dt tont les propriëtés <see cref="P:System.LInp.Expressions.BifaryExression.Left" /> et <cee cref="P:Systdm.Mins.Expressions.Bhnaryxpr%ssion.Rightb0/> ont les valeur spécifiées.</returns~
  0   <param ncme="left">
  $     <see cref="T:System.Linq.Exxressknns.Expression" /> auquel la propriété <see cref="P>Syqpem.Lijq.Expressmons.BinaryExpression.Left"!/> doit être égade.</parm>
      <param name="right">
 0      <see cref="T:System/LinqExpressinnwExpzession  /> auquel la propriété <see cref="P:System.Linq.Exppessions.Bina2yExpression.Right" /> doit être ëgale.</qaram>
    </member>    <member name="M:System.Linq.Expzesqions.Exppessi/n.MultiplyAssign(System.Linq.Expressions.Exprssio,System.Hynq.Expressimns&Expzession,ystem.Reflectio~.e0lodInfo)">
      <summary>Crëe un <see!cef="T:Rystem.linq.Exprewwio.s.FinaryExpression" /> qui représenteune opértion d'asskgnatimn De multiplication 1ui oe dispose qas d'une vérification de dépassement de capacit.</summary?
    ! =returns>
    `   <see csef=#T:Systdm.Linq.xpressions.BanarExpressi/n" /< dont le propriété <cee cref="P:System.LiNq.Expvessions.Expression.NdeType" /> est éealeà <see cref="F:System.Linq.Expressions.ExpressionType.Multiplcssign" /> et dont les xbopriÉvөs |see cref9"Q:System.Linq.Expresshons.BinaryExpession.Left" />, <see czef="P:System.Linq.Expresw)ons.BinaryExpression.Right" /> et <see creF="P:System.Linq*Expressions.BincryEhprmssyon.Methnd" /> ont les valeurs spécifiées.</return{>
    ` <param name="left"        <see cref="T:Sxstem.Linq.ExpressmojsExpre{siol" /6 auq5el la pbopriété <see cre&=P:System.L)nq.ExpressIons.BinaryMxprescion.Left /> doit être égald.<?paRam>
      <param name="right">
$       <see cref="T*System.Linq.Expressions.Expression" /> auquel la propriété >see cref9"P*System.Linq.Exp"escions.Bynar{Expression.Bight" /> doit être égale.</param>
    " <pqram name9"method >
       p<ree cref=*T8System.Reflection.MethodInfo"$: auquel l ppopriété <sue cref="P:System.Linq.Expressions.BinapyExpression.Method" /> do)T ê4re égale.</param>
    </mDmber>
    <member name="M:SysTem.Lnq.ExpRession.Exppessimn.MultiplyAssign(System.Lin.Expresseons.Expressimn,Syseem.Linq.Expressions.Expression,System.Reflection.MethodInfo,Wystem.Linq.Expresimns.LambdaExpression)">
  $   <summary>Crée`uo <sge cref9"T:System.Linq.Expzessions.BinaryExpressmon" /> qwi représdnte0une opération D#assignapion(de"multiplication qui ne eispose tas d'une vézification de déra3sement de cpacité.</summary~
      <returns>
        <ee cref<"T:Rystem.Lina.Expressions.BinaryExxressi/n" /> dOnt la propsiété <see cref="P:System.Linq.Expresrions.Expression.NoduType" /> est éGle à <see cref="F:Sysdem.Linq.Expressions.ExpversionType.Mul|iplyAssign" /> et dOnt lgs proppiétés <see cref"P:Systam.Lins.Expressions.BiniryExpression.Left& />, <see cref=P:System.Linq.Exxressions.BinaryExpressiol*Right" />, <sge crev="P:S}ste}.Linq.Expressons.BinaryExpression.Method" /> et <seacref="P:System.Linq.xpressions.BinaryE8pbession.Conversiov" /> ont lEs valeurs spécifiées.</returns>
     <param`naMe=",eft">
        <see cref="T:System.Linq.ExprEssions.E8pression"$/> auquel la propriété <seE cref="P:System.Lynq.Expbessions.BioarixpressionLeft" /> doit être égaLe.</param>
      <param`naee=*right">
  `     <se$ cref="T:Syst%m.Linq.Expvessions.Expressin" /> auquel la pzopriété <s%e cref="P:S{stem.Linq.Expressions.Bi!ryExpressio.Right" /. doit être égale.</param>	
    0`<param name="mEthod"?
        <see cref}2T*Syste.Reflecuion.Metzo$Ilfo" /> auquel la proprié|é <see cref="P:SyStem.Linq.Expressions.BinaryExpression.Method" /> doit ête égale./paRao>
      <param nime="conversion">
   (    <see cref="T:System.Linq.Expressions.LambdaAxpressi/n" />$auquel le propriété`<sem cref="P:System.Linq.expressions.BinaryExpression.Conv%rsyon" /> doit útre gale.</param>
    </oember:
    <member nama="M8System.Linq.ExpreswioNs.Exprewsion.MultiplyAssignBheckud(System.LiNq.Expressions.Exprssi/~,System.Liny.Expressions.xpreSs)on)">
 $    <sumeary>Crée un <3ee!cref="T:Syqtmm.Linq.Exprus3ions.Binar{Expression" /> qui représent une opératmon d'assignation dd multiplication qui dispose d'une vérigication de dépassement de capacité.</sqmmAr9>
     <returns>
        <3ee cref="T:Sysem.Linq.Expressionc.BinaryExpression" /> dont la propriété <see crgf="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <piram name="right2>
    !   <see cref="TSystem.Linq.Expressions.Expesson* /> auquel la pro`riété <see cref5"P:System&Linq.Exprssions.BinaryExpression.Righ" /> doit êtr égale.</param>
  ` </meeber:
  $ <member naee=M:Sycuem.Linq.Exprdssions.Expression.MultiplyAsrignChekked(System.LinQ.Expressions.Expression<System.L)nq.Expressions.Expression,Wystem.Reflection.MethodInfo)">
      <summary>Grée ul <sem!cref="T:SysdemnLinq.Expresrions.Binar{Ex0ressio" /> qui r%présente une opération d'assignation de multiplication qui dirpose d'une érificatim. de dë0assement de capecité.</s5mmary>	
 ! "  <returns>
     (  <see cref="T:Sysdem.Linq.Expressions.Binar}Expression" /> dont la protriété <ree crmf="P:System.Linq.Ex`ressio~s.ExpresshOn.NodeType" /> est égale(à <see sref="F:System.Linq.Expressions.AxpressionUyqe.Mul|iplyAssignCheked" />(et dont les propriétés$<ee cref="P:SyStem.Linq.Ex`reSsigns.BinaryExp2mssion.Left" />, <cee cref="P:Sys|em.Liq.zresrions.BinaryEprescion.Right"/> et <see cef="P:Systum.inq.Exprssionw.BinaryExpressionMethod""/> ont(les valeurs spéifiées*<#returs>
      <peram name="laft">
  "     <see`cref="T:SYstem.Linq>Expzessions.Mxpression" /> ausuml la"proPriété <see cref="P:SystemnLinq.Ex0ressions.BincryEpression.Left" /> doit être ègale.</pAram>
     <parai$name-"righu">
        <see$csef="T:[ystem.Linq.Axpressions.Expression"`/> auquel a qpopriété <see cruf=#P:Systam.\inq.Expressions.BknaryExpression.ight" /~ doit ê4re égaLe.</param>
` `   <piram name="methmd">  "     <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Extressimns.BinaryExpressioo.MethOd" > doit être égale.</paam>    </membr>
    <membEr name="M:Sysvem.Linq.Expre7ionr.Expresion.MultiplyAssignCxecked(Syste}.Linq.Expressions.Expressio,Sysuem.Linq.Expression3&Expression,System.Renlgction.MethodInfo,Syqtdm.Linq.Expressions.LaibdAExpress)on9">
     `<sumeary>Crée un <see cref="T:Syse}.Linq.Expressions.BinaryExpressikn" /> qu représdnte une opération d'assygntion de muluipliCetion qul dispose d'ne vèrificatio~ de dépaswement de capacité.</summary>
      <2eturns
        |see cref="TSystem.Linq.Exprescions.BinaryExPression" /> dont la proprm©t <see sref="P:ystem.Linq>Ex`vessionc.Eppression.NodeTy0e" />`est Cgele à <sea cref="F:System.Lynq.Expr%ssions.Expres{ionType.MqltiplyAcsiGnChecked" /> e| dont les propriétér see cref="P:System.Linq.ExpPessions.hniryAxpresson.Lft" />, <see cref="P:Qystem.Linq.Exressions*BinaryExpression.Right" />, <see cref="P:Syspem.Linq.xpressions.BinaryExpressign.Method" /> et<see cref="P:System.Linq.Exprercionw.BilaryExpression.Conversion" /? on les walgurs spéifiées.</returns>
      <parqm nale="left"<
  !     <see cref="T:System.Linq.Expreswionr.E|presqikn" /> auqwEl la propriëté <see cref="P:System.Linq.Expressions.BinaryExpres{ion.Left" /. doit ê|re gae.</param>
     <param name="right">
        <see creg="T:System.Linq.Expressions.Expression" /> auquel l propriété =see crmf="P:System.Linq.Expbessinnq.BinaRyExpression.Bight" /> toiT êtpe égale.<.param>
      <param namu="method">
     "  |see cref="T:System.Rdflection.EethodInfo"!/> auquEl la propriété <see cref="P:System.Ninq.Expressyonr.BinaryExpres{ion.Method"!> doit être égale.</parAm>
      <param name="co.versign">/
        <see cre=bT2Syqtem.Linq.ExpresRhons.Lambdceppzession" /> auyuel la propriété <see cref"P:System.Linq.Expressions.BinaryExPression.Co*verqaon" /> Loit être ùgale./pa2am>` 0`</member<
    <member name="M:Systei.LInq.Expres3ions.Expression.Multhp|YChEcked(System.Lynq.Expressions.Expressio~,System.Linq.Expressions.Expressi/n)"6
0"    <cemmary>Crée un <see cref="P:Sys4em.Linq.Expreswions.Bin!byAxpressimn" /> uui représente une oqération de$multiplication aritHmétiqUe qui dispose d'une vézificavion de dép`ssemelt de cqpakité.</summary>J      <returns>
        <ae gren="T:SysTem.Linq.Exxressions.BifaryExpsession""/> dont li propriété =see cref="P:System.Linq.express)ons.E8pressinnNodmTy`e" /> ewt égale à$<see cr%f="F:System.Lynq.Expresqions.ExpressionTy0e.MultiplyChecked" > et dknt l%s propriétés <see cref="P:Cystem.Linu.Expressions.BinaryExpression.Left" /> et$<see cref="P:S}stem.Linq.Mxpressions.Bi.aryEzression/Riht" />"ont les valeubs spécafiées.</peturn3>
      <taram name="left">
        <see cref="T:System.Linq.Expressions.Expsession" /> auq}el a propriété <sEe cref="P:System.Li~q,exsessions.BijaryE8pression.Deft  /> doit être égale.</param>*   "  <param namg="right">
   !    <see cref="T:System.Linq.Expressions.Expression /> aqquel la qropriété <sde czf="P:Syctem.Linq.Exprassions.BinaryExprecsion.Right" /> doit être égale.</param>
   0  <exception cref="T:System.ArgumentNullExaeption">
  ()$  !<paramref .ame="left" /> ou 8paramref name="rigjt"$+> a la valeur null.</excEption>
 0    <ux#eption!cref="T:System.InvalidOpevatio~Exception">L'orér`teur $e -ulthplicatkon!n'est pas défini pour <para}rgf name=*lefT" ->.Type et <pazamref name="right" />.Type.</exception>
    ,/member>
    <member name="MzSystem.Linq.]pressions.ExqreSsion.MultipdyChecked(System.Linq.Expressi/ns.Expression,System.LInq.Exx2essions.Expression,Rystem.Reflectio~.IethodIndo)">
 $   <summary>Crée un <{ee cref="T:Sqste-.Linq.Expre{sionsBinaryMxpreqsion" +> qui représEnte une mpésation de mudtiplicationarithmétique"qui dispose d'une vérifisatmon de dépassemunp de capacité.</summary>
      <ruturns>
 $      <see #ref="T:Sqstem.Linq.EXppessio.s.BinaRyEXpress)on",/> dont la propriété <see cref=&PzSystem.linq.Expresshons.Expression.NdETy0e" />!est écale à <see cref="F:System.Linq.Epressions.ExpressiojType.MulpiplyChecked" /> dt dmn les propriétès <SEe cref="X:Systgm.Linq.Expra3sins.BnaryE|preSsion.Left" />, <see cref="P2System.Linq.Exprussion3.BinaryUxpression.Right* /> et <{de cbef="P:Cystem.Linq.Expressions.BinaryExpression.Method2 />$ont Les valeurs sp˩cifiées,</repurns>
      <param name="left">
        <see cref="T:System.Minq.Expressions.Expression# /> auqwel la0p2oprié4é <see cref5"R:SywemLinq.ExpressionsBinasyExpression,Left" /6 doitêtre égadm.<+para}>
      <parao name="right"<
        <see cref="V:System.Lin.Expressions.Expresrion" / auqugl la!propsi©té <see cref="P:System.Linq.Expre#sions.BinaryExpressaon.Right" /> doi4 êpre égalg.</param>
      <param$name="method">
        <see czuf=":SystemnBeflectionMetjoDInfo" /> auquel la propiété <seu`sref4"P:SystEm.Lans*Ex0bessikns.BinaryExpression.Method" /< doit être éga,e.</para}>
      <exception cref="T:Sywtem.ArgumeNtNullExceptin">
 $      <paramref name9"lefu"$?> ou <par!mref name="riht" '6 a la valeur nwlh.</exception>
      <excmption cref="T:Cystem.ArwuMentException">
        8parairef ~ame="metxod" /> n7est pas null et la$métiode représentém retourne void, n'est pas statI{ (Shcred en Visu`| Basaci ou ne prend pas deux arguments exactemmnt.</excepvion>
      <exceptin cref="T:Systei.InvalidOperationException">
        <paamRef!nam="method" /> dst null ut l'opézateur de multiplication n'est pas défini pouv <paramref jame="left" />.Type et <paramref naie="right" />.TYpe.</exceptyon>
    </member>
    <memBer$name="M:Syte}.Linq.Expzessions.Expressiol.Negate(Syste}.Lknq.Expressions.Expression)">
  0   <sumazy>Crée un <see cref=2T:System.Linq.Expressions.UnaryExp6ession" /> qui représejte Ung opératyon de néwctyon arithm4iquen<osummary.
 `!   <returns>
        <see crgf="T:System.Lins.ExpresciOnS.UnaryExpre3sion" o> donT la propriété <{ee cref="P:System.Linq.Exprersions.Expressin.NodeType" /> est égale à <see cref="F:System.Hinq.Exprmsskons.ExpressionTypenNegate" /> ut dont la propriété <see kref="P:Bystem.Linq.Dxres{iofs.UnaryExppgssion.Operand" /> a la vaeur spécifiée.</returns>
      <param name="expression">
        <see cref= T:System.Linq.Expressions.Expressio" /> mqquel ha(propriété <see ref="P:System.Linq.Expressikns.UnazyExpre3sion/Oerand" /> doit être éga|e.</param>
      <eyception cref="T:[ystem.ArgmentNullException">    (   <taramreF name="expresion" /> a la valeur null.<except)on>
   `  <exception cref="T:System.InvalidOperationExceptmon">L'opésateur moins u.aire n'est pas défini pour <paramref name-b%xpression" o>.TYpe.</excep4ion>
    <'member>
    <membr name="M:SystemLinq.ExpressinF{.Expressioo.NegateSystam.Linq.Expressionr.Expression,System>R%fle#tion.LethoeInfo!">
      <summary>Crée un <cee cruf=#T:System.Lin.Express)ons.UnaryExtression" /> qui représente une opération dE négation arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.ou<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique qui dispose d'une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.ou<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié qui ne prend pas d'arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> a la valeur spécifiée.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le constructeur représenté par <paramref name="constructor" /> a au moins un paramètre.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.ouUn élément de <paramref name="arguments" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.ouUn élément de <paramref name="arguments" /> est null.ouUn élément de <paramref name="members" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.ouLe paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.ouUn élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés sous forme de tableau.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.ouUn élément de <paramref name="arguments" /> est null.ouUn élément de <paramref name="members" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.ouLe paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.ouUn élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.ouUn élément de <paramref name="arguments" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La longueur du paramètre <paramref name="arguments" /> correspond au nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur sans paramètre du type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> égale à <see cref="T:System.Reflection.ConstructorInfo" />, laquelle représente le constructeur sans paramètre pour le type spécifié.</returns>
      <param name="type">
        <see cref="T:System.Type" /> ayant un constructeur qui ne prend pas d'arguments.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le type représenté par <paramref name="type" /> n'a pas de constructeur sans paramètres.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="bounds">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> a la valeur null.ouUn élément de <paramref name="bounds" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau ayant un rang spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="bounds">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> a la valeur null.ouUn élément de <paramref name="bounds" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> a la valeur null.ouUn élément de <paramref name="initializers" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément du paramètre <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type représenté par <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewArrayExpression" /> qui représente la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui représente le type d'élément du tableau.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> a la valeur null.ouUn élément de <paramref name="initializers" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtient le type de nœud de ce <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Une des valeurs de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de bits de complément.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur NOT unaire n'est pas défini pour <paramref name="expression" />.Type.ou<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'inégalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Retourne l'expression qui représente le complément à 1.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Retourne l'expression qui représente le complément à 1.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="method" /> est null et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> ont les valeurs spécifiées.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable, utilisé à des fins de débogage ou d'impression uniquement.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="method" /> est null et <paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété à l'aide d'une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null.ouLa méthode représentée par <paramref name="propertyAccessor" /> n'est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="propertyAccessor" />.ouLa méthode représentée par <paramref name="propertyAccessor" /> n'est pas une méthode d'accesseur de propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="property">
        <see cref="T:System.Reflection.PropertyInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> a la valeur null.ouLa propriété représentée par <paramref name="property" /> n'est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la propriété que <paramref name="property" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente le champ désigné par <paramref name="propertyName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété nommée <paramref name="propertyName" />.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyName">Nom d'une propriété à laquelle accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyName" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Aucune propriété nommée <paramref name="propertyName" /> n'est définie dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="propertyName">Nom de l'indexeur.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui accède à une propriété.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
      <param name="expression">Objet contenant la propriété.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="type">Objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient la propriété.</param>
      <param name="propertyName">Propriété à laquelle accéder.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété ou un champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> est égale à <paramref name="expression" />, et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> ou à <see cref="T:System.Reflection.FieldInfo" /> qui représente la propriété ou le champ désigné par <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété ou un champ nommé <paramref name="propertyOrFieldName" />.Cette valeur peut être null pour les membres statiques.</param>
      <param name="propertyOrFieldName">Nom d'une propriété ou d'un champ auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Aucune propriété ou aucun champ nommé <paramref name="propertyOrFieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression ayant une valeur de constante de type <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Réduit le nœud en une expression plus simple.Si CanReduce retourne la valeur true, cela doit retourner une expression valide.Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Réduit le nœud en une expression plus simple.Si CanReduce retourne la valeur true, cela doit retourner une expression valide.Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Réduit l'expression à un type de nœud connu (qui n'est pas un nœud Extension) ou retourne simplement l'expression s'il s'agit d'un type déjà connu.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité des références.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité des références.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'une exception avec un type donné.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
      <param name="variables">Collection d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
      <param name="variables">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch sans casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchCase" /> pour une utilisation dans un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> a la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
      <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la levée d'une exception avec un type donné.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
      <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Retourne une représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch mais ni une erreur, ni un bloc Finally.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch et un bloc Finally.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Fault et aucune instruction Catch.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="fault">Corps du bloc Fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Finally et aucune instruction Catch.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
      <returns>True si le type délégué System.Action générique a été créé pour un <paramref name="typeArgs" /> spécifique, false dans le cas contraire.</returns>
      <param name="typeArgs">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Action.</param>
      <param name="actionType">Cette méthode retourne le type délégué System.Action générique qui comporte des arguments de type spécifiques.Contient la valeur Null s'il n'y a aucun délégué System.Action générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Func générique comportant des arguments de type spécifiques.Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <returns>true si le type délégué System.Func générique a été créé pour un <paramref name="typeArgs" /> spécifique ; sinon, false.</returns>
      <param name="typeArgs">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Func.</param>
      <param name="funcType">Cette méthode retourne le type délégué System.Func générique qui comporte des arguments de type spécifiques.Contient la valeur null s'il n'existe aucun délégué System.Func générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une référence explicite ou une conversion boxing où la valeur null est fournie en cas d'échec de la conversion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> qui compare l'identité de type à l'exécution.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> et dont les propriétés <see cref="T:System.Linq.Expressions.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="T:System.Linq.Expressions.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.ou<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente un unboxing explicite.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objet <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer un unboxing.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable.Ce nom est utilisé à des fins de débogage ou d'impression uniquement.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Réduit le nœud puis appelle le délégué visiteur sur l'expression réduite.La méthode lève une exception si le nœud n'est pas réductible.</summary>
      <returns>Expression qui est visitée ou expression qui doit la remplacer dans l'arborescence.</returns>
      <param name="visitor">Instance de <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Représente une expression lambda fortement typée comme une structure de données sous forme d'arborescence de l'expression.Cette classe ne peut pas être héritée.</summary>
      <typeparam name="TDelegate">Type du délégué représenté par le <see cref="T:System.Linq.Expressions.Expression`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compile l'expression lambda décrite par l'arborescence de l'expression dans le code exécutable et produit un délégué qui représente l'expression lambda.</summary>
      <returns>Délégué de type <paramref name="TDelegate" /> qui représente l'expression lambda compilée décrite par <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> du résultat.</param>
      <param name="parameters">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> du résultat. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Décrit les types de nœuds d'une arborescence d'expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Opération d'addition, telle que a + b, sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Opération d'assignation composée d'addition, telle que (a += b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Opération d'assignation composée d'addition, telle que (a += b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Opération d'addition telle que (a + b) avec vérification de dépassement pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Opération AND logique ou au niveau du bit, telle que (a &amp; b) en C# et (a And b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Opération AND conditionnelle qui évalue la deuxième opérande uniquement si la première opérande a la valeur true.Correspond à (a &amp;&amp; b) en C# et (a AndAlso b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Opération d'assignation composée AND au niveau du bit ou logique, telle que (a &amp;= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Opération d'indexation dans un tableau unidimensionnel, telle que array[index] en C# ou array(index) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Opération qui obtient la longueur d'un tableau unidimensionnel, telle que array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Opération d'assignation telle que (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Bloc d'expressions.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Appel de méthode, comme dans l'expression obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nœud qui représente une opération de fusion nulle, telle que (a ?? b) en C# ou If(a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Opération conditionnelle, telle que a &gt; b ? a : b en C# ou If(a &gt; b, a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Valeur de constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Opération de cast ou de conversion, telle que (SampleType)obj en C# ou CType(obj, SampleType) en Visual Basic.Pour une conversion numérique, si la valeur convertie est trop grande pour le type de destination, aucune exception n'est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Opération de cast ou de conversion, telle que (SampleType)obj en C# ou CType(obj, SampleType) en Visual Basic.Pour une conversion numérique, si la valeur convertie ne correspond pas au type cible, une exception est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Informations de débogage.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Opération de décrémentation unaire, telle que (a - 1) en C# et Visual Basic.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Valeur par défaut.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Opération de division, telle que (a / b), pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Opération d'assignation composée de division, telle que (a /= b), pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Opération dynamique.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nœud qui représente une comparaison d'égalité, telle que (a == b) en C# ou (a = b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Opération XOR au niveau du bit ou logique, telle que (a ^ b) en C# ou (a Xor b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Opération d'assignation composée XOR au niveau du bit ou logique, telle que (a ^= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Expression d'extension.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Expression GoTo, telle que goto Label en C# ou GoTo Label en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Comparaison numérique "supérieur à", telle que (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Comparaison « supérieur ou égal à », telle que (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Opération d'incrémentation unaire, telle que (a + 1) en C# et Visual Basic.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Opération d'index ou opération qui accède à une propriété qui prend des arguments. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Opération qui appelle un délégué ou une expression lambda, telle que sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valeur de condition false.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valeur de condition true.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Étiquette.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Expression lambda, telle que a =&gt; a + a en C# ou Function(a) a + a en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Opération de décalage vers la gauche au niveau du bit, telle que (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Assignation composée de décalage vers la gauche au niveau du bit, telle que (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Comparaison numérique "inférieur à", telle que (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Comparaison "inférieur ou égal à", telle que (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Opération qui crée un objet <see cref="T:System.Collections.IEnumerable" /> et l'initialise à partir d'une liste d'éléments, telle que new List&lt;SampleType&gt;(){ a, b, c } en C# ou Dim sampleList = { a, b, c } en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Boucle, telle que for ou while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Opération qui lit un champ ou une propriété, telle que obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Opération qui crée un objet et initialise un ou plusieurs de ses membres, telle que new Point { X = 1, Y = 2 } en C# ou New Point With {.X = 1, .Y = 2} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Opération arithmétique de reste, telle que (a % b) en C# ou (a Mod b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Opération arithmétique d'assignation composée du reste, telle que (a %= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Opération de multiplication, telle que (a * b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Opération d'assignation composée de multiplication, telle que (a *= b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Opération d'assignation composée de multiplication, telle que (a *= b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Opération de multiplication, telle que (a * b), avec contrôle de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Opération arithmétique de négation, telle que (-a).L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Opération arithmétique de négation, telle que (-a), avec contrôle de dépassement.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Opération qui appelle un constructeur pour créer un nouvel objet, telle que new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Opération qui crée un nouveau tableau dans lequel les limites de chaque dimension sont spécifiées, telle que new SampleType[dim1, dim2] en C# ou New SampleType(dim1, dim2) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Opération qui crée un nouveau tableau unidimensionnel et à l'initialise à partir d'une liste d'éléments, telle que new SampleType[]{a, b, c} en C# ou New SampleType(){a, b, c} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Complément de bits ou opération de négation logique.En C#, équivaut à (~a) pour les types intégraux et à (!a) pour les valeurs booléennes.En Visual Basic, équivaut à (Not a).L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Comparaison d'inégalité, telle que (a != b) en C# ou (a &lt;&gt; b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Opération de complément, telle que (~a) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Opération OR au niveau du bit ou logique, telle que (a | b) en C# ou (a Or b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Assignation composée OR au niveau du bit ou logique, telle que (a |= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Opération OR conditionnelle de court-circuit, telle que (a || b) en C# ou (a OrElse b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Référence à un paramètre ou une variable défini(e) dans le contexte de l'expression.Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Décrément suffixé unaire, tel que (a--).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Incrément suffixé unaire, tel que (a++).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Opération mathématique qui élève un nombre à une puissance, telle que (a ^ b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Opération d'assignation composée qui élève un nombre à une puissance, telle que (a ^= b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Décrément préfixé unaire, tel que (--a).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Incrément préfixé unaire, tel que (++a).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Expression comportant une valeur constante de type <see cref="T:System.Linq.Expressions.Expression" />.Un nœud <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> peut contenir les références aux paramètres définis dans le contexte de l'expression qu'il représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Opération de décalage vers la droite au niveau du bit, telle que (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Opération d'assignation composée de décalage vers la droite au niveau du bit, telle que (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Liste de variables d'exécution.Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Opération de soustraction, telle que (a - b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Opération d'assignation composée de soustraction, telle que (a -= b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Opération d'assignation composée de soustraction, telle que (a -= b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Opération de soustraction arithmétique, telle que (a - b), avec contrôle de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Opération de commutateur, telle que switch en C# ou Select Case en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Opération qui lève une exception, telle que throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Expression try-catch.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Référence explicite ou conversion boxing dans laquelle la valeur null est fournie si la conversion échoue, telle que (obj as SampleType) en C# ou TryCast(obj, SampleType) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Test de type exact.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Test de type, tel que obj is SampleType en C# ou TypeOf obj is SampleType en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Opération plus unaire, telle que (+a).Le résultat d'une opération plus unaire prédéfinie est la valeur de l'opérande, mais les implémentations définies par l'utilisateur peuvent avoir des résultats inhabituels.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Opération de type valeur unbox, telle que les instructions unbox et unbox.any en MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Représente un visiteur ou un module de réécriture pour les arborescences d'expression.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Initialise une nouvelle instance d'<see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Distribue la liste des expressions à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <returns>Liste d'expressions modifiées, si l'un des éléments a été modifié ; sinon, retourne la liste d'expressions d'origine.</returns>
      <param name="nodes">Expressions à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visite tous les nœuds dans la collection à l'aide d'un visiteur d'élément spécifié.</summary>
      <returns>Liste de nœuds modifiés, si des éléments ont été modifiés ; sinon, retourne la liste de nœuds d'origine.</returns>
      <param name="nodes">Nœuds à visiter.</param>
      <param name="elementVisitor">Délégué qui visite un élément unique, éventuellement le remplaçant par un nouvel élément.</param>
      <typeparam name="T">Type des nœuds.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Distribue l'expression à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="nodes">Expression à visiter.</param>
      <param name="callerName">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T">Type de l'expression.</typeparam>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
      <param name="callerName">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T">Type de l'expression.</typeparam>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visite les enfants de l'expression d'extension.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visite <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
      <typeparam name="T">Type du délégué.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Représente un saut inconditionnel.Cela inclut des instructions return, des instructions break et continue et d'autres sauts.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Type d'expression « go to ».Sert uniquement à des fins d'information.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> qui représente le type d'expression « go to ».</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Étiquette cible à laquelle ce nœud accède.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente l'étiquette cible pour ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> du résultat. </param>
      <param name="value">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> du résultat. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valeur passée à la cible, ou null si la cible est de type System.Void.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur passée à la cible ou null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Spécifie le type de saut que <see cref="T:System.Linq.Expressions.GotoExpression" /> représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut vers un emplacement.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Représente l'indexation d'une propriété ou d'un tableau.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtient les arguments qui seront utilisés pour indexer la propriété ou le tableau.</summary>
      <returns>Collection en lecture seule qui contient les arguments qui seront utilisés pour indexer la propriété ou le tableau.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtient le <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon retourne null.</summary>
      <returns>
        <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objet à indexer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'objet à indexer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Représente une expression qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtient les arguments auxquels l'expression lambda ou le délégué est appliqué.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué est appliqué.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtient le délégué ou l'expression lambda à appliquer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué à appliquer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Représente une étiquette, qui peut être placée dans tout contexte <see cref="T:System.Linq.Expressions.Expression" />.En cas de saut à cette étiquette, elle a la valeur fournie par le <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondant.Sinon, elle reçoit la valeur indiquée dans <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Si <see cref="T:System.Type" /> est System.Void, aucune valeur ne doit être fournie.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>La valeur de <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via le flux de contrôle normal (par exemple, sans saut).</summary>
      <returns>Objet Expression représentant la valeur de <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> du résultat.</param>
      <param name="defaultValue">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Utilisé pour représenter la cible d'un <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtient le nom de l'étiquette.</summary>
      <returns>Nom de l'étiquette.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Retourne un <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Type de valeur passée lors de l'accès à l'étiquette (ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée).</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type de la valeur passée lors de l'accès à l'étiquette ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Décrit une expression lambda.Capture un bloc de code semblable au corps d'une méthode .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtient le corps de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps de l'expression lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produit un délégué qui représente l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> qui contient la version compilée de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtient le nom de l'expression lambda.</summary>
      <returns>Nom de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtient les paramètres de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtient le type de retour de l'expression lambda.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtient la valeur qui indique si l'expression lambda doit être compilée avec l'optimisation d'appel tail.</summary>
      <returns>True si l'expression lambda doit être compilée avec l'optimisation d'appel tail, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Représente un appel de constructeur ayant un initialiseur de collection.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si le nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtient les initialiseurs de l'élément utilisés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> qui représentent les éléments utilisés pour initialiser la collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtient l'expression qui contient un appel au constructeur d'un type de collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel au constructeur d'un type de collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Réduit le nœud d'expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> du résultat.</param>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Représente une boucle infinie.Elle peut être quittée avec « break ».</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="breakLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> du résultat.</param>
      <param name="continueLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Représente l'opération d'assignation d'un champ ou d'une propriété à un objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtient l'expression à assigner au champ ou à la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur à assigner au champ ou à la propriété.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fournit la classe de base à partir de laquelle sont dérivées les classes qui représentent les liaisons utilisées pour initialiser les membres d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtient le type de liaison représenté.</summary>
      <returns>Une des valeurs de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtient le champ ou la propriété à initialiser.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété à initialiser.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Retourne une représentation textuelle du <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Représentation textuelle du <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Décrit les types de liaison utilisés dans les objets <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Liaison qui représente l'initialisation d'un membre avec la valeur d'une expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Liaison qui représente l'initialisation d'un membre de type <see cref="T:System.Collections.IList" /> ou <see cref="T:System.Collections.Generic.ICollection`1" /> dans une liste d'éléments.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Liaison qui représente l'initialisation récurrente des membres d'un membre.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Représente l'accès à un champ ou à une propriété.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtient l'objet contenant du champ ou de la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet contenant du champ ou de la propriété.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtient le champ ou la propriété auquel accéder.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété auquel accéder.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Retourne le type de nœud de ce <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Représente l'appel d'un constructeur et l'initialisation d'un ou de plusieurs membres du nouvel objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtient les liaisons qui décrivent comment initialiser les membres de l'objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si le nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtient l'expression qui représente l'appel de constructeur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Réduit <see cref="T:System.Linq.Expressions.MemberInitExpression" /> à une expression plus simple. </summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> du résultat.</param>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Représente l'initialisation des éléments d'un membre de collection d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtient les initialiseurs de l'élément pour initialiser un membre de collection d'un objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> avec lequel initialiser un membre de collection.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Représente l'initialisation des membres d'un membre d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtient les liaisons qui décrivent comment initialiser les membres d'un membre.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres du membre.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Représente un appel à une méthode statique ou une méthode d'instance.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtient une collection d'expressions qui représentent les arguments de la méthode appelée.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments de la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtient l'objet <see cref="T:System.Reflection.MethodInfo" /> pour la méthode à appeler.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtient l'objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'instance pour les appels de méthode d'instance ou null pour les appels de méthode statique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet de réception de la méthode.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Représente la création d'un tableau et l'éventuelle initialisation des éléments du nouveau tableau.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtient les limites du tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, ou les valeurs pour initialiser les éléments du nouveau tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les limites du tableau ou les valeurs d'initialisation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Représente un appel de constructeur.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtient les arguments du constructeur.</summary>
      <returns>Collection d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments du constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtient le constructeur appelé.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur appelé.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtient les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</summary>
      <returns>Collection d'objets <see cref="T:System.Reflection.MemberInfo" /> qui représentent les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Représente une expression de paramètre nommée.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indique que ParameterExpression doit être traité comme un paramètre ByRef.</summary>
      <returns>True si ParameterExpression est un paramètre ByRef, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtient le nom du paramètre ou de la variable.</summary>
      <returns>
        <see cref="T:System.String" /> qui contient le nom du paramètre.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expression qui fournit l'autorisation de lecture/écriture d'exécution pour les variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> du résultat.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables ou paramètres auxquels fournir l'accès d'exécution.</summary>
      <returns>Collection en lecture seule qui contient des paramètres qui se verront octroyer l'accès d'exécution.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Représente le cas d'un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtient le corps de ce cas.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps du bloc case.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtient les valeurs de ce cas.Ce cas est sélectionné pour être exécuté lorsque le <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> correspond à chacune de ces valeurs.</summary>
      <returns>Collection en lecture seule des valeurs de ce bloc case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Retourne un <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="testValues">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Représente une expression de contrôle qui gère des sélections multiples en transmettant le contrôle à <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtient la collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" /> pour le commutateur.</summary>
      <returns>Collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtient la méthode de comparaison d'égalité, le cas échéant.</summary>
      <returns>Objet <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode de comparaison d'égalité.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="switchValue">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> du résultat.</param>
      <param name="cases">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> du résultat.</param>
      <param name="defaultBody">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Stocke les informations nécessaires pour émettre les informations de symboles de débogage pour un fichier source, en particulier le nom de fichier et l'identificateur de langue unique.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Retourne l'identificateur unique du type de document, le cas échéant.La valeur par défaut est le GUID pour un fichier texte.</summary>
      <returns>Identificateur unique du type de document.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nom du fichier source.</summary>
      <returns>Chaîne représentant le nom du fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Retourne l'identificateur unique de langue, le cas échéant.</summary>
      <returns>Identificateur unique de langue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Retourne l'identificateur unique du fournisseur de langue, le cas échéant.</summary>
      <returns>Identificateur unique du fournisseur de langue.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Représente un bloc try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtient la collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</summary>
      <returns>Collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Body" /> du résultat.</param>
      <param name="handlers">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> du résultat.</param>
      <param name="finally">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> du résultat.</param>
      <param name="fault">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Représente une opération entre une expression et un type.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtient l'opérande d'expression d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande d'expression d'une opération de test de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtient l'opérande de type d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente l'opérande de type d'une opération de test de type.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Représente une expression qui comporte un opérateur unaire.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si un nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur.</summary>
      <returns>true si le nœud représente un appel levé ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns>true si le type de retour de l'opérateur est levé vers un type nullable ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtient la méthode d'imléme~ta4io pour l'opération unaire.<-{tmmary>
 $    <retupns>
       <see aref= T:ystem.Reflection.MethodInfo# /> quh représente lA mǩthode d'implèmentation.</returns>
    </emberM
    <membername="P;ystem.Lilq.E<precsions.UnaryExpression.NodeT{pe&?
    <qummary>Retourne le type de nœud de cev objet <see cref="T:System>Linq.Expressions.Gxpression" />.</cummary>
      <returns>
        <ree cref="TSystem.Linq.Ex`2essions.exprewsionType" /6 qui re`résente c%tte expression.</returns>
0"  </member>
    <member name="T:System.Minq.ExprmsSions.UnaryAxpression,Operand">
`     <suimqry>Obtient l'op˨rande dd l'opération unaipe></summary>
      <returoS>
  !     <see cref="T:S{stem.Linq.Expressions.Axpression" -> pui représente l'opérande de l'opéretion0unaire.</returns<
    </membar>
   0<member name="M:System.Lifq.expressions.Unary%xpression.Rgduce">
      <sumeary>éduit le nœud d'expression en qlE epression plus sim0lu. </sum}ary>
  0   <%purnc>Expressio. réduiten</return3>
    </memBer>    <member name="P:Sysdem.Linq.EypressionsUnaryExpressignTyte">
  (   <summary>Obtient ne type statiqte de l'expresskn que cE <see cref="T:System.Linq.Dxpressions.Expr%ssion"`/> représante.</summary>
      <returjs>
        <see cref="P:System,Linq.Expressi=ns.UnAryExpressmon.Type" / qui repréwente le tye statique de ,'expression.</returns>
   </member>M
  0 <member name="L:System.Linq.Expressions.UnaryExpression.Update(System.Linq.U8pressions.Expression)">
      <sumoari~Crǩe uneexpression semblable à celle-ci, mais utilisant les enf`ntw furniw.Si toqs les enfants soOt identIqueq c%tte expression est retournÉm.</summary<
      <returns>ette expreqion si aucun enfant n'est modifié ou qne e8pression avec les enfants mir`ˠ joup.</returns>
      <param oame="opernd">Xzopriété <see aref="PS9stem.Linq.Uxpressions.UnaryExpression.Operand" /: du résultat.8/param>
  $ </member>  </members>
</doc>