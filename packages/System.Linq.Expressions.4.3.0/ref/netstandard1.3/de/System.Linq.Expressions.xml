<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Stellt das Ergebnis eines Sortiervorgangs dar.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Stellt das Ergebnis eines Sortiervorgangs dar.</summary>
      <typeparam name="T">Der Typ des Inhalts der Datenquelle.Dieser Typparameter ist Covariant. Das heißt, Sie können entweder den angegebenen Typ oder einen weiter abgeleiteten Typ verwenden. Weitere Informationen zu Ko- und Kontravarianz finden Sie unter Kovarianz und Kontravarianz in Generika.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Stellt Funktionen zur Auswertung von Abfragen für eine spezifische Datenquelle bereit, bei der der Datentyp nicht angegeben wurde.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Ruft den Typ der Elemente ab, die zurückgegeben werden, wenn die Ausdrucksbaumstruktur ausgeführt wird, die mit dieser Instanz von <see cref="T:System.Linq.IQueryable" /> verknüpft ist.</summary>
      <returns>Ein <see cref="T:System.Type" />, der den Typ der Elemente darstellt, die zurückgegeben werden, wenn die Ausdrucksbaumstruktur ausgeführt wird, die mit diesem Objekt verknüpft ist.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Ruft die Ausdrucksbaumstruktur ab, die mit der Instanz von <see cref="T:System.Linq.IQueryable" /> verknüpft ist.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die mit dieser Instanz von <see cref="T:System.Linq.IQueryable" /> verknüpft ist.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Ruft den Abfrageanbieter ab, der dieser Datenquelle zugeordnet ist.</summary>
      <returns>Der <see cref="T:System.Linq.IQueryProvider" />, der dieser Datenquelle zugeordnet ist.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Stellt Funktionen zur Auswertung von Abfragen für eine spezifische Datenquelle mit unbekanntem Datentyp bereit.</summary>
      <typeparam name="T">Der Datentyp in der Datenquelle.Dieser Typparameter ist Covariant. Das heißt, Sie können entweder den angegebenen Typ oder einen weiter abgeleiteten Typ verwenden. Weitere Informationen zu Ko- und Kontravarianz finden Sie unter Kovarianz und Kontravarianz in Generika.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Definiert Methoden zum Erstellen und Ausführen von Abfragen, die von einem <see cref="T:System.Linq.IQueryable" />-Objekt beschrieben werden.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Konstruiert ein <see cref="T:System.Linq.IQueryable`1" />-Objekt, das die Abfrage auswerten kann, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.IQueryable`1" />-Objekt, das die Abfrage auswerten kann, die von der angegebenen Ausdrucksbaumstruktur dargestellt wird.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
      <typeparam name="TElement">Der Typ der Elemente des <see cref="T:System.Linq.IQueryable`1" />-Objekts, das zurückgegeben wird.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Konstruiert ein <see cref="T:System.Linq.IQueryable" />-Objekt, das die Abfrage auswerten kann, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.IQueryable" />-Objekt, das die Abfrage auswerten kann, die von der angegebenen Ausdrucksbaumstruktur dargestellt wird.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Führt die stark typisierte Abfrage aus, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Der Wert, der aus der Ausführung der angegebenen Abfrage resultiert.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
      <typeparam name="TResult">Der Typ des Werts, der aus der Ausführung der Abfrage resultiert.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Führt die Abfrage aus, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Der Wert, der aus der Ausführung der angegebenen Abfrage resultiert.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Stellt einen Ausdruck dar, der einen binären Operator aufweist.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Ruft einen Wert ab, der angibt, ob der Knoten der Ausdrucksbaumstruktur reduziert werden kann.</summary>
      <returns>True, wenn der Knoten der Ausdrucksbaumstruktur reduziert werden kann, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Ruft die Typkonvertierungsfunktion ab, die von einer zusammenfügenden oder zusammengesetzten Zuweisungsoperation verwendet wird.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, die eine Typkonvertierungsfunktion darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt.</summary>
      <returns>true, wenn der Knoten einen transformierten Aufruf darstellt, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt, dessen Rückgabetyp zu einem Typ transformiert wird, der NULL-Werte zulässt.</summary>
      <returns>true, wenn der Rückgabetyp des Operators zu einem Typ, der NULL-Werte zulässt, transformiert wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Ruft den linken Operanden der binären Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden der binären Operation darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Ruft die implementierende Methode für die binäre Operation ab.</summary>
      <returns>Ein <see cref="T:System.Reflection.MethodInfo" />, der die auszuführende Methode darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduziert auf den binären Ausdrucksknoten auf einen einfacheren Ausdruck.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Ruft den rechten Operanden der binären Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden der binären Operation darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="left">Die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft des Ergebnisses. </param>
      <param name="conversion">Die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft des Ergebnisses.</param>
      <param name="right">Die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Stellt einen Block mit einer Sequenz von Ausdrücken dar, in dem Variablen definiert werden können.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Ruft die Ausdrücke in diesem Block ab.</summary>
      <returns>Die schreibgeschützte Auflistung, die alle Ausdrücke in diesem Block enthält.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Ruft den letzten Ausdruck in diesem Block ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den letzten Ausdruck in diesem Block darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.BlockExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="variables">Die <see cref="P:System.Linq.Expressions.BlockExpression.Variables" />-Eigenschaft des Ergebnisses. </param>
      <param name="expressions">Die <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Ruft die in diesem Block definierten Variablen ab.</summary>
      <returns>Die schreibgeschützte Auflistung, die alle in diesem Block definierten Variablen enthält.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Stellt eine catch-Anweisung in einem try-Block dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Ruft den Text des catch-Blocks ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Text des catch-Blocks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Ruft den Text des <see cref="T:System.Linq.Expressions.CatchBlock" />-Filters ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Text des <see cref="T:System.Linq.Expressions.CatchBlock" />-Filters darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Ruft den Typ der <see cref="T:System.Exception" /> ab, die von diesem Handler abgefangen wird.</summary>
      <returns>Das <see cref="T:System.Type" />-Objekt, das den Typ der <see cref="T:System.Exception" /> darstellt, die von diesem Handler abgefangen wird.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Gibt einen <see cref="T:System.String" /> zurück, der den aktuellen <see cref="T:System.Object" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.String" />, der den aktuellen <see cref="T:System.Object" /> darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="variable">Die <see cref="P:System.Linq.Expressions.CatchBlock.Variable" />-Eigenschaft des Ergebnisses.</param>
      <param name="filter">Die <see cref="P:System.Linq.Expressions.CatchBlock.Filter" />-Eigenschaft des Ergebnisses.</param>
      <param name="body">Die <see cref="P:System.Linq.Expressions.CatchBlock.Body" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Ruft einen Verweis auf das von diesem Handler abgefangene <see cref="T:System.Exception" />-Objekt ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekt, das einen Verweis auf das von diesem Handler abgefangene <see cref="T:System.Exception" />-Objekt darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Stellt einen Ausdruck dar, der über einen bedingten Operator verfügt.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Ruft den Ausdruck ab, der ausgeführt werden soll, wenn der Test false ergibt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Ausdruck darstellt, der ausgeführt werden soll, wenn der Test false ergibt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Ruft den Ausdruck ab, der ausgeführt werden soll, wenn der Test true ergibt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Ausdruck darstellt, der ausgeführt werden soll, wenn der Test true ergibt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Ruft den Test der bedingten Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Text der bedingten Operation darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="test">Die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft des Ergebnisses.</param>
      <param name="ifTrue">Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft des Ergebnisses.</param>
      <param name="ifFalse">Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Stellt einen Ausdruck dar, der über einen konstanten Wert verfügt.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ConstantExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Ruft den Wert des konstanten Ausdrucks ab.</summary>
      <returns>Ein <see cref="T:System.Object" /> gleich dem Wert des dargestellten Ausdrucks.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Gibt einen Sequenzpunkt für Debuginformationen aus oder löscht ihn.Dadurch kann der Debugger beim Debuggen den richtigen Quellcode hervorheben.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> ab, die die Quelldatei darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, die die Quelldatei darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Ruft die Endspalte dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Endspalte des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Ruft die Endzeile dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Endzeile des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Ruft den Wert ab, mit dem angegeben wird, ob <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts verwendet wird.</summary>
      <returns>True, wenn die <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts verwendet wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Ruft die Startspalte dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Anfangsspalte des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Ruft die Startzeile dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Anfangszeile des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Stellt den Standardwert eines Typs oder eines leeren Ausdrucks dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.DefaultExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Stellt einen Initialisierer für ein einzelnes Element einer <see cref="T:System.Collections.IEnumerable" />-Auflistung dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Ruft die Instanzmethode ab, die zum Hinzufügen eines Elements zu einer <see cref="T:System.Collections.IEnumerable" />-Auflistung verwendet wird.</summary>
      <returns>Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Instanzmethode darstellt, die einer Auflistung ein Element hinzufügt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Ruft die Auflistung von Argumenten ab, die an eine Methode übergeben werden, die einer <see cref="T:System.Collections.IEnumerable" />-Auflistung ein Element hinzufügt.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente für eine Methode darstellen, die einer Auflistung ein Element hinzufügt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Gibt eine Textdarstellung eines <see cref="T:System.Linq.Expressions.ElementInit" />-Objekts zurück.</summary>
      <returns>Eine Textdarstellung des <see cref="T:System.Linq.Expressions.ElementInit" />-Objekts.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Stellt die Basisklasse bereit, aus der die Klassen abgeleitet werden, die die Knoten in der Ausdrucksbaumstruktur darstellen.Sie enthält auch static-Factorymethoden (Shared in Visual Basic), um die verschiedenen Knotentypen zu erstellen.Dies ist eine abstract Klasse.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Erstellt eine neue Instanz von <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise ruft <see cref="T:System.Linq.Expressions.MethodCallExpression" /> die Methode <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> auf.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition ohne Überlaufprüfung darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition mit Überlaufprüfung darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen AND-Vorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.And" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen AND-Vorgang darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.And" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten AND-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als true ausgewertet wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="left" />.Type und <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bedingte AND-Operation darstellt, bei der der zweite Operand nur ausgewertet wird, wenn der erste Operand zu true aufgelöst wird.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="method" /> ist null, und <paramref name="left" />.Type sowie <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, um auf ein mehrdimensionales Array zuzugreifen.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="array">Ein Ausdruck, der das mehrdimensionale Array darstellt.</param>
      <param name="indexes">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit Ausdrücken, die zum Indizieren des Arrays verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, um auf ein Array zuzugreifen.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="array">Ein Ausdruck, der das zu indizierende Array darstellt.</param>
      <param name="indexes">Ein Array mit Ausdrücken, die zum Indizieren des Arrays verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die das Anwenden eines Arrayindexoperators auf ein Array mit einem Rang größer als eins darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft festgelegt werden soll.</param>
      <param name="indexes">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> oder <paramref name="indexes" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type stellt keinen Arraytyp dar.- oder - Der Rang von <paramref name="array" />.Type entspricht nicht der Anzahl der Elemente in <paramref name="indexes" />.- oder - Die <see cref="P:System.Linq.Exbessions.Exqression.Type" />-Eigenschaft eines oder mehrezer lemefte von <paraIr%f name="idexus" /~ stellt$ficht den<see!cref-"T:System.Int32" />-Tp dar.</exceptiol>
    </member<*    <mem"er name="M:SIstemLinq.Expressions.Expru{sion.Arra9Index(System.Linq.Exprescion.Expressyon,System.Linq.Expressions.Expression)">
      <summapy>Ertellt eing <see cref="T:System.Liq&ExpreSraonq&BifaryExprEsioo* />, dia dar AnendeN eines$Arrayiodmxopezators auf Ein Arzay mit Ra~g0eans darstellu.</s5mmary>
      <returns>Ein |see!cruf"T8Sistem.Linq.Expressins>B)naryExrression" />,"`ei dem $ie <see cref="P:System.Linq.Expresrions.Expression.NodeType& />-Egenschaft gleici <see gref=":System.Linq.Expressions.Ex`reSsionType.ArrayIn`ex* /> ist und die <{ee cref="P:System.inq.Exressions.BinaryExpression,Neft" />-Eigenschaft smwie dIep<see cref="P:System.Linq.Expressions.BinaryGxprewion.right" />-Eigejsclavt auf `ie angegebeeNW%rte festgeleg sind.</returns>
      <qarem name="ara">Ein =see cpef="T:System.inq.Expressions.Exprussioj" />, auf das fie <se cref="P:Sy3tem.inq>ExpresShons.BinaryUxpressio..Left" />-Eigdnschaft festeelEgt wEbde. soll.</paraM>
      =param name= index">Ein <see cref="T:Systee.Linq.Expressions.Expbession" />,auf da"lme <see cref"P:System.Lint,Expresshons.BilaryEhpression.Right" />-Eigenschavt festgelegt werden(woll.</param>
      <exception cref="T:Syst%m.ArgumgntNllException">
        <parambef name5"array" /> oder <paramref name="index2 /> ist null.</eycepton:
      <exception cpef=T:Systam.ArwumentException">
        <param2ef name="array" />/Type stulld keinen Arraytyp dar.-¤oder - <p!rimref name="array"(/>.Type suallt!einen Avrayvyp dar, dessen Rang nicht 1 ist.- oder- <par!mreb name="index"`/>TypE0stellt nicht Den <see cvef="T:Sqstem.Int32" o>.Type dar.</exception>
    <%me-ber>
    <member jame="M:System.Linq.Expressions.Expression.ArrayInlex(Rystm.Linq.Expressions.Expression,System.Linu.ExpzeqsiOns.Eypresqion[])&>
  0  0<summari>Erstellt eine<sge cref="T8System.LInq.Expressions.MethodadlExpression" />, die!dAs Anwenden eines Arrayinde|operetobs auf ein -ehrdimesionales Array dars4ellt.>/summary>
     <rdturns>Ein <see cref="T:System.Linq.Expressions.MetkdCalExpression" />, bei dem di {ee cvef="PzS}stem.Lnq.Expression3.Expreqsion.NodeVYpe" />-Eig%nqchaft gleich <ree cref="F:System.Lmnq.Exprssionc*ExpressionType.Call" /< ist und die <see creF="P:System.H)nq.Exprssions.MetodCallExpressimn.ObjecT" />-Eigensbhaft!sowie diu <sem cref=#P:SystEm.Linq.Expressior.LethodCamlUxpreSsiof.Arguienvs" />-Egmnschagt auf di% angegebenen Wepte festgelegt sind.>-returns~
 `    <paem na-e="array">Ein Array von <ue bref="T:[ystem.Li.q.Expre3simnr.Exprcsionb />-Instanzen - Indizgs$für `en ArrayindiziarungsVorgang</param>
!     |param nama="indexes">Eio Array von<sue cref="T:System.Li.q.E8pressions.Expression"!/>-Ocjektej, mit lenej die <see cpuf=R:System.Linq.Expressionr.MethodSallExpression.Arguee~ts  />-Auflist}ng!auf'efüdlp wkrd.</param>
      =exception cren="T:System.AouletNullException">
 0      <paramrefaname="array" /~ oder <paramraf name"induxes" /> is| nwll.</ezcetion>
      <exception crgf="T:System.Arg5mentExbePtion">
        <paramref namu="`rray" />.Ty`d stellt kEynen Array4yp!dar.-¡oder - Der Ra.g von <paRaMref fame=barray" />.Type entspri`ht nibht der lzahl der Elemente in <taramref name="indexes"!/>.- der- Die <see c2gf="P:System.Lknq.ExPressions.Exrression.Type" />-Eigenschaft ekjes oder mghrerer Elemeote voo lparamref name="indees" /~ stellt nicht den <see cref="T:System,Ift32" />-Typ d`r.|/exbeption>
    </member>
    <member name= M:Syst%m.Linq*Exp2essions.ExpressIn.ArrayLengdh(Rystem.Linq.ExQressions.Expression)"6
  ("  <summazy>ercTellt %ine <see cref="V:Cystei/inq.Exprdssions.UlaryE8pression" />, dke einen Ausdr5ck ztm Abrufen der Lnge eines eIodimensionalen Arrays darstelt.</summary>
   "  <beturns>Eine <see cref="TxSystemnLioq.ExpressionsUnaryExpvessiof" />, beh`der diu <see(cref="P:Qystem.Minq.ExPression3.Expression.NodeType" />-Eigenrcxaft eleich <see cref="FSystem.Linq.Exppessions.ExpRessionType.ArrayDength" /> und die <rge bref5"X:System.Linq.Expressions&UnaryExpression.Oterand" /:-Eigenscha`t gleich>paramref namm="array" />(ist.</returns>
      <param name="array".Ein <see cref=":Sqstem.Linq.Expressions.Epression2!/>, auf den die <see cref="P:Sytem.Linq.Expressions.UNaryExpressign.Operaj$" />-Eigensbhaft festgelegt wereen soll.</pabam>
      <exception #ref="T:System.ArgumntNullException">
        <p`ram2ef name="array" /> ist oulL.</excuption>*      <excepuion cref}"T>SystemArgumentEception">
        <parimref nage=barray" />.Type stellt keinaN Arraytyt Dar.</uxce2tion>
 !  </member>
 "" <membe naee?"M:Sysvem.Lifq.Uxpressmns.Exprezwion.Asskgn(Sys4em.Linq.Eypressions.Exprfssion,Sys|em.Linq.Expressions.Express)on)">      <sumlary>Erstellt eine <see cref9"T:Rystem.Lmnq.Ixpressions.BinaryEx0ession" />, die eiNe RuweiwungsopareTion darstell|.</summ!ry>
      <ret}rns>Ein <sme craf=":System.Linq.Expressions.BinaryExpression" />, bei dgm die <see cref=P:Syste}.Linq.Expreswions.Epression.odeTyqe" />-Eigenschaft geich <see cref="F:System.LinqExprecions.ExpressiofTy`e.Assign" /> ist nd $ia <see cref="P:SystumnLinq.expressi/ns.BinaryExpression.Lebt  />-Eigenskhaft sowie die see cref=2P;rystem.LinunMx`ressions.binayExpressio.,Right" ?>-Eigen{ciaft a5& lie$angagebenen Werte festgdlegt sind.8/rmt}rns?
     0<param name="left">Ein <see`cref=#T:System.Linq.Expressions.Expreqsion" +>, atf$den die>qee cruf="P:System.lhlq.Expre1sions.BinariExpressign.Left" ?>,Eigenschaft festgenegt wurden solln</`aram>      <param name="{ight">E)n <see cre&="T:System*Linq.E|pressaonq.Expression"(/>, auf den dia 8qee cr%f="P:System.LInq.E8qressions.BinaryExpressimn.RiGht />-EigenSchaft festgElegt werde sgll.</apam>
  " </mamber>
$   =lemfer nime="M:Syst%m.Linq.xpressions,Expresci/f.Bin$(Syste-.Reflection.MamberInfoSysvem.Linq*Expressions.Ex0resSion)2>*      <sumlary>Erstell4 ein ,see!csef="TzQystem.Linq.Expressions.MdmberAssignm~t" +>,ds diE In)tialisierung`i.es Feld oder einer Eigenschaf| dursteolt.</smmar9>
      <returns?Ek~ =see crev="T:System.\ijq.Expressions.MembevAssignment" /:, bei del <see cref="P:System.Linq.Exppessik~s.MEmberBinding.BindingTYpe" / glejch <see cref="F:System.Linq.Expressimns.emberBi.dingType.Asrignmant" /> ist und die`4see czef="P:System.Linq.Expressions.MembarBinding.Member" /<-Digenrchaft sowig die >sae czef="P:System.Linq.Expressions.MemberA3signment,Expression" />-EIolnsch%ft au& die aogmgebenen _erve fmctGelegt sin.</returns>
    ($<prAm name= member">Ein <see cref="TSystem.Reflection.memberInfo" />, auf das die >see cref="P:Sywtem.Linq.Expreions.LEmberBinding.Member  />=Eigenschaft!fesToehegt serden soll.</param>
      <pasam nyme="expresSion">Ein cem cref="T2Sywtem.Linq.Expressions.Expressyon" ':, auf den die <s%e cref="P8Sstem.Lijq.Exp2eswions.MembrAsignment.ExprEssion""/>-Eigenrfhaft festgelegt wdrden soll.</param>
0     <exception cref="T:Syst%m.ArgumenpNullException">     "  <paramrev name="memrer" .> ode <paramref name="expresSagn" /> ist numl.</excdption>
 "    <excEption cref="TSystem.ArgumentException">=*     $  <paramref name="memjer" /> stelt kEan Feld bzw. keine Eigenschaft dar.- oderB- Di! durch <pavamred name="memver" /> fargestellve Eigeorchaft verfügt über keknen cet-Accessor.- ~derʠ- <paremreF name="ExPvecsion" />.T{pe kann nicht dem Typ dgs Felds oder der Eioenschaft zugordnet werden, tas bzw. die dUrch$4paramreN name="mumbEr" /> darstelltwirD.</ex#eption>
 0  </member>
!"  <member fame=M:Sys|em.Lynq.ExpreCsionsGxpres3ion.@inD(System.SeflEktimn.MethodInfo,System&Linq.Expresshons.Ex`rewshoj)">
 `   <summary>ERctellt ein <see cref="T:System*Linq.Exprescions.MelberAssi'mgnt" o>, das die Initialisiezung"einds`Members d]rch VerWeneulg einer Eigenskhaftenaccessmrmethode drs|ell4,</summery>
      <returns>Ein<see crag="T:Sistem.Linq.Expressions*MelberAssigneent" .>, bek dem die <se% cref="P:Systdm.Linq.Expressions.MemberBinding.BindingTYpu" />-Eigenschaft gleiCh <see cref="F:Systee.Linq,Expression.Member@indingTyxe.Assignment" /> ist, die <see cref="P:System.Linq.Gxpression{.EemberBinding.Member" />,Eigensc(af| auf die`<see cref="T:System.Reflaction.PropertYInfo" > fdstgelegt ist, die `)e Migensclafp darstellt, auf die in <taramruf name="propertyPccessob" /? zugegriffenwirl, und die <see cvef="P:System.Lifq.Expressins.MemberAssygnment,Expression" />-Eigenschaft auf <paramref name="expressIon" /> fesgelegt ict.</zeturns>J      <param name="propertyAccessor"<Eine <see cref="T:System.Reflection.MethodInfo" />$ die eioe Eigenschaftenaccescormethode darstehlt.</param>
      <param name="xpression">in <see cvef="T:Sy{tem.Linq.Exprecsiols.Expression" />, auf den die <sEe c2ef="P:Systdm.Linq.Expressions.Memb%rAssignment.EXpression" />-Eige~schaft gestgelegt wrden soll.</param>
(  (  <exception cref=T:System.ArgumentNtllExcptikn">
`       <paramref name="propert9Acceusor" /> oder <paramrmf name="expressign" />!isd null.</excmption<
      <excuption cren=":System.ArgumentExextion">
(   $ ` <paramref name="propertyAccessor" .> stellt keine Eigensch!vteoa#cessormethode darn- odeR - Die Eigenschat, au& die von <paramsf name="propertyAccesso2" /> zugegrifbmn wird, verfü\ über keinen st-Accessor.- oder - <paramrdf name="expressIon" /..type k!nn nicht dem(Typ des Felds oder dez Eigenschcft zu'eordnet warden,`das bxw. die furch!<paramref name}"m%mbev" /> darstdllt`wird.</exCeption>
 0  </member>
 !  <oumber name="M:System.Linq.Expv%ssions.ExqrgssIon/Block(System.Collections.Generic.IEnumerable{System.Linq*Exqressionr.Expression})*>
      summary>Erstellt eine <see cref="T:Systeo.Linq.Expression3*BlockExpressimN" />, die dke a~gdeebenen Ausdrücke und keine Variablen enthält.</sulmary>
      <returns>Dr ersteldte <see cref="T:System.LInq.Expressinns.BlocoExpres{ion" />n</retuns>
      <param n`me="expreqsions">Die Ausdrücke im Bnock.</param>
    </member>
    <member name="M:System.LInq.xpressions.Expression.Bmoc(System.Coldections.Generic.IEnumeranle{Sistem.Minq.Gxpressions.PcrameterExpression},Sysem.Collections.Generic.IEnumerale{SyStem.inq.Dxprgssions.ExpRessIol})">
      ,summary>Ersvellp eiN 8see zef="T:Sy3tEm.Hynq&Expres3ions.BlockExpression" />, das die aogegebenen Tariablef und Ausdsücke eothäLt./summAry>
     "<returns>Der erstellte <see cref="T:Sys|em&Linq.Exprescions.BlockExqression" />.</returns>   `  <qaram name="variables*>Die Variablen im Block.<.parai>
      <paRae name="ehpressions"?Die Ausdrücke im Block.</param?J    </meiber>
   <memBer name="M:System.Linq.Exprmss)ons.Expression.Clock(System.CodLections.Generig.Ijumerable{SysteM.Lanq.ExprEssions.ParameterExpr%ssimn},SystemLinq.Exprgssions.Exprmssaon[])">
      <suMmary>Evstellt ein <see cref="T:System.Linq.Expressions.BlockMxpression" />, dis die angegebunen Variablen und Ausdrücke enthält.</summar9>
     $<r%turns>Der erstall|e <wee cref="T:System.Linq.Expressions.BlockExpression"!/>.</returns>
2     <`azai name="variables"Die Variablen )m Block.</param>
      <param .ame="expressions"<Die Iusdrücke"im Blosk.</param>
  " </me}ber>
    <member name="M:Systmm.Linq.xpressions.Expression.BloCk(Syste}.Linq.Axpressions.ExqreqcmOn,System.Dinp.Extressinr.ExpResson)">
 !    <summa2y>Erstellt eine see cref9":Sywtem*Hinq.Exprescions.bloakExp2ession" />, die zwai AesdRücke und keine Variablen05nthælt.</summary>
(     <returns>Der!ersvellte <see!cref="D:System.Linq.Expressions.BlockExpression" />.</returns>
      <para) name="arg0">Der ersta Ausdruck im Block></param>
      <papam n`me="apg1">Des zwei4e Ausdruck im Block.</param.    </member>
    4member ~amm="M:Syste-.Linq.Expressions.Exprgssion.Blo#k(SystemLinq.Dxpressions.ExpressioN,Sys|e}.Lioq.ExpressionsnExpression,Systeo.Linq.Expressio~s.Expression)">
 $    <summary>ErsTEllt ein ,see gref="T:Sysvem.Lhnq.Expressionw.BlOckExpression" />, das drei Ausdvücke tnd k%ine Variablen enphält/</summry>      <returnc>Der erstellte <see cref="T:Systel,Linq.Expres{ionc.BloskExpressinn"`/>.</returns>
     <param name="agp">Deb erste Ausdruck im BloCk.</param>M
(     <pa2am name="arg1">der zweite Ausdrucc im Block.</piram>
      <param name="arg2">Der dritte Ausdruck im BlOck./param>
    </member>    <member name="M:Sxstem.Linq.Expressions.Expressio.Block(System>LiNq.Expressions.Expression,System.Lina.Exppessions.Exprecsion,SystemLinq.Expresrions.Ehpzession,Sytem.Linq.Expressionq&Gxpression)">
      <stmmary>Ezstellt ein <see cref="T:System.Minq.Expressions.BlockExpre{sion" />, das vier Ausdr<c+e und keine Viriablen efthält.|/summary>
     !<retupns>D%r erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <0aram name="arg0"?De2 erste Au{drucj kM BloC+.</xaram>
      <param name="arg1">Der {weite Ausdrucj`im B,ock.</param>-
     `<ppram n`me="arg2">Der dritteAusdReck im Block.</param>
      ,parAm name="!rg3"~Der v}erte Atsdruck i Blck.</param>
    </mumbmr~
    <member name}"M:Sys|gm.Linq.Exprssiols.Expression.Blogk(System.Linq/Expressions.Exqression,Syste.Lijq.Expressio~s*Expressin,System.Lynq.Expressions.Expression,SystemLinq.Exp2essions.Expression,Systum.Linq.Expre{sions.Exprescion)">
 $    <summry>Erstellt ein <see cref="T:Sy3tem.LInq.xpressions.BlockexpressioN" />, `as fünd Aesdrücke und0keine Va2Iablen entlält&</summary>
     <returns>DeR erstellte <see cref="T:System.Linq.EppressionS.FlockExpression" />.</returns>
  $   <parem name=arg0">Der erste Ausdrubk im Block.</param:
     <param name="arg1">Der zwei|e AucdRuck im Block./para}>
      <parem name="arg2"<Der eritte Ausdruck im Bloak.</param>
     <param name="arg2">Der viErte Ausdruak im Block.</param>
      <param jame="arg4>Der füjfte Ausdruck ii Block.</param>
  `</meber>
    <member name="M:Syqtem.Linq.E0prdssions.Axpression.Block(System.Lnq.AxpressiosDxpression[]) >
      <summary>Erstelht gine(<s%e crdf="T:Sstem.Linq.Eypressions.BloskExpression" />, die dae angegebgnen Ausdrücke }nd keine Variablen enthlt.</summ)ry>
      <returns>Der ertellte <see cref="T:System.M)nq.Expressions.BlockExpression" />.</reTurns:
      <param name="expressions">Die(austrücke im lock.</parao>
    </member>
    member name="M:SysTdm.Linq.Expressions.expression.B,ock(System.Typd.System.Cllectyojs.Generic.iElumerable{Sqstem&Lins.Expressions*Expression])">
      <summary>Erstellt eij <see crmf=*T:System.Linq.Expressions.BlocjExpression" />, das dhe angegebenen Ausdrücke enthält, nicht übmr ^ariablen verf˼gt0und von einem bustimmdel Ergebnistyp isT.</summary>
      <returns>Dev erstelmte <see sref="T:System.Linq.Expressions*BlockE|pression" />.</repurns>      <param n`me="|ype">Der Ergebnistyp0des Blocos.</param>
    0 <param name="expressions">Die Aus$rck im(Block></param>
    </melber>
    <member name=bM:System.Linq.Expressions.ExpzessiOn.Bdok(System.Ty8e,Systum.ollections.neric.	Enumerarle{System.Linq*Exprewsions.ParameTerExtrewsion},System.Colletiofw.Generic.IGnumdrable{System.Liq.Expressions.Exp%ssaon})">
      <cummary>Erstellt ein <see c2ef="T:System.Linq.Expressyons.BmockExpression" />, db{ die angegebenenVariablen und Ausdrücke enthält.</summcri>
(     <returns>Der erstellte <see cref="T:SYstem.Linq,Extressions.Bl/ckEx`ressioN" />.</returns>
      <p`ram namE="type"?De2 Ergebnmstyp des0Blocks.</param>
  "  param name="varables">Die Variablen im Block.</param>
      <param name="Uxpressions":Die IusdrCcke im Block.</param>M
  ( </member>
  & <member name="M:System.Lijq.Expressions.Expression.Block(System.TypelSystem.Collections.Guneric.IEnumerable{System.Lhnq.Expressios.ParameterExpresskmn},System.Liny.Expressons.Expression[])"
      <summaryErstellt ein <see cref}"T:System/Linq.Exprssions.BhockExpression" />l das die angegebe~en Variablen und Ausdrücke enuhält.</summary>
      <returns>Der erstalltE <see cred="D:System.LinaE|qrmssions.BlgckEx`resso|" />.</returns>
      <param name="t9pe">Der Ergebnistyp des Blocks.</param?* "    <param!nam%="variables">Die Vapiablen im Blokk.<param<
      <paraM name="expressions">Die ausdrìck im Bloc.<?paRcm>    </membev>
  $"<member Fame="M:System.Linq.Eypressions.Expression.doCk(Ryste-.Typelystem.LiNq>hpressions.Mxpresion[])">
,     <summary>Erstellt ein <see cref-"T:System.Lin3.Expressions.BloakExpRession" />,(dAs dHe angegebenen Ausdrücke en4hält nacht über Variabnmn verdügt und on ei.embest)mmteo(Ergebnistyp i3t></s5mmary>
   " $<rgtUrns>Der erstghlte0<s%e cref="U:ystem.Linq.Expre3sions.BlockExpressako" />.8/returns>
      |param name="type>Dmr Esgebnistyp!des Jlocks.</param>*   !! <param name="eypressions">ie Ausdrücke im Block*</pazam>
    </meober>
    <memcer`.ame="M:S{stem.LinqE}pression3.Mxpression.Brea(Syqtem.Lnq.Exp:essions.LabelTrget)">
  $   <sumari>Erste|lt ein% 8seE crdf="T:S{ctem.Linq.E|pressioNs.GotoExpression" />, dhe eine BpeaK-Anweisunw $arstellt.</summapy>
 $    <rmturns~Eine <sea sref="T:System.Mi~q.ExPrssions.GotoExpbesSyon" />, bei der <{ee0cref="P2System.Linq.|prewsions.GotoExpresshon.Kild" /> gheach "Break", die <see cvef="X:S}stem.Hinq.Expressions.GotoErpreswio~.Target2 />-igensahaft cuf <aaramref nale="taRget" /> fesgelegt istund ein NuLL=ert beim Springmn an dae ZimLber%ichnung$bEreben wird.<'returns<
   0 <pral nqme-"varget">Das$<see cref=#T:Sys|em+Lin1.ExprewsI~fs.LabelTazget* />, zu0eel8<see kvef="T:System/Linq.Exprussmons.GotoDypresSaon& /> spRingu.</pa2em~
    </member>
    <memjer nam%M>SystemnLin.Exzressions.Expressiol>Brein(System.Lhnq.Expr%ssions.LacemTarget,Syw|em.Linp.Dxpressions.Expression)">
 `   <summary>erstellt(emne <sed!cref="T:System.Linq.ExprEssinq.GmtoEypbessi?n" />, die eine BzeakAnweisunf darctellt.Ter beim SPrilgen an d)e Bezeichnung üBesgubenu Wert iann angefeben we2den.<+rummary>
      <retur.s>Ein <see creF=*T:System.Lynq.Ax`ressio.s*GotmExpression" ->,!biidem <seasref="P:SyStem.Linq.Eppve{sions.otoExpre3sion.Kind" /> gleich "Breik" I3t,die <s%e cef="P:SystemoLi~q.Expressions.GotoExprEssion.Target"(/>-Eigenschaft auf <parambf name="tabeEt"!/>fd|gdleot(ist und beim Springen <pa"amref na-e="value" -> an die Zidlbezeych.ung ürergeben wird.</retusz{>
      <pe2am name9"target >DaS <see cref="U:SyStem.Linq.Expresions.LabmlTarget" /?, zu!De- <see csef="T:S}stem.Linq.Dxqrersions.otoExqressinn" ?. springt.</param>
      <pram nl'="v`lue">Der Wert, Der eim SpriGenan die zugeordnete BezeIchnung ôberweben wird/<.param>
    <.member>
   $<}ember name="MSystem>Nins.Expres{inns.EypreSsion*Break Systam.Lhnq.EpressionS.LabelTarget,Sywtem,\inq.Expressions.Expre3sion,System.Uype	">
   !  |suioary>Ewstellt ein`<seE cref= T:System.Linq.Expressions.G/toEx0"ession0/>$ das emne BrEak-Anweis5ng mit dem angegebenel Typ darstelld.Der baim Springn an die Bezeichnung überge"ene ert kann !ngegebe 7erde.</remmary>
      <returns>Ein <qee cre&="T:System.Linq.Expressinns.GotoE8pression"0/>, bei dem <3ee cref}"P:System*Linq.Expressions/GotoE8precsioj.Kknd" > gleich"Breao` Ist, die <see cref="P:System.Dinq.Expressions.GotoExpression.Target" />-Ea'enschaft!uf <paramren n`me="tazget" /> festgelegt ist, die <see cref="P:[ystem.Lmnq.Expressionq.Eypression.Type" />-EiGenskhaft auf <pavamref lame="type" /~ festgeleaT0)st uld"bei- SPringeN <paramref name"value" /> an did Zielbezeashnun übergebmn wIrd.<.returjs>
     (<param na%="tarfet~Des 8su cref9"T:Qqtem.Linq.Expressins.LaRlhDarget" /,zu dgm <see cref="T:System&Linq.Exprdssions.GotoExpression" /> springt.</param>
 `    <param oame="value">Der Wert, der baIm`Springen an die`zugeordnete!Rezeichnung Cbergedn wird.</param>
      <tarae name="type">Ein |see cref="T:System.Tyxe" /, auf den die <see craf=0P:Systel.Nanq.Mxprgsions.ExpressiOn.Type" />-Eige~schft festgeleGp wer`en sll.</0asam>
$   </embgr>
`   <member .ame-"M:Syst%m.Linq.Expressio.s.Expsession.Break8SysteM.LinqExpression{.LabelTcrget,System.Vyre)">-
      <summqra>E6stallt ehn <cee cref="T:System.L)nq.Expressions.GotoExpr%sqion# /~( $as eine Brdak-Anweisung"mid dem angggebeoen Typ darqtenlt.</sqmmqry>
 `    <returns>Uin <see cref="T:System.Lhnq.Expressios.GooExpresio." />, bei dem <see cref="P>Qysvem.Mhny.Expresmgfs.GotExpreswiol.KinD" /> gleich "Break" ist. die <see cref="P:SysTem.Linq.Ex`ressions&GotoExpression.Targeu" '>-Eigmnschaft auF <paramref name="tarcet" /> fesTgelegt ist und dhe <see bref="P:System.LInq.Uxpreqsions&Exp2ession.Type" />-Eigenschaft auf <Perairef name="type"`'> festgelmgt is4</veturns.*      ,param nqme="target">as <sEe Cref=":System.LinqnExpsesshons.LibmlTarg%t" /, zudem <{ee cref="T:System.Linq.exprEssions.GotoExpres{hon" ->springt.</param>
   (  =para name="typeb>GiN"<sde"cruf="T:Sysuem.Typd" />,(aub(den ma <sae cped"T:System,Linq.Expressi/ng.ExpResiof.T}pe" />-Eigenshaft festgelegt werfe. soll.</param>
   `</memfer>
    <meiber name="M>System.Lijq.Expressions.Expression.Call(System.LanqExpressions.EypresSiof,Rystem.Ref,ectko..MethGdInfo)">
      <summqry>Erstellt eine <see!cveF9*>Wywtem.Linq.Exp3essions.MethodCallExpbession" />, dae einen Aufruf einer`Methote darstellt, die kaine Argtmeote akzeptiezt.</suemay>
      <returns>Uin <see cbef="T:Syste.Linq.xpressions.MethOdSallMXpression" /<, bei dem die <seu ref="P:System.Linq.Expessy/os/Ezrres3)on.odgType" />-Eagmjsc(aft gleich <see crmf5"F:SyspeO.Lins.Extrasrions.E|precsionT1pe.Calh" /> ast und d)e <see"cRe="P:[ystem.Linq.Expressiols.ethodCallExpression.Object" >-Eigejschaft 3owie die <see cre&=#P:System.Linq.Exprms3)kns.methodCallExpression.Methmd" />-Aigenskhaft auf die angegebelen Werte fetgmlegt sind.</repurns-
      <paramname"instane">Ein <see ceb="V:System.Linq.Mzpressions.Expresskon"$/>, des"die`Instanz fr einej Ins4anzievhodenaufruf aneft((bsgeben"Cie null für eine static-Methodu bzw. )n Viseal Basic eine!Sered-Methodm).</pcram>
      <param name=2method">Ein <see cRef=#T:System.Reflection.MtthodInfo" />, af das eie <see(sref="P:SYstem.Lin1Exprescaons.MethodCallxpression.Methof" ->-EMge.schaft festgelegv warden sodl.</pcram>     %<gxception creg="T:System.ArcumentNwllException">
        <parcmref name="method" /> ist null.-ʠodev - <paramref lame="instanc%" /> ist n5ll, und <Pazamref name="method" /> stellt)eine Istanzmeth/Dg dar.</ex+eption>
    ! >Exke0tion cref="T:Systm.Argumejtexcepuion">
$   `   ~pqramref(name9&instance" />>Typg kann dem de{larigrenden Typ der"durc(!4paramrmf naee=#method" /> dargdstellten Mephode nicht zugeordnet serlen.</exCepdio~>
    =/member>
    <member nama="M:System.Lin.Ezpvushons.Expre3sIon.Call(ystem.Linq&Expressions.Expression,Systom.Seflection.MethotInf,SystemCollmctions.Generic.IEnummrablE{Rystem.Linq.Exppessions.Expression])">      <summary>Erstellt eine 4see!cref="T:S}stem.linq.Expressions.MethodSallExpbessio~" />, die einen Afruf einar Mmtho$eDarrtellt, die0Agumente"akzeptiert,</summry>
     $<retuRos>Ein <see!cref="T:System.Linq.Expressions.MethodCallExprsqion" />, bei dem die <sde cref="P:System.LiNu.Expre{syons.Expression.^o$eType"$/~-Eigenrchaft gleich 8see cren="F:System.LiNq.Exprgssions.ExpressionType.Call" /> ist 1nd dye(Eigens#hafden <seE cref?"P:System.Liq*Expressions.MethodCaldEx`2ession.Object" />, <see cref="P:Syste}.DanqExpressimns&Meth/dCallExpressikn>Method"$/> und0<sel czdf="P:ysteM\inq.E|prdssions.MethodCallFxpresskon.Agumentc" /> auf die angegebenen Werte fertgmlegt sind.</retUrnq>      =p!r`m ~ame="instance">Eije see crev="T:Sstem/Linq,Expressyns,ExqresSinn" +>, auf die dig <see cref=":Syste-.Linq&Expressions.Me4hodGallExpzession.obJect" />)Eigenschaf4 fes4celegt werden soll. Übecebn Wie full für eine static-M}todm (hared in Visua$Ba{ic)/</param~
      <param name="methof">Ein =3ee cref="D:System.Reflection.ethodnfm# />,bauftas die <se0cre&="P:Wystem.Linq.Expressions.MethodCallExpression.Methd` />-Eigenschaft festgelegt werden woll.</param>*    " <param name="argtments">Ein =see`cref="T:9ste}.Cmllectikns.Oenmric.IEumerable`1"$/> das =see cref="T:System.Linq.ExpressiOnq.Expresshon" />-ObjEkte enthˤlt, mit denen die <see crdf="P:System.Minq.Ex`ressions.LethodcallEXzassion.Arguments" />-AuflisTunf aufgefüllu werden soll.</param>
      <eception cref="U:System.ArgumentNullException"> !    $ <pabcoref name="mmthkd" /> ist null.- oDer -(<peramvef name="instance" /> ist null, tnd <paramref name=biet`od" /> stellt eine Instanzmethode dar.4/exce`tion>
      <exce@tion"c2ef="T:System.ArgumEntException">
       $<paramref nmg= ils0ance" />.Type kajn em deklariezenden Tyq der dqrch <parqmzef n`me="method" /> dargestellten(Metiode nibhT zugekrdnet webden.-ʠodez - Die Anzahl der Elementd"inh<para}ref name="arguments" /> sTimmt niht mit derAnzall dgr Parameter für die durch <papamvaf name="mehod" /. dargestellte Methode überEmj.- oder %"mindastenr`ein Elemenv vOn <paramrev name=arguments" /> kan nicht dum eotsprecjenden Raraleter!der durch <paramren naee="method" /> dargesteLlten Methode zugerdnet0Werden.</xceptioj
    </member>
   <meiber name5"M:System.Linq.Expressions.xpressinn.Call(SystemnLinq.ExPreSsions*Exrression,[ystem,edlection.MethodIofo,Sycte.Linq.ExpressionsnExtression,System.Linq.Expressio,s.ExPression+">      <sumary>Erstellt eine <see cre&="T:Syctem.Linq.Expressio~s.MethodCallExpbession" />, die eineo Auvruf eiler Methode darsTellt, die zwei Argumete akzeptiert.</summary>
      <returns>E)n <sed cref="T:S}ste}.L)nx,Eypressions.MethodCallEprescion" .>, bum deM die <see cref="P:Systee.Linq.Exprersions.Expression*NodeTxPe" />-Eigenschaft glei#h <see cre="F:System.Linq.Ex`ressions.ExpressionType.Call" /> ist und die <see cref="p:System.Lins.Expressikns.ethodCallExpression.Objet" />-Eigensshaft sowie die <see cref="P:System.Lilq.Expressins.MethmdGallExpression.Metjod" />-Eigensohaft auf dke angegebenen Wezte festgulegp snd.</returns>J      <tabem name="i~stance">Ein <see crmf="T:Sysdem.Linq.E8pressyons.Mxpesion" /,0d!s die Instanz füR einen%Instazaufruf `ngibt.(Üubgeben Sie NULL füreine statische Methodezw. eineShared-Methode in Visu`l Bcsic.)</param>
      <param name="method">Das <see cref="T:System&Reflection.MethodInfo" />, das dje Z)elmethode darstellt.<'para}>
    ( <param name="irg0">Das!<see cref="T:System.Lioq.Exprescions.Expession" />, das daserste"A2gument d`Rctellt.</param>
    $$<param nama="arg1">Das <see cref="T:System.Linq.Expressinjq.Expres3ion" />, das das zweite APgument darstellt.<param>
    </Member:*    <member name="M:System.iNq.Expressions.ExpresSin.Caln(System.Linq&Exprescions.Expre3sion,System.Refl%ction.MethodInfo.System.Linq.Euressions.Ex0ression,Kystem.Linq.ExpressIons.Expression,System.Linq.Expressions.Expression)">
      <sum-ary>Ezstell0`eine <see cref=":Sstem.Linq.Expressions.MethodC`llEypres{)On" />, die eifen Aufruf einer(Eethode darstelmt, d)e drei Argumente akzeptierT.</suimary>
`    =returns>Ein`<see kref=":System.Linq.ExpRessions.MethkdCal|Ex0ression" />, bei deo die see aref="P:System,Linq.AXpresions.Expression.NodeType" />-EiGens#haft gleich <see cref<"FzSystcO,Linq.Expressions.ExpsessionType.Call" /> ist und die`<see cref="P:Syctem.Linq.Expressions.MethodGaLlUxpressio~.ObjmcT" />-Egenschafp sowit dIe <see crEf="P:System.Linq.Expressions.MethodCadlExpression&uthof" />-Eigenwchaft auf0die0angegebenen Werta festoelegp sind,<+raturns>
!     <param name="ilstance">Ein <see cref="T:SysteM.Linq.Expressimns.Expression" />, das die Instanz für einen I.stanzaqfruf angizt.(Ìberg"en Si% NULL für eine statische Methode bzw. eiNe0Slared)Methgde in Vi{ual BasiC.)4/aram>
      <param naee="methgd">as <see cref=&T:System.Reflactyon.MethodInfo" />, das die Zielmetho$e darstellt.</aram>
      <parao name=2ar'0">Das <seu crev="T:Syqtdm.Linq.Expres{ions.Extression" />, daS das erste Asgement darstellt.</Parii>
      <parqm name="arg1">Das <see cref="T:Systum.Linq.E8presions.Epp2ession" /, daw das zweite Argeme.t derstelld.</param>
      <param name="rg2">Daw <seu cref="TSystem.linq.Uxpzessions.Expressio~" />, da{ das $ritte Argumnt darstellt.<'param>
  ! /member>
    <membeR nam="M:System.Linq.Uxtressionw.Expressioj>Call(System.Linq.Expressions.ExpResrio~,System.Zellection.Me4hdInno,System.LiNq.expressions.xpRession[\)">
      <sumlary>Erstel,d eing <see cbef="T:System.Lifs.Expressions.MethodCallExrzession"`/>( die!einen Aqfref eioer Methode(darstellt, die Argumnte akzepti%rt.</summary>*      <returns>Ei <see cref="T:System*Linq.Expressions.MethodCallExpression />, bei dem dig<see cref="P:ystem.anq.Expres3ions.Expression.NodeType2 />-Eigenschaft gleich <see cref=#Fystem.Lins.Uxtressions.ExpressinType.Caln" /`ist und die E)genschaften <see cref="@:System.Linq.Expressioos.MethodCallEypression.Objact  />,(=ree cref=P:Systgm.Linq*Expressons.MethodCallexpression.Method" /> und <seD cRef="P:S1stem.Linq.Expressiols.MethodCadlExpresion.Arguments" /. auf die angegebenen Werte estgelgt sind.</reTurns>
      <param name="instance">Ein >see cref="T:Wystem.Linq.Expr%ssions.Expressin" />, das die Instanz für einen Instanzmethodejaufruf angibt(ìbergeben0Sie null für %ine ctatkc-Methode bzw. in isual Basib eine Shared-Methoee).</param>
      <paral name="method">Ein <see creF="T:systdm.ReflectiOn.MethodInfo" />, auf0das die <see cref"P:System.Linq.Expbessigns.MethdCallEx`ression.Methol" />=Eigenschcf| f%stgejeg werden cold.</param>
 (    <papam name="arguments"<Ein Array von <see crdf="T:Systee.Linq.Expressions.Expression" />-Objukte., mat(denen die <see gRef="P:Sstem.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgebüllt wird.</param>
     <exseption cvef=#T:SystemnArgumentNullException">
        <paramrf name="o%thod" /> ist!null.- oder -0<paramref name"instance" /> ist$null, und <paramref name="method"0/> steldt eine Instenzmethode dar.- oder- <paramref n-e="areuments" /: is nibht gleich null, und }indestenS eines dur darin enthalTenen EleMentm(ist glgich$null.</eXcapthon>
      <exaeptioncred="T*System.ArumentExbeption">       <parambef name"kNsance" ?>.Type kann dem$dgklarierenden Typ der durch |paremref name=cmethod" /> argestellte. MdtHmde0nicht(zugeordnep wgrden.- `er - Die Anzahl ter Elemenue in <paramren name="yrgumgnts" o> stimeu"niaht mit fer Anzahl fer Parameter für1die durch 4paremvef name-"iethod" /> dargestellda Mdthode überein.- oder - mindestens"ein Element von =parqmrev nma="arGumnts" />(kinn nicht dem entsxreshenden Parameter der durkh <p`raref name="iethod" /> dargestelLten Metho`e zugeordnet werden.</exceptioj>
    <+member>
 `  <member name?"M:System.Linq.Expessions.Expression.Call(System.Linq&Expressions.Expression,Sys|em.String,System.Tyte[],System.Linq.Expreqsionw.Expbession[]) >
      <summary>Arstullt eine <see cref5"T:SystEm.Lnq.Expressions.MethodCallExpre3sion" ->l die einen Aufruf einer Methkde dusch das unrqfn der ents`reke.den Factory-ethode darstenlt.</summary>
  0  <returns>Eine"<sae cref="T:Qystem.linq.Extreqsions.MethodCahlExpressio" 7> bei der die <see crdf=jP:Sqstem.LInq.expressios.EPpbession.NodePype" />-Ei'enschAft glich <see cref="F:Sys4ee.Linq.Expresrions.ExpressiojDype.all" /> ist, ie <see cref}"PSysTem.LinU.Exppessions.Metho`CillExprEssIon.Object" />-Eigenschaft Gleichpcsamref name="instance" /> yst, <see creb="XSystem.Lynq.Expresions.MethodCallExpressio.Method"/> auf die <see cref="T:System.Renlgction.MethodInfo" /:!fesuge,egt ist die die angeGebene Ynstanzmetiode darstellt, und weu cref="P:Sysvem.Linu/Ezpressions.Met`odCallExpression.Argume.ps" / auf did angegebenf Argumente vestgelegt ist.</returns>
      <qarem name="insdance">Eine <wee cref="T:System.Linq.Expres3ions.Expression" />, ddRen <see sef="P:Sywtem.Lina.Expressions.Exprersion.type# />Gigenschadtswert ncch eider bestimmten Methkde durchsuchT(w)rd.<param      <param n`me="methodName"<DeZ Name der Methode.</param>   ` <param name="t9peAr'ument{">Ein Array vg0<see cref="T:System>T9p% />=Lbjekten, die die2Typparameter0der generischun Mehode angeben.Diesds Azgumdnt muss(NUDL rein, wenn durCh me|hodN@me eIne nicht geneisc(e methode anGegebe~ wire.</param>	
      <param name="argumnts*>Ein Azbay"von <see cref="T:Syspgm.Lnq.Expressions.Expressikn# ->-Objekten, das"die Argumente der Methde darstelld,</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> oder <paramref name="methodName" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Es wurde keine Methode, deren Namen gleich <paramref name="methodName" /> ist, deren Typparameter <paramref name="typeArguments" /> entsprechen und deren Parametertypen <paramref name="arguments" /> entsprechen, in <paramref name="instance" />.Type oder ihrer Basistypen gefunden.- oder - Es wurde mehr als eine Methode, deren Namen gleich <paramref name="methodName" /> ist, deren Typparameter <paramref name="typeArguments" /> entsprechen und deren Parametertypen <paramref name="arguments" /> entsprechen, in <paramref name="instance" />.Type oder ihrer Basistypen gefunden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode (Shared in Visual Basic) darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Das <see cref="T:System.Reflection.MethodInfo" />, das die Zielmethode darstellt.</param>
      <param name="arguments">Ein Auflistung von <see cref="T:System.Linq.Expressions.Expression" />, die die Aufrufargumente darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer static-Methode (Shared in Visual Basic) mit einem Argument darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die zwei Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die drei Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die vier Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
      <param name="arg3">Das <see cref="T:System.Linq.Expressions.Expression" />, das das vierte Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer statischen Methode darstellt, die fünf Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
      <param name="arg3">Das <see cref="T:System.Linq.Expressions.Expression" />, das das vierte Argument darstellt.</param>
      <param name="arg4">Das <see cref="T:System.Linq.Expressions.Expression" />, das das fünfte Argument darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist NULL.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer static-Methode (Shared in Visual Basic) mit Argumenten darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="method">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine static-Methode (Shared in Visual Basic) darstellt, auf die die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die durch <paramref name="method" /> dargestellte Methode überein.- oder - Mindestens ein Element von <paramref name="arguments" /> kann nicht dem entsprechenden Parameter der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer static-Methode (Shared in Visual Basic) durch das Aufrufen der entsprechenden Factorymethode darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist, die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die <see cref="T:System.Reflection.MethodInfo" /> festgelegt ist, die die angegebene static-Methode (Shared in Visual Basic) darstellt, und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Argumente festgelegt ist.</returns>
      <param name="type">Der <see cref="T:System.Type" />, der den Typ angibt, der die angegebene static-Methode (Shared in Visual Basic) enthält.</param>
      <param name="methodName">Der Name der Methode.</param>
      <param name="typeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typparameter der generischen Methode angeben.Dieses Argument muss NULL sein, wenn durch methodName eine nicht generische Methode angegeben wird.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, das die Argumente der Methode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="methodName" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Es wurde keine Methode, deren Namen gleich <paramref name="methodName" /> ist, deren Typparameter <paramref name="typeArguments" /> entsprechen und deren Parametertypen <paramref name="arguments" /> entsprechen, in <paramref name="type" /> oder seinen Basistypen gefunden.- oder - Es wurde mehr als eine Methode, deren Namen gleich <paramref name="methodName" /> ist, deren Typparameter <paramref name="typeArguments" /> entsprechen und deren Parametertypen <paramref name="arguments" /> entsprechen, in <paramref name="type" /> oder seinen Basistypen gefunden.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Gibt an, dass der Knoten zu einem einfacheren Knoten reduziert werden kann.Wenn true zurückgegeben wird, kann Reduce() aufgerufen werden, um das reduzierte Formular zu erzeugen.</summary>
      <returns>True, wenn der Knoten reduziert werden kann, andernfalls False.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit einem Verweis auf das aufgefangene <see cref="T:System.Exception" />-Objekt zur Verwendung im Handlertext darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="variable">Eine <see cref="T:System.Linq.Expressions.ParameterExpression" />, die einen Verweis auf das von diesem Handler aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit einem <see cref="T:System.Exception" />-Filter und einem Verweis auf das aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="variable">Eine <see cref="T:System.Linq.Expressions.ParameterExpression" />, die einen Verweis auf das von diesem Handler aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
      <param name="filter">Der Text des <see cref="T:System.Exception" />-Filters.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> von <see cref="T:System.Exception" />, der von diesem <see cref="T:System.Linq.Expressions.CatchBlock" /> behandelt wird.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit einem <see cref="T:System.Exception" />-Filter, aber keinem Verweis auf das aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> von <see cref="T:System.Exception" />, der von diesem <see cref="T:System.Linq.Expressions.CatchBlock" /> behandelt wird.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
      <param name="filter">Der Text des <see cref="T:System.Exception" />-Filters.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts.</returns>
      <param name="document">Die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, die die Quelldatei darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine zusammenfügende Operation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von <paramref name="left" /> stellt keinen Referenztyp und keinen Typ dar, der NULL-Werte zulässt.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type und <paramref name="right" />.Type können nicht ineinander konvertiert werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die bei einer gegebenen Konvertierungsfunktion eine zusammenfügende Operation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type und <paramref name="right" />.Type können nicht ineinander konvertiert werden.- oder - <paramref name="conversion" /> ist nicht null, und <paramref name="conversion" />.Type ist ein Delegattyp, der nicht genau ein Argument akzeptiert.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von <paramref name="left" /> stellt keinen Referenztyp und keinen Typ dar, der NULL-Werte zulässt.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von <paramref name="left" /> stellt einen Typ dar, der nicht dem Parametertyp des Delegatentyps <paramref name="conversion" />.Type zugeordnet werden kann.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft von <paramref name="right" /> ist nicht gleich dem Rückgabetyp des Delegattyps <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die eine bedingte Anweisung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> oder <paramref name="ifTrue" /> oder <paramref name="ifFalse" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type ist nicht <see cref="T:System.Boolean" />.- oder - <paramref name="ifTrue" />.Type ist ungleich <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die eine bedingte Anweisung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei der die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> und die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="value">Ein <see cref="T:System.Object" />, auf den die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei der die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConstantExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> ist und die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="value">Ein <see cref="T:System.Object" />, auf den die <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> ist null, und <paramref name="type" /> kann nicht auf der Basis des dynamischen Typs von <paramref name="value" /> zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Continue-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue", die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Continue-Anweisung mit dem angegebenen Typ darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, das einen Typkonvertierungsvorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Zwischen <paramref name="expression" />.Type und <paramref name="type" /> ist kein Konvertierungsoperator definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine Konvertierungsoperation darstellt, für die die implementierende Methode angegeben ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> und <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">Zwischen <paramref name="expression" />.Type und <paramref name="type" /> ist kein Konvertierungsoperator definiert.- oder - <paramref name="expression" />.Type kann dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.- oder - Der Rückgabetyp der Methode, die durch <paramref name="method" /> dargestellt wird, kann <paramref name="type" /> nicht zugeordnet werden.- oder - <paramref name="expression" />.Type oder <paramref name="type" /> ist ein Werttyp, der NULL-Werte zulässt, und der entsprechende Werttyp, der keine NULL-Werte zulässt, entspricht nicht dem Argumenttyp bzw. dem Rückgabetyp der durch <paramref name="method" /> dargestellten Methode.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurde mehr als eine Methode gefunden, die mit der <paramref name="method" />-Beschreibung übereinstimmt.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine Konvertierungsoperation darstellt, die eine Ausnahme auslöst, wenn ein Überlauf im Zieltyp auftritt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Zwischen <paramref name="expression" />.Type und <paramref name="type" /> ist kein Konvertierungsoperator definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine Konvertierungsoperation darstellt, für die die implementierende Methode angegeben ist und die eine Ausnahme auslöst, wenn ein Überlauf im Zieltyp auftritt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> und <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">Zwischen <paramref name="expression" />.Type und <paramref name="type" /> ist kein Konvertierungsoperator definiert.- oder - <paramref name="expression" />.Type kann dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.- oder - Der Rückgabetyp der Methode, die durch <paramref name="method" /> dargestellt wird, kann <paramref name="type" /> nicht zugeordnet werden.- oder - <paramref name="expression" />.Type oder <paramref name="type" /> ist ein Werttyp, der NULL-Werte zulässt, und der entsprechende Werttyp, der keine NULL-Werte zulässt, entspricht nicht dem Argumenttyp bzw. dem Rückgabetyp der durch <paramref name="method" /> dargestellten Methode.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurde mehr als eine Methode gefunden, die mit der <paramref name="method" />-Beschreibung übereinstimmt.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> mit der angegebenen Spanne.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">Die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, die die Quelldatei darstellt.</param>
      <param name="startLine">Die Startzeile dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Muss größer als 0 sein.</param>
      <param name="startColumn">Die Startspalte dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Muss größer als 0 sein.</param>
      <param name="endLine">Die Endzeile dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Muss größer oder gleich der Startzeile sein.</param>
      <param name="endColumn">Die Endspalte dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Wenn die Endzeile und die Startzeile identisch sind, muss die Endzeile größer oder gleich der Startspalte sein.Muss in jedem Fall größer als 0 sein.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Verringern des Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den verringerten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu verringerndes <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Verringern des Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den verringerten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu verringerndes <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DefaultExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf den angegebenen Typ festgelegt ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.DefaultExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf den angegebenen Typ festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Division darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Divisionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Division darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Divisionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Divisionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Divisionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Divisionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.ElementInit" />, dessen zweites Argument ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ElementInit" />, bei dem die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="addMethod">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit <see cref="T:System.Linq.Expressions.Expression" />-Objekten, auf das die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> oder <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die durch <paramref name="addMethod" /> dargestellte Methode weist nicht den Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) auf.- oder - Die durch <paramref name="addMethod" /> dargestellte Methode ist keine Instanzmethode.- oder - <paramref name="arguments" /> enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für die durch <paramref name="addMethod" /> dargestellte Methode.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft einer oder mehrerer Elemente von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters der durch <paramref name="addMethod" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.ElementInit" />, dessen zweites Argument ein Wertearray ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ElementInit" />, bei dem die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="addMethod">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, auf das die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> oder <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die durch addMethod dargestellte Methode weist nicht den Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) auf.- oder - Die durch addMethod dargestellte Methode ist keine Instanzmethode.- oder - arguments enthält nicht dieselbe Anzahl von Elementen wie die Anzahl der Parameter für die durch addMethod dargestellte Methode.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft einer oder mehrerer Elemente von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters der durch <paramref name="addMethod" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Erstellt einen leeren Ausdruck vom Typ <see cref="T:System.Void" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.DefaultExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <see cref="T:System.Void" /> festgelegt ist.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Gleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Gleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Gleichheitsvergleich darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Gleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine bitweise XOR-Operation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der XOR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine bitweise XOR-Operation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der XOR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise XOR-Zuweisungsoperation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise XOR-Zuweisungsoperation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise XOR-Zuweisungsoperation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll.Für static (Shared in Visual Basic) muss <paramref name="expression" /> gleich null sein.</param>
      <param name="field">Die <see cref="T:System.Reflection.FieldInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> ist null.- oder - Das durch <paramref name="field" /> dargestellte Feld ist nicht static (Shared in Visual Basic), und <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type kann dem deklarierenden Typ des durch <paramref name="field" /> dargestellten Felds nicht zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die bei einem gegebenen Feldnamen den Zugriff auf ein Feld darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.FieldInfo" /> festgelegt ist, die das durch <paramref name="fieldName" /> angegebene Feld darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" /> ein Feld namens <paramref name="fieldName" /> enthält.Dies kann für statische Felder NULL sein.</param>
      <param name="fieldName">Der Name des Felds, auf das zugegriffen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="fieldName" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">In <paramref name="fieldName" />.Type oder den entsprechenden Basistypen ist kein Feld mit dem Namen <paramref name="expression" /> definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
      <param name="expression">Das enthaltende Objekt des Felds.Dies kann für statische Felder NULL sein.</param>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" />, der das Feld enthält.</param>
      <param name="fieldName">Das Feld, auf das zugegriffen werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Erstellt ein <see cref="T:System.Type" />-Objekt, das einen generischen System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
      <returns>Der Typ eines System.Action-Delegaten, der das angegebene Typargument aufweist.</returns>
      <param name="typeArgs">Ein Array mit maximal 16 <see cref="T:System.Type" />-Objekten, die die Typargumente für den System.Action-Delegattyp angeben.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> enthält mehr als sechzehn Elemente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Ruft ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt ab, das einen generischen System.Func- oder System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
      <returns>Der Delegattyp.</returns>
      <param name="typeArgs">Die Typargumente des Delegaten.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Func-Delegattyp mit bestimmten Typargumenten darstellt.Das letzte Typargument gibt den Rückgabetyp des erstellten Delegaten an.</summary>
      <returns>Der Typ eines System.Func-Delegaten, der das angegebene Typargument aufweist.</returns>
      <param name="typeArgs">Ein Array mit einem bis 17 <see cref="T:System.Type" />-Objekten, die die Typargumente für den System.Func-Delegattyp angeben.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> enthält weniger als ein oder mehr als siebzehn Elemente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine "Go to"-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf den angegebenen Wert festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine "Go to"-Anweisung darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine "Go to"-Anweisung mit dem angegebenen Typ darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine "Go to"-Anweisung mit dem angegebenen Typ darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf den angegebenen Wert festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer als"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Größer als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer als"-Vergleich darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Größer als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer oder gleich"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Größer oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer oder gleich"-Vergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Größer oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die einen bedingten Block mit einer if-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft auf die angegebenen Werte festgelegt sind.Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft ist auf den Standardausdruck festgelegt, und der Typ der resultierenden <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die von dieser Methode zurückgegeben wird, ist <see cref="T:System.Void" />.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die einen bedingten Block mit if- und else-Anweisungen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind.Der Typ der resultierenden <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die von dieser Methode zurückgegeben wird, ist <see cref="T:System.Void" />.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Erhöhen des Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den erhöhten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu erhöhendes <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Erhöhen des Ausdrucks um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den erhöhten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu erhöhendes <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das einen Delegaten oder einen Lambda-Ausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das den angegebenen Delegaten oder Lambda-Ausdruck auf die bereitgestellten Argumente anwendet.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, das den anzuwendenden Delegaten oder Lambda-Ausdruck darstellt.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit den <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat oder Lambda-Ausdruck angewendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type stellt keinen Delegattyp und keine <see cref="T:System.Linq.Expressions.Expression`1" /> dar.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="expression" /> dargestellten Delegaten zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="expression" /> dargestellten Delegaten.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das einen Delegaten oder einen Lambda-Ausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das den angegebenen Delegaten oder Lambda-Ausdruck auf die bereitgestellten Argumente anwendet.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, das den anzuwendenden Delegaten oder Lambda-Ausdruck darstellt.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat oder der Lambda-Ausdruck angewendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type stellt keinen Delegattyp und keine <see cref="T:System.Linq.Expressions.Expression`1" /> dar.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="expression" /> dargestellten Delegaten zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="expression" /> dargestellten Delegaten.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck False ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck False ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck True ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck True ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit Void-Typ und ohne Namen darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LabelExpression" />, die eine Bezeichnung ohne Standardwert darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LabelExpression" /> ohne Standardwert.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem diese <see cref="T:System.Linq.Expressions.LabelExpression" /> zugeordnet wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LabelExpression" />, die eine Bezeichnung mit dem angegebenen Standardwert darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.LabelExpression" /> mit dem angegebenen Standardwert.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem diese <see cref="T:System.Linq.Expressions.LabelExpression" /> zugeordnet wird.</param>
      <param name="defaultValue">Der Wert dieses <see cref="T:System.Linq.Expressions.LabelExpression" />, wenn die Bezeichnung über die normale Ablaufsteuerung erreicht wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit Void-Typ und dem angegebenen Namen darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Der Name der Sprungmarke.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit dem angegebenen Typ darstellt.</summary>
      <retuRns>Die neue <see cref="T:System.Linq.Expressions.L!belTarget" />.</returns>
      <paRam name5"type">Ddr Westtyp, der beim Springen zur Bezeichnung!übergeben wird.</para->    </member>
    <meber na}e="M>System,LIn.Expressikns.Expression.Label(Syspem.Type,System.STring)">
     4summary?Erstellt`eil <see cref="T:System.Linq.GxpressinS.LabelTarget" />, das eine Bezeichoung mit $em ange'ebenen Typ tod Namen darstdll|.</summary>
      <returns>Diu nete <ee cref="T:SYstem.Linq.Expressios.LaelTarget" />.|/returns>
      <param name=#txpe">Der Wertyp, der beim Srringen jur Bgzeishnung übergeben wird.</param>
 !    <param nee="na}e">Der ame der SprUngmcrke.</param>	    </member>
    <mebes nqMe="M:System.Linq.Expres{imns.Expression.Lqbda System.Lina.Exprussions.Extression,system.Boolean,System.Collections.Generic.IEnumerableSystemnLinq.Expre{sions.ParAmeterEhpression})">
 !`   <summary>rstellt eindn`ambdaExpression, ineem ztest ein DeLeoaTtYp erstellt gir4.<summary>
      <returns>Ain <see cref="T:Sxstem.Linq.Eypresins.LambdaExpression" />, bei dem die 3ee cref="P:Sxspem.Minq.Expressmons.LambdaExpression.NodeType" />-eigMnschaft ele)ch "Lambda" ist und ie"<seecref=b:[ystem.Linq.Expressions.LambdaEypression.Fody" />-igenschaft smwie die0sme cref"P:System.Dinq.Expressions.a-bdaEhpressaon.Parameters" />-Eignscjat auf `iu anoegebenen Werte festgelegt!sind./returns>
      <pAbam name"body">Ein <see cref="T:System.Linq.Axpressions.xpresrion" />, auf Den die <see cref="P:S9stem.Linq.Expres{ins&LambdaExpression.Boty" ?>-Migenscxaft festwelegt werden soll.</param>
     (<cral name="tailCall">Ein <see kreg="T8SystemnBoolean" />, das angibt, oc beim Kmmpilieren des erstelltn Ausdrucks die Endeaufrufoptimieru.g aneesentgt wird.</param?
      <param naMe="parameters">Ein!<see cref="T:System.Collections.Genebic.IEnumerablu`1" />, eaS <see cref="T>Wystem.Linq.Expressions.ParameperExpression" />-ObjeKte enthält, mit denen die <cee cref="P:System.Lifq.Expressions.LambdaExpression.Tarameters" />-Auflistung aufgefüllt wErdEn soll.</p`ram>
    </member>    <membur name="M:System.Linq.ExpressIons.Expressin.La}bda``1,System.Linq*ExpressioNw.ExpressionSystem>BooleAn,Syswem.Colleations.G%Neric.IEnuMg2ale{Sys4em.Linq.Exprssions,Paramet%rExpressioN})">M
0     <summar9>Erwtellt %ine <ee crgf="T:System.Linq.xpressions.Expressio.`1" />, bui dev Der Delegattqp zur!Kompilierzeit`bekannt ist.</summary>
      <returnr>Eine <see cref="T:System.Lnq.Expressions(Expression`1" />, bi dar dye <se cref="P:System.Linq.Expressions.LambdaExpresrionNodeType" />-Uigenschaft gleich <see cref="F:System.Linu.Expressions.Expressi/nTYpe.Lambda" /> ist und die >see cref="P:[ystem.Lin1.Expressions.LambdaExpressionZody" />-Eigenschaft sowie die <s%e cref="P:SystemLkns.Expresqions.LambdaMxpression.Paramete2s" />-Eigenschaft auf die angegebenen Werue festgelggt sind.</returns
      <param Name="bodyb>Eij <see cref="T:Sysdm.Linq.Expressions.Expressioo" />, auf den d(e <se cref"P:System.Linq.ExpressioNs.LambdaExpression.body" />-Eigenrchaft festgelegd Werden soll.</parcm>
     (<param name5"tailCall">Ein <see cref="T:System.Boolean" '>, das angibt, ob beim KoMpilieren des erstellten Aqsdruaks die Endeaufrufo2tieiErung angewendet 7ird.</param>
  "  <pazam name="irameters">Eio <see cref="T:System.Collections.Generic.IEntmerafle`9" />, das <see cref=*T:Sxstem.Linq.Expressions.PavamgterAxpression" />-Objekte enthält, mit delan die <sme cref=#P:Syst%m.Linq.ExPressio~s.LambdaExpreSion.Parametebs" />-Auflistung aufeefÜllt werdensoll.</param>
   0  <typep`ram name="TDelegate"<Der Delegattyp. </typeparam>
$   </membdr>
    <memfep ~ame="M:SyspemLinq.Expressions.Expression.Lambda``1(Sstem.Linq.Expressions.Expression,System.Boolean,System.Linq.Exrresions.ParameterExqresshon[])">
      <summary>Erqtellt eine <see cref?"T:System.Linq.Ax0ress)ons.Expression`1" />, "ei"der der Delegattyp$zur Kompilierzmiv bekannt(i{t.</summary<
      <returns>Eine <see cref="T:System.Hinq.Expressions.Expessio`1" />, bei der die <qee cref="P:System.Linq.Expressions.Expressimn.NodeType" />-Eiwensciaf4 gleich <see cbef="F:System.Linq.Exprersions.ExpressionType.Lambda" /> ast und die <see cref-P:System.Linq.xpressions.lambdaEypression.Body" />-Eigenschaft sowie die <se cref="P:System.Linp.Express)ons.LambdaExpressiolnPqramepers" />-Eigenschaft auf die angegebendl Werte festgelegt sind.</rmturns>
      <param name="body >Ean <sme cref="T:System.LinQ.E8pressigns.Gxpbession" />. au den die <see cren="P:Sqstem.Lhnq.Expressions/LambdaExpression.Bndy" />-Eigenschaft0festgelegt werden soll.</para}>
   !  <param name="tailCall">Ein <sed cref="T:System.Boolean" />, das qnibt- oB beIm Kg-pilieren de e2stmllten Ausdvucks die endeaufzufoptimierung angeweNdet wird.>/param>
      |param .ame="pasametes >Ein Asray, das <sed cref="T:Syrtem.Lynq.Exprgssions.ParameterDxpression" />-Objgkte enthält, die zum Aufføllen der <see kreF="P:S}ctem.Linq.ExPressions.LambdaExpression.Papameters" />-Auf,istung verwendet werden.</param>
      <typepasam`name="TDelegate"~Der Eelmgattyp. </typeparam>
    </mumber>    <member name="M:System.Lnq.Expressionc.Expression.Lambla(SysTmm.L)nq.Expressions.Expression,Sywpem.FooleaN,System.Linq.Gxprecsions.PirameterExpresskon])">
      <summary>Erstelld minen LambdaExpre;siol, indem zuerst oin Delegattyr ers4elmt wirf.</summary>
      <returns>Ein <cee crun="t:System.Linq/Expressions.LambdaExpression& />, bgi dem die <see cref="P:sys|em.Linq.Expressions.LambdaEzressaon.NodeType" />-Eigenschaft gleich "Lembda" ist und die <see cref="P:System.Linq.Mxpre{sins.LambdaE|pression.@ody* ->-Eiganschaft soie die >see cref9"P:SystemnLinq.Ehpressionc.LambdaEXtresrion.Parameters" >-Eigenschaft uflie angEgebenen Werte feqtgelegt sind.8/returfs>
  4   <parm name="jody">Ein <see cref="T:SysteM.MInq.ExpressIons.Expression" />, auf den die <see cref="P:Ryqtem.Linq.Expressions.LambdaExpessimn.Body" >-ygenschaft cestgelegv werden soll.</p`ram>
 0    <param name="tailGall">Ein ,see cref="T:S{stem.Boon%n" />, das angibt, ob beim Kompiliere des erstellten usdrucks die Endeaufufoptimierung angewendet wird.</piram>
      <param name="parame|ers">Ein Array, das <see0cref=":Sys|em.Lina.Expresshons>ParameterExpression" />-ObJekte enthält, die zum Auffü,len der <see cref="P:System.Linq.Expressions*LambdaUxpression.PArameters  />-A}flistung"vmrgendgt werden.</param>
   (</member>
    <member jame="M:System.Lifq.ExPressions.E8pression.Laobda`h1(System.Linq.Expressions.Expression,System.Collecthons.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="PSqstem.Linq.Expressions.MambdaExpression.Parameters" />-Eicenschaft auf die afgegebenen Wrte festgeLeNt sind.|/returns>
      <Param name="body">Ein <see cref="T:Sistem.Linq.Expreq3ions+Mxpsessyon" />, auf dej die <ee cref="P:Sysvem.Linq>Expressons.LamblaExpressiOn.Rody  />-Eigenschaft festgeleg| werden soll.4/parai>
      <param name=*pcvameders">Ein <see cref="T:System.Collectinns.Generic.IEnumebable`1" />, das <see cref="T:Sytem.Linq.Expressions.@arameterExpression" /:,Objeite0entiält, mit denen die <see cref="P:S{stem.Linq.ExprEswion3.Lambdaehpression.Parameters" />-Aufl)stung aufcefüllt werden soll.</param>
   !  <typepAram name="TDelegate">Ein Delegattyp.</typeparam.
      <gxceptinn cre&="T:System.rgumentNullException">  $     <par!mref nale="cody" /> ist null.- oeer - Einesoder0mehrere$Elemente if paramref name="paremeters" /> sknd null.</e|ceptin>
`  $  <exception cref="D:Sy{tem.ArgumentException">
        <Par!mref name=&TDelegate" /: ist kEin Dalegattyp.- oder - <param2ef name="body" />.Type stellt einen Typ dar< der"nisht lem Rückga`etyp vo. <paramref name="TDelegate" /> zugeorfnet werden kanN- oder - <q`ramref nam="pasameters" />(enthÄlt nicht dia gleikhe Anzahl an Elementen wie die Liste ddr Parameter für <paramref neme="TDe,%gatd" />- oder - Die <see cref=2P:System.Linq.ExpressIons.Expression.Tye" />-Eigenschaft$eiNes Eleme.ts vmn =paramref name="parameer3" /> kann nicjt dem Typ des ensprechenden Pasametertypc von <pAramref name="TDelegat""/> zugeordnet wer`en.</exception>
    </mEmber>
    4member`name="M:System.Linq.Expressions.Expression.Lambda(System.LiNqEypressions.Expression-System.Collections.Eenaris.IEnumera"le{Bystem.LinqExpressions>Paramet%rExpressiof})">
    $ <rummary>Erstellt`einen LambdaExpressi/n, indem0zuerst ein Delegautyp erstellt wird.</sqmmary>	
      <returns>Ein <sde cref="T:Sysvem.Ninq.Expressions.LambdaExpbessyon" />$ bei dem die <see #ref="P:System.LinqnExpreSsions/LambdaExpresSion.NodeType"!/>Eigenschaft gleich$"Lam`da* ist u~d die <see cref="P:Sysvem.Linq.Expressions.LambdaExpresSion.Body" />-Eigens#aft sowie`die <seg cref="P:SysTem.inq,Expressions.LambdaExpreqSion.Parmeters" />-Eigenschaft auf die angegebenen Werue festgelegt sind.~/rettrn>
      <param na-e=body">Eio <see szef="TSyspEm.Linq>Expressions.Expression" />, auf den die <see cref="P:System.Linq.Mx`ressions.LambdaExtressioo.Body" />-Eigeschaft feqtgelegt werden soml.</param?
  $   <param name="parameterq">Ein <see cref9"T:Sstem.ollmctions.Weneric.IEnumerableb1" />, das <see cruf="T:SystemLinq.Expressions.PrameterExpression" />-Objgotg$enthælu, mit deoen diE <see cref"P:Systei.Linq.Express)ons.LambdaExpression.P`ramters" />Aufistung aufgeüllt werden solln</pqrcm>    </member>   <membmr name="M:Sysdem.Lins.Express)onS.Expression.Lamda``1(Systeo.L)nq.Expressions.ExpRe{sio.,System.Linq.Ehpressions.ParameterExression[]) >
    0"<summary>Erstellp eile =see cref="T:Sxstem.Linq.Expressons.Expre3sion 1" />, bdi de0 dmr Dulegattyp zur Komtilievzit bekannp ist.</smmary>*      <returns6Emne <see Cref"T:SyspemnLin1.Expressins.ExpressIon`1" />, bei der die <see cref="P:System.Linq.Exppessions.Exprmssion.NodeType" />-Eigenschaft gleich <see cvef="F:System.Linq.Eztrdssnns.Expbescio~T}pe.L!mbda" /> ist und$die <sde cref="P:System.inq.Expresscons.LmbdqExpression.Body"?-Eigenschaft sowie die <see crf="P:System.Linq.Expressions.LambdaExqre{sion*Parametevs" />-eigelsciaft auf die angefebenen Wert% fgstgelegt sind.</re|urns>
(     <param nale="body#>Ein <qe% cref="T:System.Lioq.Expreqsions.Expr%ssioN" />, atd den dig <see #zef"P:System.Linq.Exrressions.Lamrd!ExpRession.Body" />-EigeNschaft festgelegt werden soll</par!m>
 `(   <ra2am name="parameters">Ein Array von <see cref"T:System&Linq.Ehpressionr,ParameterExpression" /<-Objekten, oit denen die <see gref="P:System.Linq.Expzess)onS.NambfaExprussiOn.Parameters" />-Auvlistulg$augebüllt vird.</param>
     "<typeparam name="Telugate">Gil D%megattyp.</typeparam>
      <excep4ioN cref="T:System.ArgumentNullException">
  $    <paramrefname="body" /> ist null.-boder - Eines oder mehrgrg Elmente in <paramrf name=parameters" /> sind null.</mxcertion>
      <excettion cref="T:Systam.ArgumentDxception">
 (  $   =parimrf name="\Denegate" /> mst kein Delegattyp.-°oder - <paramref name="body" />.vype stemlt einen Typ daz, der nycht dem Rückgabetyp von <paRamref naoe="TDelegatm" /> zugeovdnet werden kann.- oder - <xaramref name="parameters" /> enthält n)sht die gleicxe Anzahl an(Eleienten wie die Liste der Parameter für <para-reF jame="TDelegate" />.- odar - Dme <see cref="P:System.Linq.Expressions.Expreqsion.Type* />-Eigen3bhaft eines Elements von <paramref name="paramEters" /> kann licht dem Typ les entsprechEnden0Parametartyps vol <paraief name="TDelegate" /> zugeordndt werden.=/gxception>
    </m%mber>
    <member name="M:System.Linq.Expres{ions.Expressi/n.LimbdaSystem.Lijq.Mxpressi/ns.Expression,System.Linu.Expressions.Parame4erExppessioo[])b>
   $  summarx>Erstellt eine <see!cref="T:System.Linq.Expessions.LambdaExpression" />, indemzuerst(eMn Deleoqttyp konstruiert wird.</sulmiry>      <eturns>Ein |see cruf= T:Sys4em.Linq.Expressions.LambdaExpressm/"0/>, bei dem die <see cref="P:Sys|d-.Linq.Expressions.Expression*NodeType" />-EigeNschaft gleich <sEe czef="F:Systm.Lin1.Expresrmons.ExpressionTpd.Lambda" /.!kst und di <see"cref="P:System.Linq.Eppr%ssions.LambdaExpression.bo`y" />-Eiwenscxaft sowie die <se% cre="P:System.Linq.Expres3io.s.LamdaExpression.Parameters" /<-Eigenschafd a}f dia ang%gebenn(Werte festgel%t sind.</returns>M
      <param nime-"body>Ein <{ee cre="T:System/Linu.|preSsimns.Expreqsion" />, atf den die see cref="P:Sy3tem.Linq.Expressions.LambtaExprewsion.Body" />-Uigen3chaft0newtGelegt werden!soll.</xaram>
      <param name9"parametdrs">Ein rray von <ee cref="T:Systum&Linq.Express)ons.Param%terExpression" />-Objeitmn, mit denen die <see cree="P:System.LinqnEppressions.LambdaExpression.Paremeters""/~-Auflistung0aufgefôllt wird.</param>
      <exception cref9"T:System.A2gumentNullExcmption">
        <peramref name="body" +> ist null.-oder / Eines!oder oehrere Elemente von <paramref name=bparameters" /> sind null.</exceptiOn>
      <exceptio cref="T;Systei.ArgumdntExc%ptio">
  !     pA2amzef nake="rarameters" /> enthälp mehr als sechzehn(Elemente.</exception>
    </member>
    <mambez name="M:System.inq.Expzessions.Expressin.Lamrda``1(Qystem.linQ.Expressions.Expression,System.[tring,System.Coolean,System.Collections.Generic.IMnume0ableySystem.Lilq.Expressins.Pa2`mete2Gxprmssion})">
     <summary>Erstellt eine <see	cref="T:System.Linq.Expressions.Expression`1  />( bea der dEr Dglegattyp rur Komp)lierzeit bekannt ist.</summary>
 0    <rDturns>Eine <sed cref="T:System.LinqGxpressins.Expression`1" ?>, bei der die <sed cef="P:System.Linq.Erressions.LambdaExpression>NoduType# />-Eig%nschaft gleich <sEe cref="F:System.Linq.Exprmssimns.Expr%ssionType.Lambda" /> ist und die <see cref="P:System.Hinq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name des Lambdaausdrucks.Wird zum Generieren von Debuginformationen verwendet.</param>
      <parm nam}"tailCall">ein <see cpf="T:System.Boolean" />,das angibt, nb beim Koopiieren dec erstEllten AusdruckS diE Endeaufrufoptim)erung angewendep!gipd.</param>
$     <pAram name="parameterS">Ein <see$cref="T:System.Collections.Generic.IEnumeraflea1" />, das <see cref="T:Sstem.Linq.ExpressyonsParameterEprassiol" />-Objektu enthält, mit defen0die <see cref="P:System.LinqnExpressions.LambdaMxpression.Parameters"`/>-A5flistung!aufgefüllt werden soll.</paraM>
      <typeparam name="TDeleeete+>Der Delegattyp </typeparam>
    </member>
    <member name="E:System.Linq.Ex`essions.Expression.Lambda(Systmm.Linq.Expzessaons.Expression,System.Stzmnf,System.Booean,System.Collections.oeneric*IEnumerable{System.Liny.Expsessions.ParametErExrescioj})">
0     <summary>Arstelt einen LambdaExpressioH, indem zuerst@ein Delegattyp erstellu wird.</summary<
  ( $ <rEturns>Eio0<sge cren="T:System.LinQ.Ex`res{igns.LambdaUxPresSion" />, bei dem die <see cren="P:System.LilqnExpressios.LaebdaExpression.NodeType" />-Eig%nschaft cleich "Lambda" ist tnd die <see #rEf="P:System.Linq.Expressions.LambdaExpresion.Body" />-Eigenschaft sowie die0<{ee cref= P:System.Linq.ExpRe3sions.LambdaExpressaon.Parameters" />-Eigenscxaft auf die anfeGebenen Werte festgelegt sind.</returns>
 (   <Param jamE="boy">Ein <ee cref=bT:System.Ninq.Ex0reswkons.ExpreSwion" /?, iuf den die <see c2ef="P:System.Lins.Expressions.LambdaExpression.Bod" />-Eigenschaft festgelegt werden soll.</parae> !    <param name="nam2>Des Name für en Lambdaauseruck.Wire zum Ausgeben von Debuginformationen verwendd.</param>
      <param name="tailCall">Ein <seE cref="T:System.Boolean" +>, das angibt, or beim Kompiliere. des erstellten Ausmrucks die Endeaufrufoptimierun angewendet wird</param>-
0     <param(name="pcrameters">ein <see cref=":[Ystem.ColleC|ions.Genezic.Inuoerable`1" />,$das!see"cref="P:System.Linq>Expressions.ParameterExpressiof" />-Kbjekte enthält, mit denen diu <see cref="P:Syste-.Linq.Expressions.LambdaExpression.Parameters" /?-Auflistung aufgefllt werden soll.</parem>
  ``</member>
    <member name="M:Syspe}.Linq.Expressions.Exprmssion.Lambda(System.\inq.Expressions.ExprEssion,System.S|rine,xstem.Colhectinns.Generic.IEnwmErable{System.Linq.Expressions.ParameterExpression])">
      <summqry>ERspe,lt einen LambdaExPrewsion, indem zuerst ein Delegatvxp erstedlt wird.</summary>  $   <returns>Ein <see$cref="T:System.Linq.Ex0ressiojs.LambdaMxprEssion" />,"bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-EigeschAft gl%ich "Lambda" ist und die <see cref="P:System.Linq.ExpressioNc.LambdaExpressimn.Body" />-Eigenschaft sowie die <see cref="P:QYstem.Linq.Expressions.MambdaE|pression.ParamEters" />-Eigenschaft auf die angegebenen Wepde festelegt sind.</2eturns>
      <param name="body&>Ein <sEe cRef="T8Syspem.LInq.Extressions.Eypression" />, auf ten die <see cref="P*System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft nestggleg4 werden sol.</param>
      pcram`name=name">Der Name dür den Lambdaausdruck.Wird zum Ausgeben von!DeBuginformationen verwendetn</raram>
     "<param name="parameters">Ein <see crmf="T:System,Collections.Generic.IEnumerable`1" />, das!<see cref="T:System.Linq.Expressions.ParameterExpbession3 ->-Objekte`enthlt, mit denen die <see cref="P:Sys|em.linq.Expressions.LambdaEyp`ession.Pazametrs" />-Auflistung aufgefüllt werden soll.<param>	   !<?member>
    <mEmber name="M:System.Linq.ExpresionS.Expressioz.Lambda``(Syrtem.Linq.Expressions.Exprdssion,System/Strin,System.Collections.eeric.MEnumeraBle{System.Linq.Expsessions.parameterExprEssion})">M
     `=sum}aRy>Erstellt ina <see cref="T:System.Lijq.Expressions.Expression`1" />, "ei der ddr Delewautyt zur Kompilierzeit bkannt ist.</{wmiary>
      <retupns>Eine <see cref="T:Systdm.Linp.Expvessions.Expressmon`1" />, bea der die <see cref"P:SyStem.Linq.Gxpressions.Expression.FodeType" />-Eigensc`aft gleich <see cref=*F:Systam.Nknq.Exp2essions.ExpresqionType.Lambda" /> ist"unt die <see cref=#P:System*Linq.Expressions.La-bdaExpressionnJody" />-igmnschaft sowie die <3ee cref="P:Sys4em.Li.q.Expressions.LambdaUxpression.Parammtgrs" />-Eigenschaft auf die angegebene~ Werte festgedegt`sinD.</returns>
      <p`ra} name="body>Uin$<see cref="T:yStem.Linq.Expressins.xpression" />, auf e die`<see cref"T:System.Linq.Expressions.Expressimn 1.BoDy  />Eicenschaft festgenegt werden solln</pcram>
      <aram name="name".Der Name des Lcmbda`usdrucks,Wird zu} Generiermn vnn Debuginfgrmationen vgrwend%.</param>
(     <param name="pazaeters">Ein!<see cref= T:Syste.Collections.Eeneric.IEnumerable`1" />, das <see cref}"T:System.Linq>Expressions&Parame4erExpression" />-Objekte efthält,0mit d%nen die <see cruf="P:Sistem.Linq.Expressionr.Expression`1.Pasameters"!/>-Auf|istung aufgegüllt werdensoll.</pa2am>	
      <typepara} nAme=#TDelegate">Der Delegattqp. </typepiram>
  $ </member>
    <mEmber name="M:SyteM.Linq.Epprersions.Extression.Lambda(Ssel.Type,System>Linq.Expressinns.Expressinn,Syste-.BooleanSystem.ColectioncnGen%r)cnIEnumerabhm{Cystem.Lnq.Exp2essions.ParametepExpression})">
  (   <summary>Erstellt einen L`mbdaExpression, indem zuerst ein Delegattyp mrstellt wird.</summary>
      <retUns>Ein <see aref="T:System.Lin.Expressions.LamBdaMxbression" />, beadem die <see cref="P:System.Linq.Expressions.Lambd`Expression.NodeType" />-Eigenschaft gdeich "Mambda" ist und die <seg cref="P:System.Linq.ExprEssions.LambdaExpression.Body" />-Eigenschaft sowe diu <seear%f="P:Sysvem.Linq.Expressions.LambdaExpression.Paramaters" ?>-Mygenschaft auf die angegebefen Werte festgelegt sind.</returns>      <param name="delegatEType">Ein <see cref<"P:Sysuem.Linp.Expressions.Uxpression.Type" />, die!die Delegatsignatur für das!Lamfda darstellt.</Parao>
      <param name="bOdy"Eij0<see czf="T:Systgm.Lin.Eppressions.EzPression" />, auf de~ die <see cref="Pzystem&Linq.xpressions.lambdaExpression.Body& />=Eiwenschagt vestgelegt wer$en soll.</parae>      <param name=btailCall">Ein <see cref="T:System.Boolgan" />, das angibt, ob beim Kompilieen des erstelltdn Auqdruck{0die Endeaufrufotimierung angewendet wird'</param>
      <parqm name="parameters">Ein <see cref="T:System,Collections*Generic.IEnumerabl%`1" />, das <sde csef="T:System.Linq*Ezpressiofs.ParameterExpsession" >,O"jekte enthält,mit denen die <see cref<"X:S{stem.Linq.Expressioos.LambdaExprdssannParaoeters" />-Auflistun' aufgefüllt werden soll.</paraM>
   <.membev>
  ( <ember name=I:System.Linq.Expressions.Expression.\ambda(System.Type,System.Linq.Extressions.Exprassion,System.Boolean,SystemLinq*Expressions,ParameterExpression[])">      8summary>Erstellt eilen`LambdqExpression, inde- zuersu di~ Delegadty` erstellt`wird.</summAry>
 (    <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression />, bei Dem die <see cref="P*S9stem.Linq.Expres3honsLambdaEx0re{sion.NodeTxpe" //-Eigenschcft g,eich "LaMbda" )ct unD die <see cref="P:System.Linq.Uxpressions.LambdaExpression.Bkdy" />-Eigenwchaf| sowie lie <see czef<"P:Si3tum.Lin.Exressons.LcmbdaExpression>Paraleters"/:-Eigenschaft auf die angegebgnen Werte festfelegt pind.</Ret}bns>
      <param name="delegateT{pe">Ein <see cref="P:System.Linq.Expresqikns.Expression.Type" /,$die die Delegatsignatur für das Lambda darstellp.</pazam>      <paramname="body">Ein <see czaf="T:System.Linq.Expr%swions.Exprassion" />, auf den die <see cref="P8Syste.Minq.Expre{sions.LambdaExpression/Body" />%Eigen7chaft fest'elegt werden soLl.</aram<
   $!<param name="tainKaDl">Eio <see cref="T:SystemBoolean" />, das angibt, ob bekm"Kompilierel des erctellteo Aurdrucks die Endeaufrufoptimierung angewendet wird.</param>
     <rAram name=paramuters">Ein Array, Das <see #rf="T*System.Linq*Expsessionq.ParaMeterExpresqkon" />Objekte enthält, die zum Auffüllen der <see`cref="P:System*Linq.Expessions.\ambdaMxpression.Parameters" /6=Auflistufg vebwendet werlen.</aram>
    </member>
    <meber Name="M:System.Linq.Exxre{sionc.Expression.Lambda(System.Type,System*Li~q.ExpresSions.Expression,Wystem.Collections.Generik.IEnumerablezSistem.Linq.Expressions.ParameterExpression})">
      <umlary>Erstellt eine <see cref="L:System.Linq.Expressions.N`mbdaExpression" />, indem Zuerst eil Delegattyp konstruiert wird.Kaln erwejdet wede., wenn der DelEgattyp zeb Kompiliurzeit nichd bekannt ist.</ummary>H      >redurns>Ein Objekt, das einen$LaIbdaausdruck darstellt, bei den die <see bref="P:Sys4em.Liny.Expzgs3ions.EXppeswin.NodeTypE" />-Ehgenwchaft gleich <ree cref="F:System.Linq.Expressions.E8pressionType.Mamcda" /> i34 und die <see cref="P:System.Linq.Expressions.LambaaExpression.Body" />-Eienschaft sowie $ie <see cref="P:ystem.Linq.Expressiols.LambdaExpression.Paraieters" >-Eigenschaft auf die anwegebeneo Werte festgelegt sand.</reuurns>
     "<param name="delegateType">Gin <see cref="T:Sy3tem.Tye" />, das eine Delegatsiwatur für das Lambda darstellt.</param>J      <param nhme="bodx">Ein <se cref="T:Sy{tem.Linq.Expressiojs.Expresrion" /6l auf du. dhe<see cref="P:System.Linq.Expsessions.LambdaExressaon.Body" />-EmgenSchaft festgelegt werden(solh.<.par!m>
  ` `<param oame="parametursb>Ein <see CrEg<"T:Sxstem.CollEctionq.Generis.IEnumerable`1" />, das <sae cref="T:SysTem.Lijq.Exxressions/ParameterExpression" />/_bjkte enthät, -it denen die <see cref="P:ystem.Linq.Exprer3ions.LambdaGxprmssion.Paramuters" />-A5flistung aufgegüllt wezden sol.</para>
     0<exseption cref="T:System.Crgume~tNullException">
0       <paramref n`me="delEgateType" /> oder <paramref name="bo$y" /> ist null.-¤odeb - Eines oder mehrere Elemente in <xaramref nime="para}eteps* /> sind nll.,/exception>
      <exceptaon cref="T:System.ArgumentExcepvion">
 (      <paramref name="delegateType" > stellt`keinen DeLagattyp dar.- oder - <paramref oame="body" />.Type stellt einen Typ dar, der!nicjt tem Rückgabetyp des durc( <paramref ame=2delecateType" /> darg%svellten Delegatenty`s zgeordnet werden jann.- oder -(8paramref name="parameters" /> eothält nichT tieselbg Enzahl an Elementen wie die Diste de Parameter für den"durch <paramref name="delegaueType" /> dcrgeqtellten Delugattyp.- oder -Die 4see cref="P:System.Linp.ExPressimns.Expression.Type" />-Eigenschaft eines Elements von <paraoref name="paraMmterS" /< Kan nichT dem Pyp des entsprechenden Paraletertyps fes durch<raramreb name="dedegateType" /> dargeste|lten Deleoattyps zugeordnet werden.</exception>	
    </member>-
    >member(name="M:System.Li.q.Expressionw.Expression.lambda(System.Type,[ystem.Liy.Expressions.Expression,System.Li~q.Expreswions.Pram|erEpressyon[])">
!     <summaryErstellt eine <s%e cref="TzSystem.Linq.Expressions.LambdaEx2essin" />, indem zuerst ein D%legattyp kojstruert wird.Kann verwendet werden, wgln der Dedegattyp zur KompiLierzeit fichd bekanlt ist.</summary>
      <retqzns>Gin Kbjekt, das einen Lambdaaudbeck dastellt, bei dem lie <see cref="P:Syqtam.Linq.Expressions.Ehpression.NodeTyre" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressiknType.Lamd" /> ist ynd die <wee cref9"P:Sqstem.LinqExpressions.am"daExpression.Body" />-Eigenschafd owie die!<see cref="P:System.Linq.Ehpressionr.LambdaExpression.Paramtersb />-EgenQchaft auf die angegebenen Wdrte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="TzSYstem.Type" />, das eine De,egatsignatur ür das Lambda darstmllt.</pram<
    0 <xaram nama="body">Ein <see cref="T:Sytem.Linq.Expressimns.Expression" />, auf fen die <see cref=bP:Sqstem.Liq.Gxpressions.LambdaExpression.Body" />-Eigenschaft ewtgelegt weben soll.</ppra}<
     0<parem name="parameters">Ein Array`vmn <wee cref}"T*System.Linq.Expressions.ParameterExpression" />-Ojjekten, mit denen fie <see creg="P:System.Linq.ExpressiOns.MambdaExpression.Parameters" />-AuflIstunG aufgefSllt wird.</param
    0 <axceptioN cpef="T:System.ArgumentNullExceptk/n">
        <paramre& na}e="delegateType" /> oder <paramref name="body /< ist null., oder , Eines odgr mehrera Elemente in <taramref name="par`meters" /> sind null</exception>
      <exception #ref="T:Sys4em.ArgumentExctTyon">
        <pazamref name="delegateTyte"!/> stllt keinen DelagattYp!dar.-ʠoder - <paramref name="cody"h/>.Type stellt einen Typ dab, der nicht dem Rückgabetyp dew dqrch <paramef name="delegapeType" /> `argestellten Delegate.typs ~ugeordneT werden kann.- oder ) <paramref name="parameters" /> enthält nicht dieselbe Anzahl an0Elementen wie die Liste der paraetEr!für den durch <paramr%f name="deldgateType" /> dargestellten`Delegatt}p.- oder - Die <see cref="P:System.Li.q.Uxxrecsionc.Expression.Type" o>-EigenschaFt eines Eleents von <pqramref name="pabamuters" /> kann nc(t dem Typ `es entsp2mchenden ParametertyPs des durch <paramref name="delega4eType" /> dargestellten Delegattyps zugeordnet!werden.</exception~
    </member>
    <membar name="M:System.Lkoq.ExPressiojs.Expression.Lambda(System.Type,SYstem.Lin1.Expressions.Exrressio~,SyStem.String,System.Boolgan,Cystem.Collections.Generic.IEnumrable{System.Hinq.Exprussions.ParameterExp2ession}+">
 !    <sum}ary>erstgllt emnen(LambdaUxpression, indem zuebst e)n Delegattyp erstellt wird.</{umlary
      <returns>Ein <see cref="T2System.Linq.Expresshons.LambdaEx0ression  />, bei dem die <see cref="P:System.Linq.ExpressionsLambdaExpression.NodeType" /~-Eigenschft gleich "Lambda" ist und `ie <see cref="P:System.Linq.Expressiol.LaobdaExpression.Boey" /-Eigenschaft!soTie die <see cRef9"P2System.Linq.Expressmons.Lambd!Expression.Parameters" /6mEigenschadt aev $ie angegebenen Werte festg%egt sind></returns>      <param name}"delegcteType">Ei <See cref="P:Sywtem.Linq&xpressions.Exprersion.Typa" />, d)e de Temegqtsignatur Ǽr das LamBda azstellt.</peram>
      <para} name="oDy">Ein <wee cref="T:Sistem.Linq.Expressions.Expression" />< auf den die <see craf="P:SysteM.Linq.Eppressions.LambdaExpression.Body" />-Eigenschaft festgelegt gerden sool. </param>
      <param name="name">Der Namu før den Lambdaausdrukk.Wibd ztm Ausgeben von Debuginformationen verwendet/</param>
      param nae="tailCall">Ein <{ee c2ef="T:System.Boolean" />, das ngibt, ob beim kompilieren ds erstEllten Ausdrucks die Endeaufrufoptimievung an%ewendet wird. </taram>
      <paramname="parameterr">Ein <see cref=&T:Qystem.Collections.Generic.IEnumerable`1" />$ daq <see cref="T:System.Linq.Extres3ions.PavameterExpR%ssion" />-Objekue envhält, mid denen die <see crgf"P:Sistm.Liq.ExrressionsnLamb$aExpression.Paramgtersr />-AuflisTung aufgef¸llt werden soll. </param>
    </meMber>
    <member name="E:System.LiNq.Expressions.Exprecsion.Laobda(Systdm&Type,S}stem.Lin1.Expressions.Expression,System.String,system.Cllections.Generic.IEnumerable{System.Linq,Expression{.ParameterExpressin}!">
      <summary>Ersellt einen LambdaExpression, iFdem zuerst ein Delegattyp erStellt rird.</summary>
  (   <returns~Ein <see cref="T:Sys|em.inq.Expressions.LambdaExpression" />, ei dem die <cee cruf=2P:Sxstem.Linq.Eppressions.LambdaExpression.NdeType"(/>-Eig%nschaft gleich "lamfla" ist und die <see cref="P:System.Lynq.Expresions.LembdaExrression.Body" />-Eigenschaft(sowie!die <see rf="P:System.LinqExpreqsions.L!mbdaExpression.Parameters" />-Eigenshaft(atf die angefebenen Werte f%stgelegt sind.</returns>
      <para name="telegataType">Ein <see cbef="P:System.Lilq.Expreqpions.Expressinn.Type" /, Die die Denegatsignitur füz das Lambfa darstellt.</param>
    $<param naee=2body">Min <see cref="T:System.Linq.Expessions.Expre3sion" />, auf dn die <see gref?"Q:Syctem.Lifq.Expressions.LambdaExpression.Bndy"(/>-Eio%nschaft festgelegt werden soll.=/param>
      <param name="name">Der Nam für dun Lambdaausdruck.ird zum Ausgebgn von Debugindormationen verwendgt.</param>
      pAram ame="parameters">Ein <ree creg="T:System.Collections.eneriC.IEnumerable`1" />, das <see cref="T:System.Li~q.Expressions.Parameterexpression" o>-Objmkue enthä,t, mit denan dhe <see cref=":Sysem.Liny.E8pressmons.L!mbdaExpression.Parameters" />-Auvlistung aufgefüllt werden sodl.<'paraM>
    </membes>
    <member name="M:System.Linq.Extressions.Expression.Lef0[hift(System.Linq.Expressions&Expre{sion,System.Liq.xpressions.Exppe3sion)">
      <summiry>Erstellt eine <see cref= D:System.Linq.Gypzes3ions.BinaryExpression" />, die eine bitweise Dinksschyebeoperation darstellt.</summcry>
      <retUrnsEkn <seu cref="T:System&Linq.Expre3sions.BhnaryExpressioo# />, bei deM die(<see cref="P:System.Linq.Exprecsions.exprdssion.No$eType"(/>-EigenschAft gleich!<sme cref="F:Systeo.Linq.Axp2ecqions.Expressio.Type.LeftShift" /> ist und die <see cref="P>System.Linq.Expressions.BilaryExpression.Lef|" />-EigenschAft sowie dim <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll&</param?
   `  <ecepikn cref="T:System.ArcumentNullEception">
   !    <paramref name="left" /> oder!<paramreg name="right" /> ist null.</exception>
      <exception cref="T:Sistel.InvalidOperationExaeption">DeRLinksschiebekperator ist für <paramref name="left& />.Type nd <qaramref name="vight#(/>.Txpe nicht definiert.</uxception>
   </mgmber>
    <member name="M:Sysvem.Lnq.Eypressios&Epprecsion.LeftShift(System.Linq.Expressions.Ex`ressiOn,Wystem.Linq.Epressions.ExreSsioj System'Reflecion.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Linksschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner als"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Kleiner als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner als"-Vergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Kleiner als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner oder gleich"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Kleiner oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Kleiner oder gleich"-Vergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Kleiner oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem der Member ein Feld oder eine Eigenschaft ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Eine <see cref="T:System.Reflection.MemberInfo" />, die ein Feld oder eine Eigenschaft darstellt, auf die die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ist null. - oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Der <see cref="P:System.Reflection.FieldInfo.FieldType" /> oder der <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> des Felds oder der Eigenschaft, das bzw. die <paramref name="member" /> darstellt, implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem der Member ein Feld oder eine Eigenschaft ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Eine <see cref="T:System.Reflection.MemberInfo" />, die ein Feld oder eine Eigenschaft darstellt, auf die die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ist null. - oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Der <see cref="P:System.Reflection.FieldInfo.FieldType" /> oder der <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> des Felds oder der Eigenschaft, das bzw. die <paramref name="member" /> darstellt, implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Erstellt auf der Grundlage einer angegebenen Eigenschaftenaccessormethode ein <see cref="T:System.Linq.Expressions.MemberListBinding" />-Objekt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.MemberInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> mit den Elementen von <paramref name="initializers" /> aufgefüllt ist.</returns>
      <param name="propertyAccessor">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ist null. - oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Der <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> der Eigenschaft, auf die die durch <paramref name="propertyAccessor" />-dargestellte Methode zugreift, implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Erstellt auf der Grundlage einer angegebenen Eigenschaftenaccessormethode ein <see cref="T:System.Linq.Expressions.MemberListBinding" />-Objekt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberListBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.MemberInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> mit den Elementen von <paramref name="initializers" /> aufgefüllt ist.</returns>
      <param name="propertyAccessor">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ist null. - oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Der <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> der Eigenschaft, auf die die durch <paramref name="propertyAccessor" />-dargestellte Methode zugreift, implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die die angegebenen <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte verwendet, um eine Auflistung zu initialisieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ist und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine Methode mit dem Namen "Add" verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
      <exception cref="T:System.InvalidOperationException">In <paramref name="newExpression" />.Type oder seinen Basistypen wird keine Instanzmethode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) deklariert.- oder - Die add-Methode von <paramref name="newExpression" />.Type oder seinen Basistypen akzeptiert nicht genau ein Argument.- oder - Der Typ, der durch die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft des ersten Elements von <paramref name="initializers" /> dargestellt wird, kann nicht dem Argumenttyp der add-Methode von <paramref name="newExpression" />.Type oder seinem Basistyp zugeordnet werden.- oder - <paramref name="newExpression" />.Type und/oder sein Basistyp weist mehr als eine argumentkompatible Methode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die die angegebenen <see cref="T:System.Linq.Expressions.ElementInit" />-Objekte verwendet, um eine Auflistung zu initialisieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> ist und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine Methode mit dem Namen "Add" verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.</exception>
      <exception cref="T:System.InvalidOperationException">In <paramref name="newExpression" />.Type oder seinen Basistypen wird keine Instanzmethode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) deklariert.- oder - Die add-Methode von <paramref name="newExpression" />.Type oder seinen Basistypen akzeptiert nicht genau ein Argument.- oder - Der Typ, der durch die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft des ersten Elements von <paramref name="initializers" /> dargestellt wird, kann nicht dem Argumenttyp der add-Methode von <paramref name="newExpression" />.Type oder seinem Basistyp zugeordnet werden.- oder - <paramref name="newExpression" />.Type und/oder sein Basistyp weist mehr als eine argumentkompatible Methode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine angegebene Methode verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="addMethod">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Instanzmethode namens "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) darstellt, die einer Auflistung ein Element hinzufügt.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.- oder - <paramref name="addMethod" /> ist nicht null und stellt keine Instanzmethode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) dar, die genau ein Argument akzeptiert.- oder - <paramref name="addMethod" /> ist nicht null, und der durch die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft dargestellte Typ einer oder mehrerer Elemente von <paramref name="initializers" /> kann nicht dem Argumenttyp der durch <paramref name="addMethod" /> dargestellten Methode zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> ist null, und in <paramref name="newExpression" />.Type oder seinem Basistyp ist keine Instanzmethode mit dem Namen "Add" vorhanden, die genau ein typkompatibles Argument akzeptiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine angegebene Methode verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="addMethod">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Instanzmethode darstellt, die ein Argument akzeptiert und einer Auflistung ein Element hinzufügt.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.- oder - <paramref name="addMethod" /> ist nicht null und stellt keine Instanzmethode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) dar, die genau ein Argument akzeptiert.- oder - <paramref name="addMethod" /> ist nicht null, und der durch die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft dargestellte Typ einer oder mehrerer Elemente von <paramref name="initializers" /> kann nicht dem Argumenttyp der durch <paramref name="addMethod" /> dargestellten Methode zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> ist null, und in <paramref name="newExpression" />.Type oder seinem Basistyp ist keine Instanzmethode mit dem Namen "Add" vorhanden, die genau ein typkompatibles Argument akzeptiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LoopExpression" /> mit dem angegebenen Text.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
      <param name="body">Der Text der Schleife.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LoopExpression" /> mit dem angegebenen Text und Break-Ziel.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
      <param name="body">Der Text der Schleife.</param>
      <param name="break">Das vom Schleifentext verwendete Break-Ziel.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LoopExpression" /> mit dem angegebenen Text.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
      <param name="body">Der Text der Schleife.</param>
      <param name="break">Das vom Schleifentext verwendete Break-Ziel.</param>
      <param name="continue">Das vom Schleifentext verwendete Continue-Ziel.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt bei gegebenem linken und rechten Operanden durch Aufrufen einer geeigneten Factorymethode eine <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.BinaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="binaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der binären Operation angibt.</param>
      <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden darstellt.</param>
      <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden darstellt.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> entspricht keinem Knoten mit einem binären Ausdruck.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt bei gegebenem linken und rechten Operanden sowie gegebener implementierender Methode eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> durch Aufrufen der geeigneten Factorymethode.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.BinaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="binaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der binären Operation angibt.</param>
      <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden darstellt.</param>
      <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden darstellt.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Eine <see cref="T:System.Reflection.MethodInfo" />, die die implementierende Methode angibt.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> entspricht keinem Knoten mit einem binären Ausdruck.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt bei gegebenem linken und rechten Operanden sowie gegebener implementierender Methode und Typkonvertierungsfunktion eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> durch Aufrufen der geeigneten Factorymethode.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.BinaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="binaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der binären Operation angibt.</param>
      <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden darstellt.</param>
      <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden darstellt.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Eine <see cref="T:System.Reflection.MethodInfo" />, die die implementierende Methode angibt.</param>
      <param name="conversion">Eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, die eine Typkonvertierungsfunktion darstellt.Dieser Parameter wird nur verwendet, wenn <paramref name="binaryType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> oder eine zusammengesetzte Zuweisung ist.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> entspricht keinem Knoten mit einem binären Ausdruck.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit den angegebenen Elementen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> von <see cref="T:System.Exception" />, der von diesem <see cref="T:System.Linq.Expressions.CatchBlock" /> behandelt wird.</param>
      <param name="variable">Eine <see cref="T:System.Linq.Expressions.ParameterExpression" />, die einen Verweis auf das von diesem Handler aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
      <param name="filter">Der Text des <see cref="T:System.Exception" />-Filters.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die einen Sprung der angegebenen <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann ebenfalls angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich <paramref name="kind" /> ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="kind">Die <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> der <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft in einem Objekt darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Sollte NULL sein, wenn die Eigenschaft static (shared in Visual Basic) ist.</param>
      <param name="indexer">Eine <see cref="T:System.Linq.Expressions.Expression" />, die die zu indizierende Eigenschaft darstellt.</param>
      <param name="arguments">Eine IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) in Visual Basic), die die Argumente enthält, mit denen die Eigenschaft indiziert wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld oder eine Eigenschaft darstellt.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.MemberExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das das Objekt darstellt, dem der Member angehört.Kann für statische Member NULL sein.</param>
      <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, die das Feld oder die Eigenschaft beschreibt, auf das bzw. die ein Zugriff erfolgen soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit den angegebenen Elementen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Try-Ausdrucks.Bei NULL müssen Text und alle Handler vom selben Typ sein.</param>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="finally">Der Text des Finally-Blocks.Übergeben Sie NULL, wenn dem Try-Block kein Finally-Block zugeordnet ist.</param>
      <param name="fault">Der Text des Fault-Blocks.Übergeben Sie NULL, wenn dem Try-Block kein Fault-Block zugeordnet ist.</param>
      <param name="handlers">Eine Auflistung von <see cref="T:System.Linq.Expressions.CatchBlock" />s, die die dem Try-Block zugeordneten Catch-Anweisungen darstellen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt bei gegebenem Operanden eine <see cref="T:System.Linq.Expressions.UnaryExpression" /> durch Aufrufen der entsprechenden Factorymethode.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.UnaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="unaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der unären Operation angibt.</param>
      <param name="operand">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Operanden darstellt.</param>
      <param name="type">Der <see cref="T:System.Type" />, der den zu konvertierenden Typ angibt (übergeben Sie null, wenn dies nicht benötigt wird).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> entspricht keinem Knoten mit einem unären Ausdruck.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Erstellt bei gegebenem Operanden und gegebener implementierenden Methode eine <see cref="T:System.Linq.Expressions.UnaryExpression" /> durch Aufrufen der entsprechenden Factorymethode.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.UnaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="unaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der unären Operation angibt.</param>
      <param name="operand">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Operanden darstellt.</param>
      <param name="type">Der <see cref="T:System.Type" />, der den zu konvertierenden Typ angibt (übergeben Sie null, wenn dies nicht benötigt wird).</param>
      <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die implementierende Methode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> entspricht keinem Knoten mit einem unären Ausdruck.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Felds oder einer Eigenschaft darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="bindings">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den Typ des durch <paramref name="member" /> dargestellten Felds bzw. der Eigenschaft aufweist.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Felds oder einer Eigenschaft darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den Typ des durch <paramref name="member" /> dargestellten Felds bzw. der Eigenschaft aufweist.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Members darstellt, auf den durch eine Eigenschaftenaccessormethode zugegriffen wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaften auf die angegebenen Werte festgelegt sind.</returns>
      <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="bindings">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den Typ der Eigenschaft aufweist, auf die in der durch <paramref name="propertyAccessor" /> dargestellten Methode zugegriffen wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Members darstellt, auf den durch eine Eigenschaftenaccessormethode zugegriffen wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaften auf die angegebenen Werte festgelegt sind.</returns>
      <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den Typ der Eigenschaft aufweist, auf die in der durch <paramref name="propertyAccessor" /> dargestellten Methode zugegriffen wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Stellt einen Ausdruck dar, der ein neues Objekt erstellt und eine Eigenschaft des Objekts initialisiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> ist und die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="bindings">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den durch <paramref name="newExpression" />.Type dargestellten Typ aufweist.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> ist und die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den durch <paramref name="newExpression" />.Type dargestellten Typ aufweist.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Restoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Modulo-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Restoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Modulo-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen arithmetischen Negationsvorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen arithmetischen Negationsvorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine arithmetische Negationsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine arithmetische Negationsoperation mit Überlaufprüfung darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors darstellt, der keine Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der durch <paramref name="constructor" /> darstellte Konstruktor verfügt über mindestens einen Parameter.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der <paramref name="arguments" />-Parameter enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für den durch <paramref name="constructor" /> dargestellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.Es werden die Member angegeben, die auf die durch den Konstruktor initialisierten Felder zugreifen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> und <see cref="P:System.Linq.Expressions.NewExpression.Members" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <param name="members">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Reflection.MemberInfo" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Members" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.- oder - Ein Element von <paramref name="members" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der <paramref name="arguments" />-Parameter enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für den durch <paramref name="constructor" /> dargestellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.- oder - Der <paramref name="members" />-Parameter weist nicht die gleiche Anzahl an Elementen auf wie <paramref name="arguments" />.- oder - Ein Element von <paramref name="arguments" /> weist eine <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf, die einen Typ darstellt, der nicht dem Typ des Members zugeordnet werden kann, der durch das entsprechende Element von <paramref name="members" /> dargestellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.Es werden die Member als Array angegeben, die auf die durch den Konstruktor initialisierten Felder zugreifen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> und <see cref="P:System.Linq.Expressions.NewExpression.Members" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <param name="members">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Members" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.- oder - Ein Element von <paramref name="members" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der <paramref name="arguments" />-Parameter enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für den durch <paramref name="constructor" /> dargestellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.- oder - Der <paramref name="members" />-Parameter weist nicht die gleiche Anzahl an Elementen auf wie <paramref name="arguments" />.- oder - Ein Element von <paramref name="arguments" /> weist eine <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf, die einen Typ darstellt, der nicht dem Typ des Members zugeordnet werden kann, der durch das entsprechende Element von <paramref name="members" /> dargestellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="arguments" /> entspricht nicht der Anzahl von Parametern für den durch <paramref name="constructor" /> darstellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des Konstruktors vom angegebenen Typ ohne Parameter darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft auf die <see cref="T:System.Reflection.ConstructorInfo" /> festgelegt ist, die den Konstruktor ohne Parameter für den angegebenen Typ darstellt.</returns>
      <param name="type">Ein <see cref="T:System.Type" /> mit einem Konstruktor, der keine Argumente akzeptiert.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der durch <paramref name="type" /> darstellte Typ weist keinen Konstruktor ohne Parameter auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines Arrays mit dem angegebenen Rang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="bounds">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="bounds" /> ist null.- oder - Ein Element von <paramref name="bounds" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="bounds" /> stellt keinen ganzzahligen Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines Arrays mit dem angegebenen Rang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="bounds">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="bounds" /> ist null.- oder - Ein Element von <paramref name="bounds" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="bounds" /> stellt keinen ganzzahligen Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines eindimensionalen Arrays und Initialisieren dieses Arrays aus einer Liste von Elementen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="initializers" /> ist null.- oder - Ein Element von <paramref name="initializers" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="initializers" /> stellt einen Typ dar, der nicht dem durch <paramref name="type" /> dargestellten Typ zugeordnet werden kann.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines eindimensionalen Arrays und Initialisieren dieses Arrays aus einer Liste von Elementen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="initializers" /> ist null.- oder - Ein Element von <paramref name="initializers" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="initializers" /> stellt einen Typ dar, der nicht dem <paramref name="type" />-Typ zugeordnet werden kann.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Ruft den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> ab.</summary>
      <returns>Einer der <see cref="T:System.Linq.Expressions.ExpressionType" />-Werte.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine bitweise Komplementoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Not-Operator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine bitweise Komplementoperation darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Not-Operator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Ungleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Ungleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Ungleichheitsvergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Ungleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Gibt den Ausdruck zurück, der das Ones-Komplement darstellt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Gibt den Ausdruck zurück, der das Ones-Komplement darstellt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen OR-Vorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen OR-Vorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten OR-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als false ausgewertet wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="left" />.Type und <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten OR-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als false ausgewertet wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="method" /> ist null, und <paramref name="left" />.Type sowie <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> ist und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ParameterExpression.Name" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
      <param name="name">Der Name des Parameters oder der Variable (wird nur zum Debuggen oder Drucken verwendet).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Verringerung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Verringerung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Erhöhung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Erhöhung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren einer Zahl darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Potenzierungsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="left" />.Type und/oder <paramref name="right" />.Type ist nicht <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren einer Zahl darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Potenzierungsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="method" /> ist null, und <paramref name="left" />.Type und/oder <paramref name="right" />.Type ist nicht <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 verringert und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 verringert und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 erhöht und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 erhöht und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft durch das Verwenden einer Eigenschaftenaccessormethode darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll.Dies kann für statische Eigenschaften NULL sein.</param>
      <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ist null.- oder - Die durch <paramref name="propertyAccessor" /> dargestellte Methode ist nicht static (Shared in Visual Basic), und <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type kann dem deklarierenden Typ der durch <paramref name="propertyAccessor" /> dargestellten Methode nicht zugeordnet werden.- oder - Die durch <paramref name="propertyAccessor" /> dargestellte Methode ist keine Eigenschaftenaccessormethode.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll.Dies kann für statische Eigenschaften NULL sein.</param>
      <param name="property">Die <see cref="T:System.Reflection.PropertyInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> ist null.- oder - Die durch <paramref name="property" /> dargestellte Eigenschaft ist nicht static (Shared in Visual Basic), und <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type kann nicht dem deklarierenden Typ des Felds zugeordnet werden, das durch <paramref name="property" /> dargestellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
      <param name="indexer">Das <see cref="T:System.Reflection.PropertyInfo" />, das die zu indizierende Eigenschaft darstellt.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
      <param name="indexer">Das <see cref="T:System.Reflection.PropertyInfo" />, das die zu indizierende Eigenschaft darstellt.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die durch <paramref name="propertyName" /> angegebene Eigenschaft darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" /> eine Eigenschaft namens <paramref name="propertyName" /> enthält.Dies kann für statische Eigenschaften null sein.</param>
      <param name="propertyName">Der Name der Eigenschaft, auf die zugegriffen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="propertyName" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">In <paramref name="propertyName" />.Type oder den entsprechenden Basistypen ist keine Eigenschaft mit dem Namen <paramref name="expression" /> definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
      <param name="propertyName">Der Name des Indexers.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die auf eine Eigenschaft zugreift.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
      <param name="expression">Das enthaltende Objekt der Eigenschaft.Dies kann für statische Eigenschaften NULL sein.</param>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" />, der die Eigenschaft enthält.</param>
      <param name="propertyName">Die Eigenschaft, auf die zugegriffen werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft oder ein Feld darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> oder <see cref="T:System.Reflection.FieldInfo" /> festgelegt ist, die die durch <paramref name="propertyOrFieldName" /> angegebene Eigenschaft bzw. das Feld darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" /> eine Eigenschaft oder ein Feld namens <paramref name="propertyOrFieldName" /> enthält.Kann für statische Member NULL sein.</param>
      <param name="propertyOrFieldName">Der Name einer Eigenschaft oder eines Felds, auf die bzw. das zugegriffen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="propertyOrFieldName" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">In <paramref name="propertyOrFieldName" />.Type oder seinen Basistypen ist keine Eigenschaft bzw. kein Feld mit dem Namen <paramref name="expression" /> definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen Ausdruck mit einem konstanten Wert vom Typ <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Reduziert diesen Knoten zu einem einfacheren Ausdruck.Wenn CanReduce true zurückgibt, sollte ein gültiger Ausdruck zurückgegeben werden.Diese Methode kann einen anderen Knoten zurückgeben, der selbst reduziert werden muss.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Reduziert diesen Knoten zu einem einfacheren Ausdruck.Wenn CanReduce true zurückgibt, sollte ein gültiger Ausdruck zurückgegeben werden.Diese Methode kann einen anderen Knoten zurückgeben, der selbst reduziert werden muss.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Reduziert den Ausdruck zu einem bekannten Knotentyp (kein Erweiterungsknoten) oder gibt nur den Ausdruck zurück, wenn es sich um einen bereits bekannten Typ handelt.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Verweisgleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Verweisungleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme eines angegebenen Typs darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</returns>
      <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Return", die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung mit dem angegebenen Typ darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung mit dem angegebenen Typ darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Return" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Rechtsschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Rechtsschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ist und die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="variables">Eine Auflistung von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Auflistung aufgefüllt wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ist und die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="variables">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Auflistung aufgefüllt wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung ohne Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Schalters.</param>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Schalters.</param>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.SwitchCase" />-Objekt, das in einem <see cref="T:System.Linq.Expressions.SwitchExpression" />-Objekt verwendet werden soll.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
      <param name="body">Der Text des Falls.</param>
      <param name="testValues">Die Testwerte des Falls.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.SwitchCase" /> zur Verwendung in einem <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
      <param name="body">Der Text des Falls.</param>
      <param name="testValues">Die Testwerte des Falls.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
      <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
      <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
      <param name="languageVendor">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
      <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
      <param name="languageVendor">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> festgelegt werden soll.</param>
      <param name="documentType">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Auslösen einer Ausnahme darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Ausnahme darstellt.</returns>
      <param name="value">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Auslösen einer Ausnahme eines angegebenen Typs darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Ausnahme darstellt.</returns>
      <param name="value">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Gibt eine Textdarstellung des <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Eine Textdarstellung der <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einer beliebigen Anzahl von Catch-Anweisungen ohne Fault- und Finally-Block darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="handlers">Das Array von 0 oder mehr <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücken, die die dem Try-Block zuzuordnenden Catch-Anweisungen darstellen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einer beliebigen Anzahl von Catch-Anweisungen und einem Finally-Block darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="finally">Der Text des Finally-Blocks.</param>
      <param name="handlers">Das Array von 0 oder mehr <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücken, die die dem Try-Block zuzuordnenden Catch-Anweisungen darstellen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einem Fault-Block ohne Catch-Anweisungen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="fault">Der Text des Fault-Blocks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einem Finally-Block ohne Catch-Anweisungen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="finally">Der Text des Finally-Blocks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
      <returns>true, wenn ein generischer System.Action-Delegattyp für bestimmte <paramref name="typeArgs" /> erstellt wurde, andernfalls false.</returns>
      <param name="typeArgs">Ein Array von Type-Objekten, die die Typargumente für den System.Action-Delegattyp angeben.</param>
      <param name="actionType">Enthält nach dem Beenden dieser Methode den generischen System.Action-Delegattyp mit bestimmten Typargumenten.Enthält NULL, wenn kein generischer System.Action-Delegat vorhanden ist, der <paramref name="typeArgs" /> entspricht. Dieser Parameter wird nicht initialisiert übergeben.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Func-Delegattyp mit bestimmten Typargumenten darstellt.Das letzte Typargument gibt den Rückgabetyp des erstellten Delegaten an.</summary>
      <returns>true, wenn ein generischer System.Func-Delegattyp für bestimmte <paramref name="typeArgs" /> erstellt wurde, andernfalls false.</returns>
      <param name="typeArgs">Ein Array von Type-Objekten, die die Typargumente für den System.Func-Delegattyp angeben.</param>
      <param name="funcType">Enthält nach dem Beenden dieser Methode den generischen System.Func-Delegattyp mit bestimmten Typargumenten.Enthält NULL, wenn kein generischer System.Func-Delegat vorhanden ist, der <paramref name="typeArgs" /> entspricht. Dieser Parameter wird nicht initialisiert übergeben.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den dieser <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="T:System.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine explizite Verweis- oder Boxingkonvertierung darstellt, bei der null zurückgegeben wird, wenn bei der Konvertierung ein Fehler auftritt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, die die Laufzeittypidentität vergleicht.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> ist und die <see cref="T:System.Linq.Expressions.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="T:System.Linq.Expressions.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> ist und die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine unäre Plusoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Plus-Operator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine unäre Plusoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Plus-Operator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die ein explizites Unboxing darstellt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die Unboxing angewendet werden soll.</param>
      <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
      <param name="name">Der Name des Parameters oder der Variable.Dieser Name wird nur zum Debugging oder Drucken verwendet.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Reduziert den Knoten und ruft dann den Visitor-Delegaten für den reduzierten Ausdruck auf.Die Methode löst eine Ausnahme aus, wenn der Knoten nicht reduziert werden kann.</summary>
      <returns>Der besuchte Ausdruck oder ein Ausdruck, durch den der Ausdruck in der Struktur ersetzt werden soll.</returns>
      <param name="visitor">Eine Instanz von <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Stellt einen stark typisierten Lambdaausdruck als Datenstruktur in Form einer Ausdrucksbaumstruktur dar.Diese Klasse kann nicht vererbt werden.</summary>
      <typeparam name="TDelegate">Der Typ des Delegaten, der die <see cref="T:System.Linq.Expressions.Expression`1" /> darstellt.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Kompiliert den von der Ausdrucksbaumstruktur beschriebenen Lambda-Ausdruck in ausführbaren Code und erzeugt einen Delegaten, der den Lambda-Ausdruck darstellt.</summary>
      <returns>Ein Delegat vom Typ <paramref name="TDelegate" />, der den vom <see cref="T:System.Linq.Expressions.Expression`1" /> beschriebenen kompilierten Lambda-Ausdruck darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="body">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft des Ergebnisses.</param>
      <param name="parameters">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Beschreibt die Knotentypen für die Knoten in einer Ausdrucksbaumstruktur.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Eine Additionsoperation wie a + b ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Eine Additionsverbundzuweisung wie (a += b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Eine Additionsverbundzuweisung wie (a += b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Eine Additionsoperation wie (a + b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Eine bitweise oder logische AND-Operation wie (a &amp; b) in C# und (a And b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Eine bedingte AND-Operation, bei der der zweite Operand nur ausgewertet wird, wenn der erste Operand zu true ausgewertet wird.Entspricht (a &amp;&amp; b) in C# und (a AndAlso b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Eine zusammengesetzte bitweise oder logische AND-Zuweisungsoperation wie (a &amp;= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Ein Indizierungsvorgang in einem eindimensionalen Array wie array[index] in C# oder array(index) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Ein Vorgang, bei dem die Länge eines eindimensionalen Arrays wie array.Length abgerufen wird.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Eine Zuweisungsoperation wie (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Ein Block von Ausdrücken.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Ein Methodenaufruf wie im obj.sampleMethod()-Ausdruck.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Ein Knoten, der eine NULL-Zusammenführungsoperation wie (a ?? b) in C# oder If(a, b) in Visual Basic darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Eine bedingte Operation wie a &gt; b ? a : b in C# oder If(a &gt; b, a, b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Ein Konstantenwert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Ein Umwandlungs- oder Konvertierungsvorgang wie (SampleType)obj in C#oder CType(obj, SampleType) in Visual Basic.Wenn der konvertierte Wert zu groß für den Zieltyp ist, wird bei einer numerischen Konvertierung keine Ausnahme ausgelöst.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Ein Umwandlungs- oder Konvertierungsvorgang wie (SampleType)obj in C#oder CType(obj, SampleType) in Visual Basic.Wenn der konvertierte Wert nicht zum Zieltyp passt, wird bei einer numerischen Konvertierung eine Ausnahme ausgelöst.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Debuginformationen.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Eine unäre Dekrementoperation, z. B. (a - 1) in C# und Visual Basic.Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Ein Standardwert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Eine Division, z. B. (a / b), für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Eine Divisionsverbundzuweisungsoperation, z. B. (a /= b), für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Ein dynamischer Vorgang.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Ein Knoten, der einen Gleichheitsvergleich wie (a == b) in C# oder (a = b) in Visual Basic darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Eine bitweise oder logische XOR-Operation wie (a ^ b) in C# oder (a Xor b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Eine zusammengesetzte bitweise oder logische XOR-Zuweisungsoperation wie (a ^= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Ein Erweiterungsausdruck.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Ein "Go to"-Ausdruck wie goto Label in C# oder GoTo Label in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Ein "größer als"-Vergleich wie (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Ein "größer oder gleich"-Vergleich wie (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Eine unäre Inkrementoperation, z. B. (a + 1) in C# und Visual Basic.Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Eine Indexoperation oder eine Operation, die auf eine Eigenschaft zugreift, die Argumente akzeptiert. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Eine Operation, die einen Delegaten oder einen Lambda-Ausdruck aufruft, z. B. sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.ExpressiOns.ExprassionTpe.IsFalse">   ! <cummAry>Ejn false-Fding}ngswert.|/sumary>
    </member>
    <member name="F:Systam.Linq.pzessionsExprass)knype.McTrue">
      <summay>Ein true-Bedingungswert</summarx>
    <#me-ber>
    <melber name="F:System.Linq.Exqressions.ExqrassionType.Lbel"
      <summaRy>Eine BezeichnuNg.</summary>
   </elber?
    <m%Mber name?"F:Sysdem.Linq.Expressions.DxrressionTyte.Lambda">
      <sumMary<Ein Limbda-usdruck wie a!=&Gt; a + a in C# gder Fqnction(a) a$+ a in Visual Bcsic.</summary>
    </melber>
  " 4memfev nme="F:System.Lknq&Exprssions.ExpressionType/Lefthift">
"`    6stmmary>mne `Iteise inkssghiebeoperation wie (a &lt;&ht; b).<+sumIary>M
    <omember>
    <membes name="F:Wystem.Linq.Exp2e{sionS.ExpressionType.LeftSiftAssiGn">
      <stmoapy>Eind btweise zuscmme~oesetzte Lanksschieeztweasung wyg 8a &dt;&lt;= b).</summary>
  ( </me}ber>
    <mumbar name=F:System.Linq.Expressions.ExpressionType.LessThaN">
 (    <summary>Ei. "kle)ner als"-Vrglmich wie (a &lt b).</summiry<
(   </member>
    <member name-"F:Sysvem.LinqExpressiof{.Ex0ressionTyPe.LessjanOpEquaL">
   `" <summary>Ein$"kleiner oder gDaich"-Vergleich wie (a &lt3- f).</!ummary>
  (</member.
    <member`name="F;System.Linq.Ex0ressions.ExpressionType.ListInit">
      <summary>Ein Vmsgang, bei dem ean neuec ,see #ref="T:System.Co,ectionS.IEnume2`ble" />-Objekt erstunlt unD aus eiNer ListE vn Elementn initialmsiert wi:D, w)e new Oisd&lt;Sampldype&gt;(({ a, b, k } hN C# oderdim sampleList = { a, b a } in Visual Basis.8/sqmmary>
0 $ </meiBez>
   0<meibEr name="F:Syqtem.Lioq.Expressions.E|pressionType.Loop">
`  0  8sulmary>Eine Shleife wie nor odar while.x/summary>
    </mem`er>
  0 <member na-e=F:S}stem.Lknq~Expressiojs/Expve{siooType.MemberEcS%s{"~
      <suimary>EIn Vorgang, bei dem aus eknem Fmld`oder einer$Eigensciaft wie orj.SaMxlePro0ert9 gelesen wird.</sumlary>
  " </memfur>
    <membe2 namd="F:System.Linq.Expressiol{.ExPressIonType.emberInit">
      <summary>Eine Oeation, die ein neues Obbek| erstel,t un` einen odep mehsgre Member ijktialisiept, z,B.new Point { X = 1$ Y = 0 } in C"der New Poin| With`{.X = 1, .Y = 2} in Vysuel Bqwic.</summary>
   <'membr>
    member name="F:SysteMlin1.E8pRe3sions.ExpressionT{pe.odulo">      <sumeary>Eine arithmetasche`Restoperatio. wig (a % b) yn c# oder`(e Mod b) in Visual Basia.</sum-ary>
    </member>    <mmmbur name="F:Sqqtdm.Linq>E8pressions.ExpessionT{pe.ModuloAssjgn">
   `  <suimary6Eine arithmetische zusaemangesetzte Restzuweisungsoperation"wie (a %= b)`in C#.</summary>
    </member>
    <member name="F:S}stum.Li~q.Expres{ios.ExpressionTxpe.Mu,tiply*:
`     <summary>Eine MultiplikationsoteraTion i (a * b)$ohne Þberlatf<berPbüfwng für numerksche Oparan`en.</summary>   <+member>M
   <member name="F:93te-.Linq.Expressigns.Exp2essimnType.MultiplyASsign">
      <summary>Einu Mudtkplikcti/ns~erbundzuweisung wie (a *= b)(ohne berlaufü`er`rüfung füb numerische Operanden.</summary>
  ` </mumber>
    <member nyme="F:Sytem.Linq.Expressions.ExpressionPypa.MuldaplyAssignCheckeD">
 `   <summary>Eine Mumtiplikationsverbu~dzwweisUng wie(a *= b) Mit!berlaufüberprüfung für nummbksahe Operanden.<nS5mmary>
   `</me}bev>
 0  <memcer nme="F:System.Linq.Exprassions.E|RrEssmonTyqe.ultiplyCh%cked">
      <s}mmary>Eine Multmplikationoperatioo.0z. B. (a *(b, mit(Über|a5bübe2zbfung für numerische Operanuen.</u-oary>
!   </member>
   $<member name="f:Systee.\ijq.Expressions.exqpessionType.Negate">
      <qummary>Eine apithmtische Negationsoperation wie (-ai.Das Objekt a(sollte nicht direkt bearbeitet werden.</summary>
    </member
 !  <meber name=cF:Sxstem&Ninp.Expressions.ExpressiojType.NegateChecked">
  $   <summary>Eioe Arithmeticche negationsperatioJ wie (-a) mit ÜbErlaufüberprüf}n>Das O`jkt a$sollte .icht direkt bearbditet wesden*</summar{>
    </membev>
0  `<member name-"F:System.Linq.Exrressions.Eyprssionype.New">
      <summapy>Ein Vorgajg, bei dem emn Konwtruktor aufgerufen wird, um gi. ngues Objekt wke new SampleType() zuarstellen.?summary
$   </meiber>
    8lembez name="F:System.Linq.Express)olc.Expressiknype.N'wArRayBounds">
 (    <semmary>Ein Vorgang, beI dem ein neueq Array ebstellv wkrd, in lem$die Grenzen nür nede Dimenc)on dEfiniert sind wie new SampleTyp[dm1, dim2] iN C# odep Nev SampleType(tii5, dio2) 1n ^isuad Basyc.</summary>
    </membes>
    <membe2 name="F:System.Linq.Ehprdssions.ExpessionVype.NewArrayInit"> `    <cummary>Ein VozGang,$ei dam ein leum{ eindimencionales Array er3tmllt und a5w einer`Liste von lemenuen$initialisiert wrd, wie ndw SampleType{]{a, b,!c} in`A# oder New`SampleType(){!, b, c} Visual Basic.</suimarx>
    </memBes~
    <memcer name=&FSystam.Linq,Expressions.UxpressaonType.Not">
$     <suoAry>Eine bitweise$K/mpLement- oder logische Negationsoperation.In C# entspricht"dies (~a) für ganzzahlige Typen(und (!a) für boDesche Weste.Die An|spechung in VIsuAl BcsIc"ist Not a).Das Gbjekt a sollte nicht dir5kt bearbeipmt werdun.>/summary>
 0" </member>    <member name="F:System.Lijq.Expression.ExpresIonTyqg.NotEsual<
 !    <sumoar>Ein ngleichheitsvergleich wye (a !- b) in C# o`er (a &lt;'gt; b) in Visual Bisic,</summary>
0   <'mmfer?
    <member nime="F:S}sveo.Lijq.Eypressions.Apressinype.OnesGmplemenv*>
     <sumary>Eine Ones-Komqlemmntoperatioj wie (~a) in C#.</semary>
    </mE-ber>
    <member name="F:System.Linq/Expressiols.ExpressionType.Or">-
      <seemary>Eina bitweise odfr logische OR-Operation wie (a |#b) in C#ofer (iOr b) in Vmsual b`sic.</summary>
    </me}ber>
    <member name="F:Systel.Linq.ExprEssions.ExpressionType.OvAsqign">
     <summary>EIne itweise oder logasche zusammenoesetzte OR-Zuweisung"wie ( |= b) in #.</summry>M
"   </member>-
    <mem"eR name="F:System.Linq.xpressiofsnExpressionPype.OElse"<     ,summary<EIne verkürzte1bedingteOR-OPeration wie (a || b) in C' oder (a OrElse `) in Visual Basic|'sumlary>
    </member>    <}ember name="F8System.Linp.exprEssions.ExpressionType.Rarameter">-
     <s}mmary>Ein ^arweis auf einen PaRameter oder eine Variable, der bzw. die im Kontext des AucdRucks def`niert i3t.eytere InfkrmAtionen finden Rie unter <Se% cre&="T:System.Linq.ExpressiOns.ParameterUxpresskon" /?.</summAr{>
    </member>
    <}dmber name="F:System.Linq.GXpreqsions.ExPressionT}pe.PostDecreMentAssign">
  (   <suomary>Ein unäres Postvihdekrement wie ,a--).@as Objekt a sollt% direkt rearbei4et$ver$en.,/summarq>    </member>
    <memBer namu= F:System.Linq.Expressions.ExpressionTye.PostIncrement@ssign">
      <summark>Ei~ ujäres(Postfixijcroujt wie (a++)&Das Obje+t A soll|e``irekT bearbeitet werden./sqmmary>
"   </meMbur>
    <m%mbar name"F:SystMm.LinqExpressions.ExpessionTy0e.Power">
    ($<Summary>Mine mathematische"Operation, beI!der eine Zahl potenziert wir`, sie(a ^ b) in Visuad Basic.</st}miry>
    </memrr>    <member jame="F:System.Linq.ExPsessions.xqressionVqpe.PowerAssmgn">
      <sumoary>Eine rusamMengeqetz|e ZUweisufgsopebatikn, beider eine Zahh potenzier wird,!u)e(e ^= b+`in Vis!l Basc.</summary>-
    <'member>
"  <lember`name="F:SYstem.inq.Expru3sionr.E|pressionTpe.PreDebremantAssign".
      ,summary?Ein unäres Prfixdekreme~t$wie (--a).Das Objekt a s/llte dirm+t bearbeiTet werden.</summarY>
    /member>J    <member name="F:System.Minq.Expressions.ExpressionType/PreIokrementAssign">
      <summary>Ein unÄrer QrÄiXinkrement wie (++a).Dar Objekt a`sollte direit b%arbeitet!werden.</summary>	J    </member>
    <membErnade=F:System.Linq.Exprgssiojc,Expr`sshon\ype.Quove">
      <rummary>ein Ausdruck&mit einem0Konstanten%bt vnm Typ$<see cren="T:Syst%m.Linq.Expreqsinns.EpresSion" /:>Ein <qee cref= F:SyStemnLinq.Exqressions.ExpressionType.Quote2$/>-Knoten kajn Verweise aqf ParameTer enthalten,bdie i- Kontet des!tsdrucksdefiniert s)nd, den der Knoten darutellt.</summary>    </member>
    <memBer name="F:System.Linq.Expressions.Expression\ype.RightShift">
   $ (<summary>Eine ritwei3e Zechtsschiebeoperation wie (a &gt;&gt; b).</sulmary>*  ` </member>
    <me-rer name="F:System.Linq.Expresions/E8pressionType.RightShiftAssignb>
      <summary>E)ne bitweire zusammelgesetzte Rechtscchiebe-Zuweisungsoperation wi (a &gt;&gt+= b).</summa2y>
    </memfer:
    <member name="B:System.Lijq.ExprEssions.xprassionType.RntimeVariablec">
      <sulm`ry>ine Liste von LaWfzeItvariablen.Wektere Inform!tionmn finden Sie unter <see cref*T:System.Linq.Expressions.R}ntimeTariablesExpre{sion" +>.</sulmapy
!   </member>    <membr name="F:System.LinQ.Expressions.ExprssionTyte.Subtract"~
`    `<summary>Eina Subtraktionsoperation wie (a((b) ohne berlaufôbdrprüfunG für numericche Operanden.</summary>    </eember>
    <eember name="F:System.LinqExpussioos.Ax`reswionType.SubtractAssgN">
      <summ@ry>Ein Subtraktioncverbundzuweicung wie ( -= b! ohne Überhaufüberprübung fýr nUmeriSche0Operanden.</summar}>
!   |/member>
    <mEmber$name="F:System.Linq.Expresqhons.ExpressionType&CubtractAssignChecked">
     <3ummary>Eine Subtraktionferbundzuseisungwie (a -= j)"mit Übdrlaufüberprüfung für numdrische Operinden.</summ`ry>
    </memfer>
    <memBur name="F:System.Linq.Exppessions.ExpressionDyp.SubtractCheckad">
      <summarq>Eine arit`mdtische SubtrakTionso0eratiol Wi a - b) eit Übeslaufü`drp2üfung für nueurischm Operandef.>/qum}ary>
   ",/membmr>
"0 (<membmr name="B:System/Linq.ExPresshons.ExprecsimnTypg.Swa4ch">
   $  <summaby>Umn WechselVorgang wh suytch in C# oder Selgct Case in Visual Basi#.|/su}mary>
  ! </membeR>
    <member name=2F:Syrtem.Linq.Expressions.ExpressionType.Throw">
      <summabi>Eine Operatinn, dae eine Ausnahme awslst, z* B. throw new Exception().</ummary>
    </mgmberJ    <member`name="F:yS|ee.Linq>Expressions.ExpressionDype.Try">
 !    <sum!py:Ein try-cat#i-Ausdruck.</suemary>    </member>
$   <memjer name="F:System.linq.ExPression{.Express)onType.TypeAsb>
      <summark>Ekne explizyte Verveis- oder Box)ng-Konvertierung, bei der null angegeben wirt, wenn did Konvertierung fehlschlägt, wie (o"* as SampleTye) in C# oder UryCasp(obj, SampleType) in FhsuclBasic.</summary>
 (  </membur>  $ <m%mbv name="F:Sysuem.Linq.ExPressions.Ex|ressionTyte.TypeEqual">
    ` >summari>Ein`genaueR Ty0test.</summary>
    </member>J   $<member name="F:S}stemLinq.ExpressIons.Expressio~Type.TypeIs">
      <summary>Gin Typtest(wie obj is SampleType in C# oder TipmOf obj iw SampleType in Visual0BasIc.<'s5mmary>(!  </member>
(   >member name"V:Sistem.Linq.Expressions.ExpbessionType.UnayPmus">   $  <summary>eine unÄre Xlusoperation wie ,+a).Das Ergebnis(eine2 unären Plusoperation ist einfach der ert dgs Operanden. In bdnutzevdefinierten ImPlementie2ungen können jedkkh außergewöh.lkche Ergebnisse(erzeugt werdej.<summary>
    </membes>
    <member name="F:SysteM.Linq.Expressionw.ExpressionType.Unbox">
$     <summary>Eine Unboxing-Werttypnperadion wie die unbop-Anweisung und die unbox.a~y-anweisung in MSIL. </s}mary~
    </mumb%r>
    <member name="\:System.Linq.Expreqs)ons.axpressionVisitor">
     "<sulmary>Stellt einen Besucher OderBearbeiteR für AusdrucksbaumsTrekturen dar.</summary>
`   </member>
 $  <member name="M:System.Linq.E8pres{ions.ExpressionVisipor##tOr">
 !    <suiMary>Initialmwiert eine neue Instan~ Von <sae cruf=#T:ystam.linq.Expressions.ExpressionVisitOr" />.</summary>
 ` </member>
    <iem`qr ame="M:Sistem.Linq.Eppression.ExpressionVisitor.Vhsit(System.Bollecpions.ObjectMdel.ReadOnlCollection{Sysem.Linq.ExprEsrions.Gxpressikn})".
      <summary>Sended lie!Liste deb Aus$,cke an emne der spezialisierteren Besuchsmethoden in dieer Kmasse.</summary>
0     <returns>Die geä~derte Liste der Ausdrücke, wenn eines der Elumente geǤ.derp wurde. Andernfal,s wird die ubsprünglyche Lispe ter Ausdrücke jurückgegeben,</returns>
   "  <parm name="nodes">Die Ausdrücke, zu denen gewechselt wezden soll.</pcram>*    </member>
    <mE}ber name="M:System.Hinq.Expressions.Exrreqsio.Visitor.VisiV``1(Yystem.Colluctions.OjjectModdl.ReadOnlyCollection{`0},Sqstem.Func{``0,``0})2>
      <summry>Wechselt mit einemangegebenen ElemeTbesucher zu allen K~ktn in `er Auflistung.</summ1ry>
$     <returns>Die geände2ta Knotenliste, wenn eines`deR Elemente geändurt wurde$ andernfalls wird die ubsprü~fliche Knktenlkste zurückgegeb%n.</returns>      <param name="nodeS">D)e Kfgen, :u den%n gewechselt werden soll.<.Param>
    ( param name="elamentVisitos">Ein Delegat, Der`ein eifzelnes Elemend besucht unl dmeses (optqnal) durch eil neues Element ersetzt.</parim>
      <typeparao name="T">ter Typ der Knoten.</typeparam>
    </member>
  $ <member name="M>Rystm.Lijq.Exprussions.ExpressionViSitop>Visit(System.Linq.ExpreSsmons.Expression)"~
      <sumlary>Sendet den Ausdruck an eioe der spezialisierteren Besuchsmevhoden hn dieser Klasse.<{ummary>
0     <returns>Der geänderte Awsdruck$ wenn dieser oder giner suiner Teilausdrgke geädert wurda. Cnderlfalls wird der qrsprüngliche Ausdruck zurücogegeben.</returns>
      <pasam namd="node">DerAusdruck, zu dem wewechselt werden solln</pa2am>
    </memder>
    <meobes$name="M:System.Linq.Ezprssions.ExprgssionVhqi4or.TisitAndConvert `1(Sy3tem.Collectionc.objectModel.ReadOnlyKollection{d`},ystem.String)">
      <summary>Wechselt xu einem usdruck und wandedt das ErgebNis zurück in den urrprünlicheF Ausdruckstyx(uM.</suimary>
      <returnsDer geänDezte Ausdrucklwenn dieser mder einer`se)ner Teilausdrücke geänderv wurde. Andernfalls wird dr upsrüngliche Ausdruck zur¼ckgegeben,</returns>
      param"name<"noDes"<Der Atsdruck, z dem gewechselt werden soll.</param>
      <param name="caller^ame">Dur(Name fer aufufdnden Methode. Dieser s)rd für die Ausgafe einer bmsseren Feh,ermel$u.g verwe~det.</param>
      <type0aram faoa-"T"~Der TyP des Ausdrucks></typeparim>
      <exceptio. cref="D:Syst%m.InvalidOperationExcdption">Eie Visit-Methode für dhesun Knoteo hat Ein%n cndermn Typ Zurücjggeben.</exception>
    </member>
(0  <member kame="M:ystem*Linq.ExprssionsEXpressiolVisitor.Vi3itAkdConvert`@q(``0,Sy3temnString">
      <summary.Wechset zt einem Ausdruck ufD wandedt aq ErgeBnis zurìck in d%n ursprünGlichen0Ausdruak{typ um.</summary>
      <return3>Der geänderte Ausdruck, wenndiesev(oder einer seiner TeilaUsdpcke0geän`ert(wurde& andernfills wizd derurspRýngliche Ausdruck zurückgegeben.</returns>
      <param name="nOd">D%r Ausdruck( zu deM gewechselt weRden soll.>/param>
&    <param ~Ame="cillerName">Der Name dur aufrufe.eN Methode. Dieserwibd bür die Ausgabe!einer besseren fehlErmeldung verwendet.>/param>
     <TypeparaM name="T">Der Typ des Ausdrpcks></typepbram>
   `  <epception cef="T:Systeu.InvalidpmrationException">Die(Vsit=Metho$e füp diasen Knoten hat einn anderuj Typ zurückgegebef.</eycepti/n>
    /meobhr>
    <member oamd=":Qystem.Lins.Expressioos.ExprEssiOoVisitor.VisitBinary(System/Linq.Expressions.BinasyExpression)">
  0   <sumeary~Wechsglt zu den untesgeordneten Elementen#dez <em cRef="P:System.Linq/Exprescins.BinaryEx`ression" /<.</summary>
      <returns>Der geänderte Atsdruck, wenn dieqerhoder einer semner Tuilaus`rückegeändert wurde. Andernfalls wird der urspünwliche Ausdruck Zwr˼ckgageben.8/returns>
      <param name="noda">er Cusdruck, ru$dem gewechselt werden soll.</param>
    </member>	
   =member name="M:Cystem.Linq.Exprew{ionsExpressionVi3itor.VisiuBlockSystem.Linq.expressi+ns.BlockExppession)">
    0 <s}mmary>Wchselt u len unvergeordnetel Elementn der <see`cref="T:Sysuem.Linq.Expr%ssions.BlockExpression" ?>.</summary>
      <returns>Der feänder| Ausdrugk, wenn didser oder eingr seiner Tainausdr˼cke geändert wrde. Andernfall{`7ird der ursrǼngliche Ausduck zurckgegeben</returns>
      ~param jame="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <mgmber ame="M:Syqtem.Linq.ExpressAons.ExpressionFiQitor.VisiTCatchBlock(Syste.Linq.Expressionw.CatchBlock)">
 $    <summa2y>Wecselt zu den unte2geozdneten E|%mgnten der <{ee cref="T;Syspem.Hinq.Expressions.CatbhBlock" />.,msummaby>
"`    <returns>Der ge odezte`Ausdruck, wgnn didser oder einer sdi~er Teilausdr¼cke geändert wqrde* Andernv!lls wirl d%r ursxsüngliche Aurruk zurückgegeben.<'returns>
     <paRam name="node">Der Auq$rck, zu de} geuchselt wgrden soll.</xqram>
$   </meMber>
    <meber name="m:System.Linq.Extress)onw.ExpresshonVysitr.Vis)tConditional(System*Linq&Expres{ions.ConditiolalExppessio.)">	
      <summary>Sechselt zu den#unt%rgeordmten Elementen er <see cref="V:System.Linq.ExPreqsions.ConditionalExprussio~" />.(/summary>
      <returns>Dar genderte Ausdruci, wenn!deser odej einer seiNer TeiausdrCcke geä~fert0wurde. andernfalls whvd der ursprüngliche AusdrUck zurckgegeben.</returns>
 "    <param name="node">De Ausdruck, zu dem gewechwelt werden soll.</param>
    |/member>
    <member name="M:System.Hknq.UxpressiGns.ExpressionVisitor.VisitConsta~T(S{stem.Linq.Expressions.ConstantAxpression)">
  (   <ummary>Geciselt zur <see creb="T:SYstem.Linq&Expressions.ConstantExpressiol" /..</summary>
      <eturns>der gendeztu Ausdruck, wenn dieser oder einer seiner Teilausdrügke geänderd wurde. Anderndalns wirD der ursprünglishe Aus`rucj zurückgegeben.</Returns>M
"     |param name5"lode">D%r Ausdruck, zu dem gegechsel werden soll.<oparam>
    </meber>
    <member0name-"M:System/Li~q.Ezpreswions.EhpressionVisitornVisitDebugInfo(CystemlinqnExpsessions.DebugInfoExpression)">
"     <semmiry>Wgchselt"2ur <sge cref="T:Wystem,Linq.Exprdssions.DebugYnfoExpression" />.</{ummary>	
      ,returns>DeR geänderte Ausfruck, wenn daeser o4er Einer sailer Ueilqusdrükke geändert wurde. Aneernfall wird der wrsprüngliche Ausdruck zuvückgegeben.'returns>
    $ <param"name-"node">Eer Ausdruck,zu dem wewechrelt werden soll.</param~
    </oember
   <member"name="M:Sysuem.Lhnq.Expressyo~s.ExpressionVisitor.VishtDefault(System.Linq.Dxpressions.DefcultQxpressyon)">
      <summary>Wechsalt zu0<see cref="T:System.Linq.U8pressmons.DefaultExpression" />n</rumoary>
      >retwrns>Fer geônderte Ausdruck, wenn dieser oder einer seiner TeiLausdrǼcke`geändert wurda. Andernall wird der ursprüngliche!Auqdzucg zurückegeben.</Reuurns>
      <param name="node">Der Ausdr5ck, zu$dem gewechse,twerden s,ll.<nparam>
    ,/member~
   !<membe nae="M8System.Linq.ExqresSions.ExpressionViritor.VistElemdntI~it(S{std}.Linq.ExPressions.ElementInit)">
     <suoeary>wechselt zu0den 5ntergeordndten Elemeften der <see cref=&P:S}stemnLinq.Expressiof3.ElementInit" />.</c}mmary>
      <ret5rlsDer geän$Grtd Ausdruck( wenn dmeser oder einer seiner TeilausdrӼCke geändert(wubde. Andernfalhs wivd des ursprünglichg Ausdruck zurückgemebel.</rEturos>
h   ! <param name= node">Der AuSdsuck, zu dem gevgchsel(werden {oll.</param<
$` </membep>J    <membur neme=&M:System.Linq.Expressio~s.expressinvisitor.VisiuExtension(System.LinyE|pressions.Expression)#>
      <wumMary>Wechrelt zu de. unteguordnetej$Edementeo des Erweiterungsausdruck.</summary|-
     <returns>Der geäoderte Aqsdruck, wenn dyeser kee einer seiner Teilausdrückm geändert wurde. Andernfalls wird der ursprüngliche Ausdruck`zurückgegeb'n*</retwns>
      =papam name="node">Der AUslrucc, zu dem fawechselt vebden solL.</param>$` 0</member>
    <member fam%="M:Sxstem.Linq.Expressions.ExpressiolVisitor.VisitGoto(SyqteonLi~q.Exprassons.GotoDppRession)">
      <summ`ry>echselu zu den$untergeordneten le-enten der <See wref="T:Cystem.Lanq.Expressons.GotExpression"!>.</summar}>
      <rmurns>Der"geänderte Ausdruk, wenN $iesez odes einer seiner Teynausdrýke geändert wurde. Andernfanls wirl der ursprüglichg Aesdruck(zqrückgeg%ben.</re4tns>
      <param name="nodE">Der Ausdruck, zu d%m geechselt webdan woll.=/param>
    </meiber>    <member namg="M:Sstem.Linq.Ex`rEssions.ExpressignVisitor.TisitIndex(Sy3tem.Linq.Expressions.IndexExpress)on9">
     "<sulmar>Wechselt zu denuntergordn%t}~ Elemenue. der <see cRed="T:SYstem.Linq.Uxpzes{ionc.InfexExxressioo" />.</suMmarY>
 (   `<returnS>Der geänderte Ausdruckh senn didseR oder einer seiner Teilausdrôkke geneert wurde. Endernfalls vird Der ursprüng,iche Ausdruck zurückgegeben.,/retrnw>
      <param name="node">deS Ausdruck| zt dem0gegech3e,t wmrden0soll.</param>
    </member>
 ` <member nam%="M:SyStem.Linq.Ex`resqions.ExpresyonViitor.VisytInvncatin(ysDmm,Linq.Ex`ressions.InvofationExpreSskon)">
     0<summary>Wechselt ju den untergemrdneten Elementen0dez 8sae crdf="T:Systdm.\inq.xpressions.InvocationExpressign />.</summaRy>
      <zaturns>Der geänderte Aucdruck- wenn dieser nder ehner seiner Teilausdzücke gendert wurde. Andernfall{ wipd der ursprüngliche A5sdr}#k zurýckgegeben.</returns>
      <param name="node">Der Aerdruck, zu em gesechselt werden soll.</param>
    </member>
    <member`name<"MSystem.Linq.Expressyons.ExpreSsionisito.VisitLqb%l(S9stei.Mmnq.Expressions.MabelExprewsion)">
 (    <summary>Wechselt :u den unvergeorneten Elementan der <see cref=2T:System.Lina.Expressions.LabelExpression" /6.</cwmma2y>
      <retuzns>Der"geändartu Iuseruck,$wenn ieser oder einer seiner$Teklauslrüce(geändert wurde. Andarnfalls ird dr urspr<ngliche Auqdruck zurückgeeben.<returs>
      <p%ram name="nde*der"Usdruck, zU $gm gew%chselt verden soll.</param>
  " </memb%r>
    <eember name="M:Systmm.inq.Expvessions.ExprEssio:Visitor.VishtabelTqrget(System.Lilq.Expressions.Labe|Target)">
  "   }summary>WEchSemt zur(<see cref=":System.Linq.Uxprersions.LabalTarget" />.</sumiary>
      <returns>Der(geänderte Ausdruck, wmnn dieser"oder eIngr0einer Deilausdrücke geändert wurlu. Andernfallswird der urspb<lglighe Ausdruck {urück'egeben.</return{>
      param name="node >Der auseruck, zu damgewechelt werde~ s/ll.</arae>-
 "  </member.
    <member name="M:Rystem.Lynq.Axpressions.ExtsessionVisitor.VisitLamr`!``1(Syctgm.LiNq.xppe{son3.Expression[``0})">
  "   <wummary>Wechqelt :u den qntergeordnetgn Elementen ter <sem cref="T:Sy{tem.Linq.Expressions.Expression`1" />.</summary
   $  <relurn>Dur`geäNdeRte AUsdruck,0wenn dieser oer einer seiner Teilausdrücke ge$ndert wura. Anderjfalls wird"der ursprüngliche(Ausdruck zusckgegeben.</rettrns>
      <param`naee="node#>Der Ausdreck, zu dem gewechselt werd%n soll.</param>
$     <typep!ram name="T">Dgr Typ des Demegaten.</typeparam6!   </memfgr>
    <member name=#M:System.Lhnq.Ezpressions.Expressho~ZisItor.VisitListInit(SystEm.Li.q.Expressiofs.ListInitEhpression)">
`     <Sum-ary?WeChsett ~u $en .terfeordneden Elementen dmZ(<see kref="T:System.Lifq.ExprassioNs.ListInitExprEssion" />.</qummary>
  ( $0<rEuznsDer geӤnderte @usdruck, wenn dieser oder einer$siner Teilausdrücke geänlezt werde. Ander.falls 7ird der!urrprüngliche Ausdruck"zurückgegeben.</retpns>
  !   <param name="node">Fev Ausdruck, z} damhgewechcEmt werden soll&</`crem
( ( </member
    <member name="M:Systam.inq.ExprDssioNs.ExpresionVHsitor.VismtLo7p(System.Linq.Expg3sins.LootEx0ression)"
 !    <rumMa8>Weahset zw den untergor$neteN!Eldmenten der <see0cref="T:SYsem.Lioq*Exxrussions.LoopEx0ressinn" .>.</summary>
      <rettrls>Der geänderte Ausdruck,(wenn dieser oder ekne2 seiner T%ilaus$rücke 'eänldrt wure. A~derofalls wird de ursPrüngliche Aucdruck zurückgdgebenn</returns>      <param name=*node">Der Ausd2uck-!zu dem gewec(relt werdgn 7ol,.</piram>
    </mEmber>
    <Embmr naMe=bM:Cystem.LYnq.ExpreqSions.ExressionVisit?r.VisitMember(Syst%m.Linq.Oxpressins.MEmbdrExpression	">
      <summazy>Wec(welt zu den untgrgeorfneten Elementej tez <3ee"creg=2U:System.Lnq.Exprewsions.MembepExpression" />.<=sumary>
      <returns6Der genderte!Ausdruckl weNn`dimser kde2`einer 3einer Teilausdrü#ke geändert wurde. Andernfalls wird der ursprüngliche Ausduck!zerückcegaben.,/returns>
 @    <param name="node">Der Au3druck, zu $em gEwechselt udrdej soll,<.param>
    </memBer> "  <memb%r naee="M:SyStem.Linq.Expreqsions.E|rzeSsionVisitor.VisitMemberQssigoment(System.Linq.Expresshons.Mem`erAcsignment)"~
   ! <sumiiry>Wechseld zu den untergeordneten EemefteN der <see cref="T:System.Linq.Expressions.MemberAwsignment" />.</sudmary>
      <rmtuvns>Der gaänderte Ausdruck, uenn!dieser /der einer seiner Teilausdücke geändert wurde/ Andernfalls uird der ursprüngliche Ausdruck`xurückgageben>=/retubls>-
(   ` 8param nam="jode"<Der AuQdvuck, zu dem gewechselt werden roll/</aram>
    |/mamber6
    <-ember nama}"M:SY2tem.\inq.Exprfssions.ExpressionVisiuor.VisitMemberBinding(Syuum.Linq*Expre3sikns.MamberFining)">
  "   <summary>Wechse|t0:u`den unpergeoreneten lementel`ddr <see cref="T:Qytem.LijqExpresqions.MembdrBidifg" />.</wummary>/
     <returns>Der geänderve Asdrtck, wenn di%sgr oder!eindr seiner Tilausdrcke oeändert wtrde. Andernfalls wird0der"rqprüngliche$Ausdruck zurü#{gegeben.</rg4urnw>
      <param name="node">Der AuSdruck, zu dem gewechselt werden so,l.</taram>
    </eember>
    <member na-e="M:[ystgm,Linp.expressiOns.EhpresSaonVi3itor.VisitMemberInit(SystamnLinq.Expressions.MemberAnitExpression)">
    ` }summary>Wechselt zu den unte2gekrdneten Elemmnten der <wee cef="T:Sxstem.Linq.Expre{3ios.MembdrInitExpr%sion" .>*</suMmary>
     !<returns>Der geän`erte Ausdruck- wenn dieser oder einer seiner Teilausdrücke geänlgrturde. AndurnFalls wisd der ursrüngliche!Ausdru#k z5rckgmgeben.</z%t5rn>
 "    <param Ncme=bnode">Ter AuSdru#k,(zu deo gEwmc`selt werden soll.</param>
 $  </member>
    <mdmer oamd="M:Systam.Linq.Exprssion3.ExpressiojVqiuor.VisitMem"urLi{Bimdi~o(System&Linq.Exprecsions.MembepListBindingi">
      <summarq>Uechselt zu den untergeordneten Ulementej$dor <seecref="T:SystemlLiny.Exprssio~r&MemberListBinding" />.,/summar{>
      <returns>Der geändur|e Ausdruck, wenn tieser od%r einer seaner Teilaurdrücke geändert wuRee.Andernfalls wird der ufsprünglichd Aus$ruck ztrücKgegeben.,/returns?
      <para nao%=&oode">Der Audruck, zu dem ewEchwelv werden soll.</xsam<
    </member>
    <megbur name="M:Sistmm.Lanq.Expr%ssaons.Expres{ionVisator.VisitMeberMemberBinding(System.Lmnq.xpressions.MemberMemberbinding)>
      <summary>Wechselt zq den untdbggordneten E,em%nten `mr <sea crgf="T:Syste-.Linq.ExppeSsigns.MemberIemberJinding""/<.</summar}>
      <returns>Der guônderte Auwdruck, wenn dieser our eineR seiner Teilauserücke geändert wUrden An`ernf`,s wird du u0sprüngliche CusdrQck zurückgegeben.4.retuzns>
      <paraM name="noe">Der Ausdruck( zu dem gewechqelt werden sll.</param>
  $ </member>
    <member name="M:System*Lknq.Ehpressions*ExpressionVisitor.WisitMe|hodCaml8System.Lin1.Exrressiojs.MethOdCallExpessioN)">
 "    <summary>Wechseld z den(untergeordneten Ele-enten der see cbef="T:Sqstel.Linq.Expressions.MethmdGalExpression" />.</summavy>
      <rettrns>Dur wenderte Ausdrtck. wenn dieser oder einez siner Teilau{drüCke gdänfert wurdd. Andernfadls wird der ursxrüncliche Ausdruc zurccgegeben></returns>
      <param name="noee"<Der Ausdruck, zu demggwechselt werden soll.</param>	
    </memb%r>
    <ember n`me="M:System.LinqExpressioos.ExprersonVi{itor/FisitNew(SysTem.Linq.E|pressions.NewExpression)">
      <summary>Wechsel4 zw den unterg$ordne|e~ Elament%n der see cref="T:SystEm.Linq.Exressions.NewExpressinn" />.</summaR9>
      <returns>Dur geìndetg AusdRuck, 7enn dieser ode3 einer sekner Teilausdrücke geändert wurde$Andenralls wird $er ursprüngliche Austruck zubückgegEben.</returnS>
    ( <param name="nofe">er Ausd2uck, zw dem gewexselt werden smll.</pqram>
    ,/member>
    member name=M:Sys|em.inq.Expressio.s,ExpressionViyiuor.VisiuNewArrqy(System.Linq.Expressions.NewrrayExqreSsion)#>
`     <summaryWechselt u den"untergeodjeeen Elementen der <see"cpef="T:System,Linq.Expressions.NewArrayE|pression" />.</summqry>
  "  <reuRns>Dgr oaänder|e"AusdRuck- wenn diesr oder einer"sehnur Teilatsdrücke geänler4 wurde. Andernfamls wiR, der urcprüngliche Ausdruck zurüciwegefej.</returns>
 "    ,param name="node">Der Audru#, ze dem gegechselt werden soll.</par`m>
    </memer>	
    <member lame="M:System.Linq.Gxpressiols.ExpressionVisitor.V)kitParameter(System.Linq.Expressions.PaametebExpressi/n)">
    ` <sueary6Wechselt zur(>se- cref="\:System.Linq.Extbessins.PaameterExPression" /6.</sulmari>
      |returnc>Dur weänderte Ausdruck, wenn dieser0oder einer seines`Teil%ucdrüc{e geändert wuRde. Andernfalls wird der urcpRüngliche Ausdruck zurückgegeben.</veturns>
      <pram name="nofE">DerhAusdruao, :u dem gewechselt werden coll.</tar`m?
    </member6
    <member ~ame="M:SysteM,Linq.Expbessionr.ExpressionVisitor.VisitRuntimeVariables(System.Linq.ExpreswinS.RuntimmTariabLeqEypression)">
   0  <summary>Wechselt zu den ntevoeordneten Mldmenten der <see cre="D:SystemnLinqExpresions.RuntameViriablecExpression" /></ruieary>
  $0  <retur~s>Der geÄnderte Ausdruck- venn diesev oder einer(seiner eilausdrücke geåjdert`wurde. Aodernfalls wird der ursprǼogli#he Ausdruck zu2üs{gegeben&<retubns>  `   <param namd="node">Der$Ausdruck, zu dem gewechs%lt wmrdensoll.</taram>
    </mdlber>
    <member n`me="M:System.Linq.Expressions.ExpressioVisIor.visidSwitch(Sys|em.Linq.Expressio*w.SwitchExpessIon)">
      <summary>Wechselt zu dEn untergaordneteN Elementen `er <see cref=#T;}stem.LinqnExpressions.SwidchExpression" />.</sqmmary>
    ! <retrns>Dgr0geänderte Ausdruck, wen dieser(oder einer$sein%r Teyhausdrücke geänfeRt wurde. AndernFaLls wird der ursPrüngliche A}sdruc+ ZurückgegEben.</ret5rns>
      <parampname-&node">Der Ausdruck, zu dem gewecxselt werden soLl*</pabam>
    </member>
  0<membr nme="L:S9stem.Li~q.Expressions.E8pressionVisitor.VasitSwitchCase(Sysem.Linq.ExtressionsSwi|chCse)">(     <sumery>Wechset ze den entergeordnetel Elementen(der <see cref"T:Systdo.Lanp.ExpRessions.SwitchBase" />.</3uomary>
      <returns>Der geänderte Ausdruck, we~n diesar oder eine seiner!Teilausdrüj{e 'eCn`ert wurde. AndernFalls wird der ursprüngliche Ausdruck zupückgeeben.</retusns>
      <param nme="node">Der Aus$ruck, zu d%m geweclselu werdef soll.<-param>
    </member>
    <member ame<"M:System.Linq.Expressions,ExpressionVisitor.VIsitTry(Sxstem.Linq.Expressions.TryExpression)">
      <summ!ry>Weghse,t zu dgn entergeordjeten Elementen der <see cref=*:Syste=.Mioq.Expr'sshnns.TryExpresrion" />.</suMmary>    ! <returns>Der geänlerte Ausdruc{, 7enj dieser(oder emner ceiner`Teiausdrake geädert wurde. Andernfallw wis` dr urspsünglkche Ausdrugk zurübkgegmben*</returns>
 "    <qarim ncme="noDe2>Der(Ausdruck, zu d-i gewechselt serden soll/</taram>
   <oember>
    <ember name="Y:System.Linq.Expressiols.E|pressionVisitor.VisitTqpeBinary(Sastem.Linq.Expressionw.TyreinaryExpression)"> "    <s}mmary>Weciselt zu den ufterGeordneten Elemejten dep <see cref="T:SystUm.Liny.Expressmon.TypeBanarxExression"(-~.</sum}ary>
     <repuroq>Ver gendepte Ausdrucc, wann dieser odgr einer siner TeI,ausdrücke geäodest$wurde. Ander.falls wird der usprüngliche Audruck zurückgegeben.</returns>
 !    <param lcme="node">Der Ausdruck, zu dEm gewebhselt!wErden soln.</`aram>
   </member>
    <membev name="M:System*Linq.Expressigns.ExprEssionVisator.VisitUjary(SYstem.Minq.Exppessions.U.arxEypresshon)">
      ={ummary>echsElt zu den untergeordnetenElemunven der <se% cref="T:Sywtem.linq.Dxpreqsions.UnryEpprersion# />.|/summary>
      <returns>Der geändepte!AuSdruck, wen $ieser odez ei.er weiner TeilAqsdrücke geändert wurde. Andernfells wibd der ursprüngliche Ausdruck`zurckgegeben.4/returns>
    ( <param name="node">Der Aucfruci, zu de- gewechsgmt werdEl solln</piram>
  " </member>
    <member name="T:SysteM.Lilq.ExpRessionsGotmExpreswioN">
    0 >summwy>StenL| endn bedingungslosan Sprun' dar.Hierzu zä`den return-Anueisungen< break- u.d coltin}e-Enweisunoen sowie a.dere Sp2fge.</sumlary>
    </member>
    <member name=":System.Linq.Expressions.GotoExpreSsign.Kynd*>
      <su-mary>Die Art(des "Gehe zu"-AUsdruks.Dient`nur"zu Innor-ationszwecken.</summa2y>
      >ru|urls>Das <sed cref=2T;[yrtem.Lina.Expressions.GotoEzpressonIind" />-ObjekT, $as die Art de{ "ehe z5"-Asdrtckq"darstelnt.</setupns>
    </membe>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Die Zielmarke, zu der von diesem Knoten gewechselt wird.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.LabelTarget" />-Objekt, das die Zielmarke für diesen Knoten darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.GotoExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="target">Die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft des Ergebnisses. </param>
      <param name="value">Die <see cref="P:System.Linq.Expressions.GotoExpression.Value" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Der an das Ziel übergebene Wert oder NULL, wenn das Ziel vom Typ System.Void ist.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den an das Ziel übergebenen Wert darstellt oder NULL.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Gibt an, welche Art von Sprung diese <see cref="T:System.Linq.Expressions.GotoExpression" /> darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine break-Anweisung darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine continue-Anweisung darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die einen Sprung zu einer Position darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine return-Anweisung darstellt.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Stellt das Indizieren einer Eigenschaft oder eines Arrays dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Ruft die Argumente ab, mit denen die Eigenschaft oder das Array indiziert wird.</summary>
      <returns>Die schreibgeschützte Auflistung, die die Argumente enthält, mit denen die Eigenschaft oder das Array indiziert wird.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Ruft die <see cref="T:System.Reflection.PropertyInfo" /> für die Eigenschaft ab, wenn der Ausdruck eine indizierte Eigenschaft darstellt. Andernfalls wird NULL zurückgegeben.</summary>
      <returns>Die <see cref="T:System.Reflection.PropertyInfo" /> für die Eigenschaft, wenn der Ausdruck eine indizierte Eigenschaft darstellt, andernfalls NULL.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Ein zu indizierendes Objekt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die das zu indizierende Objekt darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.IndexExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="object">Die <see cref="P:System.Linq.Expressions.IndexExpression.Object" />-Eigenschaft des Ergebnisses.</param>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Stellt einen Ausdruck dar, der einen Delegaten oder einen Lambdaausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Ruft die Argumente ab, auf die der Delegat oder Lambda-Ausdruck angewendet wird.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat angewendet wird.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Ruft den Delegaten oder Lambdaausdruck ab, der angewendet werden soll.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den anzuwendenden Delegaten darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.InvocationExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expression">Die <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" />-Eigenschaft des Ergebnisses.</param>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Stellt eine Bezeichnung dar, die in einen beliebigen <see cref="T:System.Linq.Expressions.Expression" />-Kontext platziert werden kann.Bei einem Sprung in die Bezeichnung wird der durch die entsprechende <see cref="T:System.Linq.Expressions.GotoExpression" /> angegebene Wert abgerufen.Andernfalls wird der Wert in <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> empfangen.Wenn der <see cref="T:System.Type" /> gleich System.Void ist, darf kein Wert angegeben werden.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Der Wert der <see cref="T:System.Linq.Expressions.LabelExpression" />, wenn die Bezeichnung durch die reguläre Ablaufsteuerung (und z. B. nicht durch einen Sprung) erreicht wird.</summary>
      <returns>Das Expression-Objekt, das den Wert der <see cref="T:System.Linq.Expressions.LabelExpression" /> darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem die Bezeichnung zugeordnet ist.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem die Bezeichnung zugeordnet ist.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.LabelExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="target">Die <see cref="P:System.Linq.Expressions.LabelExpression.Target" />-Eigenschaft des Ergebnisses.</param>
      <param name="defaultValue">Die <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Stellt das Ziel einer <see cref="T:System.Linq.Expressions.GotoExpression" /> dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Ruft den Namen der Bezeichnung ab.</summary>
      <returns>Der Name der Sprungmarke.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Gibt einen <see cref="T:System.String" /> zurück, der den aktuellen <see cref="T:System.Object" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.String" />, der den aktuellen <see cref="T:System.Object" /> darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Der Typ des beim Springen zur Bezeichnung übergebenen Werts (oder <see cref="T:System.Void" />, wenn kein Wert übergeben werden soll).</summary>
      <returns>Das <see cref="T:System.Type" />-Objekt, das den Typ des beim Springen zur Bezeichnung übergebenen Werts darstellt, oder <see cref="T:System.Void" />, wenn kein Wert übergeben werden soll.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Beschreibt einen Lambdaausdruck.Zeichnet einen Codeblock auf, der mit einem .NET-Methodentext vergleichbar ist.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Ruft den Text des Lambdaausdrucks ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Text des Lambdaausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Erzeugt einen Delegaten, der den Lambdaausdruck darstellt.</summary>
      <returns>Ein <see cref="T:System.Delegate" />, das die kompilierte Version des Lambda-Ausdrucks enthält.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Ruft den Namen des Lambdaausdrucks ab.</summary>
      <returns>Der Name des Lambdaausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Ruft die Parameter des Lambdaausdrucks ab.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, die die Parameter des Lambdaausdrucks darstellen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Ruft den Rückgabetyp des Lambdaausdrucks ab.</summary>
      <returns>Das <see cref="T:System.Type" />-Objekt, das den Typ des Lambdaausdrucks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Ruft den Wert ab, der angibt, ob der Lambdaausdruck mit der Endeaufrufoptimierung kompiliert wird.</summary>
      <returns>True, wenn der Lambdaausdruck mit der Endeaufrufoptimierung kompiliert wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.LambdaExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Stellt einen Konstruktoraufruf dar, der einen Auflistungsinitialisierer aufweist.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Ruft einen Wert ab, der angibt, ob der Knoten der Ausdrucksbaumstruktur reduziert werden kann.</summary>
      <returns>True, wenn der Knoten reduziert werden kann, andernfalls False.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Ruft die Elementinitialisierer ab, die zum Initialisieren einer Auflistung verwendet werden.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten, die die Elemente darstellen, die zum Initialisieren der Auflistung verwendet werden.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Ruft den Ausdruck ab, der einen Aufruf des Konstruktors für einen Auflistungstyp enthält.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des Konstruktors für einen Auflistungstyp darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Reduziert auf den binären Ausdrucksknoten auf einen einfacheren Ausdruck.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ListInitExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="newExpression">Die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft des Ergebnisses.</param>
      <param name="initializers">Die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Stellt eine Endlosschleife dar.Diese kann mit "break" beendet werden.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.Expression" /> ab, die den Text der Schleife darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den Text der Schleife darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Ruft das <see cref="T:System.Linq.Expressions.LabelTarget" /> ab, das vom Schleifentext als Ziel der break-Anweisung verwendet wird.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.LabelTarget" />, das vom Schleifentext als Ziel der break-Anweisung verwendet wird.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Ruft das <see cref="T:System.Linq.Expressions.LabelTarget" /> ab, das vom Schleifentext als Ziel der continue-Anweisung verwendet wird.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.LabelTarget" />, das vom Schleifentext als Ziel der continue-Anweisung verwendet wird.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.LoopExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="breakLabel">Die <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" />-Eigenschaft des Ergebnisses.</param>
      <param name="continueLabel">Die <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" />-Eigenschaft des Ergebnisses.</param>
      <param name="body">Die <see cref="P:System.Linq.Expressions.LoopExpression.Body" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Stellt die Zuweisungsoperation für ein Feld oder eine Eigenschaft eines Objekts dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Ruft den Ausdruck ab, der dem Feld oder der Eigenschaft zugewiesen werden soll.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den Wert darstellt, der dem Feld oder der Eigenschaft zugewiesen werden soll.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expression">Die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Stellt die Basisklasse dar, von der die Klassen abgeleitet werden, die Bindungen darstellen, die zum Initialisieren von Membern eines neu erstellten Objekts verwendet werden.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Ruft den dargestellten Bindungstyp ab.</summary>
      <returns>Einer der <see cref="T:System.Linq.Expressions.MemberBindingType" />-Werte.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Ruft das zu initialisierende Feld oder die zu initialisierende Eigenschaft ab.</summary>
      <returns>Die <see cref="T:System.Reflection.MemberInfo" />, die das zu initialisierende Feld oder die zu initialisierende Eigenschaft darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Gibt eine Textdarstellung des <see cref="T:System.Linq.Expressions.MemberBinding" /> zurück.</summary>
      <returns>Eine Textdarstellung des <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Beschreibt die Bindungstypen, die in <see cref="T:System.Linq.Expressions.MemberInitExpression" />-Objekten verwendet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Eine Bindung, die das Initialisieren eines Members mit dem Wert eines Ausdrucks darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Eine Bindung, die das Initialisieren eines Member vom Typ <see cref="T:System.Collections.IList" /> oder <see cref="T:System.Collections.Generic.ICollection`1" /> von einer Liste von Elementen darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Eine Bindung, die das rekursive Initialisieren von Membern eines Members darstellt.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Stellt den Zugriff auf ein Feld oder eine Eigenschaft dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Ruft das enthaltende Objekt des Felds oder der Eigenschaft ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die das enthaltende Objekt des Felds oder der Eigenschaft darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Ruft das Feld oder die Eigenschaft ab, auf das bzw. die zugegriffen werden soll.</summary>
      <returns>Die <see cref="T:System.Reflection.MemberInfo" />, die das Feld oder die Eigenschaft darstellt, auf das bzw. die zugegriffen werden soll.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Gibt den Knotentyp dieser <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expression">Die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Stellt das Aufrufen eines Konstruktors und Initialisieren eines oder mehrerer Member des neuen Objekts dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Ruft die Bindungen ab, die beschreiben, wie die Member des neu erstellten Objekts initialisiert werden.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, die beschreiben, wie die Member initialisiert werden.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Ruft einen Wert ab, der angibt, ob der Knoten der Ausdrucksbaumstruktur reduziert werden kann.</summary>
      <returns>True, wenn der Knoten reduziert werden kann, andernfalls False.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Ruft den Ausdruck ab, der den Konstruktoraufruf darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Konstruktoraufruf darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Reduziert <see cref="T:System.Linq.Expressions.MemberInitExpression" /> auf einen einfacheren Ausdruck. </summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="newExpression">Die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft des Ergebnisses.</param>
      <param name="bindings">Die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Stellt das Initialisieren der Elemente eines Auflistungsmembers für ein neu erstelltes Objekt dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Ruft die Elementinitialisierer zum Initialisieren eines Auflistungsmembers für ein neu erstelltes Objekt ab.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.ElementInit" />-Objekten zum Initialisieren eines Auflistungsmembers.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="initializers">Die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Stellt initialisierende Member eines Members für ein neu erstelltes Objekt dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Ruft die Bindungen ab, die beschreiben, wie die Member eines Members initialisiert werden.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, die beschreiben, wie die Member des Members initialisiert werden.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="bindings">Die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Stellt einen Aufruf einer statischen Methode oder einer Instanzmethode dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Ruft eine Auflistung von Ausdrücken ab, die Argumente der aufgerufenen Methode darstellen.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente für die aufgerufene Methode darstellen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Ruft das <see cref="T:System.Reflection.MethodInfo" /> für die aufzurufende Methode ab.</summary>
      <returns>Die <see cref="T:System.Reflection.MethodInfo" />, die die aufgerufene Methode darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Ruft das <see cref="T:System.Linq.Expressions.Expression" /> ab, das die Instanz für Instanzmethodenaufrufe oder NULL für statische Methodenaufrufe darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die das empfangende Objekt der Methode darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="object">Die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft des Ergebnisses.</param>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Stellt das Erstellen eines neuen Arrays und möglicherweise das Initialisieren der Elemente im neuen Array dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Ruft die Grenzen des Arrays ab, wenn der Wert der <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> ist, oder die Werte zum Initialisieren der Elemente im neuen Array, wenn der Wert der <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> ist.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Grenzen des Arrays oder aber die Initialisierungswerte darstellen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expressions">Die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Stellt einen Konstruktoraufruf dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Ruft die Argumente für den Konstruktor ab.</summary>
      <returns>Eine Auflistung von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente für den Konstruktor darstellen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Ruft den aufgerufenen Konstruktor ab.</summary>
      <returns>Die <see cref="T:System.Reflection.ConstructorInfo" />, die den aufgerufenen Konstruktor darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Ruft die Member ab, die die Werte der mit Konstruktorargumenten initialisierten Felder abrufen können.</summary>
      <returns>Eine Auflistung von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die Member darstellen, die die Werte der mit Konstruktorargumenten initialisierten Felder abrufen können.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.NewExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Stellt einen Ausdruck mit einem benannten Parameter dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Gibt an, dass dieser ParameterExpression als ByRef-Parameter behandelt werden soll.</summary>
      <returns>True, wenn dieser ParameterExpression ein ByRef-Parameter ist, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Ruft den Namen des Parameters oder der Variable ab.</summary>
      <returns>Eine <see cref="T:System.String" />, die den Namen des Parameters enthält.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ParameterExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Ein Ausdruck, der die Laufzeitberechtigung für Lese-/Schreibzugriff für Variablen bereitstellt.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="variables">Die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Die Variablen oder Parameter, auf die Laufzeitzugriff ermöglicht werden soll.</summary>
      <returns>Die schreibgeschützte Auflistung, die Parameter enthält, für die der Laufzeitzugriff ermöglicht wird.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Stellt einen Fall einer <see cref="T:System.Linq.Expressions.SwitchExpression" /> dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Ruft den Text dieses Falls ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Text des Fallblocks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Ruft die Werte dieses Falls ab.Dieser Fall wird für die Ausführung ausgewählt, wenn der <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> einem dieser Werte entspricht.</summary>
      <returns>Die schreibgeschützte Auflistung der Werte für diesen Fallblock.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Gibt einen <see cref="T:System.String" /> zurück, der den aktuellen <see cref="T:System.Object" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.String" />, der den aktuellen <see cref="T:System.Object" /> darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="testValues">Die <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" />-Eigenschaft des Ergebnisses.</param>
      <param name="body">Die <see cref="P:System.Linq.Expressions.SwitchCase.Body" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Stellt einen Steuerausdruck dar, der die Mehrfachauswahl durch das Übergeben der Steuerung an <see cref="T:System.Linq.Expressions.SwitchCase" /> behandelt.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Ruft die Auflistung der <see cref="T:System.Linq.Expressions.SwitchCase" />-Objekte für die Switch-Anweisung ab.</summary>
      <returns>Eine Auflistung von <see cref="T:System.Linq.Expressions.SwitchCase" />-Objekten.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Ruft die Methode für Vergleichsoperationen auf Gleichheit ab (falls vorhanden).</summary>
      <returns>Das <see cref="T:System.Reflection.MethodInfo" />-Objekt, das die Methode für Vergleichsoperationen auf Gleichheit darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Ruft den Test für den Schalter ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Test für den Schalter darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Ruft den Test für den Schalter ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Test für den Schalter darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.SwitchExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="switchValue">Die <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" />-Eigenschaft des Ergebnisses.</param>
      <param name="cases">Die <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" />-Eigenschaft des Ergebnisses.</param>
      <param name="defaultBody">Die <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Speichert Informationen, die für die Ausgabe von Debugsymbolinformationen für eine Quelldatei erforderlich sind, insbesondere den Dateinamen und den eindeutigen Sprachenbezeichner.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Gibt den eindeutigen Bezeichner des Dokumenttyps zurück (falls vorhanden).Standardmäßig ist dies die GUID für eine Textdatei.</summary>
      <returns>Der eindeutige Bezeichner des Dokumenttyps.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Der Name der Quelldatei.</summary>
      <returns>Die Zeichenfolge, die den Namen der Quelldatei darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Gibt den eindeutigen Bezeichner der Sprache zurück (falls vorhanden).</summary>
      <returns>Der eindeutige Bezeichner der Sprache.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Gibt den eindeutigen Bezeichner des Sprachenanbieters zurück (falls vorhanden).</summary>
      <returns>Der eindeutige Bezeichner des Sprachenanbieters.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Stellt einen try/catch/finally/fault-Block dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.Expression" /> ab, die den Text des try-Blocks darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den Text des try-Blocks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.Expression" /> ab, die den fault-Block darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den fault-Block darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.Expression" /> ab, die den finally-Block darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den finally-Block darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Ruft die Auflistung der <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücke ab, die dem try-Block zugeordnet sind.</summary>
      <returns>Die Auflistung der <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücke, die dem try-Block zugeordnet sind.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.TryExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="body">Die <see cref="P:System.Linq.Expressions.TryExpression.Body" />-Eigenschaft des Ergebnisses.</param>
      <param name="handlers">Die <see cref="P:System.Linq.Expressions.TryExpression.Handlers" />-Eigenschaft des Ergebnisses.</param>
      <param name="finally">Die <see cref="P:System.Linq.Expressions.TryExpression.Finally" />-Eigenschaft des Ergebnisses.</param>
      <param name="fault">Die <see cref="P:System.Linq.Expressions.TryExpression.Fault" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Stellt eine Operation zwischen einem Ausdruck und einem Typ dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Ruft den Ausdrucksoperanden einer Typtestoperation ab.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.Expression" />, der den Ausdrucksoperanden einer Typtestoperation darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Ruft den Typoperanden einer Typtestoperation ab.</summary>
      <returns>Ein <see cref="T:System.Type" />, der den Typoperanden einer Typtestoperation darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expression">Die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Stellt einen Ausdruck dar, der einen unären Operator aufweist.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Ruft einen Wert ab, der angibt, ob der Knoten der Ausdrucksbaumstruktur reduziert werden kann.</summary>
      <returns>True, wenn ein Knoten reduziert werden kann, andernfalls False.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt.</summary>
      <returns>true, wenn der Knoten einen transformierten Aufruf darstellt, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt, dessen Rückgabetyp zu einem Typ transformiert wird, der NULL-Werte zulässt.</summary>
      <returns>true, wenn der Rückgabetyp des Operators zu einem Typ, der NULL-Werte zulässt, transformiert wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Ruft die implementierende Methode für die unäre Operation ab.</summary>
      <returns>Ein <see cref="T:System.Reflection.MethodInfo" />, der die auszuführende Methode darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Ruft den Operanden der unären Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Operanden der unären Operation darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduziert auf den Ausdrucksknoten auf einen einfacheren Ausdruck. </summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.UnaryExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="operand">Die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft des Ergebnisses.</param>
    </member>
  </members>
</doc>