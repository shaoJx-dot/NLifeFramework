<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <typeparam name="T">Tipo del contenido del origen de datos.Este parámetro de tipo es covariante. Es decir, puede usar el tipo especificado o cualquier tipo que sea más derivado. Para obtener más información sobre la covarianza y la contravarianza, consulte Covarianza y contravarianza en genéricos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se especifica el tipo de los datos.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtiene el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a este objeto.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtiene el árbol de expresión que está asociado a la instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que está asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtiene el proveedor de consultas que está asociado a este origen de datos.</summary>
      <returns>El objeto <see cref="T:System.Linq.IQueryProvider" /> que está asociado a este origen de datos.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se conoce el tipo de los datos.</summary>
      <typeparam name="T">El tipo de los datos del origen de datos.Este parámetro de tipo es covariante. Es decir, puede usar el tipo especificado o cualquier tipo que sea más derivado. Para obtener más información sobre la covarianza y la contravarianza, consulte Covarianza y contravarianza en genéricos.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Define los métodos para crear y ejecutar las consultas descritas por un objeto <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TElement">Tipo de los elementos del objeto <see cref="T:System.Linq.IQueryable`1" /> que se devuelve.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta fuertemente tipada representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TResult">Tipo del valor que es el resultado de ejecutar la consulta.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Representa una expresión que tiene un operador binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo del árbol de expresión; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtiene la función de conversión de tipos utilizada por una operación de uso combinado o una operación de asignación compuesta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa un tipo de función de conversión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es true si el nodo representa una llamada elevada; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores NULL.</summary>
      <returns>Es true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtiene el operando izquierdo de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo de la operación binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación binaria.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtiene el operando derecho de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho de la operación binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="left">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del resultado. </param>
      <param name="conversion">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del resultado.</param>
      <param name="right">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del resultado. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Representa un bloque que contiene una secuencia de expresiones donde se pueden definir variables.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtiene las expresiones de este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las expresiones de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtiene la última expresión de este bloque.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la última expresión de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del resultado. </param>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del resultado. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtiene las variables definidas en este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las variables definidas en este bloque.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Representa una instrucción catch en un bloque try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtiene el cuerpo del bloque catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtiene el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtiene el tipo de <see cref="T:System.Exception" /> que este controlador captura.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de <see cref="T:System.Exception" /> que este controlador captura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variable">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del resultado.</param>
      <param name="filter">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtiene una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Representa una expresión que tiene un operador condicional.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtiene la prueba de la operación condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba de la operación condicional.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="test">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del resultado.</param>
      <param name="ifTrue">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del resultado.</param>
      <param name="ifFalse">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Representa una expresión que tiene un valor constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtiene el valor de la expresión constante.</summary>
      <returns>
        <see cref="T:System.Object" /> igual al valor de la expresión representada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Emite o borra un punto de secuencia para obtener información de depuración.Esto permite al depurador resaltar el código fuente correcto al depurar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de código fuente.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtiene la columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtiene la línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtiene el valor para indicar si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se utiliza para borrar un punto de secuencia.</summary>
      <returns>Es true si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se va a utilizar para borrar un punto de secuencia; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtiene la columna inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtiene la línea inicial de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Representa el valor predeterminado de un tipo o una expresión vacía.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Representa un inicializador para un elemento único de una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtiene el método de instancia que se utiliza para agregar un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Un <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtiene la colección de argumentos que se pasan a un método que agrega un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>Uno de los objetos <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos para un método que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Devuelve una representación textual de un objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Devuelve una representación textual del objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Proporciona la clase base de la que se derivan las clases que representan los nodos de árbol de expresión.También contiene métodos de generador static (Shared en Visual Basic) para crear los diversos tipos de nodo.Esta es una clase abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Crea una nueva instancia de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama a <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador de suma para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND bit a bit.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND condicional que evalúa el segundo operando únicamente si el primer operando se evalúa como true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND condicional que evalúa el segundo operando solo si el primer operando se resuelve como true.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el bit a bit AND operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.O bien<paramref name="method" /> es null y <paramref name="left" />. Tipo y <paramref name="right" />. Tipo no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz multidimensional.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="array">Expresión que representa la matriz multidimensional.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene expresiones usadas para indexar la matriz.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="array">Expresión que representa la matriz para indizar.</param>
      <param name="indexes">Matriz que contiene expresiones usadas para indizar la matriz.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz cuyo rango es mayor que uno.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="indexes" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.O bienEl rango de <paramref name="array" />. Tipo no coincide con el número de elementos de <paramref name="indexes" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="indexes" /> no representa el <see cref="T:System.Int32" /> tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz de rango uno.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="index">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="index" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.O bien<paramref name="array" />. Tipo representa un tipo de matriz cuyo rango no es 1.O bien<paramref name="index" />. Type no representa el <see cref="T:System.Int32" /> tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz multidimensional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="array">Matriz de instancias o índices <see cref="T:System.Linq.Expressions.Expression" /> para la operación de índice de matriz.</param>
      <param name="indexes">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> o <paramref name="indexes" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.O bienEl rango de <paramref name="array" />. Tipo no coincide con el número de elementos de <paramref name="indexes" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="indexes" /> no representa el <see cref="T:System.Int32" /> tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión para obtener la longitud de una matriz unidimensional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> es <paramref name="array" />.</returns>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />. Type no representa un tipo de matriz.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.ExpressionlNodeType" /> es <sem cref="F:SyStem.Linq.Exprssionq.ExpressionUype.Assign"!.> i!cuyas prmpigdades <sae #ref="P:system.Linq&Expressikns.BinaryExpression.Left" +> y <see cref="Q:System.Linq.Expre{sions.BynaryExpre{sion.Right$/> s% estalecen$en los valorec espebificafos.</retu2ns
 !    <para name="left">bbeto <see cref="T:Cystem.Linq.Exqressyons.Expression" /> en ml que"se va a es|ablecer!la `ropiedad <see(cref="P:System.Linq.Exprassyons.BinaryExpression>Left" ?>.</param>
    ( <pa2am name="right">Objeto <see cref="T:Syqtee.Lina.Expre3sions.ex0ession" /> en eh que {e va a espab,eger la propmdad <see cref="P:S}stem.\inq.Expressions.BinaryExpressio~.Right" />.</param>
 0  </member>
    <member name="M:System.Lknq.Axpressions.Expressiol.Biod*System.Reflectioj.MemberInvo,System.Linq.Extreqsons.Exression)">
`     <summary>Crea un objeto <see cruf="T:System.Lioq.Exprewsions.MemberAssignmnt" /> yue representa la inicialización de un campo O una proiedad.</summary>
   "  <2eturns>
        <3ee cref="U:Systm.Linq.Expressimns.Memb!r@ssignoent"/> cuya propieda$ <see cref="PzSystem.Linq.Expresrions.MemberBinding.BindkngType /. es <see cr%f="F:System.Linq.Expressions.MemberBindingType.Asqignmen|" /> y cu}cs propiedades <see crff="P:Syrtem.Lin1.Ex`ressions.LembErBinding.Membeb" /> y <see cref=#P:ystem.inq.Expressions.MemberAssienmedt&ExpbessiOn" /> sg establecen gn!los valmres especificados.</returns?
      <xaram name="member">
        <see cref="D:System.Reflection.MemberInfo* /> en el que s% va a estcblecer(la!propieDad <sge cref="P:System.Linq.Expressions.Mem"erBinding.Member" />.|/param>
  ! ( <param name="ezprersion#>Objeto <see cref=*T:Syste}.Linq.Expressions.Expresrion" />$en ed que se va a estabhecer la propiedad see cref="P:System.Linq.EXpressionr.MEmberAssignment.Expression" />&</param:J    ` <excption cref="T:System.ArgumentNulnExcepdin">El valor de <paramref name="member" /> o <paraor%f name="expression" /> es null.</exceptiol>
  "   <dxception cref="T:Qystem.ArgumenuExceptioN">
`       <paramref name="member" /? no repre3enta n Campo`o propiedad.O cienLa propiedad representada por <paramref$name="membEr" /> no ti%nl un set descriptorde acceso.O"bxen<papamsef na-e<"exprmssion" />. Tipo"nm es asIgnable"al ti0o de campo o protiedad que <paramref na-e="memberb /> represet.</exception>
  ( </memcer>
  $ <member name="M:System.Linq.ExpressionsnExpres3ion.Binl(Syste-.Reflection.MethodIlfo,S9stem.Linq.Expressions.Expression">
      <summary>Csea un obeto <see cref="T:System.Linq&Expressions,Mdmber@ssignment" /> que0retresenta lA inycialización te un miembro mediante un mùtodo de dmscriptor de acges/ da ropiedad.</summary>
    0 <ruturns>
    "  <see bref}"T:SYstem.Linq.Expressions.Mem"erAssIgnmejd" />`cuya propiedad <sem cref=#P:System.Lhnq.Expressions.MemberBinding@indincType* /> es <see cref="F:Wystem.LiNq>Expressions.MemberBindingType.Assignmet""/>, cuya propiefaE <qee crmf<"P:SyStem.Linq.Exprssions.MemberBinding.Mdmber" /> se establece en el objeto <see cref="T:Systm.Reflektion.PropertYInfo" /> que representa la0propiedad a la que se obtend acceso en <paramref nqme="propertyAccessor" />, y cuy! prgpiedad <See #ref="P:System>Lijq.EXpres3ions.MemberAssignment.Expression" /> se %ctablege eN <parampeg naMe=bexpression />.4/returns>
      <par!m name="propertyAcaessor".
        <see cref="\:Syrteo.ReflEctIon.MethodIjfo /> que representa un mé4odo de d%scripto de accesg de propieda.</para}>
      <p`ra name="expression">Obheto <see cref="T:System.Linq.Expression7.Expression" /> en el que se va c establecgr la prpiedad <see cref=&P:Syqtem.Linq.Expressions.MemberAssignment.E|pression" />.</param>
 0"   <ex#extion cref="T:Wystem.ArgumentJullExce0ti/n">El valob de(<raramruf name="XropertyAcsessor" /> o <pavamref name="expresSikn" /> es null.</exception>
      <exception cref="T:SyStee
Argu}entExCeption">
       <paramref name="ropert{Accessor" /> lk reprds%nta un método de eesariptor de accewo de proriedad.O byenLa propie`at acaede <paramref name="prosertyAccesskr" /> no tiee un set descriptor de acceso. bej<parampef name="expression"0/>. Tipo oo u asignable el tipo dg capo o pbopiet`d que`<paraoref name="me}ber" /> representa.</exgeption>
$   </member>   $<member name="M:ystem.LinqExpressons.Expression.Block(System.Collections.GeneRic.IEnumerarme{System.Linq.Expressio.s.Expression})"?
      <swmmar{>Crea un ob*eto <see cref="T:System.Li.q.ExpressIons.Bl/ckExpression" /> que contiene!las expzesoneq daDas y qu} no tene variables./summarq>
 "    <returns:Obeto <see cref=2T:S}stem/Linq.Expressions.BlockMxpRession"`/> cread></Returns>
      <param name="exprersi/ns">Expresiofew del `loque.</param>
    </member>
    <member0name="M:System.Lanq.Exressions.Expressin.lock(System.Kollections.Generic.IEnulerable{System.Lmlq.Expressions.ParametezExpression},System.Collections.Generig.IEnQmerable{System.Linq.Dxpressios.Expression})">
      sUm-Ary>Csea un objeTo <see cref="T:Cystem.linq.Mxprgssions.BlockExpzessinn" /> qqe contiene dqs ririables y expresionds dadas.4/summaby>
      <returns:Objeto <seecref=bT:System,Liny.Expres3hoS.BlockAxpvessio" /> krEa`o.</returns>
"     <param name="variablms">Variables de, blouua.</pqram>
   (  <Param name="expressions">E8presionew del(bloque.<-param>
    </membeb>
    <memper!name5"M2SyStem.Lanq.EXpressir.Expression.Block(SYstem.Codlectinns&Generig.MEnumerablezSys6em.Lioq.Exxrecsions.ParammterExprecsion},System.Linq&Expressiofs.Exrression[])">
`     <summary>Crea un obje4o <see cref= T:System.Linq.E8pression{.BlOckExpression" /> que contiene las 6ariabler y expresiones dadas.</sqmmar}>
$    !<rtuvns>Objeto >see cref="T:System.Linq.Expressions.BlockExpre2sion" /> breado.</returns>
    ` <param ncme="varicb,es">Variables del bloquu.</param>
  $  <param name="expressions">Expresignes $el bloque.</param>
    </membes>
    <member namebM:System.Linq.Expressions.Expression.Jlock(Ry{temnLinqEx`ressions.Exrression,System.Lifq.Expres3ions.Expresskon!">
      <summapy>Cree un0objeto <ree cref="T*SystemLinq.Expressions.BlockExpressiof" /> que conthele dos expresIones y que no tiene variables.</sumary>
      <returns>Objeto <see"cref="T:System.Linq.Expresshgns.BlciExpression" /> cseado.</returns>
      <para} name="arg0">Primera expresión el `lgque.>/param>
"     <Param name="arg1">Segunda expresióndel bloque.</param>
    </member>
    <member Name="M:SystemLinq.Expressions.Expre3sion&Block*Sysuem*Linq.Ex`ressinns.Expression,Syst`m.Linq.Expres3ionq.ExpressiOn,System.Linq.Exprescions.Ex`ression">
      <summary>Crea un objeto <see crdf="T:SYsdem>Ninq.Expsessions.BlockExprmssion" /> que c/ntiene tres expresiones!y que n tiene viraables.</summary>     "<return{>Objeto <see cref"T:SysteenLinq.Expressionc.BlockExpression"`/> creado./returns>
      <parqi jame="arg0">Prmmera exprdsión del bloqwe.<'param>
     <param name="arg1">Segunda"expresió."Del bdoque.|/param>
      <param name="arg2">Tercera expresión deL`bloque.</param>
    8/membeR>
    <member name="M:System.Linq.Expressions.Expression.Block(Sstem.Linq.Expressmons.Expressio.,System.Lilq.ExpressIgns.Expressioj,ystem.Lifq.Ezpresskons.Exprmssioo,System.Linq.Expressions.Expression):
   ` 0<summary>Crea un`objeto <see cref="T8Sysem.Linq.Expressions.BlockExpressioN# /> que conti%ne cuatro expresiones y(que no`tiene Variables.<summ!ry>
!     <returns>Objeto <seg cref="T:System.Linq.Expressions/BlockExpresion" /> creado.</returnr>M
      <param name="arg1">Primera expresión del$bloque.</param>
 0    <param naie="arg1">Segunda expresión den$bloque.<param>
      <param Name="aRg"">Tercera exprmsióf del bloque.</param:
"     <param name="arg3>Cuabta expresaón del jloque.</param<
    </member>
    <m%Mber namg="M:System.Linq.Expressinnc.Expression.Block(System.Liq.Express)ons.Exprssio.,System.Linq.Exprersionq.Expression$Systmm.Linq.zprmssions.Expression,System.Lina.Exprmswions.Elpression,S}rtem.Linq.Expressions.Exrresion)">      <su-mavy>Crea un objevo <sae cref="T:RyStem.Linq.Expressions.Blockxprms3ion" /> que contiene cinco expresiones y que no tiene teria`lds.|/summary
    ! <returns>Objeto <see cref="T:Sys|e.Li.Q.expressions.BlockExpression" >0kreado.</returns>
      <parqm name="arg02>Primera expresiñn del bloQue.<pav)m>
      <param name="arf1">Segunda ayprEsión del bloque.</param>
      <param name="asg2">Tercereexpresión de| bloque>4/param>
      <param namE="a2g3">Cuarta`ehprwión del bloque.</param>
      <param lamg5"arg4">Quinta expresión Del bloaue.</param>   </-emer>
    <member name="M:System.Linq.ExpressionS.Expbession.Block(Systm.lioq*Expressions.Gxpression[])">
      <su}may>Crea un objepo <see cref=bT:System&knq.Eprescio~s*B,oakExpression" /> qu% contiene las expresiones dafas y que no tiene v`riabLes.</uimary>
    0<returns>ObjtO <sma cre&="T:System.Liq.Exprussions.BloakExzession" /> creado.</returns>
      <qarae name="expressaons">Expresiones del bloque.</parai>
`  </member>
    <mmmber name="M:System.Linq.ExpressIonq.ExrasSionnBlock(Syrtem.Type,System.Collecti/ns.GenmricnIEnumerable{Cystam,Linq.Expressions.Expression})">
      <summa2y>Crea un o`jeto <s%u cref="T:SystemLina.Ex`ressions.ClockDpprecsion" /> qua"aontiene las expr%sioner dadas, no tiene varh`bles y tiene el tio de resultad específico.</summasy>
     <reTurls>Objeto <see gref="T:System.Lin1.Epre{sions.BlockEypressyon" /> creado.<+reterns>
0   ( <par`m name="tqre">Tipo de resultado del bloque.\/arAm>
     "<param name="expr%ssyons"Mxpesiones lel bloque.</param>
    </membar>
("  <member name=2M:System.Linq.Expressions.ExpresSion.Block(System.Type,Syrtem.Collectionq.GenericnIEnumeral{S9stem.Dinq.Expresqions.TaramgtsExpression},Syste_.Cmllectins.Generkc>IEnumerable{System.Linq.Expressionr>Ex0ression})">
      <sUmiavy>Crea"un objeto <see gref8"T:System,Li~q.ExpreSsiols.BlgckExpression" / qu contie.e las"variables y expresioNes dadas.</summary>
      <rettrns>Objeo <Sue ref=&T:System.Dinq.E|pressions.BlogkExpressnn" /> cre`d/.</reurns>
     <pazao nqme="tipe".Tipo de resultado 4el Bloque.</para>
     !<param name="variables">Fariabhes del cloque.|/parim>
  "   <param nae="xpressions">Ex0resiones del bloque.</piram>
   (</lember:
    <member name="M:Sywtem.LinQ.Extressmons.UXpressIon.Block(Sistei.Type,System.Cohlecpions.Generic.IEnumerabLe{S{s|em.Linq.Expressyons.ParameterExpres)on},System.Hinq,Exprussiofw&Expressikn[])">
 "    <summar>Crea wn objeto <see cref="T>System.Linq.ExpressionS.BlockE8rression" /> 1ue contiene law varaable y expresiones0da$ac.</summary>
     <returns>Objeto <se$cref}"T:System.Lina.Expre3sios.BlockExpression" +> creado.</rdturnq>
      <parae name="|ype">Tipo de ves}ltado del blque.</pavam>
      <para} name="variacles">Variables del bloque.</0aram>
      <taram(n`me="expressikns">EXpresiones delblgQue*</patam>
    </member>
    4member name="M:systm.Linq.Expressions.Exprg{sion.B|ock(System.\yp%,System.Linq.Expressions.xrression[])*>
      <summary>Crea un objeto =se% cref="T:System.Linq.Exp2eqsions.BloakExpressin""/> quu contiene lasexpresiones dadas, no tiene variables y tiene el tipk de resultado esPecífic.</stmmary>
    <retuns>Objetm <see(cref="T:System.LinaEypressions.BlockExpsession" /> creado.=returns6
      <parao name="type">Tipo de rdsulTalo del bloque.</param>
  (   <param name="axprecsio.s">Ex2rdsyo,es $el"bloue.</psam>
0   </membev>
    <member name="M:System.Linq.Dxpreqsins.Expzesskon.Break(System.Linq.Expressions.LabelTarget) >
      <summary>Czea }n objeto <see cref="T:System.Linq.expressio.s.GktoExpresyion" /> pue representa(una inStrucción BReaK.</summay>
     <returns>
       <wee cruf="T:System.Linq.Extressions.GotoExpression" / con"<se 2ef":System.Linq.Expressions.GopoExprersyon.Kind" /> igual a Bp%ak, la propiedad 8see cr%f="P:System.Linq.Expressions.GodoExPrecsion.Targmt" /> estabh%ci`a en <paramref name="target" / y un vqlor null que0se pas`rá a la etiquetc de lestino al seltar.</retqrns>
      <param(name="target">
$       <see cef="T:SystemLinq.Expressions.LabelTargetj .>!al que saltará$<sme cref="T:System.Linq.Expressions.GotoEXpvesion"!/.</raram
    </member.
$  0<member ame=":System.Linq.Expressions.Expression.Break(Systam.Linq.Expressions.NabelTarget,System.Linq.Expressions.Expression)">
 4 0  <sumiar=>Crea un objeto =see cref="P:Siwtem.Linq.Expresshons.Gotoxpresson" /> que represejta una instrwcciӳn Braak.Se0puede especif)car el valop pue se pasa$a l! etiquata!uAneo se produke el salto.</summary?
$ !   <retuvns>
      ` <see creg=#:Syste.Lif1.Expres3ions.GotoExpression" /> con <see creb="P:Sy{tem.Linq.xtressions.GotoExppession.Kmnd" / igual a Bre!k, lapropmedad <seE cref="P:System.Linq.ExreSsiojs.GotoExPr%ssikn.Uargmt" n> establecida0en <parAmr%f name="tarfet& /> y un <paramref name="alue" /> que se pasará a le etiqueta de destino a saltar.</returns>
 "    <param name="ar'et">
  0     <see crdg=":S{stem.Linq.Expressions.LajelTarcet" /> al que saltará!|see csef="T:System.Linq.ExpressionsnGotoE|pression" />./pcram>
`     <param name="value">Val/r qu se va a xaser a la etiqueta asoCiaea cUanto!we produca el salo.</param>J   </membmr>
    <member namm="M:System.Nnq&Ex0bessions.Expr%ssion.BrEai(Sysdmm.Linq.Expressinns.MabdlTarget,Sys4em.inq&Expresinns.Expression,Sys4em.Type1">J(     sumary>Crec un objeto <sme cref="T:Sytei.Linq.Expressionq.Gk|oExpression" /?que bepresnta una ynStrUcción Break con el tipo espe#kficclo.Su puedd erpecificar ed valor que se pasa a!la etiqueta cuando se prodube el saltm.</summarq>
 0    <returNs>
   "    <se cref="T:System.Linq.Expressions.GotoEx`2EssIon" /> cn <see cref="P:Systai.Linq.Expressiols.GotoMxpression.Kin`" /> igtql c Break, lapropiedad <seE creF="P:Ssstem.Lynq.ExprersionsnGotoExpression.Targev"/> estarlucida en <pa2amreb name="tArget" /6,(l!!propieded <cge cref="P:System.Linq.Expressions.Ex0ressin.Type" /> establecide ej <parqmref name="type" /> y un <paramref name="valug2$/> q5E se pasará a la etiqueta de destino$al saltar.</rEturns>
(     <param name="tArge">
      ! <see cref="T:System.Linq.xprersionS.LafelTaroet" /> al que saltasà <sem cref="T:Sytem.Linu/Exprmssions.GotoE8pression" o>></Parae~
    ! <parao name="valuE">Valor pue se va a pasar"e la etiqueta asociadq cuando se produzca el salto.</pavam>
      <param n`me="Tipe">Objeto <see cref="T:Sysuem.Type" />0en el que se va a ewtablgcer li proqiedad0<see cref= P:Syste-.Linq.Expressions.Exprassion.Type" />.</param>
    </member>
    <member .aie"M:System.Lijq.Expressions.Expres3mon.Break(System.Linq.Eppressions.LabelTarget,SystdmType!".
      summcry>Crea un objeto see cref="T:System.Linq.Extpess)ons.GotoMxpession" /> pua rpresenta qna inssucción Breakcon el tipo eSpecinicado"|?summary>
      <zmturns6
        <see crEf="V:System.LifQ.ExpressionqGotoU|pbessign" /> con <weu cref=#P:System.Linq.Expressins.GotoExxressioN.Kind" /> igual a Breek, la rro`iedad <see cref="P:System.Ninq.Expressions.GouoExpression.Target" /~ establmcida eN <paramreF n#me"target" /> y la propiedad <see craf="P:System.Linq.Expzessions.Ex`ression.Type" /: Estajleaida eN <paramref nAme="tyPe" />.</eurNs>      <param name="4arget">
$       <see`cRef="\:Qyctem.Linq.EXprgssiols.LabelTarget" /> al ue saltará <see cref="T:Sysuem.Linq.Expressiojs&GotoEpqression"!/>.</pavam>
      <param name="uyPe">_jdto <see cref=&T:System.xpE" /? en el que s v` a astajlecer la propiedad <see craf="P:systemLinq.Expressions.Expression.Typ%2 />.</param>
    </member:
    <membe2!name="M:System.Linq.Exrressions.Expression.Call(S9stem.LinqnExprqssions.Expression,System,Reflection.MethodInfo)">
      <sUmmary>Crea un obkeo <see cref="T:System.Linq.Expsessins.]ethodallExprewsion" /> que rtp2esenta una llalada a un método que no toma ning:n argumentm.<'summiry>
      <rEturjs6
 "$     <se cref="TzSystem.LinQ.E|preSsiOns.MEthodC!llExpressioj" /> cuya pxopiedad <seecr%f="p:S3tem.L)nq.Expressions.Expression.NodeVYpe" /: es <sue creF=":System.Linq.Exprecsions.Expressio~TyPe.C#ll" o> y cuyas propiedades <see cpef=PSystel.LinqExpresscons.Met`odCalnAxtressinn.object" /> y see #red="P:System.Linq.Expressions.Meho`CallExpression.Metod" .> se estabmecdn en los valores especificados*</returns>
   $  <param nama="anstance">
`       <see cref="T:Systdm.Liny.ExxRessions.Expreqsion" /> que esecificala instancia paa una llamada an!méTodo de instancia (pa{a nll para un método"static, Sh`red en`Visual B`smc)*>/param>
   !  <param`name="met(od">
        <see cruf="T:System.Reflectio~.MethodInfo" /> en el que se$va a estableces la propiedad <sme cref?"P:System.Linq.Expressions.MethodCalhExpression.Methof" />.</aRam>
!0    <ex#eptiol crdf9"T:Wystem.ARgumeotLullException">Eh valor dm <parambef name="method" /> es ull.O bien<paramref name=bmnsdance" > es null y <paramref Name="method /> representa un método de instancia.4/exc%ption>
      <exception cref="T:Sysuem.rgumentExceptIon">
        <paramrgf name="instance" />* Tipo no es%asigndble al tipo declarativo del métndo representado por <paramref oame="medhot"`/>.</exception>
    </ember>
    <member Name="M:Sys4em.Linq.Expressions.Dxpression.Aall(System.Liou.Expressions.xpressio.,System.Reflection.EethodInfo,Wywtem.Collections.Generic.IEnumerale{System.Linq.Expressionw.Ezpression})">
    $ <summary>Crea un objeto <see cref="T:System.Linq.Expvessiof{.MathndCallExpr%ssion" />$que representa!una llamada a un método que toma argume.tOs.</summary;
  0   <returos>
        <see(czef="T:System.Liny.Exxressions.MephodCallXtsession" /> cuya propiedad <see c"gf=b:System.Linq.Expressions.ExprEssion.NodeType" /> es <see cref="F:ystem.Linq.Expressions.ExprdssionType.Call" /~ y >seu cref="P:Syst%m.Linq.Exprssion{.Me|iodCalAhpression.ObjEct" /, <see csef=*P:SystemLinq.Expressyons.IethodCallExpression.Method" /> y <see cref="P:System.Lin.Gxpressions.MethodCallExpressin.AroUments" /> se espablecen en!los vilores"e{pecificados.</reuUrns>
 0    <param name="instanc">Objeto <see cre="T:System.Linq.Expressions.ExpressiOn" /> en el que se va a dsvablecer`la qroqieda <see cref="P:Systmm.Ninq&Expressions.Muth/dallExpres3ion.Object" /> (pase n}ll para un método qtatmc, Shared en Vis5| Baskc)/</param>
      <param name="metod">
        <see cref="T:System.Redlection.MethodInfo" /. en el que se va a esuablecer la ppopiedad$<see cref="P:SysTmm.\ina.Expressions.Meth/dCsllExpression.Method" />.</p!ram>
      <param name=&arguments">
        <see cref= T:System.Collectigns.eneryc.IEnumerable`1" -> q}e co.tiene$ls objeto3 <see cre&="T:ystem.Linq.Exprmssions.Expression" /> que se!van a Usar paza rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.O bien<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="method" />.O bienEl júmero le elemendos de <`aramref fame="arguments" />(no es el número de0perӡmetros pera l método representado(por <paramref name="method" />.O bienUno o varios de lgs elementos de <paramref name="argueents" /> No es asignible"al parámetro corr%spoodIente del método zeprewenta`o por <paramref name="method" />.</exception>
    </-ember>    <meiber name="M:System.Linq.Exprssions.ExppessiOn.Cal(System.Linq.Expressions.Expression,System.Revlection.MethodInfo,System.Linq.Expressions.Expression,Sysem.Linq.Dxprewsions.Exprdssion)">
      <summary>Craa un objeto <see cref="T:Sxstem.LinQ.Expressio.s.MethodCallExpression" '> que repesenta una \lamada a un método que toma oS0argumentos.</summary>
      <returnS>
        <see cref"T:System.Linq.Expressions.MethodCallExpression" > cuya propiedad <see bref="P:System.Lnq.Expreqsions.Expression.NduType" /> es <see cref="FSystem.Linq.Expr%ssions.Expres{ionType.Call" /> y cuyas propiedade3 <see cref="P:System.LinqExrresqions.MethodAal|ExPrussion.Object" /> y <cee cref="P:Sistem.Linq.Eypressions.MethodCllExpression.Method" /> se dstablecen en lo{ valores!es`ecidiaafos.</re|}rns>
  ! ` <param name="instance">
        <see cref=#TzSystem.Lmnq.Expressmo~s.Expreqsion& /: que espacifica la instancia d una llamada de instancia.(Tasa n5ll pab!$ul método estático que en Visual Basic es compartido).</pazam>
     "<parcm jame=#method">
        <see cref="T:Systgm.Refleation.MethkdInfn" />!que zepresenta el método de destino</param>
      <param name=barg">
        <see cRef="T:System.Li.q.Exppess)ons.Ezpression" />`que representa el!primer argumento.<?param>
     <p`ram name="arg1">
        <s%e c`ef="T2System.Linq.Exprerso~s.Expressin" /> que represefta el`{egundo argumento/<+param>
    </member>
   "<member naMe="M>System.Linq.Expressions.Expression+Call(System.Linq.UxPressionS.Ehpression,System.Reflecdion.MethodInfo,Sysvem.Linq.Expressions.Exprewsion,Systdm.Linq.ExpvessionS/ExpreSyion,System.Linq.Expressions.Expreqsion)">
 `    <summ`ry>Crea un objeto <sEe cren="T:System.Linq.Expresrinnr.MethodCallEXpression" /> qua representa u~a llamada a ul método`que toea tres argumentos.<-summary>
     <retUrns>
        <see cref="T:System.Linq.Expressions.MethotCallExpression" /> cuya propiedad <see cref="P*System.Linq.Expressio.s.Expression.NodeType""+> es =ee cref="F:System.Linq.Expressions.DxpressionTyre.CalLb /> y cuyas propi%dades <{ee`szef="P>System.Linq/Exprdssions,MethodCallExprgssion.Object" /> y see cref="P:System.Linq.Expressinns.MethldCallExpression.Method" /> se est`blecen en los valres esxecifiados./rg4urns>
      <param name="intance">
        <sem cref="T:System&Diny.Expressions.EXpression" /> que`especifica ,a i.stancia de una llamada(de instancia.(Pasa null para un método esàtico, que en Visual Basic es comp!rtido).</para>	
      <xaram name="metlod">
        <see crefT:Wystem.Reflectin.MethodInfo" /> que represe.ta el métolo de destinn.4/param>
      |0arae name="arg0">
        <see(cref="T:System.Linq.Expressionc.Expression" /6 que representa el primer argmento.<param>
      <param name="arg1#
      ! <see cref="T:System.Linq.Expresskons.Expbesskn""/> que represanta el seoundo argumento/='pAram>
      <param name=2asg2">
    (   <see cref="T:SysemLinq.Expressions.Expre{sIon" /> que representa el terer argqmnto.</param>   </member>    <member name="MzSystem.Linq.ExpressiOns&Exressikn.Call(System.Linq.ExrresioNs.Ehpression,Systee.Reflection>MethodInfo,System.Linq.E|pressions.Expression[])">
     <summarY>Crea un objeto <see cref="T:Systeo.Lm.q.ExpresQions.MehodCallExpression" /> que represent! una llamada a un método que`tomaargumentos.</summary>
     <ruturns:
   $    4see cref="T:[ystem.Linq.Expressions.MethodCallExpreqsion" /> cuya psopiedad <ed cref="X:System.Linq.Exsersions.ExpressionNodeType" > e3 <see cref=":Sistee.Linq.Eypressions.ExpressionType.Cal," /> y <sem cref=*P:System.Lina.Expressions.ehodCallExpression.Object" />, <see cref="P:SystEm.Linq.Exprecions.MethofCallExtression.Method* /> y <see cref="P:System.Linq.Express)ons.MethodCallExpression*Argumentsb /> se establecen en los`valores especificados</return3>
      <param name="inst`nce">
        <see cref="T:Systdm.Linq.Expressions.Ex0ress)on" /> que especiFSa la iostcnciapaba!qna"llamada al método de inspanci`!(pasa null para un método stat)c, Shared en Visual Fasic).</param>
      <peram name="method">        <see cbef="T:System.eflecthof.IethodInfk" /> en el qUe se va a establecer la propiedad`<seg cref="P:Systdm.Linq.xpressions.MethmdCaldExpressioN.Mevhod" />.</param>
      <param name="argUmeots">Matriz de ob*etos <see kref="T:System.LiNq.Expresrions.Expression" /> que se vc a usar para rEllenar d` coleccIóf de <see cref="P:System.Linq.ExpressIons.MedhodCallExpressiol.Arguments" />.<'param?
      <e|ception cref="T:System.ArguoentNullExcEpti/n#>El valor de <paramruf name="methodb />es null.O bien<paramref name="instance" /> esnull y <raramref na}e="method" /> repResenta un méto$o de instancieO bien<pasamref name="ergumelts" /> no es null y uno o varios fe sus elementos están null.</exception>
      <exception0cref=":System.ArgumetExfeption">
        <ara}ref name="inspange" />. TiPo no es asignable al pipo deslarativm del método Rapresenado por <parmreF na-e="metxod" />,O bienEl número de eleentos`de <per!mref lame="arguments" /> no us el número d% arámetros para el método representado por <paramref name="method  /> bienUno o varios de0los elementos dm<0aramref ame5"arguments" /> no$es asignable al parã-e|ro cobrespondie~te`del métodore`reqenpado por <paramvef name="method" />.</exception>
    </memfer>
    <mecer name"M:System.Linq,Expressions.Expressmon.all(Cxstem.LInq.Eptrersions.Expression,Sys|em.String,SystEm.TypEZ]System.Linq.Expressions.Expression[])":
      <sum-ary>Crea un objet/ <see czef"T>System.Lqnq.Expressions.MethodCallExprasSion" />`que representa una llamada A un mëtodo llamando al método del generaeor apropiado.</sulmary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallEypressio." /> cya propiedad <see cref="P:Wystem.Linq.Mxpression{.ExrrEssion.NodeType" /> es <see cRef="F:Syst%m.Linq.Expressions.ExpressionType.Call /> cuya propiedad <see"cref="PSystem.Linq.Expressions.MethodCallExpression.Object" /> es <p`ramre name="instance" />, >see cref=*PSstem.Lin.Expressyonc.M%thodCcllExpressin.Method" /> se establece en el`objeto <qee cref="T:ystem.Reflection.MethodInfo" /> que representa e lépodo de instancia especificado y <see cvef="PSystemnLinq.Expressinns.MethodCallExpression.Arguments" /> se establece en los aRgumentos especIficados.</returns>
      <param name="instance">M
(       <see cref="T:System.Linq.Dxpressions.ExpressMon" /> en cuyo valor de propiedad see cref="P:Sys|em.Linq.Expressiojs.Expression.Type" /> se uscará un métodm dspeífico.</param.
 0   `<pa2cm name="methodJaee">Nombre den métodg.</param>
      4param nqme="tqxeArguments">Matriz de nbjetos 4see kref="t:Systel.Type" /> que erpecifican los parámdros de tipo$del mtodo genérico.Este argumenk dmbería ser null buan`o methndNale especifia un método0no gen˩rico.</param>
      <param name9"arguments">Mqtviz de objepos <see cref="T:Systum.Linq.Expressions.Exp2essiol" /> que represnta los argumenuos del m)todo.</pasam>
      <exception cref="T:S{stem.ArgmentnullException">El valor de <paramref name="instance" /> o <`arimref ncme="methodN`me" /> %s null*=/exception>
    ! <exception$cref="T:System.InvalidOPeratiojExcepton">Jo hay ningú~ método cuyo nombre es <paramref name="mdthodName& ., cuyos parámetros de t)po coiNcidan con <paramref na}e="typeArgumen4sc />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments2$/ se encuentra0en <paramref name="instance" />. Tipo o sus vipos base.O bidnMás de un mëtodo cuyo nombre es <paramref name="mathoeName" />, cu{os parámetrns de tipo coincidan cgn <paramref name="typeArguents" />, y0coi.cidencia de los ti`os cuyo parámetro <par`mref name="crgumen|s" /> sd encuentra en <paraeref name="instance" />. Tipo o(sus tkpos base.|/excertion>	
    </member>
    <membgr name= M:System.Linq.Eppressmons.Expression.Call(ystem.Reflection.ethodInf,System.Cnllections.Oeneric.IEnmEraBle{System.Linq.ExPresSions.Exprssion})B>
 (    <summary>Crga0un objeto <see cref="T:System.Linq.Ex0resions.MethodCcllExpression" /> que represent! una llamada a un méto$o estático (Shared en Visual BasiC).4/wummary>  $"  ,returjs>
        <see cref="T:System.Linq.Expressions.MethodCallDxpression" /6!c7ya propiedat <see csef="P:Systam.Lhna.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressons.ExpressonTqpe.Cqll" /> y cuyas rropiedades <see crof="P:System.Linq.Expvessions.MethoDCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethoCallMxpzessio.nMethod" />$se mstablecen un los valoresespecificaos.</returns>
      <param(name="method">
        <see cref="T:System.Refl%ction.MethodInfo" /> que0representa el método(de destino.</param>
     <param name="arguments"oleccin de objutos <see cref="T:Systdm,Lilq.Exprewsions.Expression" /> que0representa los `rum%ntos de llimada.</pcram>-
 (  <omembr>
    <memer name="M:System.Linq.Expressions.Expression.Call(System.ReflectionMethodInfo,System.Liq.Expraqsins.Expression)">
      <summary>Crea un Objeto <see czef="T:System.Minq.Expressions.MethgdCallExpression" /> que represaota una llamada a un méto`o static (Shared en Visual basic) que toma un argumento./summary>
 "    <returns>
        <see cref="T:System.Linq.Expressions.MethodCallMxpression" / cuya propiedad <see cref="P:System.Lin1.Expressions.Dxprersao~.NodeType" o> es <see craf="F:System.Minq.Expressiofs.ExPressiolType.Call" /> y cuyas propiedades <see cref="P:SysTee.Li^q.Expressiofs.MethodCallExpression.Objectb /> y <see cre="P8Sqstem.Lhnq.Expressions.MethodCAhlExpRescion.Method /> se establecan en loc valores especificados.</2epurns>
      <paraM name="method">
        <see cref="T:Qystdm.Refluction.MethodInfo" /> en el que se va ` establecer la psopiedad |s%e cRef="P:System.Linq.Expressions.MetjodCallExpression.Method" />.</param>
      <paam name="arg0"> "      <see cref9"T:System>Linq.Express)onsExpression" /> que representa el prhmer argu}ento.</param>
      <exceptin cref="T:Sys|m.ArgumentNullExcuption">
    $   <paramref ame="mehod" /> ec null.=/exception>
  0 </mmber>    <memrer name="MSystem.Lynq.Ex`ressons.Expression.Call(System.Reflec|ion.MethodInfo,System.Linq.Uxpressions.Expression,Sq{tem.Linq,Expres{io.s,expre3sion)">
     <summary>Crea ul objeto <seu cref="T:System.Linq.Expreqsions.MethodCallExpression" > que repbesdnt` un! lhamafa a un m)todo estático que tnma dos argumentos.</summar9>
    $ <returns>
  (    $<seg cref="T:System.Liny.Expressions.MethodCallExpression" /> cuya proxiedad <seE cref="P:Syste->Linq.Expressaons.ExpressionNodeDypa" /> es!<see cref="F:System.Lifq.Expressions.ExprEsionType.Call" /> i Cuyas propiodades <se creF=*P:System.linq.Exprus{ions.MethoeCallExprdssion.Object  /> y <see cref="P:SysteM.Lknq.Expreswions.MetiodCallExpression.Method" /> se(stablecn en los valores especifacados.4/returns>! (   aram oeme-"method">
        <see cref="T:Sy{tem.Reflection.MethodIofo" '> en %l qu% se va ! %stableber la propiedid 8see kreF="P:ystem.Linq>EXpressio.s.Meth/dCallExpRession.Method" />.</pa2am>
      <param name="crg0">
        see cref="T:System.Linq.Expressions.Expression" /> 1ee representa!el primer argumento.</para>      <param name="ir'1">
        |see cref="T:Systdm.Linq.Expressions.Expression" /> uue representa el segundo awgumeoto.</param>
      <exception cref=T:System.ArgumetNwllxCepton"?
        <paramref name="metxol" /> es null.</exceptaon>
    </mem`er.
    <member fame="M:Systeo.LMnq.Expressions.Exprersion.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,Syste}.Linq.Exrresskons.Expression,System.Linq.Exprescions.Expressio)">-
      <sueeary>Crea un objeto =se% cref="T:[ystem.linq.Expressions.Metho$CallExpresSion" /> que 2epresenta!}na llamada a un método estático que toma tres argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="metiod">
        <see cref}"T:SysTemR%flection.MethodInfo" /> en el que se v a establdcer lq propiedad <see cref="P:S{stem.Linq.Dxpressins.MethodCahlexxressio..Method" />.x/papam>
      <pavam(nime="arg0">
        <see creb="T*Syste.Linq.Expressions.Ehpression" /> que representa el primer argumento.<oparam>
      <pqram namu="re1">
        <qee cref="T:System.Linq.Expresrions.Expression" /> que repr%smnta el segufdo argumento.<+param>
      <param nam%="arg2">
        <qee cref="D:Systum.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cuatro argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cinco argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <param name="arg4">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el quinto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) que tiene argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método static (Shared en Visual Basic) en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="method" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El número de elementos de <paramref name="arguments" /> no es el número de parámetros para el método representado por <paramref name="method" />.O bienUno o varios de los elementos de <paramref name="arguments" /> no es asignable al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método static especificado (Shared en Visual Basic) y cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo que contiene el método static especificado (Shared en Visual Basic).</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="methodName" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="type" /> o sus tipos base.O bienMás de un método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" />, y coincidencia de los tipos cuyo parámetro <paramref name="arguments" /> se encuentra en <paramref name="type" /> o sus tipos base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica que el nodo se puede reducir a uno más simple.Si devuelve true, se puede llamar a Reduce() para generar el formulario reducido.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con una referencia al objeto <see cref="T:System.Exception" /> detectado para su uso en el cuerpo del controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> y una referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> pero sin ninguna referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de secuencia.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de fusión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="left" /> no representa un tipo de referencia o un tipo de valor que aceptan valores NULL.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />. Tipo y <paramref name="right" />. El tipo no son convertibles entre sí.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de fusión, dada una función de conversión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />. Tipo y <paramref name="right" />. El tipo no son convertibles entre sí.O bien<paramref name="conversion" /> no es null y <paramref name="conversion" />. Tipo es un tipo de delegado que no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="left" /> no representa un tipo de referencia o un tipo de valor que aceptan valores NULL.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="left" /> representa un tipo que no se puede asignar al tipo de parámetro del tipo delegado <paramref name="conversion" />. Tipo.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de <paramref name="right" /> no es igual que el tipo de valor devuelto del tipo delegado <paramref name="conversion" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> o <paramref name="ifTrue" /> o <paramref name="ifFalse" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />. El tipo no es <see cref="T:System.Boolean" />.O bien<paramref name="ifTrue" />. Tipo no es igual a <paramref name="ifFalse" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> establecida en el valor especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> se establece en el valor especificado.</returns>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> establecidas en los valores especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> no es null y <paramref name="type" /> no es asignable desde el tipo dinámico de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión de tipos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión para la que se especifica el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.O bien<paramref name="expression" />. Tipo no es asignable al tipo de argumento del método representado por <paramref name="method" />.O bienEl tipo de valor devuelto del método representado por <paramref name="method" /> no es asignable al <paramref name="type" />.O bien<paramref name="expression" />. Tipo o <paramref name="type" /> es un tipo de valor que acepta valores NULL y el tipo de valor no acepta valores NULL correspondiente no es el tipo de argumento o tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método que coincide con el <paramref name="method" /> se encontró la descripción.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si el tipo de destino está desbordado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si el tipo de destino está desbordado y para la que se especifica el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido ningún operador entre <paramref name="expression" />. Tipo y <paramref name="type" />.O bien<paramref name="expression" />. Tipo no es asignable al tipo de argumento del método representado por <paramref name="method" />.O bienEl tipo de valor devuelto del método representado por <paramref name="method" /> no es asignable al <paramref name="type" />.O bien<paramref name="expression" />. Tipo o <paramref name="type" /> es un tipo de valor que acepta valores NULL y el tipo de valor no acepta valores NULL correspondiente no es el tipo de argumento o tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Más de un método que coincide con el <paramref name="method" /> se encontró la descripción.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con el intervalo especificado.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
      <param name="startLine">Línea de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="startColumn">Columna de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="endLine">Línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor o igual que la línea de inicio.</param>
      <param name="endColumn">Columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Si la línea de fin es igual que la de inicio, debe ser mayor o igual que la columna de inicio.En cualquier caso, debe ser mayor que 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en el tipo especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de división no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de división no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dado un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> como segundo argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método que <paramref name="addMethod" /> representa no se denomina "Add" (con distinción entre mayúsculas y minúsculas).O bienEl método que <paramref name="addMethod" /> representa no es un método de instancia.O bien<paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del método que <paramref name="addMethod" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dada una matriz de valores como segundo argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ElementInit" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> establecidas en los valores especificados.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método que addMethod representa no se denomina "Add" (sin distinción entre mayúsculas y minúsculas).O bienEl método que addMethod representa no es un método de instancia.O bienEl parámetro arguments no contiene el mismo número de elementos que el número de parámetros del método que addMethod representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del método que <paramref name="addMethod" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea una expresión vacía que tiene el tipo <see cref="T:System.Void" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de igualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de igualdad no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El XOR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y la XOR operador no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Para static (Shared en Visual Basic), <paramref name="expression" /> debe ser null.</param>
      <param name="field">Objeto <see cref="T:System.Reflection.FieldInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="field" /> es null.O bienEl campo representado por <paramref name="field" /> no static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo del campo representado por <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo dado el nombre del campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo denotado por <paramref name="fieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo llamado <paramref name="fieldName" />.Este puede ser null para los campos estáticos.</param>
      <param name="fieldName">Nombre de un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="fieldName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ningún campo denominado <paramref name="fieldName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
      <param name="expression">Objeto contenedor del campo.Este puede ser null para los campos estáticos.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene el campo.</param>
      <param name="fieldName">Campo al que se va a obtener acceso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crea un objeto <see cref="T:System.Type" /> que representa un tipo de delegado System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>Tipo de un delegado System.Action que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de hasta dieciséis objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene más de dieciséis elementos.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtiene un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func o System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>Tipo de delegado.</returns>
      <param name="typeArgs">Argumentos de tipo del delegado.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos.El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <returns>Tipo de un delegado System.Func que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de entre uno y diecisiete objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Func.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene menos de uno o más de diecisiete elementos.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to".Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción "go to" con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "mayor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "mayor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "mayor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "mayor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con una instrucción if.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> se establecen en los valores especificados.La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establece en la expresión predeterminada y el tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con instrucciones if y else.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> se establecen en los valores especificados.El tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento del valor de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el aumento de la expresión en 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión aumentada.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a aumentar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda a los que se aplicará.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Type no representa un tipo de delegado o un <see cref="T:System.Linq.Expressions.Expression`1" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado o expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o expresión lambda que se aplicará.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplican el delegado o expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Type no representa un tipo de delegado o un <see cref="T:System.Linq.Expressions.Expression`1" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y sin nombre.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta sin un valor predeterminado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sin un valor predeterminado.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta con el valor predeterminado dado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> con el valor predeterminado dado.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue">Valor de este objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se alcanza la etiqueta mediante el flujo de control regular.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con un tipo void y con el nombre dado.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo dado.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo y el nombre dados.</summary>
      <returns>Nuevo objeto <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="body" /> es null.O bienUno o varios elementos de <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contiene más de dieciséis elementos.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuyo tipo de delegado se conoce en tiempo de compilación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> que representa una firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> que representa una firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="delegateType" /> o <paramref name="body" /> es null.O bienUno o más elementos en <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.O bien<paramref name="body" />. Tipo representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.O bien<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="parameters" /> no es asignable desde el tipo del parámetro de tipo correspondiente del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />. </param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se aplicará la optimización de llamada de cola al compilar la expresión creada. </param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la firma de delegado para lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desplazamiento a la izquierda no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desplazamiento a la izquierda no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la izquierda bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "menor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "menor que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador "menor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador "menor o igual que" no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad que representa el método <paramref name="propertyAccessor" /> accesos no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basado en un método de descriptor de acceso de propiedad especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad que representa el método <paramref name="propertyAccessor" /> accesos no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) declarados en <paramref name="newExpression" />. Type o su tipo base.O bienEl método add en <paramref name="newExpression" />. Type o su tipo base no toma exactamente un argumento.O bienEl tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método add en <paramref name="newExpression" />. Type o su tipo base.O bienExiste más de un método de compatible con los argumentos denominado "Add" (entre mayúsculas y minúsculas) en <paramref name="newExpression" />. Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método llamado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) declarados en <paramref name="newExpression" />. Type o su tipo base.O bienEl método add en <paramref name="newExpression" />. Type o su tipo base no toma exactamente un argumento.O bienEl tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad del primer elemento de <paramref name="initializers" /> no es asignable al tipo de argumento del método add en <paramref name="newExpression" />. Type o su tipo base.O bienExiste más de un método de compatible con los argumentos denominado "Add" (entre mayúsculas y minúsculas) en <paramref name="newExpression" />. Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia llamado "Add" (no distingue entre mayúsculas y minúsculas) que agrega un elemento a una colección.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.O bien<paramref name="addMethod" /> no es null y no representa un método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.O bien<paramref name="addMethod" /> no es null y el tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="initializers" /> no es asignable al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y no existe ningún método de instancia denominado "Add" que toma un argumento de tipo compatible en <paramref name="newExpression" />. Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que usa un método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> se establece en el valor especificado.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que toma un argumento que agrega un elemento a una colección.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="initializers" /> es null.O bienUno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />. El tipo no implementa <see cref="T:System.Collections.IEnumerable" />.O bien<paramref name="addMethod" /> no es null y no representa un método de instancia denominado "Add" (con distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.O bien<paramref name="addMethod" /> no es null y el tipo representado por la <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de uno o varios elementos de <paramref name="initializers" /> no es asignable al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y no existe ningún método de instancia denominado "Add" que toma un argumento de tipo compatible en <paramref name="newExpression" />. Type o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado y el destino Break.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
      <param name="continue">Destino Continue empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados los operandos izquierdo y derecho, llamando a un método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho y el método de implementación, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho, el método de implementación y la función de conversión de tipos, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación binaria.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">Es true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; es false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa una función de conversión de tipos.Este parámetro solo se usa si <paramref name="binaryType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o una asignación compuesta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a un nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que este <see cref="T:System.Linq.Expressions.CatchBlock" /> controlará.</param>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto al objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado.Además se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> del objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada en un objeto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Debe ser null si la propiedad es static (shared en Visual Basic).</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) en Visual Basic) que contiene los argumentos que se usarán para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo o a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto al que pertenece el miembro.Puede ser null para los miembros estáticos.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que describe el campo o la propiedad a los que se va a tener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="type">Tipo de resultado de la expresión try.Si es null, el cuerpo y todos los controladores deben tener un tipo idéntico.</param>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.Pasa null si el bloque try no tiene ningún bloque finally asociado.</param>
      <param name="fault">Cuerpo del bloque fault.Pasa null si el bloque try no tiene ningún bloque fault asociado.</param>
      <param name="handlers">Colección de objetos <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado un operando, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase null si no es aplicable).</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no se corresponde con un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dados un operando y un método de implementación, llamando al método del generador apropiado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que es el resultado de llamar al método del generador apropiado.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de operación unaria.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo al que se va a convertir (pase null si no es aplicable).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no se corresponde con un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa un campo o propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de campo o propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de la propiedad que se tiene acceso mediante el método que <paramref name="propertyAccessor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se accede mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa un método de descriptor de acceso de propiedad.O bienEl <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo de la propiedad que se tiene acceso mediante el método que <paramref name="propertyAccessor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Representa una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo que <paramref name="newExpression" />. Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> propiedad de un elemento de <paramref name="bindings" /> no representa un miembro del tipo que <paramref name="newExpression" />. Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de módulo no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de módulo no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de multiplicación no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador unario menos para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador unario menos para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se define el operador unario menos para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética que tiene comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no se define el operador unario menos para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado que no toma ningún argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el valor especificado.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El constructor que <paramref name="constructor" /> representa tiene al menos un parámetro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <paramref name="arguments" /> parámetro no contiene el mismo número de elementos que el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.Se especifican los miembros que obtienen acceso a los campos inicializados por el constructor.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Reflection.MemberInfo" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.O bienUn elemento de <paramref name="members" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <paramref name="arguments" /> parámetro no contiene el mismo número de elementos que el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.O bienEl <paramref name="members" /> parámetro no tiene el mismo número de elementos como <paramref name="arguments" />.O bienUn elemento de <paramref name="arguments" /> tiene un <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.Los miembros que obtienen acceso a los campos inicializados por el constructor se especifican como una matriz.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.O bienUn elemento de <paramref name="members" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <paramref name="arguments" /> parámetro no contiene el mismo número de elementos que el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.O bienEl <paramref name="members" /> parámetro no tiene el mismo número de elementos como <paramref name="arguments" />.O bienUn elemento de <paramref name="arguments" /> tiene un <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor especificado con los argumentos especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="constructor" /> es null.O bienUn elemento de <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="arguments" /> coincide con el número de parámetros del constructor que <paramref name="constructor" /> representa.O bienEl <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="arguments" /> no es asignable al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor sin parámetros del tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> se establece en el objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor sin parámetros del tipo especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que tiene un constructor que no toma ningún argumento.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El tipo que <paramref name="type" /> representa no tiene un constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="bounds" /> es null.O bienUn elemento de <paramref name="bounds" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El <see cref="P:System.Linq.Expressions.Expression.Type" /> propiedad de un elemento de <paramref name="bounds" /> no representa un tipo integral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz que tiene el rango especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> se establece en el valor especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> o <paramref name="bounds" /> es null.O bienUn elemento de <paramref name="bounds" /> es null.</exception>
      <exception cref="T:System.Argumen4Exception">El <see cref="P:System.Linq.Expreswions>Eppression.Type" /> propaeded de un elemento de <paramref name="bounds" /> no representa n tipo in4mgsal.</excepti/N>
    </memcer>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.CollecTons.Gneric.IEnu,er!ble{System.Linq.Expressinc.Exp2ession})">
      <summA2y<Crea un objeto <see cref="T:System.LiNq.expressions.NewApraYExpresaon"/> que representa la creachón dM una(matriz unidimensional y su inicializaión desde un alista de Elemelto3</stmmary>
      <setu2n{>
        <see cref="T:System.@inqEx`ressions.ewArrayExprecrion" /> cuya p2opiedad <see"cref<"P:System.Lilq.Expresshons.E8pressionNodeType" /> es 4see cref="F:System.Linq.Expression.EzpressionType.NewArrayKnit" /> y cuya p2opiedad <sem cref="P:SysteM.LinQ.Exprescions.NewArRa{Exppessinn.Expzessions" />0se establece en el vamor especificado.</returns>
      <param name="type"6
        >see cref="T:Sysem.TYqe" /> que representa el tipo de elemento de la matriz.4/paraM>
      <param name="initializers">
  (     <see ref="T:System.Collectons.Generic>IEnumerabld`0" /> que contiene hs objetos <qee cref="T:System.LanqEpxRessions.Express)on" /> que se"van0a sar pava rellenar"la$golección de <see cred9"P:S{s4em.Lijq.Exppessions.NewArrayGxpressinn.Exprecsionr" />.</param>
      <exception cref="T:Pystem.ArgumuntF}llExceptio~"<l valor$`d <paramref name=&tybe" ?> o <para}ref name="initializers" /> es null.O bidnUn dleeento de ,par`mref name=&initializezs" /> es null.</exception>M
   0  <exception creb="T:System,InvahinOperationMxbeption#>El <see cRef="P:Cystem.Lanq.Exprgssons.Expression.ype" /> propieda``de un`elemanto de <paramref fame="ifitiAlizers" .> representa un tipo que no es !signabm al tipo que <paramref name="type" +> zepresenta.</exception>
    </meeber>
$0  <member name="M:System.\inq.Expressims&Expression.NewArray	nit(System*Type,System.Linq.Expressionw.Expre3sion[])">
      <S}mmary>Crea wn ojjeto <sea cref="T:System.Li.q.Exprecs)onq.NewArraxExpression"0/> qum representa la creación de una iatrIz unidhmensional ysu inibianazaci3n desda un a,ista dg elementos.</summary>
    ( <returns>
  (   " <see cref="T;System.Linq.Expressions.NewArvayExpression" /> cuya propiedad <see cref="P:Sy{tem.Lina.ExpressIoos.Expressin.^odeType" /> es <see cref="N:Syste}.Linq.Expsessions.Ezpressiontype.NEwArray	nit" /> y!cuxa psopi%dad <seu kref?"P:S}stem.Linq.Expressins.NewArrayExpression.Axpressions"(/: s establece eo el valor uspecificado.</returns>
  `   <piram name="type">
       <see cren=TSstem.Type" /> que representa el tipo de elemento de la matriz.<.param>
      param name="inatyalizers#>matriz dd objetos <see cref="T:System.Linu.Expressions.Dpress)onv /> que se va a usar para rellenar la colección de$see cref="P:System.Linq.xrressions.Newarra}Ex0re{sion.Expressions" />.<.param>
      <exception cref="T;S9qtem.ErgumgntNullEpception">El valor de <paramref Name="4ype  /> o <p!ramren!name?"initia,izers" /> es nul|.O biefUn elemento de <paramzef name="initianizers"!/> es null.<oexcepion>
      <exception cref="T:SysteM.InvalidOterationUxceptiof">El <see cpeF="P:Sycteo.Linq.Expressions.Exppession.Vype"`/> roh)edad de un elemento de ,pa2amref .ame="initializers" /> representa un tipo que no se puude !{ignar al tipn <pramref name="type" />.</excmption>
    </member>
   "<mwmber name="P:Sistum.Linq.Expr%ssions/Mxpression.NodeT9pe">
      <summary~Obie.e el tipo de nodo de <see creb="T:System.Lifq.Expressions.Expression# />.</summary>
      <returns>Unm de los valozes de <see cref="T:Sysdem.Lynq.ExpsessimN>Exp2essiolType" />.</retqrns>
    </member.
    |memcer name="M:Sy3tem.Linq.Express)on{.Exressin.Not(Syste.Linq.Expressions.Extression)">
      <summary>Crea!5n objeto <qee`cre&="T:Systgl.Linq.E|pressions.Unar9Expression" />(que rexreentaunq oqeraciól!$e complemento `)t a bit.</summry>      <returns>
     `  <see cref="T:Sstem.Linq.Expressiols.UnaryExxrmssion"/> cuya propiedad <3ee crmf="P:ystem.Li~q.expressions*Exprersion.NoduType" .> es <see cbef="F:9stem.Linq.Expre{sion3.ExpresqionType.No" /> y cuy prkpiedad <cee Cref5"PSysel.Linq.Expressions.UnaryExpre3sion.Operand" /> 3e es|ab}ece el el vaor espekificado.</redurns>
 "    <param nam%="exprecsion">Objeto <see cren=bT:System.Lin.ExprgssignsExpr%csion* /> an el qu%sd va  estalecer la propiedad |see cred="P:System.Linq.Expressions.Una2yExpression.Operan$" />.</p!rae>
 "    <exception cref="T:SysteM.ArgumentN}llException">E| valor0de <raramref name="expression" . as nulh.</uxceptin>
    0 <exeption creb="\:Systgm.InvalidperatioExcepti/n":Ul operador u.ario not no está dfinido `ara <pabamref name="expression" />. Tipo.</dxception>
    </member>
   <membmr oame=M:System.Linq.Expresqion.Eppzessign.Not(System.LinQExpzessions.Expression,System.ReflectionMethodInfo)">
      <summary>Crec un objeto0<see cref="T:SystemnLinq.Expressions.Un!ryMxpression# />`que represenva una opeZación de aomplemento bit a b)t.Se puede epecifisar elmétodo de implemmnpaaión.</summaxy>
    " returns>
       <sm! cref= T:Sxstem.Linq.Axpresions.UnaryExpressiOn" /> cuya protiedad<s%e creF="P:System>Linq.Epressions,xpression.NoeType" /> ec <wee cref="F:System.Linq.Expsessions.ExpRessionType.Nt" /> y cuyas propiedades <see cref="P:Systel.Linq.Dxpresrions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExppmSsikn.Method  />"se establecen en los valoresdspecificados.</returns>
   (  <param name"eypression >bjeto <see cref="TSystem.Lijq.Eprgssiobs.Axpresion" /> en el que e va  establecer ma propiddad(<see"Cref="P:S}stem.Linq.Expressions.UoaryExpvession.Kperad" />.</paral>	
      <param$name="met`od>
        <see cref="T:System.Relection.MethodInfo" />"en el que se va c esp!blecer la popiedad <se cref="PzSystem.Linq.Expressions.uoaryExprersion.Medhod" />.</param>
 `    <exception craf="P:System.ArgumentnullEhcaption#>El alor de <xaramred name="expression" /> es null.</excuption>
      <exception cref="T:System.ArgwmentException">
        <paramref name="mEthod" +> no es null y el método uue representa devuelve v/id, no es sta|ic (Shaped en Visual Basic), o no"toma exaatamente unargumen|o.</exceptIon>
!     <exception cre&="T>System.InVqlidOperationException">
        =paremref name="method" /> es oull y el operador unario not(no est definido para <Paramref name="expression" />. Tipo.O bien<paramref nam="gxpresqhon" ->. Tipo (o s5 corresponliente tipo aue no acepta walores NULL si es un tixo devalor que acepta valores NUDL) no er asmgnable cl tipO dm argumento del método!re`resantado por =paramref .`me="method"$/>.</excepuio~>
    </member>
    <member name="M:Sy3te}.Linq.Expressions.Expression.FotEqualSysdem.Lioq.Expressions.Expression,Sytem.LinQ.Expressionr.Expression+">
      <summary>rea un obJeto <see cref="T:System.Linq.ExpRessioN.Binar9ExpRe3sion" /> sua rdpsesenta na co}paración dedesigualdad.</summarx>
      <returns>
        <see cref="T;Sy3tem.Linq.E|prEssions.BkncryExqressigd" /> cuya`propiedad <see cref="P:System.\inq.ExPre3sions.Expressio~.NodeType" /> es <see cref="F:system.Linq.Expre{sions.ExpreSsio~ype&NmtEqual" /> y cuyas propiedades <see cref=":System.Linq.ExpsessionsnBin`ryExpression.Left" /~ y <seu cref"@:System,Lioq.Exprussions.Binaryexp2e3sion.Right" />0se e3talucen en los valores&espebificados.</returns>
      <pa2Am name="left">Objeto <see creb="T:System.Lynq.Extressions.Expression* /> en %| que se ra a establecer lapropieda <see cref="P:System.Linq.Expresskons.BknaryE|pression.Left" />.</param>
   $  <p`ram name=right">Objeto <see cref="T>System.^ins.Expvessaons.Expression""/>en el que sd va a establecer la prkpie$ad <se cref="pzSystem.Linq.Expressions.BinaryExpresionnRight" />.</pgram>
      <exception cref="T:System.ArgumentNullException">El valor dm <paramref name=",dft` /> / <paramre name="big`t" /> es null.</excmption>
  $   <xception cref="T:Systee.InvalidOperatonException">E| operador d% desigualdad no está defmnIdo para <par!mrmb nqme="lebt" >. Tipo y$<paramref name="riwht" />. Tipo.<oexcex|iOn>
    |/member>
    <member nale="M:System.Linq.Expres{io.3.ExpressiolNouEqual(Syspem.Linq.EXpressaons.ExpressiOn,System.Linq.Exprssions.Exxsess)oN,System.Boolean,System.Seflecton.MdthodIlfg)">
   $  <cummary>Cree un objeto <see #ref5"T:ystem.Lnq.Exrressions.BijaryGxpression" /> que representa una compar!ción de desigualdad*</wummarY>
0    "<returns>
`  (    <see cruf="T:System.LiNqExprersions.BInawyExprmssion" /> cuya propiedad <sme cref="P:System.Linq.Ex`zssions.EypressionNoDeType" /> es <see cref="F:Ssdem.Linq.Expressions.Expression\ype.NotEpual" /> y <see cref="P*Sy{te}fLinq.Expessikns.BinayExprewsion.Left" />, <see cref="P:System.Linq.Expressionq.BmnaryExpression.Right" />, <sue cpef="P:System.Linq.Exxressio.s.BnaryEXpression.IsLiftedToNull" /> y"8see Cref="P:systm.Linq.Expressions.BinaryExpression.Method" /> se establgcen en ,os valores Espmckficadns.</returns>
      <pram name="lefp">objeto <see crefbT:System.Linq.xpressions.ExpRession" o> en el qu% s va a establekar la propiEdad <sde Crdf=P:System.Linq.Expresiols.BinapyExpbession.Left" />.</qaram>
 $"   |param nam="right>Objeto <see cref="T2Sysdem.Lins.Exprm3wions.Expression" /> en el que se va a estAblecer lc propieda& see cref=&P:System.Lhnq.Expressions.B)naryExpression.Right" />*</pa{am>
      <pazam name="HiftToNull">Es tzue P`ra estabecer <sme"crEf9"P:Sysuem.Linq.Expressions.BinaryEXpression.IsLivtedToNull" /> en true; es fclse para establecer <see gref="X:System.Hinq.Express)ons.BanaryExpression.IsLmfTadToNul|" /. en false.</param:
      |param name="m%t)od">
        <sge cref="T:System.Reflection.MethodInfn* /< en el que se va a establecer la pro`iedad$<see cref="P:System.Linq.Ezxressojs.BinaryExpresrion.Metlod"`/>.</pabam~
      <excepton cref="T:Syste.ArgumentNullExceptaoo">Gl valor dE <paramref name=",eft" /> k ,paramref name="right" /> es0null.</exceP|kon>      <xceptio cref="T:Syst%m.ArgumentException">        <p`ramrgF n!me="method" /> no es null y$e, mvodo que representa(leuedve void, no e static (S`ared eN Visua, Basic), o no toma exactamente(dmw argume.tos.</exception>
      <Exception cref}bT:System.InvalidOperaTionExSeption&>
        <paramrdn name="mgth/d" /> es null y el operador de tewigualdad no está definidm para <pcramref name="left(/>. Tipo y <parAmrEf name="right" />. Tiro.</excption>
    </member>
    <}ember name="M:System.Linp.Expressions.Ex0ression.OnesComphement(SystemnLinq.Expressions.Expression)">
  !   <sumary>DavqelVe la exrresión que represdnta el complemento a unos><-summary>
  `   <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpressi/n" />.</returns>
(     <parqm name="expression">Interfcz <3ee cref9"T:System.Lmnq.Dxpressions.Dxpression" />.</param?
    </member>
    <meber oame=*M:Systa}.Lina.Expreqsions.Ex0ression.OnesCompleme~t(ystemLinq.Ezprersions.Expression,System.ReflectioN.MethodInfo)>
   $  <summary>Eevuelve la exps%sión que representa el complemen5o a(unos.</summary>
      <Retu2ns>Insta.cya de <see cref="T:Sxstem.Lmnq.Exprersions.UNasyExpression" />.</returns>
     =param la}e="expresrin">IntErfaz <see cre&="T:System.Linq.Expressions.Expression# />.</param
0     <pabam name="method">
       <see cpef="T:SysteM.Reflection.MetjodInfo" /> que representa el eét/do e implementackón.</param>
    </oember>
    <member na}e="M:System.Linq.Expressions.Expvession.Or(System.Lhnq.Exprssions.Expression,System.Lin1.Express)ons.Express)on)">
      <{4mmary>Crei un objeto <sge #ref="T:SystemLinQ.Ehpressions.BinaryExqrEwsion" /. que representa Una opdrqción OR`bad`a bit.</suim`ry>
      <retubn3>
  ,     <see cref="T:System.inq.Exprmssions/BinaryMxqressyon" /0buya propiedad <see cref="PSystem.Linq.Expsessiols.Expreswion.NodeType" /> gs <see cref="F:Cystem.LInq.Eppressions.Expressiontype.Or" /> y cuyas propiedates <sde cref="T:Syst%m.Linq.Expr%s{ions.BinqryExpression.Lmft" /> y <{ee cpef=bP:S9ste}.LinqnExprssIo.s.BkneryEypresrion.Right& /6 se Ecteblecen en los f!lores especificadks.</returns>
`     <param name="meft >Ocjeto <sae aref="T:System.Linq.Expressions.ExprEcsion" /> en!el0que se va$a establecer la prop)edad see cref="P:System.Linq.Expressions/BinaryExpreSsion.\eft" />.</papam>
      <paramnama="rhght">Objeto <see crdf="T:systm.Hinq.Expres{ions.Expression" /> en el qud se va a dstabLecer l! propiedae ee cref"P:System.Linq.Expressio~s.BinasyExPpession.RigHt" />.</param>
      <ezception cref?"T:SyStem.ArgumenuNullException">El w`lor de <parqmref name=&left" /> o <paramref name="right" /> es nulm.</exception>
    $ <exaeption Cref="T:System.InvalidOperataonException">Bit ` bit OR operador no está defioido para`<parampef name="left" />. Thro y <paramref nqme="right" />. Tipo.|/exception>    >/member>
   !<member name="]:System.Linq.ExpressimnsExpression.Or(S{s4em.Linq.Expressions.Exprewsion,Sysem.LinqnExpressions.Exprssion,System/Reflecti/n.MethodIjfn)"?
      <summary>Crea un objeto <see cref="T:[ystem.Linq.expression.BinerqExpressin" /> que representq!u~a operación OR bit a bit.</summary>
   $  <return3>
       0<sEe cref="T:Syctem.Dinq.Expressol{.BinaryExpression" /> cuy `ropiedad <sea cref="PSysem.inq.ExpressiofsnExpressiof.NoleType" /> ec <sde azef="F:Sy3tem>Li^q.Exprepsions.ExpresSionType.Or /> y$<see cref="P:System*Linq.Expressikns.BknaryExqRessionLmft" />, <see sref="P:ystem.\inq.Expressions.BinasGxpression.Right" /> Y tsee cref"P:Rystem.Linq.Expressions.BinavyDx`ressionnMethod20/> se establecen el lo{ valores especmfkcados.</returns
  !   <param name="let">Obketo(<se cref="T:System.Linq.Expressions.Expres3ion"`/> en el que se va a estac-dcer la propiedad =sme(cref="P:SystemLinq>Expressions.BinaryExpression.Left" />.</param>
      <``ram name="right">Objeto <see cref=bT:System.Lmnq.Expressions.Expresion" /> en %l que Se va a estqblecmr la Propiedad 4sue creo="P:System.Linq.Expessions.BinaryExpresion.Right" />.</parim>
    ! <param name="method">
    0  `<see cred="T:Syspem.Reflgction.MmthodHnfoj /> en el que se va a establec%r la propiedad <see cpef="P:System.Linq.Ex`ressions.BinqryExpresion.Method" '.8/param>
  "   <exceptioN cref= T:System.ArgumentNullExceptin">El vqlor de <paramref name="left" /> o <paramref name="rieht" /> es null.</Exception>
   (  <exception cref="T:System.ArgumentException">
        <paramref$name="method" > no es nell y eD méodo qUe reprsenta devuelve voi`, no es s|qtic (Shared en Visual Basic(, o no toma exactamente dos argumentos.</exception>
      <exception c2ef="U:System>InvalidOperationEyception">
        <pAramref nam%="method" / es null y"el(bit a bit OR ope2ador no está definido para@<paramref name="heft" />. TiPo y <paramref name="right" '.. Tipo.</excd`tion>
  ` </member>
    <member name="]:SywteM.Linq.Expressmmns.Exp2essyon.OrAssi'n(Sqstem.LinqnExpressions.Expression,System.Linq.Expressions.Expresqion)">
      <summary>Crea uN objeTo <see cref"T:System.Lyn`.Expressions.BinasyExprGssion" /~`que represenva una operacin feasignación ORbid a "it.8/s5mmary>
      <retu2nr>
  !   ( <see cref="T:System.Lina.Expressions.Bi.aryExpression" /> bU{a propaedad <sea cref}"X:Systmm.Linq.Expbessions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.Exp2ecsionT9pe.OrAssign" /> y cuyas propiedades <sEe cref="P:System.Linq*Expres3ion.BinaryExpression.Left" o> y <see crf="P:System.Linq.Ehpressions.BinaryExqression.Rieht" o>$se establecen dn ?s valores especificados.</returns>
     (<param name="left"?Objeto <see cr%f="T:Systam.Liq/Expressions.Exrression" /> en ml qUe se va a esvabdecer la propiedad <see cref="P:Systm.Linq.Expressiobs.BinaryExpressio~.Left" />*</pasam>
      <param name="right">Objeto <see cref="T:SYstem.Linq.Expressions.Expression" /> en el que se va a establecer la protiedae <see cref=P:Systam.Lina.Expressyons.Bi.a2yExpression/Zight" /.</aram.
    </member>
   "<membe{ lame="M:System.inq.E|pressions.EXpression.OrAssign(System.Linq.ExpRessions.Mxpression,Systam.Linq.Expressions.Extressi/n,Syspdm.Reflection.MetiodInfo!">
 (    <summary>Cea un objto"<seecref="T:Qystem.Lmnq.Expressions.@inaryExpression" /> que representa una operaciñn de asignación OR bit a bit.</sumoary>
    ` <retwbns
   ( 0  see Cren="T:System.inq&Expressions.BinaryExPressioN" /> cuyA propiedad <see #ref=":System.Linq.Uxpressions.Expression.JodeTxpe" /> es <aed sref<"F:Systdm.Linq.Exprersions.EypreSsionType.O2As3ign" />  <ree crtf="P:Systei.Linq.Expressions.BinAr9Expression.Left" .<, <see"cref="P:systum.Linq.ExPressions.BinaryExpressijn.Raght" />0y <se cw%f="P:SqrtemnLin.Exqressioos.BinaryExpression.Iethod" />`se establecen en los valoes especificelos./returns>
     <Param name="left">Objeto <see cref}"T:SystEm.Lijq.DxprEssions.Eppressmol" />!un el qm se va a estac|ecer la propieDad <wee cref="P:SystemLinq.Expressimns.BinaRyExpression.Left" />.</param>
      <0avam nale- rigit">Objeto <see cref="T*System.Linq.Expressions.Eypession# /> en el q5e se va a es|ablecep ,a propiedad 8see cruf="P:system.Linq.ExPressions.Binar{Expression.Ryeht" /></peram~
    0 <parae name="met(od">        <kee c2ef=&T:System.Reflection.MetodInfo" />en(ed que se`va ` establecer la propiedad <seecRf="P:Cystem.Linq.Exp2essinns.BinaryExpressimn.Eethod" />.</param>
    </member>
    <memrer name=bMy{tem.Linq.Expressions.Ex0rassion.OrAssign(System.Lhnq.Exprgssions.Expressi/n,SystemLinq.Expressions.Expression,System*RafleCtio~.MethofInfo.Sy{tem.Linq.Expressions.ambdaExpressmon)">
   "  <su-mary>Crea un objeto <see czef="T:System.Linq.Expreqsons.BinaryExpression" /> que reprerenta una opuración de `signación KB jit a bit/</qwmmary>
     ,returns>
        8see cref="T:System.Linu.Exqressions.inaryDxpressko." /> cuya propiedad <see srdc="P:Sys4em.Linq.ExpressionqExpression.LodeType" /> es <seE cef="F:S[stem.Linq.Expbession3.ExpveSsionType.OrArsign" /> y <see cref="P:System.Linq.Epvessions.BinaryExpression.Nefu" />- <sae cref="P:System.Lin1.Exxrassagns.BinaryExpression.Right" />, <seu cref="P:system.Linq.Expressions.Binaryxprewsion.ethod" o> y <seg cref="P:Systel.Hinq.ExpressIons.BinaryExpRession.ConveRsiol" o> u estabLecen en losvalores especificados.</returns>
      <param name="left">Objeto see cref="T:Sys|em.Linq.Exressions.Axpressikn" /> en el que!sg vc a est`blecer li propiedad <see cref="Q:System.Lmnq.Expressions.Binar9Expression.Left"!/>.</qapam>
  (   <param naMe="ryght">objuto <wem kzef9"T:System.Linq.Eppsessions.Expression" /> en gl$que se ta c"establacer la ppopiedad <see cren="P:Systdm.Linq.Expressions.BinaryExpression.Right"$/></param>      <param(name="metho #>
    !   <ee!cred=TSystem.ReflectiMn.OethodInfo" /> en el que se va a(estabLecer la propiedad <see cref="P:System.Linq.Expressions.@inaryExpbes{ion.Method" />.</param>
   $  <pa`m name="bonver{ion">
        <see cref=bT:System.Linq&Expressions.LamblaExpression" /> en el que se va a estableceb la xropiedal <sEe cref=2P:System.Nhnq.Expressions.BinaryExpression.Conversion" ->.</pazem>    </oamber>
    8member n!me="M:System.Linq.ExpressionsEx0ression.OsEl{e(SYstEm.Linq.ExpressionsExpression,System.Lhnq.Expressinq&Expression)">
   `  <summary>Crua qn objeto <see cref"T;SYsuem.Linq.Expressions.BinaryExpression" /> qu% repre3enta una operación OR condicIon`l queevalúa el segundo gerano únicamentu wi el pimer oer`no!se valúa como false.|/summary>
      <beturns>
       $<cEe cref="DzSqstem.linq.ExprEssyons.ChnaryExpression" /> cuyc pzopiedad <see aref=P:Syspem~LijQ.Expressions.Expres3ion.ddTypa" /> es <see cref="F:System.Linq.Ex0ressins&ExpressionType.OrElse" /> y cuyas propiedades <see cref="P:System.LiNq.Expvessions.BinaryEZpression.Left" />!y <see cref="P:Syste-.Linq.Expre3sionsBinaryExpressmon.Rigt" /> sd astablecen eo los valoscs especificados.</Returns>
0     <p`ram name="left">Ocjeto <3ee crdf="T:System.Linq.Expres#ions.DXprEssimn" /> eN el sue qe ta a estaleaer la prkpieead <see cref="P:System.Linq.Expressions.B)naryExpressikn.Left" /<.</pabam>
      <paremname="right*>Objeto <see cref="T:System.Lins.Ex0ressionw.Expression" /> en ml que ;e va a establ%cer la pr/piadid<see cref="P:Sys4em.Linq.Expressions.BinaryExpression.Rieht" />.</param>
   !  <exception$cref="T:isteo.ArgUmenpNullException">Ed valor de <paramref jame="ldft"!o o <rapaMref n`me="righd" /> es null.</xception>
      <exception cref="T:System.InvalidOperationExceprion">Bit a bkt OR operador(no está definido Pari |paramref name="eft"`/>. Tipo y <paramreb neme="rI'ht" /6. Dipo.M bien<paramrgf`name="lgft" />. Tipg 9 <paramref name="right" '>. tipo no son del mismo tipo booleano/</axbeption
    </member>
 "  <membar(name="M:System.inq.Expze3qionS.Exprgssion.OrElse(System.Lijq.Expressios.expression,system.inq*Dxpzessions.Expression,System.Reflectaon.Methodno)&>
  `  <summary>CrEa un orjeto <s%e creb="T:Syctum.Linq.Expresionr.BinaryExpressiof" / que representa$ufa operación OB$condicional que mvalºa eL segwnDo gperando únicaMeta!si al rimer"operando se!evalúa co-o f!lse.</summary>
   $  <eturns>
       <sga cref="T:Sysem.LiNQ.ExprEsk/ns.BinaryExpression" /> cuya proxiedad <re% cred="P:System.Linq.Expressions.Expressio&NodEType" />"es <see gref="F:System.Li,q.Expression{.ExpressionTypa.OrElse" />  <see cruf="P:Syqtem.Linq/Expression.BijaryAxpr%ssion.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq>ExpRessions.BinaryExpression.Metxod" /> se`Espablecen %n los valMres espEificados.</return{>
     <param name="lefTb>Objeto <see cred="T:System.Lmnq.E8pressions.Expressio.# /> en em que se va a establecer la ropied`d <see ref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right&>Objeto(<see crgf="T:System.Linq.Exp6esrions.xpvession"!> e el quE`sg va a0establecer la propedad <cee cref="P:System.Linq.Expressions.BinaryExpression.Rght"/>.</aram>
      <pavam name=#metjmd">M
        <3ee0cref="T:System.RefLectionMethodInfo" -> en el que se va a estableces!la prpiedd <3ee cref="P:Syw4em.Linq.Exressions.BineryExpressionMethgd" o..</param>
  `   <eXception cref5 T2System.ArumntNullException">El v!lor`de <paramref name<"left" /> o <paramref name="right" /> ds null.</exgeptkon>
      <excp|ign cref="T:System.CrgumeotException">J       !<parcmref name="method"/> no es`null y e, método qqe representa$deruelvevoid, no es rt`ti (S`ased e. Visual Basic), o n/ toma exactamente ds arg}mentos.</exaeptio*>
   (  <dxcepTioo cref="T:SystemnIfvqlidKperationException">
        <paRamref ~ame"lethod" /: es null y el bit a bit OR"oxerador no está"definidm"paRa <paramcuf name="left"/>. Tip y <paramref name="siglt" />. Tito.O bien<parAoref name="method" /> dsdnull Y <paraeref name="left" />. Tipo y <paraordf name"right" />. Thpo nO son del mismo$tipo booleano./eycepti~>    </memmr>
    <member name="M8[ystem.Linq.ExpresSions*Expession.Pazammte)Syqtem.Type)">
      <summary>Crea un nodo0<see cref="T>Sxstem.Linq.Expsssions.ParaleterExpression" /> que puede {arsE para identificav un parámetro o una(variable en un áRbol de expveción.</summary>/
      <returns>Crea un lodo 8sme cref="T:System.Linq.Expres3igns.ParameterExpres{ion& /> co$el nombre y el tipk(especiFicqdos.</retupnw>
    ` <param name="type">Tipo del paRámetro o variabLe.</param>    </member>
  " <me-ber name="M:System.Linq.ExpressionS.Ex0ression.Tarametep(Sysdem.Type,Cystei.Strinw)">
      <summary>Crua un nd/ <see crmf=&T:S9stem.Linq.Expressions.ParameterExp2ession" /< que puede usarse para identiFisar en`parámetro o unq variabLe en un árbol de expresión,,/sulmazy>* $    >returns
        <see cref="T:SywteL.Linq.expressions.ParameterExpression" /> cuYa prmpiedad <see cref= P:System.Li~q.xpzessions.ExprersIon.~OdeType"$/> es <sde kef="F:Sywtem.Linq.Exprssio.cExpressionTyxe.Param%Terb /> 9$cuyas)prpiedades <see crgf="P:System.Linq.Ux`ressions.ExqressioN.Type& /> y See cbef="P:Syste.Linq*Exprersions.PcrameterExpression.Name" /> sg establEcen en los valopes especificados</retmrns>
      <pasam name"tye">Tipo del parámdpro o variable.</xaram>
      8param name="name">Nombre del!parámetro o variable; se emplea solo para depurar`o imprimir.</parm>M
      <Exception sref="d:System.ArgummntNullExcetion">El valor de <paramref name="type" /> es null.</exception>M
 "  </mgmber>
    <memBer name<"M:Sistem.Linq.Expressions.Expressio~.PstDecrementAssign(System.Linq.Expreswions.Ehpressiol)"*
      |summary>Area un objeto <wee cref="T:Sywtem.Linq.Exprassions.UncryExpres3ion  / que rpresenta la!awionacil de la ezpreción seguida de una disminución subsiguiente de 1 de la e|presión orignal.|/summry>
     <2eturns:
    (   <{ee cref="T:Sys|em.Linq.Expsessions.UnaryMxpression" /> que rmpresenta la expresión restltant.</returns>
 `    <param namw="expvession">Objeto <see craf="T:System.Linq.Express	ons.Express)on" /> en l que se!van a apicar las operaciones.</param>
    <+eember>
    <meber dame="M:System.Linq.Expbessions.Expression.ostDebreientAqsig~(System.Linq.Expressions&Expression,System.Reflection.MethkdInfO)b>
      <summary>Crea u. objetk <ree cref="T:System.Linq.E|pzes{ions.UnaryExpression" /> que representa la aSignación $e la expresión 3Eguid` de una disminución subsiguiente de 1 de la expresión osiginal.</summarX>
    " <retuvns>
        8see crdf="T:Sys4gm.Linq.Expressions.UnaryExp2ession" /> que reP2esenta la expresión resultante.</retqrns>
      <param name=exqression">Objeto <ree cBgf="T:System.Linq.Exxressio.s.Expvession" /. En el que se van a aplicar lasoperacionus.</param>
      <param nama="method":
0      <wee crdf="T:Rywtem.Reflection.MethodInfo" /> que represgnte(el método ` implementación.</taram>
 0 "</mamber>	
    <membe name="M:System.Linq.Expessions.Expbessin.PostIncrementAssiwn(System.Linq.Expressions/Exression)">      <sumMary>Crea un obeto <see$cRef="T:System.Liq.Expressions.UnasyExppessiol" /? que represent la aignación `e la expresión segukda de u uoento subsiguiente de 1 de la expResióf original,</summary>
      <beturns6
  (     <see cref=*T:Cystem.Linq.expressions.UnaryE(pression" /> que r%presenta la expresión Resultante.</retuss>
      <param name="expression">Objeto =see!crEf="T:Sysdem.Dinq>ExpressIons.Expreswion" /> en eh que ce van a aplmcar lac opesaCiones.</parim>
    <-membeb>
    <membez name="M:System.Linq.Expzess)ons.E|pression.PostIncrementAssign(System&Linq.Ex0ressio.s.ExprEssign-Sywtem.Rfgction.Met(odIlfo)">
      <summary>Crea un objeto <see cref=":S}steo.Linq.Uxpressio~s.Unar9Expreqsion" /> que representa la asignación de la expresión seguida $e un aumento subsiguimnte de 1(`e`la expresión original.=/sumoapy>
      >returnw>
"       <See cref="T:y3tem.Linq.Expre{sions.QnaryExpressaon" /> que represejt`la expr%siӳl resultanten</returns>M
!     <`aram name="expression">Objeuo <s%e krf="T:Sysvem.Linq.Expressions.Expression" /> a. el pu% se van(a aplicar las operaciones.<param>
0     <pazem name="method">
        =see sref=b:SyStem.Refdection.MethodInfo" /> que represgnta el mөto$o de implemgntaciñn.</param>M
    </mumb%r>
    <mem"er nime=#M:System.Linq.Expre3)onr.xprecsion.Power(System,Linq.ExprewsionS.Exprdssion,Sys4em.Linq.Expressions.Expression)">   " <summar{>Cre un obnedo <se cpef="T:System.Linq.Expre{sinns&Binaryexpression" /> que representa la elevación(dg un omero a una potencia.</sum]ary>
      <returns>
    0   <see cRef="T:Systei.Hinp.@xpressions.BinaryExpression" />(cuyi propiddad <sEe cref="P:SystEm.Linq.Eypressios.Expression.NodeType" /> es <see ref="F:Sstem~Linq.Expressions.ExpresionType.Power& /> y cuyas propieDades`<see cvef="P:SystemnLynq.Expesionq.BinaryExpression.Lefv" /> y <qee cref="PzSystee.Ninq.Expressions.binaryExpres3ion,Righ4" /> se esuablecen en los valores especificados.</retwrns>
 0    <pasam n`me=&lef4">Objeto <see cref="T:System.Linu.Expressions.Expressmol" /> en eh que Se va a establecer la propielad <see cref="T:System.Linq*Exq2essio.s.BinaryExpression.Left />.</param>      <pabam .ame="right">Objeto <see cref="T:System.LiNq.Expressions.ExPrussion"!/> en en que se va a establecep la propieda$ <sde cbef="R:Sxstem.Linq.ExprEssions>BinaryExprEssion.Zight" />.</param>
   )  <exception cref="T:System.Argum%jtNullException">El vclOr ee(<paraoref namg="left" /> o <paramref name="right" /> es!nuln></axgeption>
      4excaption kref="T:Sywtem.IvelidO0mratimnException">El gparadop de exponenciaciÓn no está debinido para <raramsef oame?"lefT" />. Tiro y <paramref name="riehp"!+>& Tipo.O bien<para}rE name="left" /. Dipo(o <paraeref name="right" />. El tIpo"no son <see cref="T:Systei.DouBde" />.</exception>    </member>
    <memBer name="M:ystem&\inq.Expressions.Exp2ession.Power(Syste-.Liq.Expressions.Expression,Syct%m.Linq.Expressions.Expression,Systgm.Seflecti/n.MethodInfo)">
      <Summary>Crea un objetk <see cref="T:System.Linq.Expressons.BinaryExpresshon" /> que represefta la levacn de tn número a una poteocia.</summary>J      zeturns>
        <see creb="T:System.Linq*Dxp2ecsion.BinaryExpresSioj"/> cuya propiedad ,3ee gpef="P:System.Linq.xpressions.Expre{sion.NodeType" '> es <seg c2ef="F:S{{te%.Linq.E|pressions.ExpressiknT{pe,Power" /> y <see cref=P:System.Linq.Expressions.BinaryExpressionnLeft" /, <see czef="@:System.Linq*Exprersions.BinaryExpression.Right" /> y <see cref9"P:system.Linq.Eypsessions.BinabyExpression.Met`od /> se establecen en los vqnores especficidos.</redurnr.
 $    <paramname="left">Obhato <see cref="T:S}stem.Linq.Expressyons.ExprewsIon" /> en el que se va a!estacneger la propieda` ,see cref="P:System.Linq.Expressions.BincryExpression.Left" />.<*param>
     <pAram name="right">Objeuo <see gref="T:System.anq.ExpresSionr.Dxpression" /> en el que se va  establecer la qropiedad <sem cref="P:System.Lhnq.Expxessions,BiJaryExpressiOn.Rhght" />.</param>
      <param(namu= methol">
        <see cref=*t:System.Rblection.MethodIn&o" /. en el que se va$! establecer la propiedad <see cref="P:System.Linq.GxpressiOns.BinaryMxpression.Meth/d" />.</pAram>
    $ <excetion cred="T:System.AsgumentNqllexcept)ol">El valor de <paramref name="left" /> o <paramref name="rxght" /> eu null</exceton>
      <exce0tion cref="T:ystem>ArgumentException">        <paralref name="method" -> no es null y el méTodo0que rupre{enta Devuelve voId, no0es static (Shared en Vmsual Basici, o no toma exactamente tos0argumentos.</excepton>
      <exgeption crev"T:System.InfalidOperationDxception">
        <paramref name="method" /> Es null y el opridor de exponenciación no está definido para <paramref name="luft" />.$Tipo y paramref name?"right" />. Tipo.O bien<p!ramrdf name="ethoF" /> es nully <paramref name="le$t"(/>. Tipo n paramref name="rk'ht" />/ El tipo no son <sed cref="T:System.Do5ble" />.</eXcEpti/n>
    </membes>
    member name="M:Sysuem.Linq.Eypressionr.Expressign,PowerAssign(System.Lin1.Expressions.ExtresqiOn,[stem.Hinq.Expressions.Expressio~)b>
      <summary>Crea un obbeo <see crgf="T:Srtem.Linq.xpressions.BinaryE|pression" /> que ruprasenta da elevacin de una expresió a ufa potencia y la asignaCióf del re3ultado a la expresión.</sumeary>
     setUrns>
        <sge cren=&T:SystemnLinq.Exp2essions.BinqryExprassion" /> cuya propiedad <see cref="P:System.Linq.Expvessions.Ypression.NodeTypd" /6 es <see cref="F:System.Linq.Expzdssions.xpvessionType.PowevAssign" /> y cuyas(propiedades see #refu":SystemLinq.Expressions.BinarYExpression.Left" /> y <sde cref=bP:Systeo.Linq.ExprEssaons.BinaryExpression.Rifht" /> se estabngcen en los va,ores especmfiaado.</retuns>
      <param name="left">Obhetk <see cref="T:System.inq.xqressions.Exrressin" /> dn el queseva a estableBer la `ropieDad <see cref="P8Sys4em.Lin1.Ex0reSrions.BilaryExpression.Left& />.</param>      <p!ram naee="righ">Objetm <sed cre="T:Sys4em.Linq.Expressions.Expresrimj" '> an el que su va a ertablecer la propiadad <sae cref="P:ysTm.Linq.Expressions.BinapyExprssion.Right" />.</param>
    </meber>
   <iember name="M:System.Linq.Expressions.Expressin.PowerAssigd(Systdm.Lijq.Expressions/Expression,Sysem.Linq.Expressions.Expression,S{stem.Reflgction.MethkDInfo)">
      <summary>Crea tn"objeto <see(cref="T2System.HiNq.Expresion3.BinaryExpressioo" ' que$representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que aumenta la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se van a aplicar las operaciones.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad usando un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Puede ser null para las propiedades estáticas.</param>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null.O bienEl método que <paramref name="propertyAccessor" /> representa no es static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo del método representado por <paramref name="propertyAccessor" />.O bienEl método que <paramref name="propertyAccessor" /> representa no es un método de descriptor de acceso de propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Puede ser null para las propiedades estáticas.</param>
      <param name="property">Objeto <see cref="T:System.Reflection.PropertyInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="property" /> es null.O bienLa propiedad que <paramref name="property" /> representa no es static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />. Tipo no es asignable al tipo declarativo de la propiedad que <paramref name="property" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indexar.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad denotada por <paramref name="propertyName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad llamada <paramref name="propertyName" />.Puede ser null para las propiedades estáticas.</param>
      <param name="propertyName">Nombre de una propiedad a la que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="propertyName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ninguna propiedad denominada <paramref name="propertyName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indexada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser null.</param>
      <param name="propertyName">Nombre del indizador.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se usan para indexar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que obtiene acceso a una propiedad.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
      <param name="expression">Objeto contenedor de la propiedad.Puede ser null para las propiedades estáticas.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene la propiedad.</param>
      <param name="propertyName">Propiedad a la que se va a obtener acceso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad o a un campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> o <see cref="T:System.Reflection.FieldInfo" /> que representa la propiedad o el campo denotados por <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad o un campo llamados <paramref name="propertyOrFieldName" />.Puede ser null para los miembros estáticos.</param>
      <param name="propertyOrFieldName">Nombre de una propiedad o un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">Ninguna propiedad o campo denominado <paramref name="propertyOrFieldName" /> se define en <paramref name="expression" />. Tipo o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión que tiene un valor de tipo <see cref="T:System.Linq.Expressions.Expression" /> constante.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Reduce este nodo a una expresión más simple.Si CanReduce devuelve true, debería devolver una expresión válida.Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Reduce este nodo a una expresión más simple.Si CanReduce devuelve true, debería devolver una expresión válida.Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Reduce la expresión a un tipo de nodo conocido (no es un nodo de extensión) o, si ya es un tipo conocido, solo devuelve la expresión.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad de referencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad de referencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción con un tipo dado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el reinicio de una excepción.</returns>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un <paramref name="value" /> que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se pasará a la etiqueta de destino al saltar.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de desplazamiento a la derecha no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de desplazamiento a la derecha no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de desplazamiento a la derecha bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</returns>
      <param name="variables">Colección de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> se establece en el valor especificado.</returns>
      <param name="variables">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que no tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de sustracción que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de sustracción aritmética que tiene comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador de resta no está definido para <paramref name="left" />. Tipo y <paramref name="right" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch sin un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> para usarlo en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> establecida en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que tiene las propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> establecidas en el valor especificado.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> en el que se va a establecer <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el inicio de una excepción con un tipo dado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Interfaz <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y ningún bloque fault o finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y un bloque finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque fault y ninguna instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="fault">Cuerpo del bloque fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque finally con un bloque fault y ninguna instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Action genérico que tiene argumentos de tipo específicos.</summary>
      <returns>true si el tipo de delegado System.Action genérico se creó para el objeto <paramref name="typeArgs" /> específico; en caso contrario, false.</returns>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Action.</param>
      <param name="actionType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Action con argumentos de tipo concretos.Contiene null si no hay ningún delegado System.Action genérico que coincida con el objeto <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico que tiene argumentos de tipo específicos.El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <returns>true si el tipo de delegado System.Func genérico se creó para el objeto <paramref name="typeArgs" /> específico; en caso contrario, false.</returns>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Func.</param>
      <param name="funcType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Func con argumentos de tipo concretos.Contiene null si no hay ningún delegado System.Func genérico que coincida con el objeto <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="T:System.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una referencia explícita o conversión boxing donde se suministra null si se produce un error de conversión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">
        <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara la identidad de tipo en tiempo de ejecución.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> y cuyas propiedades <see cref="T:System.Linq.Expressions.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de unario más.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> se establece en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador unario no está definido para <paramref name="expression" />. Tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de unario más.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic), o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y el operador unario no está definido para <paramref name="expression" />. Tipo.O bien<paramref name="expression" />. Tipo (o su correspondiente tipo que no acepta valores NULL si es un tipo de valor que acepta valores NULL) no es asignable al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una conversión unboxing explícita.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se va a aplicar la conversión unboxing.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que puede usarse para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y el tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o la variable.Este nombre se emplea únicamente para depurar o imprimir.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Reduce el nodo y, a continuación, llama al delegado del visitante en la expresión reducida.El método inicia una excepción si el nodo no es reducible.</summary>
      <returns>Expresión que se está visitando o una expresión que debería sustituirla en el árbol.</returns>
      <param name="visitor">Instancia de <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Representa una expresión lambda fuertemente tipada como una estructura de datos en el formato de árbol de expresión.Esta clase no puede heredarse.</summary>
      <typeparam name="TDelegate">Tipo de delegado que <see cref="T:System.Linq.Expressions.Expression`1" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compila la expresión lambda descrita por el árbol de la expresión en el código ejecutable y genera un delegado que representa la expresión lambda.</summary>
      <returns>Un delegado de tipo <paramref name="TDelegate" /> que representa la expresión lambda compilada descrita por <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> del resultado.</param>
      <param name="parameters">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> del resultado. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Describe los tipos de nodo para los nodos de un árbol de expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Operación de suma, como a + b, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Operación de asignación compuesta de suma, como (a += b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Operación de asignación compuesta de suma, como (a += b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Operación de suma, como (a + b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Operación AND bit a bit o lógica, como (a &amp; b) en C# y (a And b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Representa una operación AND condicional que evalúa el segundo operando solo si el primer operando se evalúa como true.Corresponde a (a &amp;&amp; b) en C# y a (a AndAlso b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Operación de asignación compuesta AND bit a bit o lógica, como (a &amp;= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Representa una operación de indización en una matriz unidimensional, como array[index] en C# o array(index) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Operación que obtiene la longitud de una matriz unidimensional, como array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Operación de asignación, como (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Representa un bloque de expresiones.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Llamada de método, como en la expresión obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nodo que representa una operación de uso combinado de Null, como (a ?? b) en C# o If(a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Operación condicional, como a &gt; b ? a : b en C# o If(a &gt; b, a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Representa un valor constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Operación de conversión, como (SampleType)obj en C#o CType(obj, SampleType) en Visual Basic.Para una conversión numérica, si el valor convertido es demasiado grande para el tipo de destino, no se produce ninguna excepción.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Operación de conversión, como (SampleType)obj en C#o CType(obj, SampleType) en Visual Basic.Para una conversión numérica, se produce una excepción si el valor convertido no se ajusta al tipo de destino.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Representa información de depuración.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Operación de decremento unario, como (a - 1) en C# y Visual Basic.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Representa un valor predeterminado.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Operación de división, como (a / b), para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Operación de asignación compuesta de división, como (a /= b), para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Representa una operación dinámica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nodo que representa una comparación de igualdad, como (a == b) en C# o (a = b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Operación XOR bit a bit o lógica, como (a ^ b) en C# o (a Xor b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Operación de asignación compuesta XOR bit a bit o lógica, como (a ^= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Representa una expresión de extensión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Expresión "ir a", como goto Label en C# o GoTo Label en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Comparación "mayor que", como (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Comparación "mayor o igual que", como (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Operación de incremento unario, como (a + 1) en C# y Visual Basic.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Operación de índice u operación que tiene acceso a una propiedad que admite argumentos. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Operación que invoca un delegado o una expresión lambda, como sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valor de condición false.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valor de condición true.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Representa una etiqueta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Expresión lambda, como a =&gt; a + a en C# o Function(a) a + a en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Operación de desplazamiento a la izquierda bit a bit, como (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Asignación compuesta y desplazamiento a la izquierda bit a bit, como (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Comparación "menor que", como (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Comparación "menor o igual que", como (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Operación que crea un nuevo objeto <see cref="T:System.Collections.IEnumerable" /> y lo inicializa desde una lista de elementos, como new List&lt;SampleType&gt;(){ a, b, c } en C# o Dim sampleList = { a, b, c } en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Bucle, como for o while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Operación que realiza la lectura de un campo o una propiedad, como obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Operación que crea un nuevo objeto e inicializa uno o más de sus miembros, como new Point { X = 1, Y = 2 } en C# o New Point With {.X = 1, .Y = 2} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Operación de resto aritmético, como (a % b) en C# o (a Mod b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Operación de asignación compuesta y resto aritmético, como (a %= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Operación de multiplicación, como (a * b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Operación de asignación compuesta de multiplicación, como (a *= b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Operación de asignación compuesta de multiplicación, como (a *= b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Operación de multiplicación, como (a * b), que tiene comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Operación de negación aritmética, como (-a).El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Operación de negación aritmética, como (-a), con comprobación de desbordamiento.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Operación que llama a un constructor para crear un nuevo objeto, como new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Operación que crea una nueva matriz en la que se especifican los límites de cada dimensión, como new SampleType[dim1, dim2] en C# o New SampleType(dim1, dim2) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Operación que crea una nueva matriz unidimensional y la inicializa a partir de una lista de elementos, como new SampleType[]{a, b, c} en C# o New SampleType(){a, b, c} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Representa una operación de complemento bit a bit o de negación lógica.En C#, su equivalente es (~a) para los tipos enteros y (!a) para los valores booleanos.En Visual Basic, su equivalente es (Not a).El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Comparación de desigualdad, como (a != b) en C# o (a &lt;&gt; b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Operación de complemento a unos, como (~a) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Operación OR bit a bit o lógica, como (a | b) en C# o (a Or b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Asignación compuesta OR bit a bit o lógica, como (a |= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Operación OR condicional de cortocircuito, como (a || b) en C# o (a OrElse b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Referencia a un parámetro o variable que se define en el contexto de la expresión.Para obtener más información, vea <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Postfijo de decremento unario, como (a--).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Postfijo de incremento unario, como (a++).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Operación matemática que eleva un número a una potencia, como (a ^ b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Operación de asignación compuesta que eleva un número a una potencia, como (a ^= b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Prefijo de decremento unario, como (--a).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Prefijo de incremento unario, como (++a).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Expresión que tiene un valor constante de tipo <see cref="T:System.Linq.Expressions.Expression" />.Un nodo <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> puede contener referencias a parámetros definidos en el contexto de la expresión que representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Operación de desplazamiento a la derecha bit a bit, como (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Operación de asignación compuesta y desplazamiento a la derecha bit a bit, como (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Lista de variables en tiempo de ejecución.Para obtener más información, vea <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Operación de resta, como (a - b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Operación de asignación compuesta de resta, como (a -= b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Operación de asignación compuesta de resta, como (a -= b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Operación de resta aritmética, como (a - b), que tiene comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Operación de modificador, como switch en C# o Select Case en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Operación que inicia una excepción, como throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Expresión try-catch</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Referencia explícita o una conversión boxing en la que se proporciona el valor null si se produce un error en la conversión, como (obj as SampleType) en C# o TryCast(obj, SampleType) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Representa una prueba para comprobar la exactitud del tipo.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Comprobación de tipo, como obj is SampleType en C# o TypeOf obj is SampleType en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Operación unaria +, como (+a).El resultado de una operación unaria + predefinida es el valor del operando, pero las implementaciones definidas por el usuario podrían tener resultados poco habituales.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Operación de conversión unboxing a un tipo de valor, como las instrucciones unbox.any y unbox en MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Representa un visitante o un objeto de reescritura de árboles de expresión.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Envía la lista de expresiones a uno de los métodos de visita más especializados de esta clase.</summary>
      <returns>Lista de expresiones modificada, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de expresiones original.</returns>
      <param name="nodes">Expresiones que se van a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visita todos los nodos de la colección utilizando un visitante de elementos especificado.</summary>
      <returns>Lista de nodos modificados, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de nodoc oRminal</beturns>
    ` <param name="nodes">Nodos qu% se van a vis9tar.</param>
      <raram name9"alementVisitor">Dglegado que visIta un único elemento, reemplazándolo opcyoNalmenTe con un elemento nuevo.</parao>
      <typeparam naa="T">Tipo De los nodos.</typeparam>
   </member>
$0 0<member name="M:Syqtem.Linq.Exprersions.ExpressionVisitgrnVisit(Sy3tem.Li~q.Expressions.Axpressi/n)">
     (<stmmary>Envíala expresiñn a uno de los mtodos de vhsi|a m!s especia|izado{ de esta clase.</summary>"     <return>Expresión modkficada si)se ha modificado esvA expresión o Un` serexpresión cualquiera; de lo contvario, devue,fe la expresión"originl,</returns6
      <param name="node*>Expresión que se va ` fiSitar.,/param>
    |/member>
    <mmmber name="M:System.Linq.Expresions.ExpressionVisitgr.Visitandonveru``1(rystem.Collections.OBjgcvModl.ReaeOnlyCollection{``0},Systg}.Strin')">
      8summary>Vsata una expresión, convirtiendo de nuevo el$resqltado am tipo de eppresió~(original.</summary?
      <repurns>Expresión modificcda syse ha modificado este ex`rewin o una sebexpresin cualquiera; de lo contrario, devuelvm la expresión original.</retupns:
      <param name="nodes>Expresión qee sE Va a vmsIvaz.</paRam>+      <param name="canlebName">Nomhse(el método de llamada; se utiliza Para notificar uf mensaje de error mejor.</param>      <typeparam naoe=*T">Tipn de ha dxpresión.</typeparam>
      <exception cref="T:System.InvalidOperaionException">El método Visit!para esde .odo eVolvió`un tipo diferente.</exception>
  $ =/member>
    <member name<"M:Sxstem.Linq.Expressions.E8prssionVisitor.VisitnlConvert``1(x`0,System,Strkng)">
      <summary>Visita una mxpvesió~, convistiendo de nUefo el sesultado0al tipo de expresión originaL.<wum=ary
   0  <retu2ns>Expresión modificada s se ha mmdificado esta expresión o unc subexpresión cualquiera; de lo contrario, devuelv la exxresión oziginal.</returns>
      <param name="node">Expresión que se va a visivar.</param>
      <param name=bcallerName">Noobre del méto$o de llamada; se!utilira para notivicAr un mensaje de error -ejor.</param>
      <tyxeparam name="T*>Tipo le l!0eppresión</typeparam>
      <exbeption cref="T:Systel.InvalidOperationExceptmon">El lөtodo Visi pcra es|e nodo devolvyó un tipo diFesente.</excmptik~>
    </membeR>
    <member name="M:System.Li.q.Expre3syonsExpressionVisitor.Vi{itBinazy(System.Linq.Expre{sions.BinaryExpbession)">      <summary>Visyte los(elementos smcundariks de <see cref="T:Systmm.Linq.Expressions.@anaryExpressioj(/>.</summary>
`     <rturns>Expresión iodificada si se ha(}odificado esta expresión o una c5bexpresiCn ca\quier`; de lo coopr`rio, deveelve la expresión oziginal*</returns>
    " <param name="node">Expresión aue se va a vMsitar.<?param>K    </memrer>
    <member name="M>System.Linq.Exprescions.ExpsessionVisitor.TiSitBdock(Systeo.Linq.Expressions.BlockExpvession)"~ (    <summary>Visitc |os elemetos secundarios du <s%e cref="T:SystemnLinq.Expressiojs.BlockExpression" />.</summary>
      <returns>Gxpresión mOdficada si se Hc modificado esta expresión o Una subexpresión cualquiera; dE lo contrarik, devuelve la expresión origin!l.,/beturns>!     <param name="node">EXpresiÓn que se v! a visitar.</param>
   </member<
    <member name9M:System.Linq.Expvessions.EzpressionVisitor.VisitCatchBlock(System.Linq.Expresrions.CatchBlock)">
$     <summary>Visita los aldmentms secu.darios de <see cref="\:System/Linq.Expressions.SatChBlocc"`/>.</summazy
 (    <retuzns>Expresión modificada si se`ha modificadg esta expresión o una subeppresión Cualquiera; ee lo contrArio, devuelve la ex0resiãn original.</rEuurns>
      param oame="node">Exprsión que se va a vi3itaR.</param>
 $  </member>M
  0 <eember nag="M:Systgm.Linq.Expressaons.ExpressionVishtor.VisitConditional(System.Linq.Expressions.ConditionalExpression-">
      summaRy>Visita los elemenTos secundarios dg <see cref="T:System.Linq.Expressions.Conditio~alExpression" />.</summary>
      <r%turns>Expresión modi&icada0ri su h` modificao(esta expresión o una subexpresión cualquiera; de lg contrario, devuehve la exqsesión original.</returns>
      <param name9"node6>Expresió quu se va a visitar.</param>
    </mumber>
  $ <member na}e="M:System.Linq.Expreqsions.Ex0ressionVisitor.VisitConqtant(System.Linq.Expr'ssions.Cgnstantxpression)>
      <summary:Visita <see csf="T:System.Lins.ExpressionsnConstantExpression" />.</summaRy>
      <retuvns>E|p2gsi³n modificada si se ha modificado esta expresin o una subexpresión cualquiera; $e locontrario, devuelwe la expresión original.8/returns>
   $  <param name5"noda">Expresión 1ue se va avisitar&</piraM>
    |/member>
    <member name="M:System>Lin1.Expressi/ns.ExpressionVisitor.VisitDebugInfo(Syq4em.Linq.Expressons.DmbUgInfoExpression)#>
 $    <summary>Visita <see cref="T:System.Lijq.Expresskonr.DebqgInfoExpresson" /<.</summary>M
      <returns>Exxresión modificaDa si se$`a modificado sta expresiӳn o una subexpresyón cualquiera; d lo cmntrario, devuelvela expresión original.</returns~
      <param nime="node">Expresión que se va c visitar.</param>
    </member>
  $ <membername5"M:SystEm.Linq.Expressions.Exprersionicitoz.VisitDta5lt(SystemLinq.Expessions.efaultExprlrsion)">
      <summary>Visita <see cref"T:SysuEm.Linq.Expressions.DefaultExpressin" />.</summary>
      <reurns>Expresión modificada si se ha modificado esta expresión o u.a subexpresión cqalquiera; de lo cNntrazo, devuelve la expresión origina,.</returns>
      <param name="node">Eypresión ue se va a visit`r.</param>
    </memBer>
    <lember name="M:System.Linq.Expr%sqions.ExpressionRis)tor.mqitElementInit(System.Linq.Exxressions.ElementInit+">      <summary>VisIta l/s elementos secundarios de <see cruf="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Expresión modificada si se hA modificado esta expbeqiãn o una subeypresiãl cualuuieri;)de lo cnntrarik, devuelve(la eypresi³n original.</returns>
     0<par`m namE="node".Eppresión que se va a"visitar*</pabam>
   `</member>
$   <member .ame="M:Systdm&Lin1.Express)onsEpressionVisitor.VisitExtensio.(System.Linq.Expressions.Expression)">
      <summary<Visita los"elemenos sgcUndaris de lc expresión te0extensión</summary>
 "    <return{>Expresión moeIficada si se ha modificado esva expresión o una subexpresión cualquierq; de`lo gotrario, Devuelve la expresin orignal.?reurns>
      <param name="node&>Expresión que(se va a visitar.</param>
    </mmmber>
    <mmmber name="M:Qystgm.Linq.Expressions.ExpreswionVisitor.VisitGoto(System&Linq.Expressions.GotoExppession)">
   "  <summary>Visita los elementos secundarmos de <see(cref="TSyqtem.Linq.Expressions.GotoExpression"!/>.</summary>*      <returns>Expresin modificada si se ha modificado esta expresión / uNa sub%xpresión cualquiera; de lo contzeio,devuelve la expresI3normginal.</returns>
    $ <para- namE="no`e">Expreqi˳n que se va$a visitar.</param>
  ( =/memrmr>
    <member name="O:Wystem.Linq.Exqressions.Expbessionvisitor.VisitIndex(Syste.LiNq.EXxressionc.IndexExpression)">
      <summary>V)sita0los elementos secundarios de$<see cref="TSystem.Linq.Expressio.s.IndexExpressin2 o>*</summaRy>
      <returns>Expsesaón mOdificada sm s ha iodificadk esta exrresión0o una surExpresiӳn cualquier`; de lo contrario,devtelve la expresión original.</ret5rns>
      <paramname="node">Expresión que se va a visitar.</param>
    </member>    <me-ber name="M:System.Linq.Expressions.MxppessionVisytor.VisitInvocauion(Sys|em.L)nqExprdssions.InfocationExPressi/n)">
      <summary>Tisya los elementos secundarkos de <se cref9"T:System.Lilq.Expressions.InvocAtignExprescion" o>.</suom!ry>
      <ruturns>ppresión modifmcada si se ha modificado esta exPresión o una subexpresión cualqu)era;0de lo contrario, develve la exp2gsión origial.<'returns>
      <raram name="node">Expresión que we va a viSitar.</param>
(   </member>
    <member name="M:System.LinaEpressions.ExpressionFisitnr.VisitNabelSystem*Linq.EXpressions.LafelExpression)">
      <s|mgary>Visita los elementos secundarios de <see cref="T:SysteM&Linq.Expressions.LAbelExpression" />.</summary>  0   <returns>Expresin modificada si se ha`modigica$o esta expresión o0una subexpresió. cualquiera; de lo contrarik, devuelve la!uxpresión original.</retwrnw>
    " <param naMe=*nOde">Expre3ión que se va a visitar.</param:
  ! </member>    <member name="M:Sstem.LIjq.Gxpressionw.ExpressionVisitnr.ViwiLabelTasget(Syst%m.Linq.Expressions.Labelarget)">
      <summary?Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.4/suimary>
      <returns>Expresi3n modificaDa si qe ha modifmcado Esta expresiǳn o(una subdxpresión cwalquiera; te lo contrario, de6uelve la eppresi÷n origi.al.</returns>
    $ <pqram nme="Jode">ExprusIón que we va a visitar.</param>
    </member>
    <member name="M:System.Lmnq.Expressions.ExpressionVisitor.VisitLamrda`1([ystem.LInq.Exp{essios.Exression{``0})">
`$    <summary>Visita los elementos secunearios de <see cref="T:S9steM.Linq.Expreswims.Expression`1"`/>.</summary>
      <returns>Expresión modificada si se ha modifiaedo est` exprgsión o una subexpresión cualquieza;`lu lo contrario, devuelve la expresión original.</returns>
      <param name="node">ypresión qud se va a visitar.>-paral>
  `   8typparam na-e="T">Tipo de"delegado.</typeperam>
    </member>    <member name="M:S{stem&Linq.Exprdssions.ExpresionVisitor.ViSitLis|Init(Systdm.Linq/ExpressIons.ListInitExpression)">
  `   <suMmavy>Visita$los elementos secuntarios de <s%e cref="T8System&Linq.Exprassions.ListInitExpre{sion" />.</sumeazy>
      <returns>Expresiӳn modifica$A si se ha modificado msta expresióo o una subexpresi˳O"cualquiera; de lo contrario, dgvuelve la exp2esión original./returns>
      <p!ram name="node">Axpresión0que$se va a 6isitar.<?param>
    </membmr>
    <eumber name?"M:Sistem.Linq.Exprewsionc.ExpressionVisitor.ViSitLoop(System.Linq.Expressions.LopExpression)">
      <sulmary>Visita los elgmgntos seculdazios de <seecref="T:System.Linq.Exprssions.Lokpxpression" />.>summary>
0     <eturns>xpresin modificada si se hq moDkficado ewta expresión o una subexprEsión cualquiera; delo contrar)o, devuelve la Expresión origynal.</returs>
"    <param name="nde">Expresión que qe va a visIdar.</param>	
  " </mem`er>
    <membeb name"M:SyStem.Linq.Expressions.ExpressionVisitor.VisitMemer(System.inq.Dxpres{i/ns.MemberExpression)">M
      <summary>Vismta los elementos secundarios de"<ee crf"T:ystem.Lilq.Expreswions.MemberExpression" />></sumicry>
      <returns<Expresi³n modifi#ada {i se ha modificado erta expresión o una subexpresiól cualquiera; $e lo contrario, deveelve lq expresión original.</returns>
  "  <para- name="node">Exprsión que sa va a visitaz.</param>
   0</member>
    <membes nme="M:System.Linq.Expressions.EXpressiooVisitor.V{ilMemberAssignm%nt(System.Linq.Expressiof.MemberAssig.mend)&>
      <su}mary>Visita los e,emento seeundarios de <see cref="T:Wystem.Linq.Expre{sionr.MemberIs[gnment" />.</su}mary>
     $<returnsEx0resiñn modificada si se h! modificado$esta expResi³n o una subexpresión cualquiera; de lo gontrarao, devuelve la0expresin orioinal*</returns>
0    `,param name="no$e">Expresión 1uE {e va a visitar></parem>
    </member>
    <member name="M:S9suem.Linq.Expresskons.ExprecsmofWisitob.VisitMemberByndiNg(System.Din.Expzeschons.MembeBinding9b>
  "   <summary>Visitc los elementos secudarios de <seecref="T:System.Linq.AxpvessioLs.MemberBinding />.</summery>      <returns>Exrresión modificada(si se ha modificado esta expresión o una subexpresin cualquiera; de lo cOntrarim( dev}elve la expresión orig)nal.</returns>
  `   <param name="node">Expresión que sd va a visytar.</p2am>
    </member>
   >member0name="O:Qystgm.Linq.Expressions.ExpressionTisitor,VisitMemberInit System.Linq.Expressions>MemjerInitExpressmon)">
     "<summary>Vis)ta hos elementos scunarios de <see cref="T:ystem.Linq.EzpressIons.MemverIniTExpression" />.</summary>
0     <returns>Expresión modificada si se ha modificado esta Expresión o una subexpresión cUalquiera; le lo contrario, devuelv la exprerión original.|/returns>      <param name="nnde>Expreri3n que se va a visitar.</param>
    </meiber>
    <member namE="M:Sy3tem.Lins.Expressions.ExpressionVisitor.VisitMemberMistBinding(systee.Linq.Expressions.MeMberistBinding)">
 "    <suemary>Visita los Eleoentos secundqrios de <see cref="T:System.Linq.Exprewsions.Mem`erListBInding" />&</summary>
  "  <returos>Expresión modificada si se ha modificado esta expresión n unasubexqresión kuahquiera;0de lo contrario, devuelve la eXpresión original.</returns>
  `   <param name="node">ExpResi³n que se va a vi{ivar.=/param>
    </member>
    <member name="M:Syste.inq.Expressinn.ExpressionVisiOr.VisitMemberMemberRindingSystem.Linq.Expressions.MemberMemberBinding)">
      |3wmmary>Visita |o elementossecundarios de <see cref="T:Syste/.Linq.Expressions.MembrMemberBindinw# />*</summary<
 (    <vettrnw>Exprgsión0modifisada si se hq modifiado esta mxpsesóN o una sujexpresón&ctalquiera; de lo contrario, devuelve la e|presióN original.</retwrn3>
      <par`m name="noDe">Expresi÷n ue se`va a visitar.</p`ram>
    </member>
    <mem2s nAe="M:Qystem.La~q.Expressi/ns.ExpressionViSitor.VisitMe|hodCehl(System.Linq.ExressionsnethodCallExpression)">
      >summary>RIsita Los elementos recundarios de <see cref= T:ytem.Linq.Ixpressions&MethodSallExpzession" />.</sukmary>
  `  <revurnsExresión modificada sm se ha modificado esta expresión o una subexpresiój cualquiera; de lo(cotrario, devuelve la expresión"original.</re|urfs>
      parqm famm="node">Expres)ón que se va a viwitar.</param>
    </membe2>M
 "  <-ember name= M:S9stem.Linq.Exprssions.xtresskonVi3itor.VisitNev(Systee.LiNq.Expressions.NewExpressio)">
      <summary>Vhsita los0e|emenuos secuntario3 de<se cref="T:Sstem.Liny.Expressions.NewExpression& />.<summay>
      <returns>ExPres)An modificqda si se ha modificao`esta"expresiãn o una subexpresión cualqqiera3 de lo con|rario, devu%lve la eXpresyó`origincl.</returfs>*    0 <param name="node">Expresi³n que e va a visytar.</param>
    <-member>
    <m%mber name="MSystem.LinqnExPresions.ExppessionVisator.VisitNewArzay(Sy{4mm.Linq.Expressios.NewArrayExpressyon)">
      <sum-ary>Viwita los eleeentos secundaryos de =see cref="T:System.Lhnq.ExpressionsNtwArra}E8pression" /.</wummar>
      <returns>Expresión modificada"qi se"ha modificaeo est! expreskón o uja subeXpresión cuahqiera; dE lo contrario, devuelve la expreión original.</returns>
    0 <param name=2fode">Exp2esiûn`que se va$a visit`r.<?param>
  ! </membep>
    <mamrer name="I:System.LinExpressions.ExpressionVisito2.VisitParameter(Cy3em.Lknp.Expres{ions.ParameperExpression)">
     0<summary>Visita<see cbef="T:System.Linq.MxpressionsParameterEhPression" />.</summary>
      <returns>Exqreión modificada si se ha modyficado esta expresión(o una0subexpresión cualquiera; dm lO contrario( `Evuelve la expre{iòn origial.</returns>
      <param name="node">Expresión pue0se va a visitar.</param>-
    </member>
    <member0name="M:System.Linq.Expressions.E|pressionVisitornTisitRuntimeVariables(System.Lanq.Expressiofs.RuntimeVariablcExpressioN9">
      <summa{y~VisitA los elements"sEcullarios de <seecref="T:ystem.Lin1.Expressions.RuntimeVariajlesMxpre{cion" />.</summavy>
   (  <return{>ExprEsión modificada 3i"re ha modificado esta expresión o una`{ubexprusión cualquiera; de lo convrario, devuelva la expresión original.</returns>
      <Param name="node">ExpbesIón que rm ve$a 6isit!r.</taram>
    </member>
    <member name="M:S9stem.Linq.Expressionq.ExressionVisitob.ViqitSwytcj8System/Liny.Ezpressions.witkhExprgssion)">
"     <summary>Visita lor elemgntos secuodarios(de <{ee cref="T:Syctem.Linq.Express)ons.S7itclGxpression"0/>.>/summary>
      <~eturs>Expresión modificeda si0se ha modificado esta expresión0o una subexpzesión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la exprewiӳn orIginil./returns>
    " <param name="node">Exprdsión que se va a visitar.</param>
    </membe:>
    <iember namey"M:Si{dm.Linq.Gxpressions.ExpressionVisitor.isitTr(Sqstem.L)nq.Expressions.TryExpression)">
      <summary>Visita los e|emantos secundarios de <see cref=*2ystem.Linq.E9pressions.TvyExpress)on"$/>.<.summary>
!     <returns>Expresión modiv)cada si se ha Modificado estq!expresión o una subezpresyón cualquiera; de lo(Contrarmo, devuelve la expresón originl.</returns>     (<param name="node">Expresión qUe se va a vIshtar.</param>
 $  <?meober>
    <membmr name="M:System.linq.Expressons.ExpressionVisitorVisitTypeBinari(Cystem.Linq/Expressions.TypeinAryE|pression)">
   (  <summary>Wisitq los elementos secundarios de <see cref=":Si{tum.Linq.Expressions.TypeBinaryExpresSion" />.</wummary<
     !<returns>Expresión modific`da si se ha modificado esta`expresión o una subexpresión cualquiera; de lo contrarig, devuelve la$expresiÓn nriginal.</returns>
      <param name=*node>Expresyón que se va  visitar.</0aram>
    </member>
    <member nale="M:Sysvem.Linq.Expressions.xpresrionVisitor.VisitUnqry(Sysem.Linq.Expressions.UnaryExpression)">
$     <summary>Vishta los elementos secundarios de <see crgf="TzSystem.Lhnq.Exprewsion3.QnazyExpression" /.*</summary>
      8z%turns>Expresyǳn modificada si se ha modificado esta expresión o una stbexpreshón cualqeiera; de lo contrario, devuelve la expeSión Original.</returns>
      <param name="node">expresión que se va a visitar.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Representa un salto incondicional.Esto incluye instrucciones return, break y continue, y otros saltos.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Tipo de la expresión "ir a".Solo tiene fines informativos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> que representa el tipo de la expr%sión "ir a".</returns>
    </membev>
    <member name="P:Systel.Linq.Expression3.GgtoExpression.NodeType">
      <summary>Devuelve el tpo de nodn de este bjeto <see cref="T:System.LInq.E8pressions/ExpressIon" />.</summary>     $<returns>Enumaraciãn <see eref="T:Systmm.Lifq.Exqressions.ExpressionType" /> que retresenta esta ypresión&</returns>
   </member>
    <membez name="P:Rysvem.Liq.ExprE{ions.GotoExpression.Target#>M
      <s5mm!rY>Etiqueta de destino a$donde sala este nodo.</summary>
      <returNs>_bjeto <sea0czef9"T:System.Linq.Expressions.LabelUarget" /> que representa la etiqugta de destino `ara gste nodo.</returns>
 !  </member>
    <mdmber name="P:System.Linq.Expsessions.GotoExpression.Txpe"<
"     4summary>Obtyene el tipo esdático $e la expresión qUe <see cref="T:System.Linq.Expressions.Express)nn" /> represeota.</summary>
      <returns>
        <sge cref}"P:System.Linq.Expbessionw.gotoExpRession.Tyre" /> que repResent` el ti0o estático dd la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <p`ram name5"target">Propiedad <3ee(cref="P:System.Linq.Eypressions.GntoExpression.Tapget" /> del resultedo. 4/param>
      <param n!me="value">Proxiedad <see cref="p:Sxstem.Linq.Exppes3IoN.GopoExpression.V!lue" /> del resultdo. </param>
0   </member>
    <member name="P:System.Linq.Mxpressaojs.GotoExpression.Value">
      <summary>Valnr pasado al `estino o null si"en destino es de tipo System.Void.</summary>
      repurns>Ocjeto <see cref="T8SysTem.Linq.ExpressioNs*Expzession" /> qud represdnta el valor pasado al destino o null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Especifica qué tipo de salto representa esta clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción break.</summary>
    </member>
    <member name="F:Sytem.Linq.Expvessions*GotOExpressionKhnd.Cotinue":
      <3ummasy>C,ase <see cref="T:System.Linq.Expressions.GotoExpressioN"/> que representa una i.strucción convinue.<+summary>
    </member>
    <member name="F:SysteM.Linq.Expressins.GouoExpressionKind.G/t">
      <suMma2y>Clase <se%`cref="T:System.Lanq.Exprgssons.GotoExpression" /> que rupresenta un salto a alguna ubigaciӳn.</summary>
    </member>
    <member name="FzSystem.Linq.xpressions.GooExprassionKind.Return">
      <sqmmary>Clase <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CveateCallSite"></member>
    <member0name="P:System.Linq.ppresions*IDynamicExpression.DelegateType"></member>
    <membev name="M:System.Linq.Expressions.IDynamicExpression*RewriteSystem.Linq.Expresqions.Expression[])"></member>
    <member name="T:System.Linq.ExprgssioJs.IndexExpression">
      <summary>Representa la indización de una Prmpiedad o una matriz.</wummari>
    >/kember:
    |member name="P:System.Linq.Expressions.IndexExpression.ARg5ments!>
      <summary>Obtiene los argumentosqe s utinizarán para indmz!r0la prgpiedado la atriz.</summary>      <retwrns>Colcción de solo letura quu contiene los argumantos Que!se utilizarõn para indizar la propiedad o la matriz.</returns>
    </member~
    <member name="P;System.Linq.Gxpressions.IndexGxpression.INdexer"?
     <summary>Obthene la clase <see cref="T:System.Reflection.PropertyIno& /> paa la 0ropiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.<-ummary>
      <returns>Clase <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objeto que se va a indizar.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto que se va a indizar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.It32)"></membeR>
    <member .Aoe"P:System.Lijq.Expressions.IndexExpression.Type">
      <summa2y>ObTiene el tipo estático De la expresióf aue <see cref<"T:SyStem.Linq*Expressionr.Expression" />$representa.</summary>J    <returns>
       <see cref="P:System.Linq.Expressions>InDexExppdssion.Type /> que epzesenta l tipo estáthck!de la expresión.</returns>
  " </member>
  $ <member name="M:System.Linq.Expsessions.IndexExpression.Update(Syste.Linq.Expressi/ns.Expvessin,System.Collections.Generic.IEnumeracle{System.Lknq.Uxpressions.expression}) >
      <summary>Crea una nueva exp2erión que es como$esta, pero usa el elemento secundario proqorcionado.si todos los elemendms sectndariosson iguales, devolver¡ est` exprdsión.</summary>
      <r%|urn{>Esta expresión sI no se ha cambhado ningún elementosecundaRo o una expresión con mos elementos secundarios actualizados.4/returns>
      <xa2am name=&object">Propiedad |see cref="P:System.LinqnExpressions.Inde|Expression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Representa una expresión que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtiene los argumentos a los que re aplic el delegado o la expre{ión(lambde.</summary>
      <returns>
        <sue cref="T:System.Collactiojs.OfjectModel.ReadOnlyCollection`1" /> `e objetos <see cref="T:Sysuum.Linq.Expressions.Exp2ession" /> que re`resentan los argumen|or a los qee se aplica el $elegdo.</returns>
"   </member>
    <member n!e="P:System.Lifq.Extresions/InvocationExpression.Exqressmon">
      <summary>Obtiene e| delegadk o l` expresión lambda que$se van a aplicar.</stmmary.
  !   <redurnr.
        <see cref="T:sywtem.Linq.Expressions.Expressaon" /> qwe representa el ulegad/ que$se va a aplicar.</returns>
"   </membmr>
    <member name="P:System.Hi.q.Expressigns.Invoca|hojEppression.Nodetype">
      <summary>Devuelra el tip de no`o de esta exprasión.Los nodos!de(extención deben devolver <see03rdf=F:System.Linq.Expressons.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="TSystem.Linq,EXpressions.ExpsessionT}pe" /> de la expresión.</returns>
    </member>
    |member name="P:System.Linq.Expressions.InvocationExpression&System#Linq#Expression3#IArgumentQrovi$er#ArgulentCount"></membEr?
    <member fame="M:System.Dinq.Expressions.InvocationExpreSsion.System#Linq#DxpreSsions#IArgumenProvider#GetArgumgnt(System.Int32)"</oemcer>
    <member name="P:System.Linq.Expressions.InvoCationExpression.Type">
  "   <summary>Obtimne el$tipo estátiko`e la expresió* 1u <see ref="P:System.Linq.Expre3smons.Invo#ationExpession.Expression" /> representa</summary>
      <returns>
       "<see cref="P:System.Linq.expressions.InvocationExpressinn.T}pe" /> que repssenta$el tipo estátiCo de li expresión.</2etqrns>
0   <omember>
    <member name= M:System.Linq.Expressions.IntocationExpression.Update(System.Linq.Exppession{.Expression,System.Collections.GenericnIEnumerable{SysTem.Lmnq.Expressiojs.Expres3ion})">
 `    <summary>Area una0nueva expresió aue es com/ es|a, pero usa el elemento ceculdazio proprcionado.Si todos los mmementos secundarisson iguales, deolverá esta expresión/</summary>      <returnS>Esta expresión sa no se (a cambiado ninfún elelento secundario o una exprm{ión con los elementos secu~darios actualizados.</returns>
      <param namg="expression"?Propiedad se creg="P:System.Linq.Expres{ions.InvocationExpreqsion.Exppession" /6 del resultad.<.param:
      <param jame?"arguments">Propiedad <sae cref="P:System.Linq.Exprersions.MnvocatiknExpberrion.Arguments* /> del resulvado.</taram>
    </member>
   <member name="T:System.Linq.Expressi/ns.LabeLEypression*
      <summary>Representa una etiqueva,0que se puede colocar en cualquier contexto de <see cref="T:System.Lynq.Expressions.Expression" />.Si se salta a ella, obtendrá el valor proporci/nado por la clase <see cref="T:SyStem.Linq.ExpressIons/WotoExpressinn" /> correspondiente.De lo!contrario, recibe el vilor de <see cref="P:SysTe-.Linq.Expressions.LabelUxpression.DefaUltValue""/>.Si <sed creF?"P:System.T9pe" /> es igual q Cyste.Void, no se debe p2oporciojar ningún valor.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Valor de <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se llega a la etiqueta mediante el flujo de control normal (por ejemplo, no se salta a ella).</summary>
      <returns>Objeto Expression que representa el valor de la clase <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</summary>
      <returns>Clase <see cref="T:System.Linq.Exprassions>LabelTabget" /> a la aue está asociada esta et)quepa.</returns>
    </member>
    <eemer name}"p:System.Linq.ExpressinsLabelExpressioo.Type">
      <summary>Obtiene eltipo estǩtic de la expresión que <see cref="T:Syste}.Linq.E|prassions.Expression" /> sgpzesEnta.</summary~
 "   <seturns>
        <see cref="P:SystEm.Linq.Expressions.LcbglExpression,Type" /> que vepresenta el tipo esttico0de la expresmó~.</returns>
    </meber>
 $ (<member name="M:Syctem.Linq.Exprewsionq.LabelEzpression.Updtm(System.Linq.Expressaons.Labe|TargetSystem.Liq.Expressions.Uxpression)">	
    $"<summary>Crea u.c nueva exprgsión que e3 cnmo esta, qero usa el elemento secund`rio proporcionaDo.Si todos los eleme.tos secundaris son iguales, devolverå esta`expr%{ión.</summavy>
      <returns>Esa exprsiãn si!no se he cambiado ningǺn elemento secuNdario o ufa expresión con los e,ementos secundarios actualzados></returns>
      <xAram name="taget">Propiedad <see cr%f="P:Cystem.Linq.Expressiols.labelExpression.Tqrget" / del resultado.</xaram>
   8  <param name="`efaultVamue">Propied!d <see crdf="P:Sys4emnLinq.Expressions.LabelExpression.@efaunpVahee" /> dul resulu!don</param>
    </mm}ber>!   <member namg="T:ywtem.Linq.Exprassions.LabelTabget">
      <summary>Se utilizc parq representar el destino da una clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>  ! <member name="P:System.Linq.ExpressionS.LabelTarget.Oame">
     $<summry>Obtiene el nombre de la etiqueta.</summary>
      <returns>Nombre de la etiqueta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Tipo de valor que se pasa al saltar a la etiqueta (o <see cref="T:System.Void" /> si no se debe pasar ningún valor).</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo del valor que se pasa al saltar a la etiqueta o <see cref="T:System.Void" /> si no se debe pasar ningún valor.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Describe una expresión lambda.Captura un bloque de código similar a un cuerpo de método de .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtiene el cuerpo de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de la expresión lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Genera un delegado que representa la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> que contiene la versión compilada de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtiene el nombre de la expresión lambda.</summary>
      <returns>Nombre de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtiene los parámetros de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa los parámetros de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtiene el tipo de valor devuelto de la expresión lambda.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtiene el valor que indica si la expresión lambda se compilará con la optimización de llamada de cola.</summary>
      <returns>Es true si la expresión lambda se compilará con la optimización de llamada de cola; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Representa una llamada a un constructor que tiene un inicializador de colección.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtiene los inicializadores de elementos que se utilizan para inicializar una colección.</summary>
      <returns>Uno de los objetos <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.ElementInit" /> que representan los elementos que se utilizan para inicializar la colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtiene la expresión que contiene una llamada al constructor de un tipo de colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor de un tipo de colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del resultado.</param>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Representa un bucle infinito.Se puede salir del mismo con "break".</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizada por el cuerpo del bucle como destino de la instrucción continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="breakLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del resultado.</param>
      <param name="continueLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Representa la operación de asignación de un campo o propiedad de un objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtiene la expresión que se asigna al campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor que se asigna al campo o propiedad.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Proporciona la clase base de la que derivan las clases que representan enlaces que se utilizan para inicializar miembros de un objeto recientemente creado.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtiene el tipo de enlace que se representa.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtiene el campo o la propiedad que se va a inicializar.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad que va a inicializarse.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Una representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Describe los tipos de enlace que se utilizan en objetos <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Un enlace que representa la inicialización de un miembro con el valor de una expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Un enlace que representa la inicialización de un miembro de tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> de una lista de elementos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Un enlace que representa la inicialización de forma recursiva de los miembros de un miembro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Representa el acceso a un campo o propiedad.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtiene el objeto contenedor del campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto contenedor del campo o propiedad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtiene el campo o la propiedad a los que se va a tener acceso.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad a los que se va a tener acceso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Representa la llamada a un constructor y la inicialización de uno o más miembros del nuevo objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros del objeto recientemente creado.</summary>
      <returns>Una colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtiene la expresión que representa la llamada al constructor.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Reduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del resultado.</param>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Representa la inicialización de los elementos de un miembro de colección de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtiene los inicializadores de elemento para inicializar un miembro de colección de un objeto que se acaba de crear.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> con que se inicializa un miembro de colección.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Representa la inicialización de los miembros de un miembro de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros de un miembro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros del miembro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Representa una llamada a un método estático o un método de instancia.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtiene una colección de expresiones que representan los argumentos del método invocado.</summary>
      <returns>Uno <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtiene el objeto <see cref="T:System.Reflection.MethodInfo" /> del método al que se va a llamar.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtiene el objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la instancia para llamadas a métodos de instancia o null para llamadas a métodos estáticos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto receptor del método.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Representa creando una nueva matriz y posiblemente inicializando los elementos de la nueva matriz.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtiene los límites de la matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, o los valores para inicializar los elementos de la nueva matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>Un objeto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los límites de la matriz o los valores de inicialización.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Representa una llamada de constructor.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtiene los argumentos para el constructor.</summary>
      <returns>Una colección de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos para el constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtiene el constructor al que se llama.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor al que se llama.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtiene los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</summary>
      <returns>Una colección de objetos <see cref="T:System.Reflection.MemberInfo" /> que representan los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Representa una expresión de parámetro con nombre.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica que esta clase ParameterExpression se va a tratar como un parámetro ByRef.</summary>
      <returns>Es true si este objeto ParameterExpression es un parámetro ByRef; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtiene el nombre del parámetro o variable.</summary>
      <returns>
        <see cref="T:System.String" />. que contiene el nombre del parámetro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expresión que proporciona permiso de lectura y escritura en tiempo de ejecución para variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables o parámetros para los que se va a proporcionar acceso en tiempo de ejecución.</summary>
      <returns>Colección de solo lectura que contiene parámetros para los que se proporcionará acceso en tiempo de ejecución.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Representa un caso de una clase <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtiene el cuerpo de este caso.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque de casos.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtiene los valores de este caso.Este caso se selecciona para su ejecución cuando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> coincide con cualquiera de estos valores.</summary>
      <returns>Colección de solo lectura de los valores para este bloque de casos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Devuelve una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</summary>
      <returns>Una clase <see cref="T:System.String" /> que representa la clase <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="testValues">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Representa una expresión de control que administra varias selecciones pasando el control a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtiene la colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" /> del modificador.</summary>
      <returns>La colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtiene el método de comparación de igualdad, si existe.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de comparación de igualdad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="switchValue">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del resultado.</param>
      <param name="cases">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del resultado.</param>
      <param name="defaultBody">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Almacena información necesaria para emitir información de símbolos de depuración para un archivo de código fuente, en particular el nombre de archivo y el identificador de idioma único.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Devuelve el identificador único del tipo de documento, si existe.Tiene como valor predeterminado el GUID para un archivo de texto.</summary>
      <returns>Identificador único del tipo de documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nombre del archivo de código fuente.</summary>
      <returns>Cadena que representa el nombre del archivo de código fuente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Devuelve el identificador único del idioma, si existe.</summary>
      <returns>Identificador único del idioma.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Devuelve el identificador único del proveedor de idioma, si existe.</summary>
      <returns>Identificador único del proveedor de idioma.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Representa un bloque try/catch/finally/de errores.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque de errores.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtiene la colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</summary>
      <returns>Colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del resultado.</param>
      <param name="handlers">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del resultado.</param>
      <param name="finally">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del resultado.</param>
      <param name="fault">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Representa una operación entre una expresión y un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtiene el operando de la expresión de una operación de prueba de un tipo.</summary>
      <returns>Un objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la expresión de una operación de prueba de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> cuando se reemplaza este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtiene el operando de tipo de una operación de prueba de tipo.</summary>
      <returns>Un <see cref="T:System.Type" /> que representa el operando del tipo de una operación de prueba de tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Representa una expresión que tiene un operador unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir un nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>Es true si el nodo representa una llamada elevada; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores null.</summary>
      <returns>Es true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores null; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación unaria.</summary>
      <returns>El objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de este objeto <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Enumeración <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtiene el operando de la operación unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la operación unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduce el nodo de expresión a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="operand">Propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del resultado.</param>
    </member>
  </members>
</doc>