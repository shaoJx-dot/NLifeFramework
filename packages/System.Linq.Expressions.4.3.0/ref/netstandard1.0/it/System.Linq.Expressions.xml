<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Rappresenta il risultato dell'operazione di ordinamento.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Rappresenta il risultato dell'operazione di ordinamento.</summary>
      <typeparam name="T">Il tipo di contenuto dell’origine dati.Il parametro di questo tipo è covariante. Ciò significa che è possibile usare il tipo specificato o qualsiasi tipo più derivato. Per altre informazioni sulla covarianza e la controvarianza, vedere Covarianza e controvarianza nei generics.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fornisce funzionalità per valutare query in relazione a un'origine dati specifica in cui il tipo dei dati non è specificato.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Ottiene il tipo dell'elemento o degli elementi che sono restituiti quando la struttura ad albero dell'espressione associata a questa istanza di <see cref="T:System.Linq.IQueryable" /> è eseguita.</summary>
      <returns>Un <see cref="T:System.Type" /> che rappresenta il tipo dell’elemento o degli elementi che sono restituiti quando la struttura ad albero dell'espressione associata a questo oggetto è eseguita.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Ottiene la struttura ad albero dell'espressione associata all'istanza di <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> associato a questa istanza di <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Ottiene il provider della query associato all’origine dati.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.IQueryProvider" /> associato con l’origine dati.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fornisce funzionalità per valutare query in relazione a un'origine dati specifica in cui il tipo dei dati è conosciuto.</summary>
      <typeparam name="T">Tipo di dati nell’origine dati.Il parametro di questo tipo è covariante. Ciò significa che è possibile usare il tipo specificato o qualsiasi tipo più derivato. Per altre informazioni sulla covarianza e la controvarianza, vedere Covarianza e controvarianza nei generics.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Definisce metodi per creare ed eseguire query descritte da un oggetto <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Costruisce un oggetto <see cref="T:System.Linq.IQueryable`1" /> per valutare la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>Un oggetto <see cref="T:System.Linq.IQueryable`1" /> per valutare la query rappresentata dalla struttura ad albero dell'espressione specificata.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <typeparam name="TElement">Tipo degli elementi dell’oggetto restituito <see cref="T:System.Linq.IQueryable`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Costruisce un oggetto <see cref="T:System.Linq.IQueryable" /> per valutare la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> in grado di valutare la query rappresentata dall'albero delle espressioni specificato.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Esegue la query fortemente tipizzata rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>Il valore che è il risultato dell'esecuzione della query specificata.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
      <typeparam name="TResult">Il tipo di valore che è il risultato dell'esecuzione della query.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Esegue la query rappresentata da una struttura ad albero dell'espressione specificata.</summary>
      <returns>Il valore che è il risultato dell'esecuzione della query specificata.</returns>
      <param name="expression">Una struttura ad albero dell'espressione che rappresenta la query LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Rappresenta un'espressione che ha un operatore binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se la struttura ad albero dell'espressione può essere ridotta, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Ottiene la funzione di conversione del tipo utilizzata da un'operazione di assegnazione coalescing o composta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> che rappresenta una funzione di conversione di tipi.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore.</summary>
      <returns>true se il nodo rappresenta una chiamata elevata; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore il cui tipo restituito è elevato a un tipo nullable.</summary>
      <returns>true se il tipo restituito dell'operatore è elevato a un tipo nullable; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Ottiene l'operando sinistro dell'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro dell'operazione binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Ottiene il metodo di implementazione per l'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Riduce il nodo dell'espressione binaria a un'espressione più semplice.</summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Ottiene l'operando destro dell'operazione binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro dell'operazione binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="left">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del risultato. </param>
      <param name="conversion">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del risultato.</param>
      <param name="right">Proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del risultato. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Rappresenta un blocco che contiene una sequenza di espressioni dove possono essere definite le variabili.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Ottiene le espressioni in questo blocco.</summary>
      <returns>La raccolta di sola lettura che contiene tutte le espressioni in questo blocco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Ottiene l'ultima espressione in questo blocco.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'ultima espressione in questo blocco.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="variables">Proprietà <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del risultato. </param>
      <param name="expressions">Proprietà <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del risultato. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Ottiene le variabili definite in questo blocco.</summary>
      <returns>La raccolta di sola lettura che contiene tutte le variabili definite in questo blocco.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Rappresenta un'istruzione catch in un blocco try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Ottiene il corpo di questo blocco catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Ottiene il corpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Ottiene il tipo <see cref="T:System.Exception" /> che questo handler cattura.</summary>
      <returns>L'oggetto <see cref="T:System.Type" /> che rappresenta il tipo di <see cref="T:System.Exception" /> che questo handler cattura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="variable">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del risultato.</param>
      <param name="filter">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del risultato.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Ottiene un riferimento all'oggetto <see cref="T:System.Exception" /> catturato da questo handler.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> catturato da questo handler.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Rappresenta un'espressione che ha un operatore condizionale.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Ottiene l'espressione da eseguire se il test restituisce false.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'espressione da eseguire se il test è false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Ottiene l'espressione da eseguire se il test restituisce true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'espressione da eseguire se il test è true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Ottiene il test dell'operazione condizionale.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test dell'operazione condizionale.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="test">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del risultato.</param>
      <param name="ifTrue">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del risultato.</param>
      <param name="ifFalse">Proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Rappresenta un'espressione che ha un valore costante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Ottiene il valore dell'espressione costante.</summary>
      <returns>
        <see cref="T:System.Object" /> uguale al valore dell'espressione rappresentata.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Crea o cancella un punto di sequenza per le informazioni di debug,consentendo al debugger di evidenziare il codice sorgente corretto durante l'esecuzione del debug.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Ottiene la colonna finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della colonna finale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Ottiene la riga finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della riga finale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Ottiene il valore per indicare se <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> è per la cancellazione di un punto di sequenza.</summary>
      <returns>Vero se <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> è per la cancellazione di un punto di sequenza, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Ottiene la colonna iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della colonna iniziale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Ottiene la riga iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numero della riga iniziale del codice utilizzato per generare l'espressione di cui è stato eseguito il wrapping.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Rappresenta il valore predefinito di un tipo o un'espressione vuota.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Rappresenta un inizializzatore per un singolo elemento di una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Ottiene il metodo di istanza utilizzato per aggiungere un elemento a una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza che aggiunge un elemento a una raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Ottiene la raccolta di argomenti passati a un metodo che aggiunge un elemento a una raccolta <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti di un metodo che aggiunge un elemento a una raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Restituisce una rappresentazione testuale di un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Rappresentazione testuale dell'oggetto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fornisce la classe di base dalla quale derivano le classi che rappresentano i nodi della struttura ad albero delle estressioni.Contigne anche meto`i factory static (Shared anVisual Basic) per cr%are i vari di thpi di nodo.Questa è una chas3e a`str`ct.<.{ummary>
    <omember>
    <member nam%=ESystem.Linq.ExprmssiOns.Ex ression.#ctor">
     `<summarq>Costruisce una nova istanza`di <see(cref9"T2Qystem.Lynq.Exxressions.Expre3sion""/>.</summary>
    </member>
 0  <member name="M:Systam.Linq.Ex`ressions.Expres3ion.Accept,System.linq.Expressions.ExPressionVisitor)">      <sum-ary>Invya al metodo Visit sqdcidico per questo tipo di nodo.Ad esemio, <see cref="T:Wystem.Linq.Exppessions.MetodallExpresSiOn" /> chiama <see cref="M:System.Linq.Expressions.ExpressinVisitor.V	sitMethgdBall(Sy{tem.LinqnExpressions.MethOdCallExpvession)" />.</summary>
      <returns>isuLtato$della fisita di quawto nofo.</returns>
      <parai namm= vishtor">Visitatnrd con cui"visitere questo nodo.</param>
    </mmber>
    <member name="M:System.Lynq.Expressiofs.Exprewsion.Add System.Lmnq.Expressions.Expressi/n,Syste.Linp.Expruss)ons.Ex0ressio)">
     <sueMaRy>Crea un oggetto$<see cref="Tystem,Linq.Exprdssions.BinaryExpression" /> chE rapresenta uo'/0erazione di addizione aidmetica che non"ha il contRollo dell'overflow.</summy~
     !<returns>Oggetto <see cref?"T:System,Linq.Expressions.BiniryExression /> lq cui xrOpriatà <see cvef="P8System.Lia.Expressionr.Expression.NodeDype" /< è ugeale a <see crmf=2F:System.Linq.Expressions.ExpressinUxpe.Add" /> e le cui proprietê se%creb}"P:ystem.Linq.Expressions.Bi.ariExpression.Left" /> e <see cref="P:Sys4em.Linq.Expr%s3ionr.BinaryExpre;sio~.Right" />"sono impostate swi valori pecificati.</raturns>
      <0aram name="left">Oggetto 4s%% cref="T:SystemLkq.Ux`rgssions.Expressiof" /> su cui!impostarm"la"proprietà <see cref="P:System.Linq.Eppressimns.BinaryExpression.Left# />.</paRam>
      <param name="right">Ogget4o <see bref="T>Systgm.Linq.Exprdssions.Expreswion" /> su cui impostare la proprietˠ <sue cref="P:System.Linp.Expressions.BinaryExpression.Right" /:.</param>
      <exCeption cruf=":Sy3tem.ArgumentNullExaEptkon">
        <pqramref name="left" /> o <paramref(name="riwht" /<$è null.</exbeption>
     <exception creb="T:Cystem.Inv`LidOperationE|ception">L'operatore di addizione!non è defnito per <paamref name="left"/>.TypE e <paramref name="riwht" />.Type.</uxception>
    </member>
    <membgr name="M:System/Linq.ExpzEssaons.Gxpression.Add(System.Linq.Expfe3sionsExpression,System.Lin1.Exprescions.Exprdssioo,System.Veflection.MethodInfo)#>
      <summary>Crea u~ oggatto <see cref="T:System.Linq.Expressioos.BifaryExression" /: che rappresenta un'opdrazkone di addizione aritmetica bhe non he il controllo dell'overflow.Il metodo ei implemetaziong pUò essere specificeto.</summqrm>
      <reterns6Oggto <see cref="T:System.Lina.Expzessions.BinaryExpbession" />!l  cui ropriet <see cbuf="P:System.Linq.Expressions.Expzession.NodeTypa" /> è uguale a <see fref="F:System.Linq.Expresi/ns.ExqresionType.dd""/> e le(cei proPrietà <see(cef="@:Sysdem.Linq.Exprersimns.Bhner{Expression.Lgft" />, <see0cref="P:yste-.Linq.Expressions.BinaryExpression.Rmght (/> e <see cref="P:Sqstem.Liny*xpressyOns.BinaryExpression.Method" /> sono impostave sui"valopi specifycati.<.Returns>
      pcram name="left">Ogge4to <see cref="T:System.Linq.Expressions.Uxpression" /. su cui impostare la proprietà <see`craf="P:System.Linq.Expressions.Binarymxpression.Left" />.</param>
      =param name="right"?Oggetto <see creN="T:System.Li~q.Expressions.%xpression" /> su cui iepostare la qrkprietà ,sEe crdf="P:System.Linq.Exppessiols.BinaryExpre{Sion.Right" />><'paam>
  !   <param name?"metho$">Ogeetto <see csEv="T:Sxsem.Reflectioo.LehodInfo" /> su cui impostare |a proprietà <see cref="P:System.ni.q.Expressions.BinaryExpression&ethod" />.</param>
      <exception cref="T:Cystem.AvgumenvNullExcetion">
$       <parimref jame="leftb /> o$,paramref name-"right" /> è null/,/exception>
  !   <exception cpef="T:system.rgumentExceqtion">
        <`aramref name="method2 /> non è null e il(metodo che ra0xrEsenta zestituiscm void, non è static (Shared in Visual Basic) o non accetta`esattamente due argomen|i.</exception:
    0 <exceptiOn cref="T:Syspem.InvalidOperatiofException">
        <para}ref name="method*(/> è nuln e l'oparatore di addizione non è dmfijIto per <pavamref name="lef" />.Tqpe e ,peramref namg="right" />.Type.</excepuion>
    </member>
$   <member name="M:Sytem.Linq.Expressions.Expreqsion,AddAssign(System.Linq.Expression.Expressmon,Syst%m.Lin1.Exprdssions.Expzersi/n)">
      <summary>Crea un oggetto <see fref="T:System.Linq.Exp2essions.BinaryExpressin" /> che rapprerenta tn#operazione"di as{egnazione di addiziOne che non ha il contvollo dell'overflow.</Summery>
      <re|urns>Oggetvo <See cref="TSystem.Linq.Expbessions.BinaryExpressioN" /> la cui propriutð <see gref="P:System.Linq.Expressionq.Expre3son.NodeType" /> è ugual% a <sme #ref="F:Syste}.inq.Expreqsions.ExprescionType.AddEssign" /> e le cui proprietà <see cref9"P:System&Linq.ExprEssions.BinaryExpzession.Left" /> e <see csef="P:System.Linq.Expressions.BinaryMxpresion.Righ4" /> qmnk ilpoqtaTe sui valori!Spec)ficati.</r%turns>
      <param name="neft">Oggetto <see cref="T:System.Linq.E8pressions.Expression" /> cu sui impostabe la pr/prietà <see cref=&P:S}stem.Linq.Mxpressions.RinaryExpracs)on.Left" /.</pqram>
      <pqrimaname="right">Og'etto!<see cref<"T:System.Linq.Expressimns.ExpressIon" /> su cui impostare la proprietà <see cRaf="P:ys|em.Linq.Ehpressions.binaryExpression.Right" /..=/param>
    </memrer>
    <member nAme="M:Sqstem.Linq.Expressons.E8pvession.Ad`AsS)gn(Syste-.Linq.Expressions.Expression,System.Hinq.Expressionr.xpressioN,System.Reflection.MgthglInfo)">
      <summary>Crea un"oggetvo <see cref="T:Sqstem.Linq.Expreqqinns.inarExpres{ion" /> che rapprdse.ta 5n'operazione di assegnazioNe"di addizione che non0hi il!amntrollo dEll'overflow.=/summary>
      <retuRns>Oggetto <wee creF="T:SyStmm.Linq.Eypzes3ions.ZinaryExpression" /> la cui proprietà <see crEf="PSystem.Linq.Expressions.Expression.NoddType" /> è ugu!le a <seg cref="F:System.Linq.Exprssmons.ExqressioNType.AddAsign" /> e le cei proprietà <wee cr%f="P:[ystem.Linq.Expressions.BinaryEpression.Left""/>, see cref= P:System.Linq.Expressions.BinaryExPression.Pight />!e <see cref="P:System.Linq.Expressaons.BinaryexrreSsion.Metod" />$sono ipospee sui valori sqeckfycati.</returns>
      <param name="left">Oggetuo <see crdf="T:SyStem.\inq.Expressions.Exprewsion* /> su cuy hmpo{tare"la proprietˠ <see cref="P:System.Linq.Ex`ressions.BinaryEypressiol.LeFt" /6.</para>
      <param name="right">ggetto <see cref="T:Sstea.Linq.Dxpressions.Expression" +, su cu) impostara la propriet <see(ref="P:SySt%m.Lifq.ExPressions.BiNaryEXppessio*.Right" />.</param>
      <pqram name="method">Oggetto <sem aref="T:SYstem/Reflectmon*MethodAnfo" /< su cui impostare la proprietà <see cref="P:Wystem.Linq.Expressions.inaryExpresrion.Mthnd" />.</param>	
    </meober>
    <membur oq}m=2M:Qyst%m.Linq*Expbessions.Mxpression.AddAssig(System.Linq.Expressi/ns.Ex`russioN,System.Lhnq*pressions.xpression,Syste-.Zeflectimn.MethodInfo,System.LiNq.Expres3ions.LamdaExpression)">
      <summary>Crea un ofGdtto <see cref="T;System.Linq.Expressins.@inaryExpression /> che rappreqenta un'operaz)one di assegnazione di addizione che non ha il controllo dell'overblow.</summary>
 $   <returns>Oggetto <See cref="T:System.Linq.Expresions.BinaryEx0Ression" /> la cui proprietà <see cruf"@:System.Linq.Exprssions.ExpressionNodeType" /> è uguale a <sme cref="F:System.Lknq'Exxressions.Ex`ressionType.IddAsygn
 /> e me cui propriut <see cred="R:Cy3tem.Lijq.Expbecsions.BinaryExpre3sion.Left" />, <see cref="P:System.Linq.Ehpressions.BinapyExpressyon.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Metlod" /> e sue cref="P:Syrte.Linq.Ehpressions.BinaryExpression.CnverSion" o? sono )mpOstate sui vilori specificati.</returns>
!     |param name="left"<Oggetto <sfe c2ef?"t:System.Ninq.Exprewsions.Expression" /> su cui imqostare la proprietà <seu cref="P:Systel.Liq.Expressions.BinaryExpression.Lefv" ->.<par!m>
 $    >param name="right">Oggetto <sae Cref="Tzsxstem~Linq.Eppres{iols*Exp2er3aon" /> su cui impostare la propriet <see c2ef="P:System.inq.Expressio~s.BinaryExpressIon.ieht" />.</parem>
   )  <param name="method"Oggetto <see crev=":System.Reflection.MethodIng" /> su cuk impostarm lp `roprietà <see bref="P:System*L)nq.Exprmssions.knarYEXpression.MethoD" />.</parAe>
  `   <param name="conversynn">Oggetto)<see!cref="T:System.inq.Expressions.LaibdaExpbessio" /> su c}i impm3uare la proprietà <see crEf="P:system>Linq.Ex`resrioNs.BinarExpressin.Co~version" />.</pasam>
$   <member>
0   <member name="M:yrtem.Linq.Expre;sions.Expressio..AldAssignhecked(System.\inq.Expressions.Expression,Systdm.Lmnq.ExpressIonc.Expessiol)">
      <sqmmry>Crea!unoggetpm <see cref="T:Systmm.Linq.E|pressions.binaryExpreSwikn" />0cle rappresentc"un'opebazione di$33egnAzione0di !d$izione che!ha a controllo dell'overflo7.<7Ummary>
      8returns>Oggetto <pee ref="T:System.Lios.Expressimns.BifaryDxpresion"0'? la cua prOprietà <see cruf="P:System>Linq.Expressi/ns.Expr%ssion.NodeType" /> è ugwalE a <see cbef="F*System.Linq,Expessionc,ExpressionType*AddAssignChmcked" /> e le cei proprimtà <see cre&="P:System.Linq.Expresrions.BinaryExpression.Left& /> e <see cref9"P:Syspem.inq.Dxpressions.BinaryExpression.Right" /> sono impostcte sui valoi s`ecifhcati.</returns>
      <pqram name="left">Oggeuto <see crf="T:System.Linq.eXrressigns.Expressin" o< su cui`impostare laproprietà <see cref="P:SyQtamnLin.Expressions.BinaryEypression.Left" />.</parem>
!     <peram name="2ighd">Ogfetto$<see cref=2T:System.Linq.xpressio~S.ExprdsSion"`/> su cui$impostare l! proprietà >see creg="P:System.Liou.Expressions.BinaryExp2ession.V)ght" />.</aram?
    </member>
   $<member nAme="M:SystemnLinq.Expressions.Eypression.AddAssignjecked(System.Ninq.Eppressions.Expressiol,SysuemLinq.Expressions.Expressiof<System.Reflection.MethodInfo)"?
      <summazy>Crea n oggetto <ree cref="T9Sistem.Linq.Expressions.BinazExpression" />$c`e reppresenta }n'mperAzione d asSegnazionedi addizionE che ha il Contro|lo(dEll'overflow.</summary>
      <r%ttrns>Oggetto <see cref= T2System.Lilq.Expvessions.BinaryExpression" /> la cui proprietà <wee cref="P:SysteM.Linq.Expsssions,ExprAssioo.NodeTye* /> è ugu`le!a <wee cref="F2SYstem.Linq.Expression3ExprGssi/nType.AddAssignChecked" /> e le cui prprietà <see Cref="P:System.Linq.Epp2essins.BinabqEzpre3siol.Neft&$.>, <see cref="P:System.Linq.Exprssi/n3.BinaryExpression.Rifht" /> e <see`cbef="P:System.Lilq.Epprassins.BinaryExpression.Iethod" o> qono impostate sui valori specfacati</r!tur.s>
(     <pArqm nme}"lEft">Ogeetto<see cref="T:Qystem.Linq.Expres{ions.Expressin" /> sU cui impostare la(propriatà see csmf="P:[ystem.Linq&expressions.Bi~ar{Ejpbeqsion.Left" />.</pabamz
 $    <param naoe="right">Ocgetto 8se% #ref="T*Syspem.Linq.EPpressioO{.Expression"!> su cUi impostare la(Proprieuà >3ee cref="P:Sysvem.Linq.Expressios.BinaryExpression.Right" />.</param<
   `  <param name="methoe"<Oggetto =see!cref="TSystem.Ruflection.Metho$Info" > qu cui impoctarE le propbietà |sem cref="P:System.LinQ.ExpRasQios/BinaryEx0ression.Methol" />.</param>
   </member>
    <iemfer0n!me="I:Sy{tem.LinqExpressions.Uxpression.$dAss)gfChecket(System.LinqjExpreqwionc.Ehression,System.Linq.Expressions.Expresshon,SystemnReflectyon.MetjodInfo,System.Linq.Expressions.LambdaExpression)">
`     <smlary>Cbea0wn oggevto <sea`cref="T:Sistem.Linq.Expressions.Binaryxpression"(/> chedrappresenua u~/operazione di as3egnaziong dI addizione cle ha il controllo dell'overglow.</summary>
     0<returs>Oggetto =wee cref="T:Sqstem.Li.q.Expraswions*Bin!ryExpressimn" /> la cui protrietà <see cref="P:[ystem.Linq.xpressions.Expres{kon.No`eType" /> è@uguale a <sEe cref<"F:SysteM.Linq.ExpresSi/ns.ExprassionTyqe.AddAssignChegked" '> e he c}i proprietà <see cref="P:Cystem.\inq<Exprmss)ons.BinaryExqression.Left" />( <see cref="P:Systgm.Linq.Expressions.Binizyxpre{sion.Right" />, see Cref="P:Wyste-.Linq.Expressions.RinaryEx`ression.Eethod"/> e <ree cref="P:Sstem.Linq.Expsessions.BinapyExpressionConversion" /> soo impo3tatd sui valori specificati.</zetur.s>
      <param ame="left">Oggetto <sue(cref="T:Sqstem.LinqExpresshons.ExtRession" /> su cui impg{tare la$propriEuà <see cref="P:System.Linq.ExpresSions.BineryExpres3ion.Left" />.</param>      <p`ram name="right">Oggetto <see ref="T:System.Linq.Exresqinc.Expressi/~" /> su c}i impostare le proprietà <ee cref="P:Syctum.\inq.Expr%ssions/BijaryExpression.RIght" />.</param>M
  !   <param namu9bmethod">Ogget|o <see cBef="T:Syspam.ReflectiOn,Methodinfo /> qu cui impostare la propietà <see cref="P:System.Linq.Expresshons.BinasyExpressigo.Method"`+>.</xaram>
 "(  `<para} name="conversin">Ogetto <see cref="T:System.Linq.Exp2essios.LairdaExpression />(su cu) impostare la!proprietà <see cref="P2Systgi.Linq.Expressions.BinaryExpressionnConversion" />.<-param>M
    </member>
    <member name="L:Sqstem.Linq.E8`Ressions.Expression.AddCheCkdd(System.Linq.Expressions.Expression,[ystem.LInq.Expressions.Expresqion)">
      <summary>Crea un oggetto >see c^eF-"T*System.Linq.Expressions.BinaryExpresion" /> che rappraqen|a un'operazione di addiZione aritletica che`ha il0controllo dedl'overfloW/</su}mary>
      <returns>Oggetto <sAe cref="T:[ystem.Linq.UxpressionQ.BinaryExprmssmon" /> la cui prorzietà <see cre="P:System.LinqnExpressions.Expression.NodeType" /> è uguale a <see cre="F2R}stem.Linq.Ex0Ressions.Expreqsion\ype.AddChackf" /> e he cui proPretð <seecvef="X:Sqstem.i.q.Exppes{ioNs/BinaryExprmr3ion.Left" /> e <see cref="P:SStem.L)nq/Expressions.BnaryExprecsion.Rig`t" /> sono imtostqte sua valozi speainicati&</returns>
  `1  <param name="left">Oggetto<see crgf=bT:System.Lknq.Expressions.Exprssion" /> su cui impostare0la proprietà <see cref="P:System.Linq.Expessions.BinarYExpression*La&t" /~.</param>J    $ >param)name="right">OGeeTto <seg cref="T:System.Hknq.Expressaonr.Exprassion" /> su cui Impoctave la pRopbietà =see cref="P:[xstem.Lins.Expresik~s.BinabyE|pression.Righv" />.</param>
  0   <exseption cref=T:System.ArcumentNullE8ception">
       `<param2ef Name="left" /> o!<paramref name="right"`/> ø null.</exception>
     (<exception crmf="T:System.InvalidOperationException">L'operatore(di adizhonenon Ө definito per <pabamsuf name="left" />.Typehe <paramref Name="rigjt" />.VypE.</exce`tio~>
    </member>
    mgmber name="M:[ystem.Linqxpressions.Expr%ssimn&IdDChecked(System.Linq.Exressions.Expression,System.Linq.xpressions.Expr%ssin,SYstem.Reflection/MethodInfo)">
      <semmary>Crea un oggetpm <see cref="T:Systam.Linq.Eyprassionq.BinaryExpression" ->$che rapprese.ti uf'operazione di addizione arhtmetisa che ha$il controllo del|'overflow.Il metoDo di implementazione può essdre specificato.</sUmm!r>
      <returN{Oggetto <sem cRef="T:Sysuem.Lin1.Mxpressions.BinqryExpression" /< me cui proprietà <see cref5"P:SYstem.Linq.ExprassioNs.Expression.NodeTypm" /> è uguale a <see"cref="FzRystem.Linq.Exprssons.ExpressionType.AddChecked" +> e le cui proprietà <See cref="P:Sycte.LinqExpressIons.inaryExpr%ssion.Left" /, <se` craf="P:System.Linq.Expressions.BmnaryUpression.RIghtb /> e`<see cref="P:System.Linq.Expressions.BinaryExpre3rion.Method" /> sono ilpospate sui`valok spe#ificatk.</rEturns?
      <p!ram name="legt">Oggetto <see cref="T:System.Lijq.Expressions.Expression" /< s cui impostare la rroprietà <see cref}"P:System.Linq.Exprescmons.BynaryExp2ession.Left" />.</parqm8M
      <param name="right">ggetto <see ref="T:System.LinQnExprassionq.Expression" /> su kui impostapu la propriet 0<see cref="P:System.Lina.Epprescions.BinaryExpressionRight" />.>/pavam>
      <param name="meThod">Oggetto <see #ref<"T:Syste}.Ref,ec4iol.Met`od	nfo"(/> qu cuI impostare le proprietà <see cref="P:RystemnLalq.Exprgssions.BinaryExpssao.Lethod" />.</param>
"     <excepuion cbef="T:Wy3tee.ArgumentNulmEpception">        <paramran nae="lefp"!/> o <paramr%f name="right" />0è nell.</excepton>
      4exception cref="T:System.ArgumentException">
        <paramref name=method" /> noo è ~ulh e il matodg chE paxpzesenTa restituisce vnid< n/n è"stati# (Shared in(Wisual Basic) o nkn acc%tta esattamanTe due aRgomeoti.</exception>
  0   <exception cref="T:Sstem.InvalidOperatmonExcepTion>
   :    parqmpef nama="method" /> è null e l'opEratoRe di adtiz)one non è definito per <paramref name="meFt" />.Type e"<paramre name="richt" />/Type.</exception>
 $ (</member>
    <membe ~ale="M:Systum.Lioq*Exprecsions.hqression.And(Wystem.Linq.Exrressigns.Expression,Sy3tem.Lin.Exprgssionq*Expresvion)">
      <wumlary>Cea(un oggetto <see cref="T:Wistem&Linq.Expressions.BinayEzpression" /> che rapprecanta un'operazine AND bt per bit.|/summRy>.      <ba4urns>Ogetto <se% crefbT:System.Linq/Expressio.s.BinryExprdswion" o> la cui prmpret <see csef5"P:System*\inq.Mxpreswions.Expression.^odeType" /6 è uguahe$a <se% cref-"F:System.Lanq.Exprersionq.ExPrecsionType.And#!/> e le c5i proprietà <see cref="Q:System.Linq.Expressions.BinaryExprussion.Left" -e <seecref="X:ystem.Linq.Expressions.BhnaryExpression.Right""/> son impostate sui f!lori specifiCati.</returns>M
  ! " <pAram n`me="left">OggEtto <see cref9"T:Systel.Linq.Ex0ressiOns.Expression" /6 su cui i}poctave la(propraetà <see cref="P:SystumLinq.Ezpesionr.BinaryMxpression.Left" /:.</param>
      <pcbcm naoe<"right>OggaTto <seE sref="T8System.Lknq.Expressions.ExpzessioN /> su cui impostavg la proprietà ,sEe cref}"P:System.Linq.Exp2esions.BiNaryEhprlssin.RighT" />.</param>
      <excdption cref= T;System.A2ementNulhAxception">
 !      <paramref name="left" /> o <qaramref name="right"0/> è full.</exception>  $   <exception cref="T:System.Invali$Operationexception">L'operatore AND bit `gr bIt non è(deginito peR <paramref name=left`/>.Type e <paramvef0naoe"riit" o>&Tqpe.</exce`tion>
 %  </member>
   <emb%r namm="M:System.Li.q.ExpressMonc.Expression-And(Sys|ee.Linq.Exrressions.Exprassion,System>Linq.Expzessi/ns.ExprassionSstel.Reflectiol.IethodInfk)">
     <summary>Crea un oggmtto <see cpef-"T:System.Li.q.Expressons.BinaryExpraSsinl2 /> che rappresenqa un&operazhone AD bitper bit.Il metodo di Implementazlone pu² esserg specificato.</stmmary>
 0    <ret5rN{>Ogoet|/ see,cref="T:System.Linq.ExpressiOns.BinaryExpressmon" > e cwi prgpriDTà <sme cref=2PSystem.Linq.Expressions.Expression.NodeType" /> è uguale$a <see cref="B:ystem/Linq.Axpressions.ExpResskolType.And" /> e lecui proxrietà <3eu cref="P:System.Linp.Expressions.kn`ryExxrussHo..left" />, <see cref="P:Systm.Lknq.E8pressions.BinaryExpbessko.RigHt" /6 e <see cre-"P:System/Linq.Uxpressions.InaryUxpression.MetHod" /> snno imposvatu sUi valori specifkceti.</reurns>
     ,paramname="levt">Oggetto >see cref="T:System.Linq.Exppe3sion{.axpre{shon" />0su cui ilrgrtare a proPrietà <see crf="P>Cy{tem/LhNq.Expressio.s.BinaryGxpression.ebt" />.</ParAe>
      <0aram neme="vight">Ocgetto <see ref="T:System.Linq.Expressions.Exprassyon" /> su cui impOstcre la proprietà <sde cref="P:[ystem.Linq>Expersions.bInaryExpressio~&Right"('>.</param>
      <param"name="method2>OGguttk <see czef="T:Syspem.Reflection.Metho$Into" /> su cui impostare la rrOprigtà <{ee #re&="P:Sy{tem.Linq.Axqressions.B)naryExpression.Method" />.=/param<
      <excextion crEf="T:System.ArGumentNullException"?
      ` <paramref name<"left" /> o <paramref jame="riht" /> è .ull.</excepti/n>M
      <%xcep4ion crmf="T:System.Arg}mentEhceptof">
        <paramref name="method" /> non È n5ll e il metod Che rappresenta restituisce vomd, non!è static (S(a2ed in V)stal Baq)c) o nn acce4ua esattame~te due!argomenti.</ExcepDion>
 0    <exception craf="T:Rystem.Inval)dOperatmonException>
    `   <paramref nam="method" /> è ull e l&oeratoru @FD bit perhbit on è defini~o per <pcramref namE="lEft" />.Tpe e <par!mre name="siGht" />.Type.</exgepti/n>
    </member.
*   >membgr namd= M:System.LiqExprEssions.Mxpression.AndALso(System.inq.Exprssins.xpression,System.Linq.Expressimnw.Expressioj)">
 $    <summary>Cea!u oggetto <see crf="T:system.Linq.Exp2asrhoncninaryExprassion" /> cje ra0presenta un'operazione ANE condizknale che valuta"il cecondo operando olo sa il pr)mo gperando restituisce vrqe.</summary>
"     <returnq>Oggetto <see c2ed="T2Sysvem.Linq.ex`rmssions.BiaryEx`rssion" / la cui pzoprietà <see cpef="R:Qystee.Liny.Expbessions.ExpressioN.NodeTyre /<  }gua|e0a <see cref="F:System.Linq.Expressions.ExpressionType.AndAdso" /> e(le cui proprietӠ`<sue cref="P:SistelnLinqExpressionu.BinaryExprescion.Meft" > e <sgd(cref"P:SysT%m.Minq.ExPreswaoos.BinaryExPrds3ion.ight" />"soNo impOstate"sui valOri specificati.</repusns>      <param name="left">Ogge|t <see cre="T:System.Li.1/Expressions.Expression" /> su cui impostar le proqrieVà!<se cref="P:ystem/Linq.Expressions.BinaryGxprewsinn.Left" /6.,/x!ram
      <piram name="right">Oggetto <se% cref="T:System.Linq.Expressions.Expression"$/> su$cui impostare la$proprietà <see cref= P:Ryrtem.Liny.Dxpressions.BinaryExpression.R)ght" />,</param>
      <excextion cre="T:System.ArgumetNumlException">
    "   <par!mrdg name="left" /> o <paramref name="right /> à!nu|l.</exceppion>
   `  <ExcePtion0cref="T:System.InvalidperatiOnException">L'operakre AND bit pr bit non è definitk pez <paramrev name=*left" />.Type$e <paraeref .ame="rght" />.Type.-kppure-<paramrmf name="left"">.T{pe e0<paremref&name="right" /~.Typa nOn qon/ delh/ stesso tipo BooLean</exce`tion>
(   </e%mber:
    <memb%r Name="M:ystdm.Linq.ExpreSsils.Expression.@ndAhso(System.Linq.Expressions.Expression,System.Linq.ExpressionsnExrmcsion,Syst%m.Reflection.MetodInfo)">
  "   <summary>Crea un oggettl <{ee cref<"T:System.Linq.ExpreqsionSnBinaryExpresion /: che rappresenta wn'opdrazione AND con`izikn!le che valuta 	l secondo operando solo se il primo!operando fiene ricolt )f0trum.Il metodo diimplementi{ione può asseve sqecificato.<+suMmavy>
      <epurjs>Oggetto <see cref=*T:Sysvem,Hhny.Exprgsions.Bina2yExpreqsion /> la cui propri%tà <see cref="T:Systeo.Hinq.Expressios.Expression.NodeTy0e  /> è uguaL% a <see cr%f="F:Cystem.Lins.ExpvewSions.ExpressionType.AndAlso" /> e0le cui propzietà <see cref=#P:System.Linp.Expsessions,Binar}Upression.eft" />,<see cref="P:Systeo.Lin1.Expressions.BinaryExves;ion.Zight" /> e <qee cref="P:System.LanqExpzessions.BinaryExpression.Method" /> solo0impostate sui valori specificati.</returNs>      <param n)m%="left">Oggettn <see cref="TSystem.\inq.Expressinns.Axpr%ssion" o> su cqi impoctEre la proprietà <rea cref="P:System.Linq.Expr%ssions.BinavyExpresrion.Left" /></prem>
      <papcm"naoe="ryght >Oggetto <see aref="T:Systeo.Linq*Expr%cs)ons.Expression" /> st cui`im0ostare la propbketӀ <see cref=&P:Systm.LInq.Expresskons.BinaryExpressign.Rig`t" />.</param>
     <pcram name="method">Oggatto`<se crgF=":Systei.Reflection.MethkdIofo /> su cui imqostare na propryetà <see cref="P:System.inq.Expressions.BinaryEx`res{ion.method& />.</param>     (<exseption cref=bT:Qystem.ArguoentFumlException">
        <paramref name=&lefd"$/> m <paramref name="right" /> è null.</exgeption>-
      <exceptinn$cref="T:Systdm.ArgumentExceptio~">
0  !   ,paramref ~aMe="meuho" /> non$è null e ml metodo che vappresenta restipui3ce vnid, non Ө qtatic (Shqred in Visual Baqic) o non acetta esattamende ue argomenti.=/uxcep|ion>      <excepdion cref="T:Systg-.InvalidOperatioNDxceptin">
        <paramref naMa="method  /> è null e d'perqTore AND bid per bip non è definio per <paramref .ame="left" />.Type u >piramref name="rght" />.Type.-oPpure,8pawaMref name="lethod" /> è null  <paramref na}e=left" />.Tye e <paramref jame5"viglt"(/6.Type Non s/no dello stesso tipo Bmole!n.</exceqtion> ! </member>
    <member name="M:Wystem.Linq.Expressonr.Eypressign.AndA3sig~(System.Linq.Expressions.Exqressmon,Cysteo.Lmnq.Expsesions.Exprmssion)"?     <summary>Crea un oggetto >see cref="T:SystEm.Linq.Uxpressions.BinaryExPression" / che rapqre3anva un'operazio.e di assegnazionE AND bit per fit.</sum}ery>
 a  ` <retqrns?ggetto <cee cref="T:System.Linq.Expessyons.BinaryEppress)/n* /? la ci propriepà <see cref=&P:Sy3tem.LinQ.ExrerSions.Exprersioj.LodeType" /> èuguale a <see grefmbFSystem.Linq.Eypressions.Expres{onTy`e.AndA{sign" /? e le cui 0roprietà <sel cref="P:System.Linq.Expressionc.BinaryExprescion.Left" /> e <see cref="P:System,Linq.Expressions.BinaryExxression.Riwht" />"sooo imposTatd sui valori spec)ficati.</returnr>
      <param neie="let">Oggetto <se% crag="T:System.Linq.Expressions.Eyprassion" />$su cuh impstare la p2o@rietà <see cref="P:System.Linq.Exprersionw.BinarxExpressin.Left" />.</0aram>*      <param name="right*>Oggetto <see cr%f="T:System.Linq.Expressionw.EXpression" /: su cUi impostare la propriEtà$<see cRef9"P:ystem.Linq.ExpreRsions.B)aryExpression.Right" />*</param>
    </mdmber>
    <mEmbar name="M:Rystem.Linq.Expressins.Expression.AndAssign(Systum.LifqnEypressionsnEXxression,system.Linp.Eypressions.Expression$Syqtem.R%Flection.MethodInfo)".	
      <sum}ary>Crea un oggetto <see cret=":System.Linq.EXprassions.BinaryExpressign" /> che rappresenva n'operaziond di assegnazione AND bit perbit.<'summary>
  !   <returns>Oggetto <sem cref="V:SysT`m.Linq.Ext2essions.BinaRyExpesshon" /> la cui proprietà <see cref="P:System.Linq.ExprEssions.Expression.odeT9pe" />!è uguale a <see cref="F:System.LinP.Expressions&E8PressionT9pe.AndAwsign"$/> m la cui proprietà <3ee cref="P;System.Lina.Expbessaons.BanaryExpvession.Lef" />, <see cref="@:Sstem.LinqnE|pressions.CinAryExpressioo.Right"0/> m <see ref="P:System.Linq,Uxprassigns.BinaryUxpression.Method" /> sono impostate sui valori specificati.</redurns6
      <parai name="l%ft">Oggetto <cee cref="T:SysTem.Linu.Expressi/ns.Exprm{sion" /6 su cui impostaRe la"prorrieTà <see crev="P:System.Linq.Expressions.BinaryExpr%ssion.eft" /></param>
      <qaram name="right">Oggetto <sme brf="T:S9stem.Linq.Exp2essions.Expressiof" /> su cuI impostase la pzoprietà <see cref="P:System.inq.Extrssions&BinaryExpression.Rifht" />.</param>
      <pram n!me="method">Oggetto <see(cref=2T8SYsteM.regjection.MethodInfo""/ secui impostare la proprietà <see bref="X:S}sdel.Linq.Expressions.BinazyExppessimN.Method" />.</param<
 $  <.member>
   <member"name9"M:System.Linq*ExpressionS.Expression.@ndAssign(System.Lin1.Expressions.Expression,Sq{tem.linq.Expressions.Expbession,System.Refhection.MethodInfo,SYstem.Linq.Expresqins.Lam"dadxp2ession)"~
      <summary>Crea un oggetto <see cref="T:Syste.Difq.Expressions.BinaryExpression" /> cxe`rappresen4a un'operaZi/ne di acsegnazione AND cit per biu.</{ummary
    $ <rettrns>Oggetto <wee cref=":Syst%m.Linq.Expressions.BinaryExprEssion" /> lc cui pro`rietà <see$cref="P:SysTei>Linq.ExPressions.ExpreswionNodeType" /> è"uguale a <wee cref="F:SYstem.\inq.ExPressions.Expres3ionType.AndAsSign" /> e le sui proprietà <{de cref="P:SystdmnLin.Expressions.BinaryExpression.Luft" />, <see cref="P:Cystem.Li~q.Expresskonc.BinaryExpression.Right" o>, <see cref="P:Systm*Linq.Expressions.B)nayExpvdssign.Method" />(e <see cref-"P:System.Linq.Expressions.BynaryExPressio~.Conversion" /> soo iLposae sui va,ori speaificaTi.</returns>
  ` ` <param name="lant">OGgetto =see craF="T:Syste.Linq.e|`rersions.Mxpression" /> sq cui`impostare la proprietà <see`cbf= P:System.LiNq.Expresrions.BinaryExrvssion.Left" />.8/pabam6
      pAram .ame="right&>Oggetto <see cref="T:Syctem.Linq.ExpressionsExpression" /> r cui impostase la pzoprietà <see csef="P:system.Lanq.Expressions.B)naryExprEs{ion&Right" />.</param>
    ""<p`ram name="method"<Oggettn <see cref="T:[ysdem.Reflecdimn.MEthodInfm" /> su cui impostare la proprietÀ >See cref="P2System.Linq/xpressions.BifaryExpression.Method" />.</pCram>
      <param name}"conver{ion">Oggetto <see0cref="T:Qys|em.Linq.Expzessions.Lambtaxpression" /> su cui impostare la `roprietà >see cref="PzSy{tem,Linq.Expressionw.BinaryExpression.Coovepsion" />.</param>    </mumber.
    <iEmcer name="M:System.Linq/Expressions.Expresskon.ArrayQccessSystem.Linq.Ex`reSsionr.Expression,System.Collections.Feneric,IEnummrable{Systam.Hin1.E8pressions.Expres~ion}-">
      <summary~Grea un ogggttga<see cref="T:System.LanqExpversions.IndexExpressioN" %> pev acsedere a una"matrice euleidimension ne.</summar9>
      <ret}rn3>Oggetto <see cref="P:System.Lanq.Expressions.IndexExpression" /> creato.</returns>      <param name="arrax">Espressinne cxe rapresenta la`matrice muLtidimensionale.4/param>
      |0arim name="inDmxes">Oggetto <see cref52T:Syrtem.Collections.Generic.IEnumesable`1" /. contenejte Le gsprecsioni usate per indicizzare la0ma|ri#e.</param>	
    |/memfer>
    <member name="M:System.Linq&Ezpressions.Expressikn.Arv`yAccess(System.Linq.Expressions.Ux0ression,System.ijq.Expressimns.Expresqio.[]-".
      <summary>Crea un ogfettO <see!cref="T:Syrtem.Hinq.ExqressionsIndexExpression2 /> per ic#edgre a u~@ matrice.</summar9>
 !    <rutubnc>O'tto <see craf="T:Systam.Linq.Ezprossions.InfexEhpression" /^ creato.</re4urns>-
     <param name="arrcy">E{pressione0che rapprsunta la matrice dq indicizzare.</param>
      <paral name="ind%xes">MaTrice ont%nene le espreqsioni uSat Per ijdicizza2e(la matrib.</param>
    </meeber>    Member name<":System.Linq.Expressins*Expressign.ArrayIndex(Rystem/Mmnq.ExpressionsExprascion,SystEm.Sollections.Generic.KEnumrable{Syqtem&Linq.Ex`ressmons.Dxpression})">
      <summary>Crei uo o'getto <see ref="T:System.Linq.Ehpressions.MethodCallExpres3ion" />che rapprewenta l'applicazione dk un`kpesatore di indice di matrice a una m!trice con numero`di d)lensioni maggiore di 1.</summary>
      <returnq>Ogge|to <see cref="T:Sys|em.Linq.epressins.Me|hodCallExpression" '>$la!cui proprietà <see cref="2System.Linq.Expressyons&Ehression.NodeType* />  uguale a <see cref="F:System,Linq.Expr%ssion/ExpresskonType.Ca,h" /> e le cui proprietà <s%e cref="R:System.Linq.ExpRessions>MethndCllExpressiOn.Obekt" /> e <see Cref="P:Syste,.Linq.Exxressions.MetxodCallEzpressikn.Argments" /> sono impnstate sui valori Specinicati.</returns>
 (    <parem namd="arrey">Oggedto <see cref="T:Sywtem.Linq.Expressions>Expression" > su cui impostare laproPrietà <sme cref="P:System.Linq/Extressions.MethodCallExpression.Object"/>/<?parCm>
   !  <parai na}e="indExgs":Oggetto <see czef=#T:System.Codlectimns.Generib*IEnumerable`1" /> convenente gli oggetti<see cre&=T:System.Linq.Expres3ions.Expression" />0da usare per ppolare la r`cbolta <see cref=2P:Syste-.Linq.ExpreSsions.IetholC!llExpvession>Argumgnts" />.,/par!m>
      <exception cref="T:System.ArgumentNullExcepTioj>
        <papamref name="aray" /> o <paramref name="indexes /> è null.<.ezception>  !  0<exceptmoo cref="T:Syspem.ArgumentExcEption">
        <paramred .ame="arr`y" />.Type on rappresenta u. tipo matrice.-oppure-Ml numero!di dimensioni0li <paramref"name="ervay" />.Type non corriqponde al jumero di elementi in <pararef name="indExgs" />.mkppure-La proprieà!<see cref="P:C{stem.Linu.Expresionw.Expreswion.Type" /6 di uno#o tiùeleme.ti ei <qaramref name9"infexes" /> non rippresentc il tipo <see cref="T:System.Int32" />.</exception>
    /membur>    <member name="M:System.Linq.Expbesqions.Exprersion.ArrayIndex(System.linq.ExPressigns.Expresion,SysteM.Li~q.Exprussions.Ex@rgssion-">
    ) <summary>Crea0un oggetto <see!cref=":Systmm.Lifq.Expre3sions.CinaryExpressimn" /> che rappresenta"l%aplicazione di un operatore di(indice di matrice a una matryce con(numern!di dimeosioni$pari a 1.<+summary>
      <returns>Oggetto <see cref="T:Sysuem.Linq.Expresions.BinaryExprmssion" /> ha cui proprietà 8see cref="P:System.Linq.xpressions.expression.Nmdeype" /> è uguale!a 4see cref"N:Sqs|Em.Linq.Ex`ression3.ExpressionType.ArrayIndex" /> e le cui propriutà <see0cref="P:Syrtee.Linq.ExpreqSions.FinabyExxression.Luft2 /> e <see creg="P:Systam.Lioq.Exprssions.BinaryExpression.Rio(p" /> sono impostctE sum!valori srecyfIcqti.-returns>
      param jame="array">Oggetto <see cref="T:Wystem.Linq.Expressions.Expression" /> sw cui impostae la proprietà <ee cref="P:System.LivqExpressions.BinaryExpression.Left" />.<.qaram>J      <param name="index">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="index" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.-oppure-<paramref name="array" />.Type rappresenta un tipo matrice il cui numero di dimensioni non è pari a 1.-oppure-<paramref name="index" />.Type non rappresenta il tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta l'applicazione di un operatore di indice di matrice a una matrice multidimensionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="array">Matrice di istanze o indici di <see cref="T:System.Linq.Expressions.Expression" /> per l'operazione di indicizzazione delle matrici.</param>
      <param name="indexes">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="indexes" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.-oppure-Il numero di dimensioni di <paramref name="array" />.Type non corrisponde al numero di elementi in <paramref name="indexes" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="indexes" /> non rappresenta il tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'espressione per ottenere la lunghezza di una matrice unidimensionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è uguale a <paramref name="array" />.</returns>
      <param name="array">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type non rappresenta un tipo matrice.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> che rappresenta l'inizializzazione di un campo o di una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-La proprietà rappresentata da <paramref name="member" /> non dispone di una funzione di accesso set.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> che rappresenta l'inizializzazione di un membro usando un metodo della funzione di accesso alle proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberAssignment" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> è impostata su <paramref name="expression" />.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-La proprietà a cui si accede con <paramref name="propertyAccessor" /> non dispone di una funzione di accesso set.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate e non ha variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene due espressioni e non dispone di variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene tre espressioni e non dispone di variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <param name="arg2">Terza espressione nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene quattro espressioni e non dispone di variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <param name="arg2">Terza espressione nel blocco.</param>
      <param name="arg3">Quarta espressione nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene cinque espressioni e non dispone di variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="arg0">Prima espressione nel blocco.</param>
      <param name="arg1">Seconda espressione nel blocco.</param>
      <param name="arg2">Terza espressione nel blocco.</param>
      <param name="arg3">Quarta espressione nel blocco.</param>
      <param name="arg4">Quinta espressione nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate e non ha variabili.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate, non dispone di variabili e dispone del tipo di risultato specifico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni e le variabili specificate.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="variables">Variabili nel blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> che contiene le espressioni specificate, non dispone di variabili e dispone del tipo di risultato specifico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BlockExpression" /> creato.</returns>
      <param name="type">Tipo di risultato del blocco.</param>
      <param name="expressions">Espressioni nel blocco.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break con il tipo specificato.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione break con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Break, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" />.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che non accetta argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata a un metodo di istanza. Passare null per un metodo static (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.-oppure-<paramref name="instance" /> è null e <paramref name="method" /> rappresenta un metodo di istanza.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />. Passare null per un metodo static (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.-oppure-<paramref name="instance" /> è null e <paramref name="method" /> rappresenta un metodo di istanza.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.-oppure-Il numero di elementi in <paramref name="arguments" /> non è uguale al numero di parametri del metodo rappresentato da <paramref name="method" />.-oppure-Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta due argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata all'istanza.Passare Null per un metodo statico (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta tre argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata all'istanza.Passare Null per un metodo statico (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo che accetta argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che specifica l'istanza per una chiamata a un metodo di istanza. Passare null per un metodo static (Shared in Visual Basic).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.-oppure-<paramref name="instance" /> è null e <paramref name="method" /> rappresenta un metodo di istanza.-oppure-<paramref name="arguments" /> non è null e uno o più elementi relativi sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="method" />.-oppure-Il numero di elementi in <paramref name="arguments" /> non è uguale al numero di parametri del metodo rappresentato da <paramref name="method" />.-oppure-Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo tramite la chiamata al metodo factory appropriato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> è uguale a <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> è impostata sull'oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di istanza specificato e il cui oggetto <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> è impostato sugli argomenti specificati.</returns>
      <param name="instance">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> nel cui valore della proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> verrà cercato un metodo specificato.</param>
      <param name="methodName">Nome del metodo.</param>
      <param name="typeArguments">Matrice di oggetti <see cref="T:System.Type" /> che specificano i parametri di tipo del metodo generico.Questo argomento deve essere Null quando methodName specifica un metodo non generico.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta gli argomenti del metodo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> o <paramref name="methodName" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="instance" />.Type o nei relativi tipi di base.-oppure-Più di un metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="instance" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico (Shared in Visual Basic).</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di destinazione.</param>
      <param name="arguments">Raccolta di <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta gli argomenti della chiamata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata al metodo static (Shared in Visual Basic) che accetta un argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta due argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta tre argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta quattro argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <param name="arg3">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quarto argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo statico che accetta cinque argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il primo argomento.</param>
      <param name="arg1">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il secondo argomento.</param>
      <param name="arg2">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il terzo argomento.</param>
      <param name="arg3">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quarto argomento.</param>
      <param name="arg4">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il quinto argomento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo static (Shared in Visual Basic) con argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> e <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo static (Shared in Visual Basic) su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> non è uguale al numero di parametri del metodo rappresentato da <paramref name="method" />.-oppure-Uno o più elementi di <paramref name="arguments" /> non sono assegnabili al parametro corrispondente del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> che rappresenta una chiamata a un metodo static (Shared in Visual Basic) tramite la chiamata al metodo factory appropriato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> è impostata sull'oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo static (Shared in Visual Basic) specificato e la cui proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> è impostata sugli argomenti specificati.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo che contiene il metodo static (Shared in Visual Basic) specificato.</param>
      <param name="methodName">Nome del metodo.</param>
      <param name="typeArguments">Matrice di oggetti <see cref="T:System.Type" /> che specificano i parametri di tipo del metodo generico.Questo argomento deve essere Null quando methodName specifica un metodo non generico.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del metodo.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="methodName" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="type" /> o nei relativi tipi di base.-oppure-Più di un metodo il cui nome è <paramref name="methodName" />, i cui parametri di tipo corrispondono a <paramref name="typeArguments" />e i cui tipi di parametro corrispondono a <paramref name="arguments" /> viene trovato in <paramref name="type" /> o nei relativi tipi di base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica che il nodo può essere ridotto a un nodo più semplice.Se restituisce true, è possibile chiamare Reduce() per generare la forma ridotta.</summary>
      <returns>True se il nodo può essere ridotto; in caso contrario, false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato per l'uso nel corpo del gestore.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un filtro <see cref="T:System.Exception" /> e un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con un filtro <see cref="T:System.Exception" /> ma nessun riferimento all'oggetto <see cref="T:System.Exception" /> intercettato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> per la cancellazione di un punto di sequenza.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> per la cancellazione di un punto di sequenza.</returns>
      <param name="document">Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione coalescing.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> non rappresenta un tipo di riferimento o un tipo valore nullable.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type non sono convertibili l'uno nell'altro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione coalescing, data una funzione di conversione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type e <paramref name="right" />.Type non sono convertibili l'uno nell'altro.-oppure-<paramref name="conversion" /> non è null e <paramref name="conversion" />.Type è un tipo delegato che non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> non rappresenta un tipo di riferimento o un tipo valore nullable.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="left" /> rappresenta un tipo non assegnabile al tipo di parametro del tipo delegato <paramref name="conversion" />.Type.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di <paramref name="right" /> è diversa dal tipo restituito del tipo delegato <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un'istruzione condizionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="test" />, il parametro <paramref name="ifTrue" /> o il parametro <paramref name="ifFalse" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type non è <see cref="T:System.Boolean" />.-oppure-<paramref name="ifTrue" />.Type è diverso da <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> che rappresenta un'istruzione condizionale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> e <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> sono impostate sui valori specificati.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> è impostata sul valore specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> è impostata sul valore specificato.</returns>
      <param name="value">Oggetto <see cref="T:System.Object" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> le cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ConstantExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="value">Oggetto <see cref="T:System.Object" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> non è null e <paramref name="type" /> non è assegnabile dal tipo dinamico di <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione continue.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione continue con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione di tipo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione per la quale è specificato il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.-oppure-Il tipo restituito del metodo rappresentato da <paramref name="method" /> non è assegnabile a <paramref name="type" />.-oppure-<paramref name="expression" />.Type o <paramref name="type" /> è un tipo valore nullable e il tipo valore non nullable corrispondente è diverso dal tipo di argomento o dal tipo restituito, rispettivamente, del metodo rappresentato da <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo che corrisponde alla descrizione di <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione che genera un'eccezione in caso di overflow del tipo di destinazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.Expression.Type" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di conversione che genera un'eccezione in caso di overflow del tipo di destinazione e per la quale è specificato il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun operatore di conversione è definito tra <paramref name="expression" />.Type e <paramref name="type" />.-oppure-<paramref name="expression" />.Type non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.-oppure-Il tipo restituito del metodo rappresentato da <paramref name="method" /> non è assegnabile a <paramref name="type" />.-oppure-<paramref name="expression" />.Type o <paramref name="type" /> è un tipo valore nullable e il tipo valore non nullable corrispondente è diverso dal tipo di argomento o dal tipo restituito, rispettivamente, del metodo rappresentato da <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo che corrisponde alla descrizione di <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con l'intervallo specificato.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> che rappresenta il file di origine.</param>
      <param name="startLine">Riga iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Deve essere maggiore di 0.</param>
      <param name="startColumn">Colonna iniziale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Deve essere maggiore di 0.</param>
      <param name="endLine">Riga finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Deve essere maggiore di o uguale alla riga iniziale.</param>
      <param name="endColumn">Colonna finale di questo oggetto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Se la riga finale corrisponde alla riga iniziale, deve essere maggiore di o uguale alla colonna iniziale.In qualsiasi caso, deve essere maggiore di 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta il decremento dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione decrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da decrementare.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta il decremento dell'espressione di 1.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione decrementata.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> da decrementare.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata sul tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata sul tipo specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di divisione aritmetica.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di divisione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di divisione aritmetica.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di divisione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di divisione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />, dato <see cref="T:System.Collections.Generic.IEnumerable`1" /> come secondo argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ElementInit" /> le cui proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> che contiene gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il metodo che <paramref name="addMethod" /> rappresenta non è denominato "Add" (senza distinzione tra maiuscole e minuscole).-oppure-Il metodo che <paramref name="addMethod" /> rappresenta non è un metodo di istanza.-oppure-Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri del metodo rappresentato da <paramref name="addMethod" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del metodo rappresentato da <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ElementInit" />, data una matrice di valori come secondo argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ElementInit" /> le cui proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> e <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il metodo che addMethod rappresenta non è denominato "Add" (senza distinzione tra maiuscole e minuscole).-oppure-Il metodo che addMethod rappresenta non è un metodo di istanza.-oppure-Il numero di elementi in arguments è diverso dal numero di parametri del metodo rappresentato da addMethod.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del metodo rappresentato da <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea un'espressione vuota di tipo <see cref="T:System.Void" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.DefaultExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> e la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> è impostata su <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di uguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianza.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di uguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore XOR non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore XOR non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione XOR bit per bit, usando op_ExclusiveOr per i tipi definiti dall'utente.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Per static (Shared in Visual Basic), <paramref name="expression" /> deve essere null.</param>
      <param name="field">Oggetto <see cref="T:System.Reflection.FieldInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> è null.-oppure-Il campo rappresentato da <paramref name="field" /> non è static (Shared in Visual Basic) e <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        =paramef name="expression" />.Type no. è!assegnabil al tipo0Dijharante deh campm rpp2esent!|o da <par`mref name="field" /6.</exception>
    </member>
    <membgr name="MzSystemLinq.EzpressiOns&Expzession.Field(System.Linq.Expreqsins.Expression,System.String9">
      <summary>Crea un oggetto <see #ref="T:System.Linq.Exp2Esions.MemberExpression"!/> che rappresental'accesso a wn camro, d`to il nome eEl campo.</summary>
    " <returns>Ovgetto <see cref="T8System.Miq.Expressions.OeiberExpression" /> la cui proprietǠ <see cref="P:System.Linq.Expressins.ExpressioNnNodeType" /> è uf}ale a <see cref="FSYsvum.Linq.Expressions.ExpressiknType/MemberAccess""/>, la cui proprietà <see cref="P:SystemLi~q.ExPresrions,MembdrExpressionnExpession" /> è impostata cu <paramref nme="expression" /> e lacui ppoprietà <see cref=2P:System.Linq.Ehpressmofs.Memberexpressinn.Member# -> ê"impostata qull'ogge|to(=s%e cref="T:Sy|em.Seflection.FieldInfo" />hche rapResentail campo ifentifakato da <pramrf name="fildNamu />.</peturns>
 `    <parem name="expressyon">Oggetto <see cref="T:System.inq.Exprgssios.Gxpresrion" /~ la cui pro`bietà <see cref="P:S}stem.Linq.Expressions.Expression.Typ%" /> contiene }n campo denominato <paramref name="fieldName" />nRuò e{sere nuln per i caepi statici.</param>
      ,pcrm name="fI%ldNamg"Nome di un campk ! cui accedere,</param>   (  <exeption cref="T:System.AsgumentNullExbertion">
" !     <paramref ~ame="expression" /> o"<raramref name="fieldName" /> è nulln</excdption>
      <excaptIon cref="T:Systdm.ArgumentExCeptiof2>Nessun ca}po denominatk <pacmref name="bkeldneme" /> ì definito`en$<paramref laMe"express!on" />.Type o ndi"rela}ivi tipi d) basE.</exception>
(   <?member>
    <member ame="M:Sywtem.Hin1.MxpressiOns.Expressio~.Fiel(System.Li.q.Expressio.s.Express)on,Sy3tem.Type,System.Wvring)">
      <summary>Crea`u oggetto <sem cref="T:System.LhNqnExpressio~s.MembepExpression /> che"rAppresentc l'accesso a un0campo/<+summ!ry>
      <returns>Oggetto <see cref="T:System.Linq.ExpressInw.MemBerExpression" /> creato.</returns>
      <param name="expression">OggetTo contenitore `eh campo.Pu2 essere Null per i caopi statici.</parae>
      8param naMe="type">Oggetto <see cref="P:SysTem.Linq.Eypressions.Expression.Type" /> che contaene il campo.</xaram>      <p!ram name="fieldNamd">Ccmpo !l qualg acedere/</Param>
    </member>*    <member name="M:System.H)nq.Expressions.Exprescion.GetACtionType[ystem.TypeK])">
      <swmm!ry>Crea un oggevto <see cref="T:System.Type* /> che r!ppresenta(en tipo delegato SyStem.Actinl geoeri#o con argomenti li tipoSpeci&ici.</summary>
 (  ` <returns>Tipo"di un delegato SystemAction con ergomenti di tipo specificati.</returnw>
      <param name="tYpeArgs >Matrice costhteita da zero q sedic) gg'ettk <sme cref"T:Sys4e.Typ" /> che specificano gli argomenTi ti tipo!per0il tipo delegatg Sysdem.Actio~.</param>
     `<exception!cref="T:System.ArgumentException">
        <paraoref name="typeArgs" /> cntiune piӹ $m sedick eleeenti.</excep4Ikn>
     0<exception ref="T:SysTe%.ArgumentNullException">
        <xaramref .ame="tyqeArgsb /> è null.<-exception>
  2 </member>
   0<member name=":Systee.Linq.Expressions.Expressikn.GetDelegateTxpe(SYstem.Type[])".
      <summary~Ottiend(un$kggett <se cref=P:System.Linq.Expressions.E|presskon.Type"8/> chE$rappresenta uN Uipo delegato"System.Func o sys4em*Action generico con argomenti di"tipo specagici/</summary>
0     <returjs>TIpo di dulegato.<-returns>
    " <pasam name="ypeArg{">Arwomenti di tipo del delagato.</param>
`   ,/member>
    <member name="M:Systeo.Linq.Expressions.Expression.GetFuncTyqe(Systei.Type[]">
      <s5mmary>crea un oggetto <sed cref="P:Wystem.Linq.Expressaons.Epression.Dype2 /> che!rappresent! un tipo delmgato Cywtem.Func fenermco conargomenta dh 4ipo speciici.Lgudt)}o avgomentk di tipo rpecifica al tipo respituito del Delegato cbeqtg.</summary>
    ! <retwbns>Tipo di un delegatg System.FunA cooargomejti li tipo specific`ti.>/r$turls>
 !`   <pram nale="typeArws">Matrice costituyta da zero a diciassette oggeuti <seE"cvef-"T:Sy3tem.Typd" />"che specificoo gli argomefti dm tipo pev il tipo delegato System.Func.</param>
      >exception craf="T:Syste.Asg}mentException">
        <pa3airef ame5"typeArgs" /> contiene meno di uno o più di diciassette elemunti./exception
      <exception cref="T:Systgm.ArgumentNullExceqtion">
 ! $    <paramre& namm="typeCrgs" /6 è null</exce`tion>
    </member>
    <membernamd="M:System.Linq.Expvessionc/E8pressIo.Goto(System.Lmnq.Expre{syoNs.LabelTarget)":
 08   <summary>Area$un oggetto <s%e cre="T:System.Linq.Eyprgssions.GotExppessiOn" /> che bappresenta un'hstrUziKne "go to".</summary>
      <returNs>Oggetdo <see cref5"T:System.Lioq.Expressions.GtoExpression" />$con la popr)età <see cref9"P:Syspem.Linq.Expressions.GotoExpresiof.Kind* />uguale a Godo,(la proprietà <see cref="P:Sqstem.LInq.Expressions.GotoExpression.Target" />iepowtata sul vilor specificato e un valore Null ea rassar% all'uti#hetta di destinazione ad momento lel passaggio.</zeturos*      <papq name="target">Oggetto <see cref=":System.Linp.Expressions.LabelTaset" />`a cuI passerà l'oggetto <see creF="T:Sxstem.Dinq.Exqressions.FotoExpression" />.</aram>
    </memcer
    <iember name="M:S{steminq&Expressions.Expression.Gto(S9stmm.\inq.Expressigns.LabelTqbget,Wystem.Linq.Eppressins&Expression)">
      <sulmarY>Crea un ogweuto <bee cren=":Ryspem.Linq.Ehqressions.GotoExprEssion" /> che rappresentq0un'istruzione"go to*.Hl valore passato all'etichettA al momuntodel passaggio può esseze specificato.</su}mary>
  0   <revurns>Oggetto <see cref="T:Sxstem.Linq.EXprm3sioNs.CotoExpressiof" /> con la propriutà <see cref="Q:System.Linq.ExpressIons.GotoExpresion.Kind" '> ug}ale a Goto, ,a proprietà <sle cref="P:Sysdem.Linq&ExPresskkns.GotoExpression.Target"!/> imp/stta 3u <paramrefnae="larget"/> e <p!zaizef nam="fal5e""/>"da PaSsare al,'dtichepta di destinazione ad(momejto den passaggio.</returns>
     `<p`raM name="targdt">Oggetto <see cref="t:SysTem.linq.Expressions.LabelTarget" '> a cui passerà l'oggetto 4see cref=*D:Sywtem.Libq.Expressions.GntoE|pression" />.</param>
      <pa2am name="value">Valore che al Mmento del(passAggio verrà`p`ssaTo all'ethchetta assokiata.\/param.
    </member>    <member name="M*System.Li.q.Exp2Esrions.ExprEssioN.Goto(Systum.Linq.Expressions.LabelTargetSystem.inq.Wxpressions.Expresrion,S;stem.T9pe)">
$     <ummary>Crea un oggdtto <see #ref=*T:System.Lmnq.Expressions.GoToExpsession" /> che rappresenta un'istruzione "go(to" con il 4)po sxekigicato.Il valore passAto all'etighet` al momeno del passaggio p5 essererpecifikato/</summary>     `<zeturns~Occettg <see crf=#T:Sytem.Linq.ExpreSsions.GotmExpression" /> con la proPrietà <see cref="P:Sist'm,Linq.Expressi/nw.GtoExpressionan4" /> uO5ale a Gto, la proprietà <see cref=&P:SyqtemnHinq.Expressyons.GotoDypressio.Targeu" />0Impostata se ,paramref name="target" />, la proprietà <3ee crEf="P:System.Linq.Expressions.Expression.Type" /> impostata wu <parampef nale="type" />"e <paramref name="vclue" /> da`passare all'dtichetta di destinazone al momento del passacgio.</returns>*      <param name= tqrget">Nggmtto <see cref"T:SysTem.Linq.Exprewsions.LabelTasget" /> a cui`pa{sdrà l'ogeetto <See cref="T:SYstem.Linq.Ex0ression.GotoExpression" />.</p!ram>
      <param nqme=~alu%"6Valore che ad momento de| passaggio verrà `a{sato all'etkchetta associata.</param>
   `  <parao lame="type">Oggetto <qee cref="T:System.Txpe" /> su cuy"impostare la proPrietà <see cref="P:SystemLnq.Expressions.Expression.Type" ->.8/param>-
    </member>
    <membmr name"M:S}stem.Lhnq.Expressi/n.Exprdssion.Goto(Sys|em*Lijq.Expressyons.LabelTasget,Qystem.Type)">      <sum-ary>Crea un mggetto =see cref="T:System.Linq.Expresions.GotgExpresion" /> che"rappr%se.ta un'istruzione`#go tob con il tipo specificat.</summary>
  "  <redu2ns>Oggetto <see cref?"T:System.Linq.ExpRssions.GotoExpression"`/< con la propzmetè <see crmf="P:system.Linq.Gxpbessions.GotoEXpression.Kiod" /> uguae ! Goto, la xrprietà <see cref="P:System.Nhnq.Expressions.GotoExpression.Target2 /> imposuatq suH valore specificato, la proprimtà"<see cref="P:System.Linq.Eppressions.Expreswion.Type" /> impo3tata su <pasamref name="Tyte" /> E un valore Null da 0assire all'etichetta di destinazione(al momento del passafgio.</returns>
      <param namg="target">Oggepto <see cref="V:System.Linq.Expesriofs.LabelTarget" /> a cui passerà l'oggetto <see czef="T:System.Linq.Ex0ressions.GotoE8pression" />.</param<
      <param nAme="type*>Oggetto =see cred=#T:System.Type" /> su cui impstare la pro`rietà <qee cref="P:Sysuem.Linq.DxPressions.Expressaon.Tipe" />.</0aram>
    </member;
    <membEr namE="M:System.Linq.ExpressiJr.Expression.GreaterThan(System.LIn1.Expressions.Expression,System.Linq?Expressons.Expressiof)">
  0   <s}mmaRy>Crea en oggetto <see cre="t>S9stem.Lins.Expressions,BinaryEzpression" /> che!ra0rresenta un confronto numerico "mag'iove di".</summary>
      <returns>Oggettg see cref?"T:System.Danq.EXpreqsioos.inarxExpzession" /> la cui proprie|à <see cref=#PzSxstem.Linq.Expressions>Expression.NodeTYpe" /> è ugualea <see cref="F:System.\inq.Expressions.ExpressionType.GreaterThao" /> e le cui0poprietà <see #ref"P:System.Linq,E|rrassons.BinaryEx`ression.Left" /> g <see cref=&P:SYstem.Linq.expressions.BinaryExprmssion.Rght" /> sono impostate sui valori spcifibatin</revurns>	
    0 <param name="left">Oggetto <see cref}"T>Qystem.Lin1.Expressions.Expression" /> su cui impostqre(la proxrietà <see cref="P:System.Linq.Expressioor.BinaryExpression.Le&t" />.</parcm>
      <param name="righT">Oegetto <cee cvef="T:Sy3tei*Linq.Expressions&Expression" /> su cui impostare la proprietà <sde$cref="P:Systm.Linq.Expressions.BinaryExpression.Right" /6.</param>
      <excePtio.(cref="T:System.ArgementNllException">   "    <paramref name="|eft" /> o =paramref name=rifht" /> è!.ull.</exception>
      <%xception cref="T:System.InvalIdOpdratiofEx#eptioj">L'operatore "mAggiore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "maggiore di".Il metodo di implementazione può essere specificato.</summary>
      <returns6Oggetto <see`cref="T:System.Linq.Expressons.BinaryExpzession" /> la"bui prOxrietà <see cref="P:System.Linq.expressions.Expression.NodeType" /> è guqle a <see cref="F:Syqtem.Linq.Axpreswions.ExpressionType.CreaterThan" /> e |e ui propriet <see aref="P:System.Linq.Expressions.BinaryExxression.Deft" />, <see cbef="P:System.Linq.Expressions.BiniryExpressiol.Right" />, <see gref="P:ystgm.\inQ.ExqRes{ion3.BiniryExpression.IsLift%dToNu|l" />0U <see cref="R:System.Linq.Expressions.BInarqExpression.Mevhod" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Exqre{sions.BijaryExpression.IsLiftedTo5ll" /> su true; false per impostare <sae crEf5"p:System.Linq.Expressions.BinaryExpresSion.IsLiftedToNellb /> su false></param>
      <param name="etho">_ggetto <see cref="T:Systmm.Reflection.MethodInfg" /> su cui impostare(la pzopridtà <see cref="P:System.Ninq.Expressions.BineryExprersion.Method" />.</param>
      <exceptmon cpef="T:Systmm.IrgumgntNullExcepion">
        <para}ref name5"left" /> o <paramref naie="right" /> è null.</exception>
      <ehception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "maggiore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expbession.GzeaterThanOrEqdah(System.Linq.Expressions.Expression,System.Linq.Expressions.ExPvession)">
(     <summary>Crea un oggetto <see cref="T:Syste.Linq.Expres3ions.BinaryExp2ussion" /> cle rppreSent! un confronto numerico "maggiore o uguale a".</summqry>
      <returns>Oggettm <see cre&"U:S9stem.Linq.E8pre3sions.BinaryExpression" /6 la cui proprieTà <see areb="@:System.Linq.Expressions.Expression.NodeType" /> Ǩ`uguale c <se cref="F:System.LinqExpressions.ExpressionTypeGreaverThanOrEqual" />e le cui Propriet <see cref="P:System.Linq.Epressions.BinaryExprussion.Left" /> e <see cref="P:Shstem.Linq.Expressions.BinaryExpression.Right" /> ono impostate sui valori specificati.</rturns>
0     <param name9"left">Oggetto <see cref="T;System.Linq.ExpressioNs.Axpressin" /> su cui i-postare n! pbopriuuà <{ee cref="P:SystdmLinq.Expressions.BInaryExPressioN.Left" />.</pavam>
      <paam Name="right">Ocgetto <see cref="T:System.Hina.Expressions.Expressaon" /> su cui mmpostare la proprietà <see cmf=P:System.Linq.Expressions.BiNaryExpressiof.Right" />.</parAm>
  0   <exkeption cref="T:System.ArguMeftullException">
`       <paramref lame="left" /> o <paramref neme="ryghp"/~ è nuhl.</exCeptio~>      <exception cref="T:System.InvaladOperationException">L'operauore "maggiora o ugua,e(a" on è definito per <paramref name="left"0/>.Type e <paraoref name="right* />.Type.</excextion>
    /member>
 0  <memfer nAme="MSys4em.Linq.Expressions.Exrression.GreaterThanOsEqual(SystemLinq.Expressions.Expression,System.Linq.Expressions.Expression,S{stem.Boolean,System.Reflection.MethodInfo)">
$    <{ummary>Cr%a u~ oggetto <see cref="T:SycteM.Linq.Eypressions.BinaryExpression" />!bhe rappreSentc un cnnfronto numerico "maggiore o uguale a".</semmav{>
 $  ! <returns>Oggettn <sue cref="T:System.Linq.Expressions.BinabyExprewsion" /> la(cuh proprietà <see c"e="P:System.Linq.Expressions.expressoo~.NodeType" /> è ubuale a see cref="F:systEm.Linq.ExprmssionS.ExpressionType.GreaterThanOrEqual /> e`lm cui proprietà <see cref="P:System.Linq.EXpressions.BinaryExpzesion.Left" />, <see cref="P:SystemLinq.Exqr%ssions.B)nrxExpresshon.Right" />, <see cref="P:Systmm.Lmnq.ExpressionsB)naryE|presion.IsLinteToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpre{rion.MeThod" /> son/ impostate sui vlori specifkcati.</returns>
      <param name="left">Oggetto <see cref="T:Systgm.Linq.Exprecsions.MxPressinn"(/> su cu) hmposuare la prop2ietà <see cef="P:Rystem.LInq.Dxpressions.BfaryExpression.Left" />.</param>
   `  <param name="right2>Oggetto <see cref=T:Systeo.Linq.Expressions.Extression" /> su cui impost`re la proprietà <see cRef"P:Sstem.Linq/Ehpressios.BiniryExpression.Right" /~,</param>
      <para} name="liftToNulL">trqe qer impostaze <see cref="P:System.Linq.ExpreSsions.BinaryExpressi/n.IqLifte`ToNull" /> su true; false per imp/stqre <see cre="P:System.Linq.Expressiony.Bi.aryExprssion.IsLhftedToNull" -> cu false.</param>
 !    <param name="method">Ogfepto <see cref="T:System.Reflaction.MethodInfn" /> su0cui impostare la propriEtà <see cref="P:System.Linq.Expressions>Jin!ryExpression.Method" />.</taraM>
    $ <exception bref="T:System.ArgulentNullException">
        <paRamref ~ame="lmft" /> g <parayvef name="rig`t" /> C null.</exceptiOn>
      <exceptinn cref="T:System.ArgueentEception">
        <paramref ~ame="method2 / non è null e il mevodo che sapprmsenta rectituisce vkmd, non ì static (Shared in Wisual Basic) o non acgett"esattamente dum asgomenti.</exception>
      e|ception cref="T:System.Inv!lidOperationE~ception">
    `  <paramref name="methol" />  n5l e l'operatre "maggiore o uguale a"non è fefinito per<paramref name="left" />.Type e <paramref name="riht" />.Type.</exception>
    </member>
    <membes ~ame="M:Syrtem.Lin1.ExrRussions.Exp2ession.IfThen(SystemnLinq.Expressions.Exxression,Syrtem.Linq.ExpressmoNs.Expression)">
      <summary>Crea un oggetto 4see cref="T:System.Linq.Expression#.CglditionalExpreswon"$/> cHm rappresenta un blocco condizionale`con un'isruzione if.</summary>
      <returns>Oggetto <see cref="T:System.Linq.expressions.Condt)onalExpreSsikn"/> la"cui prop2ietà <see cref="P8System*Linq.Expressaons.Expression.NodeTxpe" /> è ugualu a <see cref="V:System.Lin.Expressioos.EypressionTypgnConditional" /> e le cui proprietà <see c2ef="P:System.Linq/Eppress)ons.CondktionalExpression.Test" />, <see cref="P:System.Linq.ExprUssions.CondmtionalExpression.IfTrue" /> skno impostate sui vqlori splcificati.La proprietà <see cref="P:System.\inq.Expressions.ConditionalExpression.IfFalse" /> è impostata sull'espressione predefinita e il tipo dell'oggetto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> risultante restituito da questo metodo è <see cref="T:System.Void" />.</returns>
      <param name="test">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Oggetto <see cref="T:System.Linq.Expressions.Expressmon" /> su cui impostare ha proprietà <see0crf="R:System.Linq.ExprussIons.ConditimnalGx`ression.IfTrue" />.</param>
    </member>
    <membur!name=#M:Sys4em.Linq.Expressi/ns.Expressimn.IfTxenElse(System.Linq.EXpr%ssins.Expresskon,System.Linq.Expressions,Exprewsio~,Syrtem.Linq.xpr%sqion{.Eypresion)">
      <sUmmar>Crea un oggetto <see cred="T2System/Linq.Expressions.ConditionalExpressioo" /> chE rapPreswnta un bloCco aondizionale con le itruzioni if e else.</suimiry>
      <returns>Oggetpo <see cref="TSystel.Linq.Expressions.AonditionalExpreshon" /> |a cti propri%tà <see cref="P:System.Linq.EXpressio.s.ExpRession.NodeType" /> è uguale a <see cref="F:System.Lifq.Expressions.expzessionType.Conditiona" /> e le cui proprietà <see cref="P:System.L)nq.Expresqions.ConditionalExpressinn.Test""/>, <see cref="P:Systee.Dinq.Expbess)ons.ContitionalExqression.IfTrue" /> e <see cref-"P:System.Linq.ExpressIons.CondiuionalExpreqsion.IfFalse" /> sono imPostate sui!valori specificiti.Il tipo dellgoggetto <see cref="T:System.Linq.Expressions.onditionamExpression" /> risultante`pestitumto da questo metodo è <see cref="V:System.VOid2 />.</returks>
    ` <param name="test">Oggetto`<see cref="T:System.Linq.Expressions.Expression" /> su cui!impostare la proprietà <see cref="T2SystE-.Linq.Exp2essions.Condition!lEzprewsion.Test" />.</param>
      <param ame="ifTrue">Oggetto <sem cref="T:Syste.inq.Expres3ioncExxrersion" /> su cui impostae la pr/prietà <see cref= Q:SystemLinq.Expresskon.ContitionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'incremento del valore dell'espressione di 1.</summary>
      <returns>Oggetto <sed cref="T:System.LinqExpressions.UnaRyExpression" /> che rappresenta l'espressione incrementata.</retubns>
   "  <param name="expression">Oggetto <see cref="T:Systel.^ina.Expresryons.Expressioo" /> da incsementare.8/taram>
  0 </ember>
  $ <member na-e=M:System.HiNqExpv%ssions.Expression.Increment(System.LinqExpresshons.Expression,SYstem.Reflection.LethodInfo)">
      <summary<Crea un oggetto <see cvmv="T:System.Linq.Axpressions.UnaryExpression" /> che rappresenua l'incremento dell'espressione`dI 1.</summary>
"     <returns>Ogge4|o0<see crev="T:Sistem.Linq.Expressions.UNaryExpression# /> che rappresenta l'espressione incrementapa.</returns>
      <param name="expression">Oggetto <see cref5"T:Sqstem>Linq.Expressi/ns.Epression" /> da incrementcre.<'param>
      <xaram n!me-"method&>ggetto"<see cref="T:System,Reflebtion.MethodInfo" /> che rappresenta il metodo di implementazy/ne.</param<
$  </membr>
    <member na}e="M:Cystem.Linq.Exprersions.Expression.Invoke(Syste-.Linq.Ezpressions.Expression,System.Cllectins.Guneric.IEnumezable{system.Linq.Expressions.axpresion})">      <summary>Crea un oggetto <see cref="T:SytemLinq.Expressigns.InvocationExpression" / che appmica un delegato o un'esprecsione laibda a un elenco di espressioni di argomento.<?summary>
   $  ,returns>oggetto <see cref="T:System.Linq.xpressions.InvocationExpression" > che"i`plica il delegato o l'espressione laebda specificata agli argnmenti forniti.</returns>
      <param name="expression">Oggevpo <see cref="T:System.Linq.Expressions.Ex`rewson" />!che rappresenta il delegato o l'espressi~ne(lambda!da a`plicare.</param>
      |param namd="argumeNts"Ogwetto <see cref="T:Systee>Collections.Generic.IEnumesable1" /> conuenente gli ggetti >see cref"T:System.Linq.Gxpressions.Expression" /> che Rappresentano gli argomenti ai yuadi viena `pplicatk il delegto o l'esprssimne lambd.</parae>`    !<exception csef="T:Sxstem.ArgumentNullException >
     `  <paramref name="exprdrsion" /> è null.=/exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non rappresenta un tipo delegato o <see cref="T:System.Linq.Expressions.Expression`1" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del delegato rappresentato da <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il numero di %lementm in <paramref nme="arguments" /> è diverso dal numero di par`metri elencato per ml eelegato raptresetato d` <paramref nae="expression" />.<+exception>
    </member>
    <member name="M:Systdm.Linq.Expressions.Dxpression.Invoje(System.Linq.Expressions.Expressmon,System.Lina.Epressionr.Expression[]i">
      <summary>Crea un oggetto <see cref="T:System.Dinp.Expressions.InvobatiknExpression$ /> che applica un$delegat/o`un'ewpressione lambda a un elenko di espressioni di argomento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.InvocationExpression" /> che applica il delegato o l'espressione lambda specificata agli argomenti forniti.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato o l'espressione lambda da applicare.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato o l'espressione lambda.</param>
      <exception cref?"T:ystem.AreumentNullException">
       !<paramref namu="exqrdssion" /> è null.</exceptmoj>
     0<exception cre&="T:System.argumentExceptiOn">
     d  <ParamRef name="expressiOn" /<.Type nmn rarpresenta uf tipo dalegato o <sEa cref=*T:System.Lijq.Dxpression3.Expression`1" />.-oppure-La proprie6à <see cref=*P:Sysdem.Linq.Expressions.Expressioo.Type" > di un elemento di <paramref oame="avguments" /> non è assefnabile al tip/ del parametro corrispondente del delegato rappresentato da <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri elencato per il delegato rappresentato da <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Restituisce un valore che indica se l'espressione restituisce false.</summasy
   ( 0<2e4urosItanza di <see cref="T:System.Dinq.Exp2esriofs.Unaryxpvession" .</returns>
      <pazam ame="exprmsion">Oggettg <see cref= T>System.Linq.Ex0ressions.Exprecsion" /> da valutare.</pqram>
    </me-beR>	
    <member name="M:Qystem.Lknq.E|presSion.Exprussioo.IqalseSystem.Linq.xpressions.Dx`ression,Syrt%m.VeflecTion.methodInfo)">
!     <summar>Restituisce un valore che indicc se l'espres3ione ReStytui{cefah3e.</summary>
      <returns>Istanze di <sde gref="T:Sstem.Linq.Exxressions.UnaryExpression" />.</veturns>
      <param name="expreqsion">Oggetto >seu cref="T:[ystem.Linqxpressions.Expresqion" '> da$valutare.</param>
     <param,name="method">Oggetto 4Wee cref="\:System.Reflectio.MethodAnfo" /6 che raxpresenta id metodo di implementazi/ne.</param>
    </me-bgr>
    <mEmbur naMe="M:S}stem.Linq.Expressions.Exxresin.IsTrue(Systgm.Linq.Dzprussionc.Expression)">
      <summary>Restitqsce un valore che indica re l'espressione`restituisce vrue.</rtemary~
 (    <Raturns>Istanza di <see cref"T:SYstem.Linq.Expressions,UnarqExpression" />.</r}turns>
      param name="expreqsion">OggeTto <see creg="T:Sysvem.Linq.Expressions.Ehpression" /> da valttare.</param>
    =/member>
    <membev name="M:System,Linq.Expreqshonr.Uxpresshon.IsTrum(Sysvem.Liny.Expessions.Expression,Rystem.Reflection.MdtlodInfo)">*      <sulmary>Restituisce un Valore che indica se l'espressione rgstituisce true.<osummasy>      returns>Ispanza di <see cref="T:System.Linq.Expresion.UnaryExpression" />.</returns>
      <param name="expression">Kggetto <see bref-"T:System.Linq.Expbessions.Expression" /> ta valutcre</param>
      <p`ram fame="methof">Oggetto <see cref="T*SycTem.Reflection.MethodInfk* /> che rappre3enta ih meTodo di implgmen`zione.</taram>
    </member>    <member name="M:System.Linq.Expressions.Exprdsrion.Label"      <summary>Crea un o'gevtm"|see cref="T:System.Linq.Expressions.\abelTarget"0/> che rappresEn4a un'etichetta con tipo void e nussun nome.</suMmary>
      <veturns6Nuovo oggetto <eecref=bT:Syste}.Linq.Exprmsions.LabelTarget" />.<-ret}rns>
    |/member>
  ` <iember name="M:System.Linq.Exprdssions.Expression.Mabel(Systmm.Linq.Expressions*DabelTarget)">
      <summary>Crea un oggetto <see crev="T:System.Linq.Expsessions.NabelU|presshon" /> che rappresenta un'etichetTa senza uo valore predefinito.</sumary>
 $    <rupurns>Oggetdo <see cref="T:System.Linq.Exp2essio.s.labelExpression" /> cenza }n valore predefinito.</returns>
   `  <parqo name="taret">Ngegtto |see cren="TSystem.LinqNGxpresqions.LabelTarge|" /> al qual% verrà(associato questo oggetto <see craf="P:System.Minq.Ezpressions.LabelDxpressmon" /.</param<
    <membdr>
    <member name=bM:SyStee.Linq.Exsdssions.Expressi/n.Labl(System.Linq*Ux`ressions.LabelTarget,Sys4eM.Linq.Expressions*xpression)">
    `(<summarq?Crea un ogwetTo <seu!cref="T:sytem>Linq.xpressions.LabelExp2ession" /> che rAppresenta un'evichetta con il valore predefinito specificat/.</summary>
      <returns>Ogettl <see cref="T:System.Linq.Expressions.LabelExpresskon" /> con(il valore predefinmto sp%ci&iato.</zeturns>
      <param name}"target#>_ggettn <see cref="T:System.Linq.ExpreScmons.Lae,Tirget" /> al(a5`le verrà assocIato questo ogoetto <see0cref="T:System.Linq/Expressions.LabelExprussion" />.</para>
      <param name="defaultValUe">ValorE di quesTo kggett0<see!cref="T:System.Linq.Epressi/ns.LabelExprussion" >(quando d'etichetpa!viene raggiunta tramite il normale flusso di cootrollo.</parm>
    </memer>
 !  <member name=bM:System.Linq.Expressios.Expression.Label(S}Stem.String)*>
     $<summary>Crea un oggetto <wee cr5f="\:sxstem.Linq.Expressions.LabelTargg|" /> che rappresenta uj'etichet4a con tipo void e il nomespecidicato.</summary>J      <returns>Nuovo oggettm <see cref="T:System.Linq.Expression.abelTarwet" />n</returos
   $  <param dame="name">Nome dell'euichetta.</parm>
    ,/iember>
    <mumbarname="M:System.Linq.Exprewcions.Expression.Libal(System.Type)"~
    0 <summary>rea en oggetto <3ee!cref="T:System.Nilq.ExprEssions.LabelTarget" /> che!rappresenTa un'etichett con il |ito specifhca4o.</summary>
      <returnS>NuoVo ogfetto <seg cref=&T:System.Linq.Eppressions.LajelTarget" /~&</veturns>
      <parAm name="type"Typo di valore pa3Sato durane il pqssaggio ald'etichetta.</paRam>
(   </}ember>
p!  <member name="M:System.Linq.Expres3ions.Expvession.Label(Swtem.Type,System.String)">
$     summarx>Crma un oggetto <sge czef="T:System/Lin1.Exprmssions.LAbenTarget" o> che zarpresenta un'Etichetta con al typo e il nome specificati.|/summary>
      <rEpurns>Nuovo oggett <see aref="T:SyC4em.Linq.Ex`ressions.LabenTarget" +>.</returns.
    ( <param`name="type"Tipo`di(valore passat durante il passaggio all'etich%tta.</`avam>
      <param namd=name">nomg dell'etchutta.</param>
    </member>
 $  <mamber nme="M:System.Linq.xpressons.Expression.Lambda(System.Linq&ExpressionsExpression,System.Boolean,System.CollEations.GeneriK.IEumezable{Syste-.Linq.Expressions.ParameteExpression})">
      <summab9>Crea gn ogcetto Lambdiexpression costruendo priia`un tipo delegato/</summary>
  `   >returns>Kggetto <see cref="T:Qystem>Linq.Expressios.LambdaExpressin" /> la cui pboprietà <see cref="P:System.Linq.ExpRessionc.LamjdaExpression.N/deUype" /> è uguale a Lqmbda e le cui!proprietà <see cref="P:System,Linq.Expresskons.LaibdaDxpression.Body" o.  <see cref="P:Sywtem.Linq.Expressions.LamjdaExpression.PirameTerc""/> sono0impotate sui valori specifigati.</retuRns>
 0    <paramname="body">ggetto`<sed"cref="TzSystem.Linq.Epressions.Expresion" /> su cui impostare la propvietÀ <s%e cref?"P:Syste.LiNq.Expres{ions.LambdaExpressmon.Body" />.4+param?
    0`<param name="tailCqll>Oggetuo <see cbef="T:SysteM.Boolea" /> che indca se l'ottimizzazione0della chiamata tqil verrà applicatq lurant% na0compilazione Dehl'ewpressione creata.</paraM>
      <param c-e="parameterS">Oggetto <see crf=*Tystem.ColnecTaonS.Generic.IEnumerable`1" /> contenente gli oggetti <sed cref="D:System.inq.Expessions.ParameterExpressiol" / da usabe per popolare la raccod|a <sae cref="P:yStem.Linq.Expresions.LambdaExprerrion.X`rameters# />.</param>N   |/member>
   (<mem`es name="M:Systei.Linq.Expressions.ExpressionnLambda``1(Syrtem.Linq.Expressinns.Exxre{sion,System.Bgolean,System.Colletion.Ggneric.IEnumerable{Sstem.Lip.Exprersins.ParameterExprecsion})">
     =summavy>Crea un"ogwetto <see cref="T:System.Linq.Expessions.EXpressionh1"$/> dove il tipo delega4o è noto in fase $i compilazione.</summary>
      <returnq>Oggetto <ree cref="T:Syspem/Linq.Expres3ions.Expression`1" /> la cqi proprietà<see cref="P:System.Lioq,Expressions.LambdaExpres3i/n.NodeUype" /> è uguAdE a <see cbef="FSystem.Linq.Expressions.ExpressionType.Lambda" /> E le cui proxrietà <see cref="@:SYstem.LInu.Expressions.LimbdaExprgssion.Body" /> e <see cref="P:System.Linq.Expressions.LambdcExpression.Parameters" /: sono impostate sui Valori"3pecifica4i.</returns>
      <param name="body">Oggetto <see kref="T:SyS4e.Linq.Ex`res3iOns.Expression" /> se Cui )mpostare li proprietˠ<see c2ef="P:System.Linq.Exprecsions.LambdaE8pression.Body />*<+param>
     <param namM="TaalCall">Nwgetto <see cref="T:Systum.Bomlean" /> che indica se l'ottimizzazione della chiam#ta tail vmrrà applycat` durant% la compilazIone d%ll'espressione creata.</param>
     <p!ram name= parameterS">OgGetto <sa cref="T:Sisem.Collections.Genric.IEnumereble`1" /> contenente gli oggetti <see cref="T
System.Linq.Expressions.ParameterExpressign  /> da usard er poxolare la raccoltad<see sref="P:Syste}inq.Exprassions.HambdaExpRession.Par`metrs" />.<.param>
  0   <typeparae namE="TDelegate*>Tip di deegato. <otypeparam>
    </member>
    <member nime="M:System/Linq.Expressio.s.Expression.Lambla``1(System.Linq.Expressions.Expsession,Systel.Boolean,System.Li~qExressions.ParameterExpRession[])">
      <summary>Cre` unogggtto <see cref="T:Systmm.Linq.Expressions.Express)on`1" /> dove il tipo delegato  noto in fase di compilazikne.</summary?
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Matrice contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Matrice contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo delegato.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> è null.-oppure-Uno o più elementi in <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> non è un tipo delegato.-oppure-<paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito di <paramref name="TDelegate" />.-oppure-Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per <paramref name="TDelegate" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente di <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo delegato.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> è null.-oppure-Uno o più elementi in <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> non è un tipo delegato.-oppure-<paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito di <paramref name="TDelegate" />.-oppure-Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per <paramref name="TDelegate" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente di <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> è null.-oppure-Uno o più elementi di <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contiene più di sedici elementi.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la generazione di informazioni di debug.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la creazione di informazioni di debug.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la creazione di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> dove il tipo delegato è noto in fase di compilazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression`1" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la generazione di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo di delegato. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata.</param>
      <param name="parameters">Matrice contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato.Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <returns>Oggetto che rappresenta un'espressione lambda la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="T:System.Type" /> che rappresenta una firma di delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> è null.-oppure-Uno o più elementi in <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> non rappresenta un tipo delegato.-oppure-<paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito del tipo delegato rappresentato da <paramref name="delegateType" />.-oppure-Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per il tipo delegato rappresentato da <paramref name="delegateType" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente del tipo di delegato rappresentato da <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> costruendo prima un tipo delegato.Può essere usato quando il tipo delegato non è noto in fase di compilazione.</summary>
      <returns>Oggetto che rappresenta un'espressione lambda la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="T:System.Type" /> che rappresenta una firma di delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> è null.-oppure-Uno o più elementi in <paramref name="parameters" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> non rappresenta un tipo delegato.-oppure-<paramref name="body" />.Type rappresenta un tipo non assegnabile al tipo restituito del tipo delegato rappresentato da <paramref name="delegateType" />.-oppure-Il numero di elementi in <paramref name="parameters" /> è diverso dal numero di parametri elencato per il tipo delegato rappresentato da <paramref name="delegateType" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="parameters" /> non è assegnabile dal tipo del parametro corrispondente del tipo di delegato rappresentato da <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />. </param>
      <param name="name">Nome dell'espressione lambda.Usato per la creazione di informazioni di debug.</param>
      <param name="tailCall">Oggetto <see cref="T:System.Boolean" /> che indica se l'ottimizzazione della chiamata tail verrà applicata durante la compilazione dell'espressione creata. </param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un oggetto LambdaExpression costruendo prima un tipo delegato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> è uguale a Lambda e le cui proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> e <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> sono impostate sui valori specificati.</returns>
      <param name="delegateType">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che rappresenta la firma del delegato per l'espressione lambda.</param>
      <param name="body">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nome dell'espressione lambda.Usato per la creazione di informazioni di debug.</param>
      <param name="parameters">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di spostamento a sinistra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di spostamento a sinistra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a sinistra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore di".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "minore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore di".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "minore di" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore "minore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto numerico "minore o uguale a".</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore "minore o uguale a" non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> dove il membro è un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta un campo o una proprietà su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-<see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o della proprietà che <paramref name="member" /> rappresenta non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> dove il membro è un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta un campo o una proprietà su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-<see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o della proprietà che <paramref name="member" /> rappresenta non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basato su un metodo della funzione di accesso alle proprietà specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e il cui oggetto <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> è popolato con gli elementi di <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-<see cref="P:System.Reflection.PropertyInfo.PropertyType" /> della proprietà a cui accede il metodo rappresentato da <paramref name="propertyAccessor" /> non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basato su un metodo della funzione di accesso alle proprietà specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberListBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.MemberInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e il cui oggetto <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> è popolato con gli elementi di <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è null. -oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-<see cref="P:System.Reflection.PropertyInfo.PropertyType" /> della proprietà a cui accede il metodo rappresentato da <paramref name="propertyAccessor" /> non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> specificati per inizializzare una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo denominato "Add" per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) è dichiarato in <paramref name="newExpression" />.Type o nel relativo tipo di base.-oppure-Il metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base non accetta esattamente un argomento.-oppure-Il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> del primo elemento di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base.-oppure-Esiste più di un metodo denominato "Add" (senza distinzione tra maiuscole e minuscole) compatibile con l'argomento su <paramref name="newExpression" />.Type e/o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa gli oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> specificati per inizializzare una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo denominato "Add" per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Nessun metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) è dichiarato in <paramref name="newExpression" />.Type o nel relativo tipo di base.-oppure-Il metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base non accetta esattamente un argomento.-oppure-Il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> del primo elemento di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo add su <paramref name="newExpression" />.Type o sul relativo tipo di base.-oppure-Esiste più di un metodo denominato "Add" (senza distinzione tra maiuscole e minuscole) compatibile con l'argomento su <paramref name="newExpression" />.Type e/o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo specificato per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che aggiunge un elemento a una raccolta.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.-oppure-<paramref name="addMethod" /> non è null e non rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che accetta esattamente un argomento.-oppure-<paramref name="addMethod" /> non è null e il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> è null e non esiste alcun metodo di istanza denominato "Add" che accetta un argomento compatibile con il tipo su <paramref name="newExpression" />.Type o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> che usa un metodo specificato per aggiungere elementi a una raccolta.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ListInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> è impostata sul valore specificato.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo di istanza che accetta un argomento e aggiunge un elemento a una raccolta.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> è null.-oppure-Uno o più elementi di <paramref name="initializers" /> sono null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type non implementa <see cref="T:System.Collections.IEnumerable" />.-oppure-<paramref name="addMethod" /> non è null e non rappresenta un metodo di istanza denominato "Add" (senza distinzione tra maiuscole e minuscole) che accetta esattamente un argomento.-oppure-<paramref name="addMethod" /> non è null e il tipo rappresentato dalla proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di uno o più elementi di <paramref name="initializers" /> non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="addMethod" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> è null e non esiste alcun metodo di istanza denominato "Add" che accetta un argomento compatibile con il tipo su <paramref name="newExpression" />.Type o sul relativo tipo di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
      <param name="body">Corpo del ciclo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo e la destinazione di interruzione specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
      <param name="body">Corpo del ciclo.</param>
      <param name="break">Destinazione di interruzione usata dal corpo del ciclo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> con il corpo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LoopExpression" /> creato.</returns>
      <param name="body">Corpo del ciclo.</param>
      <param name="break">Destinazione di interruzione usata dal corpo del ciclo.</param>
      <param name="continue">Destinazione di continuazione usata dal corpo del ciclo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro e il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che specifica il metodo di implementazione.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> tramite la chiamata al metodo factory appropriato, dati gli operandi sinistro e destro, il metodo di implementazione e la funzione di conversione di tipi.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="binaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione binaria.</param>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando sinistro.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando destro.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che specifica il metodo di implementazione.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> che rappresenta una funzione di conversione di tipi.Questo parametro viene usato solo se <paramref name="binaryType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o assegnazione composta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> non corrisponde a un nodo di espressione binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresenta un'istruzione catch con gli elementi specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.CatchBlock" /> creato.</returns>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> di <see cref="T:System.Exception" /> che verrà gestito da questo oggetto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="variable">Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresenta un riferimento all'oggetto <see cref="T:System.Exception" /> intercettato da questo gestore.</param>
      <param name="body">Corpo dell'istruzione catch.</param>
      <param name="filter">Corpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un passaggio dell'oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> specificato.Anche il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> impostata su <paramref name="kind" />, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e con <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="kind">Oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> dell'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata in un oggetto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Deve essere Null se la proprietà è static (shared in Visual Basic).</param>
      <param name="indexer">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Interfaccia IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) in Visual Basic) contenente gli argomenti che verranno usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a un campo o a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto a cui appartiene il membro.Può essere Null per i membri statici.</param>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> che descrive il campo o la proprietà a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con gli elementi specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="type">Tipo di risultato dell'espressione try.Se Null, il corpo e tutti i gestori devono disporre di tipo identico.</param>
      <param name="body">Corpo del blocco try.</param>
      <param name="finally">Corpo del blocco finally.Passare Null se al blocco try non è associato alcun blocco finally.</param>
      <param name="fault">Corpo del blocco fault.Passare Null se al blocco try non è associato alcun blocco fault.</param>
      <param name="handlers">Raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> tramite la chiamata al metodo factory appropriato, dato un operando.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="unaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione unaria.</param>
      <param name="operand">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo in cui convertire (passare null se non applicabile).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> non corrisponde a un nodo di espressione unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> tramite la chiamata al metodo factory appropriato, dato un operando e il metodo di implementazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> risultante dalla chiamata al metodo factory appropriato.</returns>
      <param name="unaryType">Oggetto <see cref="T:System.Linq.Expressions.ExpressionType" /> che specifica il tipo di operazione unaria.</param>
      <param name="operand">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> che specifica il tipo in cui convertire (passare null se non applicabile).</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> non corrisponde a un nodo di espressione unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un campo o una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> e <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="member">Oggetto <see cref="T:System.Reflection.MemberInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> non rappresenta un campo o una proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo del campo o della proprietà che <paramref name="member" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un membro a cui si accede usando un metodo della funzione di accesso della proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo della proprietà a cui si accede con il metodo che <paramref name="propertyAccessor" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> che rappresenta l'inizializzazione ricorsiva di membri di un membro a cui si accede usando un metodo della funzione di accesso della proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> è uguale a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> è impostata sull'oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> non rappresenta un metodo della funzione di accesso alle proprietà.-oppure-La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo della proprietà a cui si accede con il metodo che <paramref name="propertyAccessor" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Rappresenta un'espressione che crea un nuovo oggetto e inizializza una proprietà dell'oggetto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo che <paramref name="newExpression" />.Type rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberInitExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> e <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> sono impostate sui valori specificati.</returns>
      <param name="newExpression">Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matrice di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> di un elemento di <paramref name="bindings" /> non rappresenta un membro del tipo che <paramref name="newExpression" />.Type rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di resto aritmetico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore modulo non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di resto aritmetico.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore modulo non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di resto.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di moltiplicazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di moltiplicazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di moltiplicazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore meno unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore meno unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore meno unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di negazione aritmetica che ha il controllo dell'overflow.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore meno unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato che non accetta argomenti.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> è impostata sul valore specificato.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il costruttore che <paramref name="constructor" /> rappresenta ha almeno un parametro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.I membri che accedono ai campi inizializzati del costruttore sono specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Reflection.MemberInfo" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.-oppure-Un elemento di <paramref name="members" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.-oppure-Il numero di elementi nel parametro <paramref name="members" /> è diverso da quello in <paramref name="arguments" />.-oppure-La proprietà <paramref name="arguments" /> di un elemento di <see cref="P:System.Linq.Expressions.Expression.Type" /> rappresenta un tipo non assegnabile al tipo del membro rappresentato dall'elemento corrispondente di <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.I membri che accedono ai campi inizializzati del costruttore sono specificati come matrice.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> e <see cref="P:System.Linq.Expressions.NewExpression.Members" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.-oppure-Un elemento di <paramref name="members" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="arguments" /> è diverso dal numero di parametri per il costruttore rappresentato da <paramref name="constructor" />.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.-oppure-Il numero di elementi nel parametro <paramref name="members" /> è diverso da quello in <paramref name="arguments" />.-oppure-La proprietà <paramref name="arguments" /> di un elemento di <see cref="P:System.Linq.Expressions.Expression.Type" /> rappresenta un tipo non assegnabile al tipo del membro rappresentato dall'elemento corrispondente di <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore specificato con gli argomenti specificati.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e le cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> e <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> sono impostate sui valori specificati.</returns>
      <param name="constructor">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> è null.-oppure-Un elemento di <paramref name="arguments" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="arguments" /> corrisponde al numero di parametri per il costruttore che <paramref name="constructor" /> rappresenta.-oppure-La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="arguments" /> non è assegnabile al tipo del parametro corrispondente del costruttore rappresentato da <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore senza parametri del tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> è impostata su <see cref="T:System.Reflection.ConstructorInfo" />, che rappresenta il costruttore senza parametri per il tipo specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> con un costruttore che non accetta argomenti.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Il tipo rappresentato da <paramref name="type" /> non dispone di un costruttore senza parametri.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice con una classificazione specificata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="bounds">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> è null.-oppure-Un elemento di <paramref name="bounds" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="bounds" /> non rappresenta un tipo integrale.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice con una classificazione specificata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="bounds">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> è null.-oppure-Un elemento di <paramref name="bounds" /> è null.</exception>
      <exception cref="T:System.ArgumentException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="bounds" /> non rappresenta un tipo integrale.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice unidimensionale e la relativa inizializzazione da un elenco di elementi.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="initializers">Oggetto <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenente gli oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> è null.-oppure-Un elemento di <paramref name="initializers" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="initializers" /> rappresenta un tipo non assegnabile al tipo rappresentato da <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> che rappresenta la creazione di una matrice unidimensionale e la relativa inizializzazione da un elenco di elementi.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> e la cui proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> è impostata sul valore specificato.</returns>
      <param name="type">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di elemento della matrice.</param>
      <param name="initializers">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> è null.-oppure-Un elemento di <paramref name="initializers" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">La proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> di un elemento di <paramref name="initializers" /> rappresenta un tipo non assegnabile al tipo <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Ottiene il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uno dei valori di <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di complemento bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore Not unario non è definito per <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'operazione di complemento bit per bit.Il metodo di implementazione può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> e le cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> e <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente un argomento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore Not unario non è definito per <paramref name="expression" />.Type.-oppure-<paramref name="expression" />.Type , o il tipo non nullable corrispondente se si tratta di un tipo nullable, non è assegnabile al tipo di argomento del metodo rappresentato da <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di disuguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su true; false per impostare <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> su false.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di disuguaglianza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Restituisce l'espressione che rappresenta il complemento a uno.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Restituisce l'espressione che rappresenta il complemento a uno.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione OR bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR condizionale che valuta il secondo operando solo se il primo operando restituisce false.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione OR condizionale che valuta il secondo operando solo se il primo operando restituisce false.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore OR bit per bit non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="method" /> è null e <paramref name="left" />.Type e <paramref name="right" />.Type non sono dello stesso tipo Boolean.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con il nome e il tipo specificati.</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> che può essere usato per identificare un parametro o una variabile in un albero delle espressioni.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.ParameterExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> e le cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> e <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> sono impostate sui valori specificati.</returns>
      <param name="type">Tipo di parametro o di variabile.</param>
      <param name="name">Nome del parametro o della variabile, usato solo a scopo di debug o di stampa.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo decremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo decremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo incremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'assegnazione dell'espressione seguita da un successivo incremento di 1 dell'espressione originale.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un numero a una potenza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di elevamento a potenza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="left" />.Type e/o <paramref name="right" />.Type non sono <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un numero a una potenza.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di elevamento a potenza non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.-oppure-<paramref name="method" /> è null e <paramref name="left" />.Type e/o <paramref name="right" />.Type non sono <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta l'elevamento di un'espressione a una potenza e l'assegnazione del risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che decrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che decrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che incrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che incrementa l'espressione di 1 e assegna di nuovo il risultato all'espressione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'espressione risultante.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> al quale applicare le operazioni.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà tramite un metodo della funzione di accesso alle proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" />, che rappresenta la proprietà a cui si accede in <paramref name="propertyAccessor" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Può essere Null per le proprietà statiche.</param>
      <param name="propertyAccessor">Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta un metodo della funzione di accesso della proprietà.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> è null.-oppure-Il metodo rappresentato da <paramref name="propertyAccessor" /> non è static (Shared in Visual Basic) e <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante del metodo rappresentato da <paramref name="propertyAccessor" />.-oppure-Il metodo rappresentato da <paramref name="propertyAccessor" /> non è un metodo della funzione di accesso alle proprietà.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> e le cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> e <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> sono impostate sui valori specificati.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Può essere Null per le proprietà statiche.</param>
      <param name="property">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> è null.-oppure-La proprietà rappresentata da <paramref name="property" /> non è static (Shared in Visual Basic) e <paramref name="expression" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type non è assegnabile al tipo dichiarante della proprietà che <paramref name="property" /> rappresenta.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="indexer">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Raccolta <see cref="T:System.Collections.Generic.IEnumerable`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="indexer">Oggetto <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta la proprietà da indicizzare.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" />, che rappresenta la proprietà identificata da <paramref name="propertyName" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una proprietà denominata <paramref name="propertyName" />.Può essere null per le proprietà statiche.</param>
      <param name="propertyName">Nome di una proprietà a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyName" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Nessuna proprietà denominata <paramref name="propertyName" /> è definita in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> che rappresenta l'accesso a una proprietà indicizzata.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.IndexExpression" /> creato.</returns>
      <param name="instance">Oggetto a cui appartiene la proprietà.Se la proprietà è statica/condivisa, deve essere Null.</param>
      <param name="propertyName">Nome dell'indicizzatore.</param>
      <param name="arguments">Matrice di oggetti <see cref="T:System.Linq.Expressions.Expression" /> usati per indicizzare la proprietà.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che accede a una proprietà.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> creato.</returns>
      <param name="expression">Oggetto contenitore della proprietà.Può essere Null per le proprietà statiche.</param>
      <param name="type">Oggetto <see cref="P:System.Linq.Expressions.Expression.Type" /> che contiene la proprietà.</param>
      <param name="propertyName">Proprietà a cui accedere.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> che rappresenta l'accesso a una proprietà o un campo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.MemberExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> è impostata su <paramref name="expression" /> e la cui proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> è impostata su <see cref="T:System.Reflection.PropertyInfo" /> o su <see cref="T:System.Reflection.FieldInfo" />, che rappresenta la proprietà o il campo identificato da <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una proprietà o un campo denominato <paramref name="propertyOrFieldName" />.Può essere Null per i membri statici.</param>
      <param name="propertyOrFieldName">Nome di una proprietà o di un campo a cui accedere.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> è null.</exception>
      <exception cref="T:System.ArgumentException">Nessuna proprietà o campo denominato <paramref name="propertyOrFieldName" /> è definito in <paramref name="expression" />.Type o nei relativi tipi di base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta un'espressione che ha un valore costante di tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> e la cui proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> è impostata sul valore specificato.</returns>
      <param name="expression">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> è null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Riduce questo nodo a un'espressione più semplice.Se CanReduce restituisce true, deve essere restituita un'espressione valida.Questo metodo può restituire un altro nodo che deve essere a sua volta ridotto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Riduce questo nodo a un'espressione più semplice.Se CanReduce restituisce true, deve essere restituita un'espressione valida.Questo metodo può restituire un altro nodo che deve essere a sua volta ridotto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Riduce l'espressione a un tipo di nodo noto (diverso da un nodo di estensione) o restituisce solo l'espressione se è già un tipo noto.</summary>
      <returns>Espressione ridotta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di uguaglianze di riferimento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un confronto di disuguaglianze di riferimento.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione con un tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la rigenerazione di un'eccezione.</returns>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Return, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e un valore Null da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return con il tipo specificato.Il valore passato all'etichetta al momento del passaggio può essere specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Continue, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e <paramref name="value" /> da passare all'etichetta di destinazione al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valore che al momento del passaggio verrà passato all'etichetta associata.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione return con il tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpression" /> con la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> uguale a Return, la proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> impostata su <paramref name="target" />, la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" /> impostata su <paramref name="type" /> e un valore Null da passare all'etichetta al momento del passaggio.</returns>
      <param name="target">Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> a cui passerà l'oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Oggetto <see cref="T:System.Type" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di spostamento a destra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di spostamento a destra non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di spostamento a destra bit per bit.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e la cui proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> è impostata sul valore specificato.</returns>
      <param name="variables">Raccolta di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Istanza di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> e la cui proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> è impostata sul valore specificato.</returns>
      <param name="variables">Matrice di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> da usare per popolare la raccolta <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che non ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di assegnazione di sottrazione che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Oggetto <see cref="T:System.Linq.Expressions.LambdaExpression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.InvalidOperationException">L'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> che rappresenta un'operazione di sottrazione aritmetica che ha il controllo dell'overflow.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.BinaryExpression" /> la cui proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è uguale a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> e le cui proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> e <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> sono impostate sui valori specificati.</returns>
      <param name="left">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Oggetto <see cref="T:System.Linq.Expressions.Expression" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Oggetto <see cref="T:System.Reflection.MethodInfo" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> è null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> non è null e il metodo che rappresenta restituisce void, non è static (Shared in Visual Basic) o non accetta esattamente due argomenti.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> è null e l'operatore di sottrazione non è definito per <paramref name="left" />.Type e <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un oggetto a <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzioneswitch senza un case predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un caso predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="type">Tipo di risultato dell'opzione.</param>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> che rappresenta un'istruzione switch con un case predefinito.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creato.</returns>
      <param name="type">Tipo di risultato dell'opzione.</param>
      <param name="switchValue">Valore da testare a fronte di ogni case.</param>
      <param name="defaultBody">Risultato dell'opzione se <paramref name="switchValue" /> non corrisponde ad alcun caso.</param>
      <param name="comparison">Metodo di confronto di uguaglianze da usare.</param>
      <param name="cases">Set di case per questa espressione switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> da usare in un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> creato.</returns>
      <param name="body">Corpo del case.</param>
      <param name="testValues">Valori di test del case.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> da usare in un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SwitchCase" /> creato.</returns>
      <param name="body">Corpo del case.</param>
      <param name="testValues">Valori di test del case.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> la cui proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> è impostata sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> con le proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> impostate sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> le cui proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> sono impostate sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea un'istanza di <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> con le proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> e <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> impostate sul valore specificato.</returns>
      <param name="fileName">Oggetto <see cref="T:System.String" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">Oggetto <see cref="T:System.Guid" /> su cui impostare la proprietà <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la generazione di un'eccezione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'eccezione.</returns>
      <param name="value">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta la generazione di un'eccezione con un tipo specificato.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.UnaryExpression" /> che rappresenta l'eccezione.</returns>
      <param name="value">Oggetto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuovo oggetto <see cref="T:System.Type" /> dell'espressione.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Restituisce una rappresentazione testuale di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Rappresentazione testuale di <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> che rappresenta un blocco try con qualsiasi numero di istruzioni catch e nessun blocco fault o finally.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.TryExpression" /> creato.</returns>
      <param name="body">Corpo del blocco try.</param>
      <param name="handlers">Matrice di zero o più espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> che rappresentano le istruzioni catch da associare al blocco try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFina,ly(Systeo.Linq.Expressions.Exppession(System.Linq/Expressions.Expression,System.Li.q.xpressionc.CatchBdockZ]) >
      >summar.bea un oggetto <see cref="T:System.Linq.Expre3sions.TryExpression" /> rhu rappreqenta un bloccg try con qualsIari numero di istruzioni ca4ch e un blocco finally.</sqmmary>
      >rmturns>Oggetto <see cref4"T:Syste-.Lina.Expressions.TryEzpres3ion" /> creato.</returns>
    <param!name="rody">Corpo0del bl/cco try.<param>
      <pasa- name= finally!>Cobpo del$blocco inAlly./papqm>
      <par!m name9"handlers">Matrice di zer/ o più spressioni <s%e(cref=T:System.Linq*Exprmssions.CatchBlock" /> che rappresentano le iStruzioni catch da `ssociare al blocco try.</param>
    </iember>
    <member name="M:System.Linq.Expressigns.Axpression.Tr9Fault(System.Linq.Expressions.ExpressIon.System.Linq.Expvession.Expression)">
  `  (<summary>CRea un oggetto a <see Cref-"T:Systeo.Ninq*Express)ons.Tryxpression"!/> che rappresenta un b|occo 4ry con n blocco fault e n%ssuna()Struzione catch.</summarY>M
      <returns?Oggetto <see cref=*T>System.Linq.Expressions.TryExtreswyon" /> aravon</rEtrns>
      <param name="body">Corpo del blocco(try.</pazam>
      param lame?"fault">Corpo del bloccO fu|t.</param>
    </member>
  $ <member name="M:Syste}.Linq.Exprdssions.Expression.TyFanallY(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <suemar>Crea un oggetto ,see cref="T;System.Linq.Expresions.TryExpre3sion" /> che rapprerenta un blocc- try ckn un(blocco fi~all e nessunq istruzione0catbh.</summry>
      <rmturnq>Oggepo <see cref=*T:Systdm.Linq.Exp2eqsions.TryExpression" /> creatg&</returns>
     "<parae name="body">Cor`o dl blocco try.</param>
     <param name= finally">Corpo del blocco0Finally.</param>
    </membdr>
    <membeb name="M8Systeo&LinQ.Expressions.Expres{ion.TryGetActionTyp(System.VypeZ\,System.Type@)">
      <sumiary>Crea%u oggetto <see cref="P:ystem.Linq.Expressons.Expression.Tyra" /> che rapprusenta un tipo delewato SystemAction oenerico con argomenti `i tipo specifici.,/summary>
`     <returw?true se`il tipo delegato SyStem.Acpiol generico è stato cReato per ,paramref name="typeArgs" /: specifico; in casm contrario, fals%.</rutupns>
      =parae!name="typeAbgs"<Matrice di oggetti Type che specificano$gli argoMenti dI4kpo per il tipo delegato Szstem.Action.</xaraM>
      <para nqme="actionType">Quando"questo metodo viene restituito, contiene il tipo d%legato System.Action genericm cie dispone di argomenti ti tpo specifici.Contiene ^ull se nessun deleg!to SYste.Acu)on generico corritode all'ogwedto <paraMref name<"typArgs" />. Questo parametrn viene paswat non inizializzato.</param    </mamber>    <meMber name="M:Systee.LinqEx`ressions.E8pression.ryGetFuncType(System.T{pe[],System.Type@)">
      >summz9>Crea un gggetto <see cRef="P:SystEm.Linq.Express)ons.ExpreSsiof.Type" /> che rappreseta un tipo(delegato system.Func generigo con argomenti di tipo 3pecifici.L'ultimo argomelto di tipo stecifica il tipo rstifuito del delegato creato.,/su-mary>
      <returns>true se il thpo elegato Systgm.Fu.c generico è stato creato pmr <`!pamref name&typeArgs" /> specivico; in #aso contRArio, false.</returns>
      param name="typeArgs">Matsice d) oggetTi Type che0specifhcano gli argomenti di tipo per in tipo delegato Syctem.Fufc.</param>
"     param name="funcType">Quanfoquesto metodo viene restituito, contyene il tipo de,egato SystemnFunc gene3iCo con argomenti di tipo specifici.Ckntiene Null se nessun delegato System.Vunc generico corrisponde aln'oggetTo <qraoref name="typeArgs" />. Questo paraoetro viene passato non"inizianizzato.</param6
    </member>
    <member nme="P:Sqstem.\inq&ExpresSions.Expressmon.Type">      >summary>Ottien} il tipo staticg demlestressione rappresentava da <see c2ef"T:Cystem.LinsExpressaonsEhpressiol2 />.<summary>
  0   <return3>
   0"  !<see cbef="T:ystem.ype"(/>"che rappreseota il tipo suati#o dell'espressione.</returns:
!   <-mumber~
    <membep name="M:System.Linq.Expressions.Eppression.TypeAs(System.LInq.Expressions.Expressin,System.Type)">
    !0<summary>Crea un oggetto <see cruf="T:System.Linq.Expressions.UnaryExpression" /> che raptresenta un riferimento esplicito k une cnversione oxing(in cui viene forniTo jull$se la con~ersinne non riesce/summary>	
      returns>Oggetto <see cref="T:System.Lhnq.Expressons,UnaryEypression" /> la$cui proprietà <3ee creF="P:Si3t%m&Linq.Ehpressions.E|tres3hon.NodeType" /> è uguale a <seeczef="F:System,Linq.Expressions>GxpressionType.TyteAs" ->`e le cui prg`rietà <sem`gref="T:s9stem.Lin!.Expresions.UnaryExpresskon.operand" >!e <see cref="P:System.Linq.ExpressionsExpre{sign.Type" /> sono impostate sui valori specificati.</returns>
      <param name=&expresrionb>Oggetto <sem cref="T:Sstem.Lifq*EypzessiOns.Expression" /> su cui impostare la`proprietC <see Cref=&PSYstem.Linq*Exprssons.Unaryaxpression.OqeranD" />.8/parim>
 `    <pa2a- name="type">Oggetto <see SreF="T:[ystem.Type" /> su cua impostaRe la proqrietà <see #ref="T:System.Linq.ExtreRsimnsExpre{sion.Type" />/</aram>	
      <exception cref=bT:System.AscuentNulnException">
   0    <pcraref$name="expression2 /> o <paramref name="type" /> è nul,./eXcptin>
"   </member>
    <memBer jame="M:System.Linq.Exprussiojs.Expsession.TypeEqual(Sxstem>Linq.Expresshols.Ehpressikn,System.Type)">
      <summari>Crea Un oggett`<see c2g="T:System.Inq.Exprussions.TypeBinaryEppression" /> che confronta d'identitÀ del tipo$in fase di esdcuzIole.</summary>
      42eturns>Oggetto <see cref="T:SYstem.Minq.Expressyons.TypeBinaryEhpressikn" /> per il quale la proprietè <sme cref="P:Syst%m.linq.Expressions.Axpression.NodeType" /> è Uguale a =see cref="_:System.Lnq.EhprdsSions.Expression.TypeEqtal(Cystem.Linq.Axpressions.Expression,xstem.Type	" /> e per il quale leproprietà sge cref<"T:SysteM.Li.q.ExpressIoNs.Expressyon" /> e <see cref"P:System.Linq.Expressions.TypeBinaryExpressionTypeOpera.d"!/> s/.o impostte`sui valori specifigati.</ReturnS>
   "  <paraM nme5"expression >Oggetto`<see cref="T:System.Linq.Expressions.Exprassion" /> su cui impostare lq 0roprietà <see cref="T:Qqstem.Linq.Expressins.Expression" />.</par!m>      <param name="tp%">oggetto`<see cref="P:System.Linq*Exxressimns.Expression.Pype" />!su cui impostard la proppietà =see cref="P:Syrtem.Linq.Expressions.TypeBinaryExprssion.TypEOpeand" />.</param>
$   </member>
    <membur name="M*System.Linq.Expressigns.Exression.TypeIs8System.Linq.Expresrins.Expression,Systm.TypE)">
     <summary>Crea un oggetto <red cref="T:System.L)nq.Dxprssions.TypeBinaryExpresrion" />.</summarx>
      retur.s>Oggetto <see cref="T:System.Linq.ExprEssmons.TpeBinaryExpression" /> per il qeale la proprietà |sGe Cref="P:cystEm.Lilq.Exxre7rions.E|xress)on.N/$eType"!/> è uguale ! <we% cref="F:Sywtem.Linq.U8pressions.ExpressionT}pd&TypeIS" .> e Per0il quale le proprietà <se creg="P:Sysdem.Lkjq.ExpResioos.TypeifaryExpressiol,Expression"/> g <see cref="P:System.Linq.Expressions.Ty`eBinaryExpressin.TypeKperand" /> sono impostate`sui valobi srecifiCati.</returNs>
 `    <param nime="expression">Oggetto <see cref9"T:sxstm-.Linq.Expresrins.Expression" />$su cui ampnstare a proprietà <see sref="P:System.Linq>ExpressiknqTypeBinaryExpresgin.Exprassion" />.</param>
      <param lame="type":Oggetto <see"czef=#P:System.Linq.Gxpvessions.Expresion.Type" > su cui imposare la propriEtà <see cref="P*SysTem.Liny.Expsessions.TypeBinaryExqvession*TypeOpgrand"0o>.</param>
      <excdptioo cref"TzSystem.ArgumentullExcetion">	
  p     <paramsef Name}"expression /> m 8paraipef name}"type" /> è null.exception>
    </meMber>
(   <member naee="EzSystem.Linq.Expres3iods.Exprdssinn.UnapyPlds(System.Liju.Expressions.Eypre3ion)6
      <summary>Csea un oggetto <see cref="T:[ystem.Li~q.Expressions.QnaryExpressinN" /> ihe rappresanta un'operazione con al"più unario.</summapy>
      <veturns>Oggetto <see cref="T:SxstemMinq.ExpressiOns.UnaryExprersion"(/>(la cui$pbop2ietà <see cref="P:Systel.Linq.Expressions.Exprersion.NodeType" /> è uguale a <see cref="F:System,Linq'EXpressions.ExpressionType.UnaryPluc" /> e la cui pro0rietà <see cref=b@;System.Linq.EXpressions.UnaryExprdssion.Operand" /> C iepgsvata sul valore s`ebificato.</Returns>
      <pabem!name="exrpassion">Oggetto <sea cref="T:Ss|em.Lip.Expressions/Expression" /> su gui impOsu`re la pRoprietá <seE ref="P2System.Linq.Expruscions.UnaryExrr%ssion.Opera~d" />.</param>M
      ,excmtion cref="T:S9stem.CrgumentNullExc%ption">
        4parampef nae="expression" /:`è nqll.</dxception.
      <exceP4ion crf=&T:System.InvalidOperationExceptko">L'operatore più unarig non è defiNito p%r <paramref name="expression" />.Type</exception>*    </memb%r>
    <eember name="M:System.Lknq.Eypressions.Expressio~.UnaryPlus(Systum>Linq.AxresSions.Eppression,System.Reflection.MedjodInfo)">
      <su-mary>Srea un(oggetto <sae cref=":ystem.Lin1.Gxprdswions.UNaryExpressio" /> che rappresenTa0uo'perazione con al più enario./summary>
     <returns>Oggetto sEe cref="T:Cystem.Lynq.expressyofs.TnaryExpression" /> la kui prkpriedà <sed cref="P:System.Linq.Expressions.ExpresyionnNodeType"!/> è uguale a <see sref="F:Sys4Em.Linq.Exrressions.ExpressionType.UnaryPlus" /> e le bui proprietà >see cref="P:System,LynqExpressions.unaryExpressyof.Operand > e <see cref-P>System.Linq.Expressions.UneryExpre{sion.Method" /> so~o imtostat% sui valori specificati.|/rgturns>
     0<param nae="expressyon">Oggetdo <see cref=*T:Sy3tem.Linq.ExxresSyons.Expressiol" /> su cui impostavu la propriet!<see cre="P:Syste-.Linq.Expressinns.Un`ryMxpression.Operanf" />.</param=
 "    <param name="metod">Oggetto >see cre&="D:System.Reflectmon.Met`odInfo" /> se cui impostqrm la proxrietà <see Cref="P:SystemLinq.Exprewsions.UnaryExpre3si}n.Method" />.>/xapam>
 (   <e8ception cref="F:C9stel/Argume4NullExcepti/n">
      ( <para-ref!name="uxpressin" /?  null.</exceppio~>
 !   (<eyception cref="T:System.ArgumentDxception">
  !     <pAbamref name="iethod" +> non è null e yl metodm(che rapprgsenta restituiscm void noN è ctatic (Shabed in Visual Basic) o non$accetta esattaeente un rgomendo.<'exception>
      <exception cref="T:System.InvcmidOper`pionUxception">*        <paramref name="method"`/> è Null e l'operatgre pi unario non è defynito per <paramrf name="ezprdssion  /,Type.-op`ure-<paramref name="expression" />.Type , o ilvipo nnn nullable corrispondente(se si tratta ei)un tipo nullable, non è assegnabile al tipo ti argoment+ del$eetofo rappresentato da <paramref name="methkd" >.</exae`tion>
    <'member>
    <membu2 name="M:System.Linq.Expbessiofs.Exprewsion.Unb/x(SysTem.Linq.Expressions,Exprgssion,System.Type)"
      <summary:Crea un oggetto <see Cref=bTzSystem.Lilq.Exprassions.UnaryExpression" /. che raprrEsenta una cknversione unboxyng esplicit`.</summpy>
      <raturns>I3tcnza di <see cref="T:System,Linq.xpesSions.UnaryExppes{ion" /.</returns>
      <pram name="expressmon">oggeTto <see cref="T:system.Lknq.Exprecwion.Expressi/n" /> di #ui eseguire lA converrikne0un"oxing.</param>
  (   <param namd="txpe">Nuovo oggetdo <3ee cref="T:System.Type" /> $ell'ecpressione.</`aram
    8/memer>
    <member name="E:System*Linq.Exprewsons.Expression.VariajLe(SystemType)">
    (<suemaRy>rea un ngfo"<se%!cref="T:[ystem.Linq.Exqressions.ParameteRExpression" /> che può esere usato pep identificare un parame4ro o Una variabile in un alcer delle espressyoni.</suemary>"     <retubns>Nodo <see cref="T:System.Lifq.Expressions.arameterExprecsion" />con il .ome e Il tipo spechficati<'returns~
      <p!ram nae="type">Tipo di parametro o0di variabk,e.</param>
    </meber>
    <member name="M:Sywdem.Linq*Expressions.expresqion.Variible(S}3tem.Type,Systei.String)">
      <suimari>Crea un Nodo <seE cref="T:Sywtem.Liny.Expre3sions.ParameterExpression" /> che può esserm usavo qer ientificare wn param%tro m una variabile`yn un albero delle espressioni.</qtlmarq>
      <retwrns>odo0<see creF="T:System.Linq.Expressions.ParameterEypression" />!con il nome e il tipo spekiFicati.</re|urns>
     (param name="yp%"Tipo di parametro o!di vabiajile.</param>      <param oame?"n!e">Noee del paraMetro o $ehla varIabile.Questo nome viene usato soloa"scoN di debug o di 3tampa./parae>
    </meber
 `` <membe name="M:System&Linq.Expressions.Expression.V)sithildren([ystgm.Linq.Expressions.ExpressionVisitor)">
   0  <sumaby>Riduce il no$o, quindi chiama il delegato del vasitator%$sumn'espressione$ridotta.S il lodo non è$riducibile, il metodk gefera"un'eccazmone.</3umm`ry>J      <reuros>EsPvessione visktaTa o esPbussionu ahe`deve so{tituirla nelm'!lbaro.</returns>
   $  <param na-%="visitor">Istanza di >seu cref="T>Sistem.Funcb2"`/>.</psam>
  ` </member?
 !  <ie}ber nam="T:Sy3tem.Linq.Ex`ressins.Expression`1">
      <summ`rq>Rappresenta!un'espressione!dambda fortemegTe thpizzau! #ome stz}tturc dei deti sotto forma di tna sTrutuUza$ad``lbe2o dell'espressione.L! classe non può"essere erelitapa.,'Summary> ( 0  <typepasam naee="Telegate2>Tipo del!delegao rappresentato danl'oggetuo <see cref="T:SYstem&LInq.Expressions.Exp2eSSion`1" />.</typeparam>    </meiber
 0  <ember nAme="M:Qystem>Lins.Axpessions.Exprussion`1.ComPile">
  !   <summary>Compiha l'espressione |aebda descritta ealla strutTura ad!albero dell&esp2essione in cmdice eseguibide e produce un delegato che r0presEnt l'espresqione(lambd!.</summary
   0  rutusnr>Delegato fi tipn$<paramref n`me= TDe,egate" /> che rapprdsenta l'esqressionm la,bda comphlata$descritta dall'ogGetto <see creg="T:Systee.Lynq.Exprmssions.ExPressmon`1b />.</return{>
a  0</mmber>
    <member nam%="M:SYsteo.Linq.Expressions,E8PresIon`1.UPdate(SyStem.Linq.Expre3cions.Expression,SYstem>Collectiojs.GeneriC.IEnumerab,e;System.Li^q.ExpressionsnParametgrExprEq{ion})">      =summ!r}>Crea una nuovaespressione simile a 1uella corrmnte, utilizzandm Però gli eleme*|i figl)o specificatI.Se$twtti gli elementi$figlio sono ug5ali, verrà restituida l'uspresqione`correjte</smmary>
 `   !<returns>Ecpre3sIone corrEnte se l~ viene modificato alcqn elemento fig,io O espressiofe con gli glelenti figlio aggiornati.</returnw> (   <param name=body">P{orrietà <see"cred-"PSqtem.Linq.xpressions.NambdaExqression.Bodq" />0del risultaPo.</param>
      ,param name="qaRameters">Xroprietà <Sem cref="P:System.Lins.Ehpressioos.La-bdcExpressionParameters" /> del risultato. </p`ram>
 "  </member>    <member namE="T:System.Lin1*Exprdcsions.GppresioType">
      <summ`ry>Descrive i tipi $e) nofi di una strutura ad clbeRo dell'espressione.</cummary>
  ` </member>
    }ember(naMe="F*System.L+nq>Exprescions.Exprssio~Type.Qdd">
      <summ!r9>O`erazlone di addizhone, ad esempio a + b seoza controllo dell'Ovrblow, per operafdi numerici/</sWmm`ry>
    </mu}be2>
    <member name="F:ystem.Lnq.Expressiof.ExpressionTyPe.AddAssign">
      <rummar9>Oerazionu di assegnazione coposta di addizioNe, ad esempio (a += b), senza controelo dell'overflow,$per perind( numerici.</summary.* `  /meebes?
    ,memBer name="F:SystemLinq.Expressions.ExpressionType.AddAssignChe#ied">
      <sumlary>Operazione0dI a3segnazio~ecompospA di addizione, ad esempio (a += b), Con controllo `ellgoverflog, per"Opdrandi numerici.</summary>
    <.lemer>
    <m%mber name="F:Syrtem.Linq.Expressions.ExpvessonType.Addhecked">
   $  <sumia6y6Operazione di(addiza/nd, ed esemqio (e + b), con controllo dell'oVergLow, pev operandi oumgrici/</summary>
    </member>
    <mmber name="F:Sqste-.Hinp,Expressions.GxpresSionTypeAnf">
   (  <{ummar>Operczione AFD bit xer bit o logi#a, ad esempio (q &amt: b) iN K# e a And0b) in Vistal BasIc.,/3ummary>
    </mumber>
    <mgmber name="F;System.Linq.Exppessions,ExpresshOnType.AndAls">   $  <suem`ry>perazione AL condizionale che valuta il secondo operan$o sono se il prImo$oprendo rStituasce true.Corrisponde ! (a &amp;&amp; b) in C# e a (a Azd@,so b) in Vhstal Basic.</summary>
`   </member>    <member dama="F:SystmLyN.Expressyons.ExpvessionType.AndAssign">
      <summary>Oparazione di assegnazione somposta ANT bit per bit ologic!, a esempio (a &amp;= b)")n C#.</summcry>
    </mgmbe2>
    <member name="B:Sy{tem.Linq.Expressions.GxpressionType.ArrayIndex">      <rummarY.Opgrazimne ti ind)cizzaziole )n una matrice unidimansimnale, q5ale `rsay[index] in Z# o array(inlex) in Visual Casic.</ummary>
    =member>
    <-ember jame="F:Sysuam.Linq.E|pression.xpressionT{pe.ArbAyLmngth2>
      <sumeary>Operazione ch% ottieng la lunghezza di"una matrice unidimensiooale, ad ese}0io array/\ength.<sumiary.
"   </member>	
    <-embep nam="F:SysTem.Linq.Expressios.ExpressinnType.Assign">
 0    <summary>Operazione di aSpegnazone, ad esempio (a = b).</sum-ary>   0</me}ber>
 $  member nama="F:System.lInp*Ex`ressi/ns.Expre{sionType.Jlock">
 "    <summary>Bdocco di(espzessioni*<'suimary>
    <--ember>
 `  <membep name=2;System.Lifq.Expressions.ExppessionType.Call">
 0$   <sumary>chiamta a un metodo, ad esemponel'espressiong obj.sampleMethod)*</sumMaz>   </memrev>	
!   <member ame="F:System.Linq.xpressiols.ExpresSionType.Coalesce">
   `  <summap>Nodo che r!px2eseta un&op%razione!null coalescing, ad eseepio (a ?? b) in G# o!Ig(a, b) i ^isual Bawic></su-eary>)
$ ( </member>
    <membez Nbme="F*Qystem.Linu.EpReqions.ExpressionTypg.Conaitional"<
      <sumlary>Operazione cOndazionale a$ esempio a &ct; b / a$2 f"in C# k If(a &gt; b, a, b) in Visual$Basic.</wu-maRy> "  </member>    <membr name="F:System.Linq.Expressio~s.E8pra{sionTypu.Constan0">
  (   <suimary>Vaore coStante</suomary>
    </eember>
    <memBer name="F:System.Ninq.Exressio~s.ExpsessionType,Convert">
      <summery<Operazkone caSt o(i convErsione, ad esempho 8SampleType/N`j in C# o cT{pe(obj, SampmeTypd) 	n Visual Basic.Nel baso0di ufa conversikne numericI,(se in valo2e Convertito è |Roppo lung peril tipo di destinazimne non fiene generapa$alcuna0ecce:one.</summapy>
$   </Member>	
    <membdr name="F:System.Linq.expressions.Exxression\pe.ConvertKhecoed":
      <summcr{>OperazionE casto di conversione, qd eSempio (SampleT9pe+obj i~ C# / CTy0e(obj, SAmpleVype)il Visqal Basik.Nel casn dH una cnnversikne numerica, se il falore convertit è tropto lundo per il typ!di destinaZionefiele"Generata un'eccezione.</Summary>
    </member>
    <membEv name= F>System.Linq.Expressions.ExpressIonType.EebugInfg">      8swmmary>Informazioni sul febugn<-summary>
 !" </mem`dr>
    <mmmber oame="F:Sy{tem.Hinq.ExpressIons.Axxre{{ionUype.DecreMent">
      >summary>Operazione di debremento unaria"quaLu (a - 1i kn C# m Visual Rasic.È necesSario cle l'oggetto`a jn vengamodificato sul posto.</summary>
    </membep>
    <mamber name="F:S{tem.Linq.Exprmssions.ExrressionType.Defalt">
      <sumary>Valore predeFini4o.</ummary>
    </memfer>
    <member naee"F:Wystdm.Minq.EhrressioNs.ExpressionVype.Divide">
  !!(0<summary>Operazione di dmvisione, ad esempio`(a / b), pr operqndi nuierici.8/summary>
    </memfur>
    <}eibeV neme="F;System.Lifq.Expressi/ns.expressionT9pe.DivideAssign">
     (<swmmary>Operazione di assegNazione!compota di divisione, ad esEmpio (a / b( pe operandi numerici.</wummary>
    </me-ber>
    <iem"er ame="F:Syrtem.Linq.Expressions.ExpressionType.dy~aoic">
 `    <sumAry>Operazione dinaeica.</summary>
0  $/membev>
    <ember nam="D:Gystem.Linq.Expressions.Expressiontyp.Equal">-
      <summarY>Nolo che rappre2npa uN colfronto di ugueglianZa, ad esempio (! == b)$in C#o (a = b) in(Visua, Basic.</summar{>
 "  <-memfer
    <membur name="F:System.Linq.Mxprgssions.Expressmonyre.ExblusiveOr">
     <summary?OperazienE$XORbit 0er bi o logica, ad esempio (a ^ bi in C# o (a Xor b) in Vi3ual Basic.,/summary>
    ,/iember>
    <membEr nMe=bF:System.Linq.Extres3ions.ExpresskoKType.ExclUsiveOrAs1ign">      summari>Operazigne di essdgn!zione composta XOR bix pdr bit o lmghcq, ad esempio (a ^= b) in C#.</summar>
    <-edober>
    <member jame="F;SysueM.Liju.Exprewsions.ExpRessionType.Exdensin">
      <stmmarq>Esxressione$di estunsione.</summary> (  <'mmber>
 d  <member name="F:SysPee.LInqGxpressaO.s*ExpbessionType.oto">
      <summary>Esp2essione *go to" ad esempio 'oto LaB%l i. C# o GoTo Labeh"in Visuem Basic,<?summary>
    /member>
    <membep nAme="F>System.Linq>E8prssion1.ExpveqsionTyp.GreaterThan">
      <st-maryCo~&ront/ "mcggmore di", ad esempio (a &gt;(b).</summary>
    <.meyber>
!   <mEmber name="F:System.^ia.Expressions.Expres{ionType,GrmaterThanOrquel">
      <summary>Cgnfr/nTo "maggiore o ugule a", ad eremPo (a &ct;= f(.</sumar}> "  </memcer>
  $ <member!name="F:System.Linq.Express-ons.EprssiOnPype.Incremnt"^
  "   <sulma2y:Opdrazione di incrementk unaria quale((a + ) in # e VisUah Basic.È necessarko bhe l'oGgetto a non venga modificcto`s}l posto.<.summa2y>
    </membe`>
    <member namd="F;Sysvem.LijqnExpressmons.Expre{sionTypd.IndEx">
    ( <{ummary>Operazioe di indicizzAione o operazione cha a#g`e ! una pRopriet ce accetta argoMenti. </summary>
  " </mfmber>
   <ommber name="F:Sydem.Linq.Exprm{sions.ExpressionTxpe.Invoke">
      <sulmary>Operazione che richiama un dehEg!to o0u^'spress)onelambda- al esemtio scmpleDelegate.Invoke().</summary>-    </member6
    <memjer(namm=*:System.Linq.EypreSsions.EypressionTYpe.HsFalse&>
0     <summaby>alOre con$izhOnale fals%.,/summay>
 #(</iembar>
    <member nme="F*Sysvem.Linq.Expressions.ExpressinnType.IsTrue">
      <summazyValore condizionale vrue.</summary>
    </member>
    <meber na}e="F:System.Lknq.Expbars)ons.ExrressionType.Label">
!     sulmary>Etichetta</summary>
    </member>
    <member name="F:Systfm.Linq.Expressions.ExpresionTy0e.Labda">
     h<semma2y>Ecprmssio~g la-bda,$iD`esempim(a =&gt> c + q io A# o Fungtion(a) a + c in Vistal basic.8sqmmary6
    </member>
 (  <member naMe="F:System.Linq.Expressions.Expressio~Type.LntSh)ft">
     `<summaryNperaxione di rcorrimuno a Sinistrc`bit per bit, ad esempio (a &,t;&lt; b).</s}mmary>
 $ `</member>
    <memfer name="F:Sstem/Linq.ExpzEssions.ExpresIonType.LuftShiftAssign">
      <summmry>Assegnazione comrosta ti scosramentg a sinerdra bit pev bit, ad gsempio (c "lv;&lt9=(b).|/{wmmary>
    </member>
$   <mem`er name="F:System.Lin1.Expresqions.EzprescionUype.L%ssThan*>
      <summarx>C/nvronto "manore d", ad esempio (a &lt; b).>/cummar}>
    4/mdmber>
  ( <mdober name="F:Wsuem.L)nq.Expressions.ExppessionType.LessThanOzEyuaL">
  "   <summary>Cnfsonto "minore o uguale a", ad eempio (a$&lt;= b).</summary>
    <.member>
    <iember ame"F:Syste.Dinq.Expressions.EpbdqsignTyPe.LivTInmt">
 ! $  <summary>Npera*ione`ch creA un nuoVo oGgetto 8se cref="T:Syqtdm.Bolections.IEnumrafle" /> d lo inizializza da!un elencn di elemen4i, ad eseipio new List&lt;SaulgTypa&gt;)z a, `, c } in S# o Dim sqmpleList = { a, b, c } in Fisual Basic.</Summary>
    </memjer>
    <member"Nam%="F:System.H)nq.Expressins.ExpzewsionTyp%.Lkop">
      summar9>Ciclo,`aD esempio for`o while.</smary>  ( </membr>
    <mamber name="F:System.Linq.%xprersions.EypressioType.MeMbgrAccess">
      <su-mary>Operazione!ahe legge da un capo2o un proprhatà, ad esempio obJ.SampePropertx.</sumary>    </meeber>-
"  <member name=G:Cystm.Linq.ExpresqionsnExpressiojTyqe.MemberInit"6
  0  (<summay>Operazione0cHe #rea uNnuov o'gettg e ne iniziali[{a uno0O più mem`ri, ad esEmpio new Point {  = 1,0Y = 2 } in C# o New Point With!{.X = 1, .] = 2 in ViruAl Bas)c.</summary>
   ,-member:
    <member naMe="F:Systum.Linq.Exprer#ions.ExpressionType.MoDulo>
 (    <SummayOperazid da`resto aritmetica.ad Ese-pio  a % b) in C# o$(a Md b) in VIs}cl Basig.</summay>
    <mmber6
 `` <member name}"F:S9stam.LInq,Expressiofs.ExprersioType.Modu|oAssign">
      ,s}mmary>Operazione di asseonazione aomposta ei resto critMevyca, ad eSempio (a -= b) in C#.</summary*    </member>*    <membr`nme="f:Sysdem.Lins.Exprdssion3.ExpressionType.Mqltiply">	
      <cqmmary>Operazionefi moltiplicaziona, a esempio (a * b), senza controllo dell'oerfhow, per kperaKdy numerici.|/sumiary>
    (?member>
"   <member nae="F:System.Linq.Dxpressions.ExpressinT}pe.MultipnyAssign">      <summary>Operazione dI assegnazhona composta di moltiplicaz)one, d`esempio (a *= b), sex! controllo dell'ovevflow, pEr oxerandi ~}merici.</summary>
  ! </membdr>
   `<member!name="F>SystdmLinq.Expressions.ExpsescionTypeMulviplyAqsignChecjed">
      <summar{>Operazioj di !ssegnazione Compo{ta di"moltitlicazione, ad esempio (a *= ), con contr/llo dElm'overflow, pe2`oPerandk`nuierici./sumoary.
    <ommber>
    <member name="F:System.Linq.Expressions.ExprassionType.MultiplyCheckeD">
      suomarq>Operazionu di moltitl)cazione, `d e{empmo (a * b), con`#kj4rllo fell'overflow, per operandi nwmerici.</summary>
    </member>
    member naMe="F:System.Lijq.Expressions.ExpressionType.egate">J      <sumoary>Mperazione di ne7azioe !r)tmetica, a` esempin (-a).È necEssario cHml'oggetvo a non venwa modificat sul posto&<?sqmmasy>
   0,/mm"%r>
   "<membes name=bFSysttm.LinQ.Expressions.GxpresSionTqpe.NdgaeChebked">
      <s}mmary>Operazione fi nmgaziond aritmetica, ad esdmpio (-a), con ckntr/|lo dell'oveflow.È necasscrio che l'oggetto a non venwa mmdIficato`sul posto.</semmqry
    ,/member>J    <member name9"F:System.Lmnq.Expressions.ExpressionType&New">
      <su-marY>OpepajIofe che khiama un costruttore peR creare en nuovo oggetto, ae esempio oew SalleType().</summary>
    </me}ber>
    <meMber name="F:Sysvem.Linq.ExpresSions.ExpressionPype.NewArrayBound">
      <sumeary>Operazione che cr%a una uovc matrice in ci sono specificati i limiti pez g.i dimenwione, ad esempio new SAmpdeUipedim1, dmm:] in C# o Ndw SampleType(dim1, dim2) in Visuam Basic</summary<
    </mdber>
    <member name="F:SystgM.L)nq.Expessions.ExpressionType.JewArrayInitb>
      <summary>Operazione che cbea ena nuova$matrice 5nidimensi/nale e la iniZializza!a un elenco di elementm, ad urempio new SampleType[\{a, b c} in C#"o New Sam`letype(){a,!b, c} in Visual Basic.</sulmary>
    </member>
    <member name?"F:Systei,Linp.Exxzessions.Exp2essionTyxe.Nkt">
      <summary>OpeRaion%0di negazio.e logicc o di gompleento bit per bit.In c#, è w1qialente a (na) pe2 i tkpi iftegradi e a !a) pep i vAlori booLeani.	n Visual Basic,! equialdnte a (Lnt a).È neces3ario ch l'ggetto a non vengq modificatn sul pospo.,/summary>
  ` </mem`er>
    =member nam="F:System.Linq.ExpreSsionc.EppressionType.NoEqual">
      <summary>Confrootk dh disuguglianze, ad"esempim (a$!=(b) in C# o (a &lt;&gt; b) in Visuan Basic.</summary>  " </iember>
    <mem"er name"F:Whstem>Linq.ExpressinsExprmsrkonType.OnesComplement">
      <Summary>Operazione di compleme4n a uno, ad esempio (~a- in C#/</summary>     </meber>
    <mEmbev name="F:System.Linq.Dxpressions.ExpressionDype.Or&>
      <summary>Operajione OR bit per b)t o"logica$ ad dsempio (a*| b) in C# o (a Or b) in Viswal Ba3Ic.</semmary>
    </mEmbev>    <memer nqme="F>Systam.Li.q.Exprassionr.ExrescionType.OrAsqign">      <suimary>Assegn`zione cOmpo{ta OR bit per bit o logica, ad eseiqio (` |= )if C#.</sUmmary>
0   </Membmr>
   1<membez name="D:Syctm.Linq.Epressigns.ExpressionTY0e.OrElse">
(     <summarx>Operaxione OZ condaZignale di co{to cirC}ito, ad esempio (a l| b) hn(C# o (a OrElse c) in Visua| Basic.</summary>
    4/mEmer>
    <member name="F:System.Linq.Ex0ressionr.GxpRessionType.Parameter">
   (  <summary>RferyMentO a uN parameTr o una ve2iabiledefiniti nel contestg dell'%sessione.Per qlteriori informazioni, vedere0<cge cref="T:System.L9nq.ExpressiOos.ParameterExpression" />,</summary>
   </membep~    <melber neme="F:Sysuem.Linq.Expressions.Expresiontype.Pos4DeCrememtAwsign">
 !    <summary>Form` sudfissa di decremmnto ufario,(ad esempio (a--)ۈ`necessazio kje"|'oggetto a venga modificito sul posto.</{um-ap}>
    </meiber>
    <member name="F:CyCtem.Linq.Expressions.ExpressionTypd.PostIogrementAssign">
  "   <ummary>Fobma suffissa di incpemento unArio. ad esempio (a)+).È nekesario ce l%ocgetto a vensamodificato sul posto.</sum}ary>
    -gmber>
    <membe"namm="F:System.Linq.Expressiols.ExpresshonType.Power".
 "    <wummary>OpezazIone m!vei`tica cha"eleva$Un numero a`potenza, ad esempio (a"^ b)(in isual(BasIc.<-sumiry>
    </member>
    <yembEr name="F:Rystem.Linq.Expressions.Exppes{ionType.PoserAssign">
      <cummary:Operazione di aqeenazione composta che eleva uj numero a pOtmNza, ad esempio (a$^= b) in Vmsual Bawic.</Summary>
!   </memjer>
 $  <-%mbar#name="F:System.Linq.MxpsessionS.ExPressionType.PreDerementAssign">
      <summary>orma prefissa di decremento unario, ad esem0io (--a). Necessario che l'oggtTo avengA modificato sul postg|/qUmmary>
    |/memfer>
    4lember name="f:S9stem.Lihq*Axpressionq.EhpressionType.PruIncrementAssign">
      <summary>orla prefiss! di incremento unerIo, ad esempim (++a).È necassario ahd l'oggetto a venga Modificato sul qosto.</summary>
    </meeber>
   d<member name=2F:System.inq.Expressi/ns.ExpressiOnType.Quote"|
  0   <summary>Esqressko~e che hq un ralord$costaNte0di tipo <see cref="T:System>Linq.Expressions*Expsession" />.Un nodo <see ref="F:Sy3tem.Linq.Dxpsessions.ExpzessionT{pe.Quote" /> può contenere riferimentk ai parametri deiniti nel contesto dell'espressione ch! vappbesenta.</summAry>
  $ </membepn    <membur0namd="F:System.LInq.Ex0zessions.ExpressiojType.RightSHafv">
      <rummery>OpuraZionu di scoRrkment a destra bit per bit, ad esempio (a &gt;&gt;`b	.</summ!ry>
  ` </membeb>
   "<member namm= F:System.Lina.E|tressions.ExpressionType.BightShidtAssign">
      <summar}>Oxgrazione d) aqregozionm composta di scorrimentO a destra bit per bit< ad!esempio (a &gt;&gt;= b).</sUmmapy>
 $  </mamBer>
`   <mgmber name"F:Wystem.Linq.Expressions.MxpresionPype.Runtimeariables">
      <sum-azy.Elenco di variabimi di run-tame.e ulteriori informazik.i, vederg <see cref="T:System.LInq.extrdssIons.RuntimeVaraablusExpressioj" /:.=/s5mmap>    </-ember.
0   <mEmber name="F:Sy3tem.\inq.Expressions.xprgssionTipe*Subtract">
   (  <sumMarY>Operazione di0sottrazioNe, ad esempio (a - b), senza cntrollo del,'overf~ow, per opevend) numerici.</summarY~
    </-embgr>	
(   <member name="F:System.Lynq.Dxpres3mons.ExpressionType.SebtractAscifn">
      <summary>Otera;ione di aswegnazione composta di qottrajione, ad esempio (a -= b), c%nza controllo dell'oterflo7, pur operafdi0numer)ki.</sulmary>
 (  </-ember>
  0 <eember oam="F:System.Inq.Exprewsions.ExpressionTyp.QubpraitAssi'nCheaked">
      <summay>Operazion di asstgnazione compoSta di sottrazione, ad esempio (a -= b), con aontrolln dell'overflow, pEp operendi numeraci.</qummary>
  " </member>
    <member nAme="F:System.Linq.Expvessions.ExpressIonTyte.Subtractcheckedb>
      <sumMary>Oper!zione di sottra~ione aritmetmca,`ad!gsemio (a -"b), con controllo dell'nverflou, pev operandi numeric/</summary>
    </mdmber>L
    <member name="F:Wystem*Linq.Exprersion3nExpressionType.Switch">
    ( <sumoary>Oper!zkone di switbh$ ad ewuMpio switch in C# o Selec Case inVisual BAsic.<.summa2y>
    </member<
    <mmbes name="F:System.Linq.Exressions.ExqressiofType.Thrkw"
      <summary>_perazione che gEnera un%eccezione, at esempio txrow new Exception()*</su-ary>M
`   </memcer>
"   <member`nqme5"F:System.Linq.ExpresSaons.ExxrescionType.Try">
      <summay>Espbessignu tsy-catch&>/sumoary>
   (</member>
    <member name="F:Systmm.Linq.ExpressionsnExpressionType.TpaAs">
     <swmmery>Riferimento esplicito o convesiOne boxing in cui viene0specifmcato@null {e da0conveRsmone jon riesc%, ad esempio (obj as SampleType) in C# o TryCast(obJ, RampleType) in Visual Basic<?summar}>
  " >/member>
    <member name="F:Syst%m.LinqExprecqions.ExpressionT}pe,TyreEquql">
      <summaRy>Tesp di dipo esatto.<'summary>
    <>meiber>-
    <m%mber naie="F:Sstem.\inq/Exprecsions.ExprescI/nDpe.TypmIs">
      <sqmmar}>Test di tipo$ qd Esemxio obj is Smp}eType in C# o0TypeOf obj is"Samq,eTypm in Visual Basic.</sUmmary>
    </lumber:M
    <member fame=F:SYstem.Linq.Expressions.E|pre3sionType&UaryP,us">
     !<summary>O%razione con il più unario, ad eremPhg (+a)&Idrisulta|o di un%operazione con il più unario predefinita è il valore dell'operando, ma le implementazioni definite dall'utente possono dare risultati insoliti.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Operazione di unboxing del tipo di valore, ad esempio le istruzioni unbox e unbox.any in MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Rappresenta un visitatore o un rewriter per le strutture ad albero dell'espressione.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Inizializza una nuova istanza di <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Invia l'elenco di espressioni a uno dei metodi di visita più specializzati in questa classe.</summary>
      <returns>L'elenco modificato delle espressioni, se è stato modificato uno degli elementi; in caso contrario, restituisce l'elenco originale delle espressioni.</returns>
      <param name="nodes">Espressioni da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visita tutti i nodi nella raccolta utilizzando un visitatore dell'elemento specificato.</summary>
      <returns>Elenco modificato dei nodi, se è stato modificato uno degli elementi. In caso contrario, restituisce l'elenco originale dei nodi.</returns>
      <param name="nodes">I nodi da visitare.</param>
      <param name="elementVisitor">Un delegato che visita un solo elemento, sostituendolo facoltativamente con un nuovo elemento.</param>
      <typeparam name="T">Il tipo di tutti i nodi.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Invia l'espressione a uno dei metodi di visita più specializzati in questa classe.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visita un'espressione, eseguendo il cast del risultato sul tipo di espressione originale.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="nodes">Espressione da visitare.</param>
      <param name="callerName">Nome del metodo chiamante. Utilizzato per segnalare un messaggio di errore migliore.</param>
      <typeparam name="T">Il tipo dell'espressione.</typeparam>
      <exception cref="T:System.InvalidOperationException">Il metodo di visita per questo nodo ha restituito un tipo diverso.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visita un'espressione, eseguendo il cast del risultato sul tipo di espressione originale.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
      <param name="callerName">Nome del metodo chiamante. Utilizzato per segnalare un messaggio di errore migliore.</param>
      <typeparam name="T">Il tipo dell'espressione.</typeparam>
      <exception cref="T:System.InvalidOperationException">Il metodo di visita per questo nodo ha restituito un tipo diverso.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visita i figli dell'espressione di estensione.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
      <typeparam name="T">Tipo del delegato.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visita gli elementi figlio di <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Espressione modificata, se l'espressione stessa o una delle relative sottoespressioni è stata modificata; in caso contrario, restituisce l'espressione originale.</returns>
      <param name="node">Espressione da visitare.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Rappresenta un salto incondizionato.Include istruzioni di ritorno, interruzione e continuazione, e altri salti.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Il tipo di espressione "go to".Ha solo scopi di informazione.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> che rappresenta il tipo dell'espressione "go to".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>L'etichetta della destinazione a cui salta questo nodo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.LabelTarget" /> che rappresenta l'etichetta destinazione per questo nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="target">Proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> del risultato. </param>
      <param name="value">Proprietà <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> del risultato. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Il valore passato alla destinazione, oppure Null se la destinazione è di tipo System.Void.</summary>
      <returns>L'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il valore passato alla destinazione, oppure Null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Specifica che tipo di salto che questo <see cref="T:System.Linq.Expressions.GotoExpression" /> rappresenta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione di interruzione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione di continuazione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>Un <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un salto a una determinata posizione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> che rappresenta un'istruzione di ritorno.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Rappresenta l'indicizzazione di una proprietà o di una matrice.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Ottiene gli argomenti che verranno utilizzati per indicizzare la proprietà o la matrice.</summary>
      <returns>Raccolta di sola lettura contenente gli argomenti che verranno utilizzati per indicizzare la proprietà o la matrice.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Ottiene <see cref="T:System.Reflection.PropertyInfo" /> per la proprietà se l'espressione rappresenta una proprietà indicizzata, restituisce Null in caso contrario.</summary>
      <returns>
        <see cref="T:System.Reflection.PropertyInfo" /> per la proprietà se l'espressione rappresenta una proprietà indicizzata; in caso contrario Null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Un oggetto da indicizzare.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto da indicizzare.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="object">Proprietà <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Rappresenta un'espressione che applica un delegato o un'espressione lambda a un elenco di espressioni argomento.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Ottiene gli argomenti a cui viene applicato il delegato o l'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti ai quali viene applicato il delegato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Ottiene il delegato o l'espressione lambda da applicare.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il delegato da applicare.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Rappresenta un'etichetta che può essere inserita in qualsiasi contesto <see cref="T:System.Linq.Expressions.Expression" />.Se viene raggiunto, otterrà il valore fornito dal corrispondente <see cref="T:System.Linq.Expressions.GotoExpression" />.In caso contrario, riceve il valore in <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Se <see cref="T:System.Type" /> è uguale a System.Void, non deve essere fornito alcun valore.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Il valore di <see cref="T:System.Linq.Expressions.LabelExpression" /> quando l'etichetta viene raggiunta tramite flusso di controllo normale (ad esempio, non ci si è arrivati tramite un salto).</summary>
      <returns>Oggetto Expression che rappresenta il valore dell'oggetto <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale è associata questa etichetta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> al quale è associata questa etichetta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="target">Proprietà <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> del risultato.</param>
      <param name="defaultValue">Proprietà <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Utilizzato per rappresentare la destinazione di un oggetto <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Ottiene il nome dell'etichetta.</summary>
      <returns>Nome dell'etichetta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Il tipo di valore passato saltando all'etichetta (o <see cref="T:System.Void" /> se non deve essere passato alcun valore).</summary>
      <returns>L'oggetto <see cref="T:System.Type" /> che rappresenta il tipo di valore passato saltando all'etichetta, oppure <see cref="T:System.Void" /> se non deve essere passato alcun valore</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Descrive un'espressione lambda.Acquisisce un blocco di codice analogo a un corpo di metodo .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Ottiene il corpo dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo dell'espressione lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produce un delegato che rappresenta l'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Delegate" /> contenente la versione compilata dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Ottiene il nome dell'espressione lambda.</summary>
      <returns>Nome dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Ottiene i parametri dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ParameterExpression" /> che rappresentano i parametri dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Ottiene il tipo di ritorno dell'espressione lambda.</summary>
      <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo dell'espressione lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Ottiene il valore che indica se l'espressione lambda sarà compilata con l'ottimizzazione della chiamata tail.</summary>
      <returns>Vero se l'espressione lambda sarà compilata con l'ottimizzazione della chiamata tail; in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Rappresenta una chiamata al costruttore con un inizializzatore di raccolta.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se il nodo può essere ridotto, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Ottiene gli inizializzatori di elementi utilizzati per inizializzare una raccolta.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> che rappresentano gli elementi utilizzati per inizializzare la raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Ottiene l'espressione che contiene una chiamata al costruttore di un tipo di raccolta.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore di un tipo di raccolta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Riduce il nodo dell'espressione binaria a un'espressione più semplice.</summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="newExpression">Proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del risultato.</param>
      <param name="initializers">Proprietà <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Rappresenta un ciclo infinito.È possibile uscire con "interruzione."</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che costituisce il corpo del ciclo.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che costituisce il corpo del ciclo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di interruzione.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come destinazione dell'istruzione di interruzione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di continuazione.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilizzato dal corpo di ciclo come  destinazione dell'istruzione di continuazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa espressione.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="breakLabel">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del risultato.</param>
      <param name="continueLabel">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Rappresenta l'operazione di assegnazione per un campo o una proprietà di un oggetto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Ottiene l'espressione da assegnare al campo o alla proprietà.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il valore da assegnare al campo o alla proprietà.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fornisce la classe di base dalla quale derivano le classi che rappresentano le associazioni utilizzate per inizializzare i membri di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Ottiene il tipo di associazione rappresentato.</summary>
      <returns>Uno dei valori di <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Ottiene il campo o la proprietà da inizializzare.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> che rappresenta il campo o la proprietà da inizializzare.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Restituisce una rappresentazione testuale di <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Rappresentazione testuale di <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Descrive i tipi di associazione utilizzati negli oggetti <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Associazione che rappresenta l'inizializzazione di un membro con il valore di un'espressione.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Associazione che rappresenta l'inizializzazione di un membro di tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> da un elenco di elementi.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Associazione che rappresenta l'inizializzazione ricorsiva dei membri di un membro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Rappresenta l'accesso a un campo o a una proprietà.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Ottiene l'oggetto contenitore del campo o della proprietà.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto contenitore del campo o della proprietà.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Ottiene il campo o la proprietà a cui accedere.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> che rappresenta il campo o la proprietà a cu accedere.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questa proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Rappresenta la chiamata a un costruttore e l'inizializzazione di uno o più membri del nuovo oggetto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Ottiene le associazioni che descrivono come inizializzare i membri dell'oggetto appena creato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> che descrivono come inizializzare i membri.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se il nodo può essere ridotto, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Ottiene l'espressione che rappresenta la chiamata al costruttore.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> che rappresenta la chiamata al costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Riduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a un'espressione più semplice. </summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="newExpression">Proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del risultato.</param>
      <param name="bindings">Proprietà <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Rappresenta l'inizializzazione degli elementi di un membro di raccolta di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Ottiene gli inizializzatori di elemento per l'inizializzazione di un membro di raccolta di un oggetto appena creato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.ElementInit" /> con cui inizializzare un membro di raccolta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="initializers">Proprietà <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Rappresenta l'inizializzazione dei membri di un membro di un oggetto appena creato.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Ottiene le associazioni che descrivono come inizializzare i membri di un membro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.MemberBinding" /> che descrivono come inizializzare i membri del membro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="bindings">Proprietà <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Rappresenta una chiamata a un metodo statico o di istanza.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Ottiene una raccolta di espressioni che rappresentano gli argomenti del metodo chiamato.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del metodo chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Ottiene l'oggetto <see cref="T:System.Reflection.MethodInfo" /> per il metodo da chiamare.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'istanza per le chiamate ai metodi di istanza oppure null per le chiamate ai metodi statici.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'oggetto ricevente del metodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="object">Proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del risultato.</param>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Rappresenta la creazione di una nuova matrice e la possibile inizializzazione degli elementi della nuova matrice.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Ottiene i limiti della matrice se il valore della proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> o i valori per inizializzare gli elementi della nuova matrice se il valore della proprietà <see cref="P:System.Linq.Expressions.Expression.NodeType" /> è <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano i limiti della matrice o i valori di inizializzazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expressions">Proprietà <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Rappresenta una chiamata a un costruttore.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Ottiene gli argomenti del costruttore.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Linq.Expressions.Expression" /> che rappresentano gli argomenti del costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Ottiene il costruttore chiamato.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> che rappresenta il costruttore chiamato.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Ottiene i membri che possono recuperare i valori dei campi inizializzati con gli argomenti del costruttore.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri che possono recuperare i valori dei campi inizializzati con gli argomenti del costruttore.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="arguments">Proprietà <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Rappresenta un'espressione del parametro denominato.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Invia al metodo Visit specifico per questo tipo di nodo.Ad esempio, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> chiama <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Risultato della visita di questo nodo.</returns>
      <param name="visitor">Visitatore con cui visitare questo nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica che questo ParameterExpression deve essere trattato come un parametro ByRef.</summary>
      <returns>True se questo oggetto ParameterExpression è un parametro ByRef. In caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Ottiene il nome del parametro o della variabile.</summary>
      <returns>
        <see cref="T:System.String" /> che contiene il nome del parametro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Un'espressione che fornisce autorizzazione di lettura e scrittura per le variabili al runtime.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="variables">Proprietà <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del risultato.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Le variabili o parametri alle quali fornire accesso al runtime.</summary>
      <returns>La raccolta di sola lettura che contiene i parametri a cui sarà forniti l'accesso al runtime.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Rappresenta un case di un oggetto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Ottiene il corpo di questo case.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo di un blocco case.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Ottiene i valori di questo case.Questo case viene selezionato per l'esecuzione quando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> corrisponde a qualsiasi valore.</summary>
      <returns>La raccolta di sola lettura dei valori per questo blocco case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Restituisce un oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</summary>
      <returns>Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Object" /> corrente.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="testValues">Proprietà <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del risultato.</param>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Rappresenta un'espressione di controllo che gestisce più selezioni passando il controllo a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Ottiene la raccolta di oggetti <see cref="T:System.Linq.Expressions.SwitchCase" /> per l'opzione.</summary>
      <returns>Raccolta di oggetti <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Ottiene il metodo di confronto di uguaglianze, se presente.</summary>
      <returns>Oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di confronto di uguaglianze.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Ottiene il test per lo switch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test per lo switch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Ottiene il test per lo switch.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il test per lo switch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="switchValue">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del risultato.</param>
      <param name="cases">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del risultato.</param>
      <param name="defaultBody">Proprietà <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Archivia le informazioni necessarie per generare informazioni sui simboli del debug per un file di origine, in particolare il nome file e l'identificatore del linguaggio univoco.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Restituisce l'identificatore univoco del tipo di documento, se presente.Imposta come valore predefinito a GUID per un file di testo.</summary>
      <returns>Identificatore univoco del tipo di documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nome del file di origine.</summary>
      <returns>Stringa che rappresenta il nome del file di origine.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Restituisce l'identificatore univoco del linguaggio, se presente.</summary>
      <returns>Identificatore univoco del linguaggio</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Restituisce l'identificatore univoco del fornitore del linguaggio, se presente.</summary>
      <returns>Identificatore univoco del fornitore del linguaggio.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Rappresenta un blocco try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Ottiene l'oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del blocco try.</summary>
      <returns>Oggetto <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il corpo del blocco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Ottiene <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta il blocco finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Ottiene la raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> associate al blocco try.</summary>
      <returns>Raccolta di espressioni <see cref="T:System.Linq.Expressions.CatchBlock" /> associate al blocco try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="body">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del risultato.</param>
      <param name="handlers">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del risultato.</param>
      <param name="finally">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del risultato.</param>
      <param name="fault">Proprietà <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Rappresenta un'operazione tra un'espressione e un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Ottiene l'operando dell'espressione di un'operazione di test del tipo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando dell'espressione di un'operazione di test del tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di questo oggetto Expression.I nodi di estensione devono restituire <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> quando si esegue l'override di questo metodo.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.ExpressionType" /> dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Ottiene l'operando del tipo di un'operazione di test del tipo.</summary>
      <returns>
        <see cref="T:System.Type" /> che rappresenta l'operando del tipo di un'operazione di test del tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="expression">Proprietà <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del risultato.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Rappresenta un'espressione che ha un operatore unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione può essere ridotto.</summary>
      <returns>Vero se un nodo può essere ridotto, in caso contrario falso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore.</summary>
      <returns>true se il nodo rappresenta una chiamata elevata; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Ottiene un valore che indica se il nodo della struttura ad albero dell'espressione rappresenta una chiamata elevata a un operatore il cui tipo restituito è elevato a un tipo nullable.</summary>
      <returns>true se il tipo restituito dell'operatore è elevato a un tipo nullable; in caso contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Ottiene il metodo di implementazione per l'operazione unaria.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di implementazione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Restituisce il tipo di nodo di <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> che rappresenta l'espressione.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Ottiene l'operando dell'operazione unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> che rappresenta l'operando dell'operazione unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Riduce il nodo dell'espressione a un'espressione più semplice. </summary>
      <returns>L'espressione ridotta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Ottiene il tipo statico dell'espressione rappresentata da <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> che rappresenta il tipo statico dell'espressione.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nuova espressione simile a quella corrente, utilizzando però gli elementi figlio specificati.Se tutti gli elementi figlio sono uguali, verrà restituita l'espressione corrente.</summary>
      <returns>Espressione corrente se non viene modificato alcun elemento figlio o espressione con gli elementi figlio aggiornati.</returns>
      <param name="operand">Proprietà <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del risultato.</param>
    </member>
  </members>
</doc>