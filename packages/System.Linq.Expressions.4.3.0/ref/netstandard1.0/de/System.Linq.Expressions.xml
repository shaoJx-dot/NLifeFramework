<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Stellt das Ergebnis eines Sortiervorgangs dar.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Stellt das Ergebnis eines Sortiervorgangs dar.</summary>
      <typeparam name="T">Der Typ des Inhalts der Datenquelle.Dieser Typparameter ist Covariant. Das heißt, Sie können entweder den angegebenen Typ oder einen weiter abgeleiteten Typ verwenden. Weitere Informationen zu Ko- und Kontravarianz finden Sie unter Kovarianz und Kontravarianz in Generika.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Stellt Funktionen zur Auswertung von Abfragen für eine spezifische Datenquelle bereit, bei der der Datentyp nicht angegeben wurde.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Ruft den Typ der Elemente ab, die zurückgegeben werden, wenn die Ausdrucksbaumstruktur ausgeführt wird, die mit dieser Instanz von <see cref="T:System.Linq.IQueryable" /> verknüpft ist.</summary>
      <returns>Ein <see cref="T:System.Type" />, der den Typ der Elemente darstellt, die zurückgegeben werden, wenn die Ausdrucksbaumstruktur ausgeführt wird, die mit diesem Objekt verknüpft ist.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Ruft die Ausdrucksbaumstruktur ab, die mit der Instanz von <see cref="T:System.Linq.IQueryable" /> verknüpft ist.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die mit dieser Instanz von <see cref="T:System.Linq.IQueryable" /> verknüpft ist.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Ruft den Abfrageanbieter ab, der dieser Datenquelle zugeordnet ist.</summary>
      <returns>Der <see cref="T:System.Linq.IQueryProvider" />, der dieser Datenquelle zugeordnet ist.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Stellt Funktionen zur Auswertung von Abfragen für eine spezifische Datenquelle mit unbekanntem Datentyp bereit.</summary>
      <typeparam name="T">Der Datentyp in der Datenquelle.Dieser Typparameter ist Covariant. Das heißt, Sie können entweder den angegebenen Typ oder einen weiter abgeleiteten Typ verwenden. Weitere Informationen zu Ko- und Kontravarianz finden Sie unter Kovarianz und Kontravarianz in Generika.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Definiert Methoden zum Erstellen und Ausführen von Abfragen, die von einem <see cref="T:System.Linq.IQueryable" />-Objekt beschrieben werden.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Konstruiert ein <see cref="T:System.Linq.IQueryable`1" />-Objekt, das die Abfrage auswerten kann, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.IQueryable`1" />-Objekt, das die Abfrage auswerten kann, die von der angegebenen Ausdrucksbaumstruktur dargestellt wird.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
      <typeparam name="TElement">Der Typ der Elemente des <see cref="T:System.Linq.IQueryable`1" />-Objekts, das zurückgegeben wird.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Konstruiert ein <see cref="T:System.Linq.IQueryable" />-Objekt, das die Abfrage auswerten kann, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.IQueryable" />-Objekt, das die Abfrage auswerten kann, die von der angegebenen Ausdrucksbaumstruktur dargestellt wird.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Führt die stark typisierte Abfrage aus, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Der Wert, der aus der Ausführung der angegebenen Abfrage resultiert.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
      <typeparam name="TResult">Der Typ des Werts, der aus der Ausführung der Abfrage resultiert.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Führt die Abfrage aus, die von einer angegebenen Ausdrucksbaumstruktur dargestellt wird.</summary>
      <returns>Der Wert, der aus der Ausführung der angegebenen Abfrage resultiert.</returns>
      <param name="expression">Eine Ausdrucksbaumstruktur, die eine LINQ-Abfrage darstellt.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Stellt einen Ausdruck dar, der einen binären Operator aufweist.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Ruft einen Wert ab, der angibt, ob der Knoten der Ausdrucksbaumstruktur reduziert werden kann.</summary>
      <returns>True, wenn der Knoten der Ausdrucksbaumstruktur reduziert werden kann, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Ruft die Typkonvertierungsfunktion ab, die von einer zusammenfügenden oder zusammengesetzten Zuweisungsoperation verwendet wird.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, die eine Typkonvertierungsfunktion darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt.</summary>
      <returns>true, wenn der Knoten einen transformierten Aufruf darstellt, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt, dessen Rückgabetyp zu einem Typ transformiert wird, der NULL-Werte zulässt.</summary>
      <returns>true, wenn der Rückgabetyp des Operators zu einem Typ, der NULL-Werte zulässt, transformiert wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Ruft den linken Operanden der binären Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden der binären Operation darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Ruft die implementierende Methode für die binäre Operation ab.</summary>
      <returns>Ein <see cref="T:System.Reflection.MethodInfo" />, der die auszuführende Methode darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduziert auf den binären Ausdrucksknoten auf einen einfacheren Ausdruck.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Ruft den rechten Operanden der binären Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden der binären Operation darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="left">Die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft des Ergebnisses. </param>
      <param name="conversion">Die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft des Ergebnisses.</param>
      <param name="right">Die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Stellt einen Block mit einer Sequenz von Ausdrücken dar, in dem Variablen definiert werden können.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Ruft die Ausdrücke in diesem Block ab.</summary>
      <returns>Die schreibgeschützte Auflistung, die alle Ausdrücke in diesem Block enthält.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Ruft den letzten Ausdruck in diesem Block ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den letzten Ausdruck in diesem Block darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.BlockExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="variables">Die <see cref="P:System.Linq.Expressions.BlockExpression.Variables" />-Eigenschaft des Ergebnisses. </param>
      <param name="expressions">Die <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Ruft die in diesem Block definierten Variablen ab.</summary>
      <returns>Die schreibgeschützte Auflistung, die alle in diesem Block definierten Variablen enthält.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Stellt eine catch-Anweisung in einem try-Block dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Ruft den Text des catch-Blocks ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Text des catch-Blocks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Ruft den Text des <see cref="T:System.Linq.Expressions.CatchBlock" />-Filters ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Text des <see cref="T:System.Linq.Expressions.CatchBlock" />-Filters darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Ruft den Typ der <see cref="T:System.Exception" /> ab, die von diesem Handler abgefangen wird.</summary>
      <returns>Das <see cref="T:System.Type" />-Objekt, das den Typ der <see cref="T:System.Exception" /> darstellt, die von diesem Handler abgefangen wird.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Gibt einen <see cref="T:System.String" /> zurück, der den aktuellen <see cref="T:System.Object" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.String" />, der den aktuellen <see cref="T:System.Object" /> darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="variable">Die <see cref="P:System.Linq.Expressions.CatchBlock.Variable" />-Eigenschaft des Ergebnisses.</param>
      <param name="filter">Die <see cref="P:System.Linq.Expressions.CatchBlock.Filter" />-Eigenschaft des Ergebnisses.</param>
      <param name="body">Die <see cref="P:System.Linq.Expressions.CatchBlock.Body" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Ruft einen Verweis auf das von diesem Handler abgefangene <see cref="T:System.Exception" />-Objekt ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekt, das einen Verweis auf das von diesem Handler abgefangene <see cref="T:System.Exception" />-Objekt darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Stellt einen Ausdruck dar, der über einen bedingten Operator verfügt.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Ruft den Ausdruck ab, der ausgeführt werden soll, wenn der Test false ergibt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Ausdruck darstellt, der ausgeführt werden soll, wenn der Test false ergibt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Ruft den Ausdruck ab, der ausgeführt werden soll, wenn der Test true ergibt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Ausdruck darstellt, der ausgeführt werden soll, wenn der Test true ergibt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Ruft den Test der bedingten Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Text der bedingten Operation darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="test">Die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft des Ergebnisses.</param>
      <param name="ifTrue">Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft des Ergebnisses.</param>
      <param name="ifFalse">Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Stellt einen Ausdruck dar, der über einen konstanten Wert verfügt.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ConstantExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Ruft den Wert des konstanten Ausdrucks ab.</summary>
      <returns>Ein <see cref="T:System.Object" /> gleich dem Wert des dargestellten Ausdrucks.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Gibt einen Sequenzpunkt für Debuginformationen aus oder löscht ihn.Dadurch kann der Debugger beim Debuggen den richtigen Quellcode hervorheben.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> ab, die die Quelldatei darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, die die Quelldatei darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Ruft die Endspalte dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Endspalte des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Ruft die Endzeile dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Endzeile des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Ruft den Wert ab, mit dem angegeben wird, ob <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts verwendet wird.</summary>
      <returns>True, wenn die <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> zum Löschen eines Sequenzpunkts verwendet wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Ruft die Startspalte dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Anfangsspalte des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Ruft die Startzeile dieses <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> ab.</summary>
      <returns>Die Nummer der Anfangszeile des Codes, mit dem der umschlossene Ausdruck generiert wurde.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Stellt den Standardwert eines Typs oder eines leeren Ausdrucks dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.DefaultExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Stellt einen Initialisierer für ein einzelnes Element einer <see cref="T:System.Collections.IEnumerable" />-Auflistung dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Ruft die Instanzmethode ab, die zum Hinzufügen eines Elements zu einer <see cref="T:System.Collections.IEnumerable" />-Auflistung verwendet wird.</summary>
      <returns>Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Instanzmethode darstellt, die einer Auflistung ein Element hinzufügt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Ruft die Auflistung von Argumenten ab, die an eine Methode übergeben werden, die einer <see cref="T:System.Collections.IEnumerable" />-Auflistung ein Element hinzufügt.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente für eine Methode darstellen, die einer Auflistung ein Element hinzufügt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Gibt eine Textdarstellung eines <see cref="T:System.Linq.Expressions.ElementInit" />-Objekts zurück.</summary>
      <returns>Eine Textdarstellung des <see cref="T:System.Linq.Expressions.ElementInit" />-Objekts.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Stellt die Basisklasse bereit, aus der die Klassen abgeleitet werden, die die Knoten in der Ausdrucksbaumstruktur darstellen.Sie enthält auch static-Factorymethoden (Shared in Visual Basic), um die verschiedenen Knotentypen zu erstellen.Dies ist eine abstract Klasse.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Erstellt eine neue Instanz von <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise ruft <see cref="T:System.Linq.Expressions.MethodCallExpression" /> die Methode <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> auf.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition ohne Überlaufprüfung darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Additionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Addition mit Überlaufprüfung darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Additionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen AND-Vorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.And" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen AND-Vorgang darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.And" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten AND-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als true ausgewertet wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="left" />.Type und <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bedingte AND-Operation darstellt, bei der der zweite Operand nur ausgewertet wird, wenn der erste Operand zu true aufgelöst wird.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise AND-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="method" /> ist null, und <paramref name="left" />.Type sowie <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise AND-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, um auf ein mehrdimensionales Array zuzugreifen.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="array">Ein Ausdruck, der das mehrdimensionale Array darstellt.</param>
      <param name="indexes">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit Ausdrücken, die zum Indizieren des Arrays verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, um auf ein Array zuzugreifen.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="array">Ein Ausdruck, der das zu indizierende Array darstellt.</param>
      <param name="indexes">Ein Array mit Ausdrücken, die zum Indizieren des Arrays verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die das Anwenden eines Arrayindexoperators auf ein Array mit einem Rang größer als eins darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft festgelegt werden soll.</param>
      <param name="indexes">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> oder <paramref name="indexes" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type stellt keinen Arraytyp dar.- oder - Der Rang von <paramref name="array" />.Type entspricht nicht der Anzahl der Elemente in <paramref name="indexes" />.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines oder mehrerer Elemente von <paramref name="indexes" /> stellt nicht den <see cref="T:System.Int32" />-Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Anwenden eines Arrayindexoperators auf ein Array mit Rang eins darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="index">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> oder <paramref name="index" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type stellt keinen Arraytyp dar.- oder - <paramref name="array" />.Type stellt einen Arraytyp dar, dessen Rang nicht 1 ist.- oder - <paramref name="index" />.Type stellt nicht den <see cref="T:System.Int32" />.Type dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die das Anwenden eines Arrayindexoperators auf ein mehrdimensionales Array darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="array">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Instanzen - Indizes für den Arrayindizierungsvorgang.</param>
      <param name="indexes">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> oder <paramref name="indexes" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type stellt keinen Arraytyp dar.- oder - Der Rang von <paramref name="array" />.Type entspricht nicht der Anzahl der Elemente in <paramref name="indexes" />.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines oder mehrerer Elemente von <paramref name="indexes" /> stellt nicht den <see cref="T:System.Int32" />-Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen Ausdruck zum Abrufen der Länge eines eindimensionalen Arrays darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft gleich <paramref name="array" /> ist.</returns>
      <param name="array">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type stellt keinen Arraytyp dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, das die Initialisierung eines Felds oder einer Eigenschaft darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, bei dem <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> gleich <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Ein <see cref="T:System.Reflection.MemberInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> oder <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Die durch <paramref name="member" /> dargestellte Eigenschaft verfügt über keinen set-Accessor.- oder - <paramref name="expression" />.Type kann nicht dem Typ des Felds oder der Eigenschaft zugeordnet werden, das bzw. die durch <paramref name="member" /> darstellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, das die Initialisierung eines Members durch Verwendung einer Eigenschaftenaccessormethode darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberAssignment" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist.</returns>
      <param name="propertyAccessor">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> oder <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Die Eigenschaft, auf die von <paramref name="propertyAccessor" /> zugegriffen wird, verfügt über keinen set-Accessor.- oder - <paramref name="expression" />.Type kann nicht dem Typ des Felds oder der Eigenschaft zugeordnet werden, das bzw. die durch <paramref name="member" /> darstellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BlockExpression" />, die die angegebenen Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="variables">Die Variablen im Block.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="variables">Die Variablen im Block.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BlockExpression" />, die zwei Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="arg0">Der erste Ausdruck im Block.</param>
      <param name="arg1">Der zweite Ausdruck im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das drei Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="arg0">Der erste Ausdruck im Block.</param>
      <param name="arg1">Der zweite Ausdruck im Block.</param>
      <param name="arg2">Der dritte Ausdruck im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das vier Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="arg0">Der erste Ausdruck im Block.</param>
      <param name="arg1">Der zweite Ausdruck im Block.</param>
      <param name="arg2">Der dritte Ausdruck im Block.</param>
      <param name="arg3">Der vierte Ausdruck im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das fünf Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="arg0">Der erste Ausdruck im Block.</param>
      <param name="arg1">Der zweite Ausdruck im Block.</param>
      <param name="arg2">Der dritte Ausdruck im Block.</param>
      <param name="arg3">Der vierte Ausdruck im Block.</param>
      <param name="arg4">Der fünfte Ausdruck im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BlockExpression" />, die die angegebenen Ausdrücke und keine Variablen enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Ausdrücke enthält, nicht über Variablen verfügt und von einem bestimmten Ergebnistyp ist.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Blocks.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Blocks.</param>
      <param name="variables">Die Variablen im Block.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Variablen und Ausdrücke enthält.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Blocks.</param>
      <param name="variables">Die Variablen im Block.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BlockExpression" />, das die angegebenen Ausdrücke enthält, nicht über Variablen verfügt und von einem bestimmten Ergebnistyp ist.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Blocks.</param>
      <param name="expressions">Die Ausdrücke im Block.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Break-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break", die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und ein NULL-Wert beim Springen an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Break-Anweisung darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine Break-Anweisung mit dem angegebenen Typ darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine Break-Anweisung mit dem angegebenen Typ darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Break" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die keine Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzmethodenaufruf angibt (übergeben Sie null für eine static-Methode bzw. in Visual Basic eine Shared-Methode).</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist null.- oder - <paramref name="instance" /> ist null, und <paramref name="method" /> stellt eine Instanzmethode dar.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type kann dem deklarierenden Typ der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> und <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft festgelegt werden soll. Übergeben Sie null für eine static-Methode (Shared in Visual Basic).</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist null.- oder - <paramref name="instance" /> ist null, und <paramref name="method" /> stellt eine Instanzmethode dar.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type kann dem deklarierenden Typ der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.- oder - Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die durch <paramref name="method" /> dargestellte Methode überein.- oder - Mindestens ein Element von <paramref name="arguments" /> kann nicht dem entsprechenden Parameter der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die zwei Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzaufruf angibt.(Übergeben Sie NULL für eine statische Methode bzw. eine Shared-Methode in Visual Basic.)</param>
      <param name="method">Das <see cref="T:System.Reflection.MethodInfo" />, das die Zielmethode darstellt.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die drei Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzaufruf angibt.(Übergeben Sie NULL für eine statische Methode bzw. eine Shared-Methode in Visual Basic.)</param>
      <param name="method">Das <see cref="T:System.Reflection.MethodInfo" />, das die Zielmethode darstellt.</param>
      <param name="arg0">Das <see cref="T:System.Linq.Expressions.Expression" />, das das erste Argument darstellt.</param>
      <param name="arg1">Das <see cref="T:System.Linq.Expressions.Expression" />, das das zweite Argument darstellt.</param>
      <param name="arg2">Das <see cref="T:System.Linq.Expressions.Expression" />, das das dritte Argument darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode darstellt, die Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> und <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="instance">Ein <see cref="T:System.Linq.Expressions.Expression" />, das die Instanz für einen Instanzmethodenaufruf angibt (übergeben Sie null für eine static-Methode bzw. in Visual Basic eine Shared-Methode).</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> ist null.- oder - <paramref name="instance" /> ist null, und <paramref name="method" /> stellt eine Instanzmethode dar.- oder - <paramref name="arguments" /> ist nicht gleich null, und mindestens eines der darin enthaltenen Elemente ist gleich null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type kann dem deklarierenden Typ der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.- oder - Die Anzahl der Elemente in <paramref name="arguments" /> stimmt nicht mit der Anzahl der Parameter für die durch <paramref name="method" /> dargestellte Methode überein.- oder - Mindestens ein Element von <paramref name="arguments" /> kann nicht dem entsprechenden Parameter der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, die einen Aufruf einer Methode durch das Aufrufen der entsprechenden Factorymethode darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MethodCallExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> ist, die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft gleich <paramref name="instance" /> ist, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> auf die <see cref="T:System.Reflection.MethodInfo" /> festgelegt ist, die die angegebene Instanzmethode darstellt, und <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> auf die angegebenen Argumente festgelegt ist.</returns>
      <param name="instance">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaftswert nach einer bestimmten Methode durchsucht wird.</param>
      <param name="methodName">Der Name der Methode.</param>
      <param name="typeArguments">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typparameter der generischen Methode angeben.Dieses Argument muss NULL sein, wenn durch methodName eine nicht generische Methode angegeben wird.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, das die Argumente der Methode darstellt.</param>
      <exceptinn cref="T:ystem.ArgementNullException">M
      $<raramref name="instaoc" /> o`ur >Parambef name="mmtlodNAme" />0irt null.</exc%ption>
     !<exgep<ion cref="T:System&IlvalifOpErationException&>ES wu2dE k%ine Methode, deren Namen eleich <paramref name=&methodName" /> ist, dezen Typparameter <paramref n`me=*tipeArguments" /> entsprechen uld(deren Parametartypeo <paramref name="arguoents" /> entspsechen, in <aramvEf name="instance" />.T{pe ode0 ihrer!asistypen gefundEn.% odgr - Es wurde mehr als eine Methode, deren NAmen glea#h <paRamref lam%="methodNam%" . ist- gren TyparameTer <paramref namg="typeAzgume~ts" /> entsprechen und deren Parametrtypen <paramref name="arfuments" /: entsprechef, in <paraoref0nam="instance" />.Type odar ihrer Basystypgn ge&unden.</gxkettion>
0  </meeber>
    <membmr nam%="M:System.Linq.Expressions.Eypression.Call(Systum.Reflection.Met`odInfo,Systei,Cohlectins.Generic.IE~umerable{Sysvem.Hinq.Expressions.Exprewsion})">
      <summarq>Erstellt eine <see cref="T:Sysem.Linq.Expressi/ns.MethodCAllExpress)o." />, die einen Aufruf eIner statirchen Methode (Shared in ^isUah Basic) darwtellt.<osummasy>
      <retUrn3>Ein <see cref="T:System.Linq.Expressions.MethOdCAllExpression" />, bei Eem die <see cref="P:System.Linq6Expresso~s.Expvession.NodePype" />-Digenschaft gleich <seecref="F:QysTem.Linp.Expr%ssions.Mxpjes{ionType.Aall" /> irt`und die <see cref="P:System.Linq.Dxpres3ions.MethodCallExprecsion.Objekt" '>-Eigenschafd sow`e Die <see cref="P:System.Linq.ExprdssIons.MethotCallExpressO..Mdthod" />-Eigenschaft auf Die angegebenen Wertg Nestgelegt sind</retrns.
  "   <taram fame"method">Tas <see cref="T:System.Refektion.MethodInfo" />l las $ie kalmetho$e $ar{tdllt.</param>
      <param name="arguMents">Ain"Auflistung von <seEcRef=*T:Cystem.Linq.xpressions.Expression"$/>, die eie Aufrun`rguMente darste|lt.4/param>
    <omember>
    <member name="M:System.Linq.Exprescions.Expressi/n.Call(Rystem.Reflection.MethotIfO,System.L)n1.expressons.Expression)&>
      <summarq>Grstellt eine <see cref="T:System.LiNq.Expresioos.mdthodCallExpression" />, die %inen Aufrwf einer wtatic-Method} (Shared in Visual Basi#) mit einem0argument dastellt.</summary>
      <rdturls>Ain <sea cref="TSxstem.Linq.Expressi/ns.Met(odCallExpre{sion"!/>, bei dem die <sde cref="P:Syrtem.Linq*Expressions.Expression.NodeTpe" />-Eigenschaft gmeich <wae cref="F:System.Lyoq.Expressions.ExpresrionTypu.Call" /> ist und die <wee cref="P:System.linq.Exqressions*MethodCaldExrression.Object  /:-Eigenchaft sowie die!<se cref="P:System.Linq.Expressions.MethodCallExpression.Method" />-EIwenschaft af die angegebenen Werte!festgadegt sind.</returnr>
      <pavam nam%="oethod">Ain <see cREf="T:Systm.Reflectikn.MethodInfc# />, auf lis die <qee cref="P:System.Linq.Expressions.Met(odCallExrression.Method" '>-Difenschaft festgelegt werdun soll.</param>
    ! <param$nama=&arg0">Das <3ee cref<"T:Systel.\in1.ExPre3sions.Expression" /, das das erste Argumeft darstellt.</param:*      <!hcePtion crEf="T:System.rgumentNullExcupthol":
        <paramreg name<"mehod" /> i{t NUNL.</xceptIon>
    </member>
    <oember name="M:System&LinQ.Ex`ressions.ExpRessio~.Call(System.Reflection.MethodInf/(S9stem.Ninq.Expressions.Expression,Syste-.Linq.ExxressiofsExpression".      <summary>Erstedlt"eine <see cref="T:System&Linq/Expressions.MethdCqllExpression" />, die einen Aufruf einer statirchdn ]etode darstellt, die zwEi Argumende akzepdiert.<?summary>
      =rettrns>Ein <see cref="T:Syuem.Lilq.Expressions.MethodCallExpression  />, fei dem lie <see Cef="P:System.Linq.ExpsesSions.Expression.NodeType" />-Eigenschaf glEich <qea cref="F:System,lIq&Expressions.ExpressionT{pe.C`lh" /> ist uNd$die >see cref= P:SystgM.Linq.Expressions.EthodCamlExpressionObjmct" +>-Eigeschaft sowie die <see cref=P:System.Linq.ExpresshonS.MethodCallExpression.Method" />-Eigenschaft aufdie angegebanen Werte vestgelegt sind.</returns>
      <parum .ame="medhod">Ein <cee cred="T:Systel.Reflestion.Me4hodInfo" />, auf dac die 8see cref="P:Systum.Linq.Ezpressions.MethodCallExprEsqyon.Method" />-Eigenschaft festgelegt werden soll.</paral>
      <param nme="irg0#>Das <see cref="T:Syctem.Lin.Expressions.Exprssion" />, das das(erste @rgument darstallt.>/pirm>
      <param name="arg1">Daq <see sref=T:Wystem.Linq.ExpressionsExpression" />, daq das {weie Argument da2wtellT.<+parae>      <exseption cref="T:Syztem>@vgumentNullException">
        raramref name=mthod* /> iu NULL.</exception>
    </member>
    <membe2 nade="O:Sy3tem.\inq.Exressins.Exp2essioj.Call(System.Reflection.MethodInfo$Sy3tem.Lina.ExprEssions.Expression,System.Lin.Expressions.Expression,S}stem.Linq.Expressions.Expression)">
     `<summary>Erspellt uine <see cvef="T:System.Linq.Expressiofq.MethodCadlExXress)on# />, die einen Aufuf einer stetischen$Methkde dabstellt, die drei Argumente akzeptiert.</summary>
      <returs>Ein <see cref=":System.,inq.Expressions.MethodCallE8presion" /n, bei deo die <see cref="P:System.Linq.Exprssions.Exprdssion.NkdeType" />-Eigenschaft edeiah <see cref="F:Sysdem.Linq.Expre3saosnExxressionType.Ccll" />"ist und die <see cref="P:System.Linq.Gxpressimns.MethodCallExpressio.Object2 />-eigel3chant sowie ie see cref="P:System.L)nq.Expressions.MethodCallDxqression.Methd" />-Eigenschaft auf die angegebendn Werte festgelegt sind.</returns<
    ` <param ncme-"method">Ein <seecref="t:Sxstem.Reflection.MethodInfo""/>, auf das diE <see kref="P:SystEm.Linq.Expressions.MethodCallExpresskon.MDthnd" />-EigensChaft festgelegt werden soll.</param>
     <para- name="arg0&>Das <see cref="T:System,Linq.E|pressions.EXpression" /<, das das er{ve ArguenT darstellt.</param>
    ( <param name=&arg1">Das <3ee cv%f="T:System.Linq.Expressigns.Exprgssion" />- das$das!zweide Argtment artell4.>/parqm>
` `(  <param name="arg2">Das <sae cref="T:Syc|m.Linq.Expressions>Expression" /~, das"das drittE,Argument darstellt.</parao>
      <exception cref="T:System.Az'umentNuLlException">
        <paramrgf name="method" /> ist NULL.</eyception>
   </ember>
 "  <member name="M:QysTem.Linq.Epressions.|pression.CalL(System.Reflection.MethodIjfo,SystemLinq.ExpressIons.Expession,System>Linq.Ex`vessions.ExPreSsionlSystem.Linq.Exppessions.Exqressioj,System.Linq.Expressioos.Expressiol) >
      <sumlary>Erstellv eine <see crEf="T:System.Linq.Expressions.Met`odCallExpbescion" />, die einen Aufruf iner stAtischen M%thode darsvellt, die(Vier Argumente akePt)ert.</sulmary>
      <raturns>Ein!<Sde cref="T:System.Lijq.Expressions>MeThodCallExpressiol" />, bei dem die!<seE cref="P:Syspem.NHnq.Eppressions.Dxpression.NodeType" />-Eigenschaft gleich <see creb="F:W9stemLinqExpressions.ExpressignType/Cqll" /> ist u~d die <see cref="PSistem.Linq.Expressions.MethodCallExpressioN.Object" />-Eigenschaft sowie die <See cref="P:System.Linq.Expressio.s.MethodCallExpReusion.Method" />-Eiwenschaft auf dIe angewebenen Wrte fdstgdlegt sind.</ret}rns>
    " <`aram name="method">Ein <see crdf="E:SYstEm.reFlectio..Meth'dInfo" />, auf das die <sed cref?"P:Systel.Linq.Expressions&MethoCallExpression.Method" />-EigeNschaft festgelegt werden snll.</param>M
      <param namu="arg">Dds!<see cref"T8Syqtem/Linq.Expressikns.Exrression" />, das das erste argument darstel|t.</param>
      <param name="arg1":Tas <cee cref="T:Syctam.Lin.Expressions.Expressio~" /?, $as das zweite Argument dasste|lt.</0aram>J     !<param la}e=argr"Das <see"cref="TSystem.Linq,Eypresi/ns.Expressionb />, das da{ dritte Arguoenv darstellt.>/param>
      <param`n`me="arg3">is <see$cpeg="T:SY{tem.LiNq.Expressions&ExprEs{ion" />, das $as0vierte Argumund darstellu.</paral>M
     <exceptionkref="T:Cystem.ArgumentNullDxcextion >
        <parmref name="methnd" /> isd NULN.<'exception>   "</mmmbgr>
    <membern!me="M:System.Linq.Expsessions.Exprespion.Call(System.Reflection.MethodInfo,System.Minq.Ax`ressions.D|pressionSystem.LinqnExpressions.ExpressioL,System.Linq.Expresrions.Expression,S{stam.Linq.Expres3ions.Expression,System.Linq.Expressions.Expression)">
      <s}mmary>Erstllu eine <see Cref="T:S9stem.Linq.Ezpressions.MethodcallExprgssimn  />, die einen Aufruf emnes statischen Methode darstellt, die fýnf Argumente akzeptert.</summary>
 0    <return3>Ein!see Creg=":Siqpem.Lanq.Expressiols.Met(odKalLExpressioN" />, bei$dem die`<see cref="P:System.Linq.Express)ons.Ex ression.NkdeType" /:-EigenqchafT"gl%ich <see cref="F:Sy3tem.Linq.Expressionw.E\psessionType.Canl" /> ist und$dIe <sde cref=2P:Sysvem.Linq.Ezpressions.MethodCcllExprEssiol/Objecp" />-Eigunschaft sowie dke <seu kruf= P:System.Linq.Expressions.MethodCallE8pression.Method" />-Eienschaft awd die angegebenen Weste festgalegt wind.</retubns>
      <param name="iephod">Ein <see cref="V:System.Reflecthon.MethodInfo" />,auf das die(<see cref="P:System.Linq.Expressions.MethodCallE|precsion.Methodb />-Eignscjaft festgelegt wmrden {oll.</param>
      <param name="ar'0">Das <sEe cref="T:System.LInq.Expses{ions.Expression" />, da{ $as ersta Argtment darstel,t.</param>
      <param nAme="arg1".Das <see cref="T>Sy2temnLilu.Expressions.Expression" />( das das ~weite!Arume.t darstellt.</param>
      <parai name=arg2">Das <see cref="T:System/Linqnexpzessions.Exrrdssinn" />, dAs das drItte Arfumunt darstellt.</paRam>
    ` par!m oame="qrg3">Fas <see cref="T:System.LInq.Exp2essionsnE8pression"`/>, das daS vkerte Argument darse|lt.</pabam>
   (  <param .ame=&arg4">Das <see"cRuf="T:Sy{de-.Linq.Exqressions.Ex0russion" ?>, das dasfünfde Argumnt`larstellt.</param>
      <exception cref"T:SysTei.CrgumentNullExaettion">
       (<pa2amref name="methd2 o> ist NULL.</ex#eption>
    </member>
    <meMber name=&M:Systm.Linq.Eypressions.Expression.Cadl(ystem.Reflection.MethodInfo,System.LinplExpressions.Epprewsin[])">
      <summ`ry>Erstelt eiN <see cref"T:System.Lijq.Expressions*MethodCallExpression" />, die"eInen Aufrug einar static-Methkde (Shared in Visual Basmc) mit Argwmenten darstellt.</semmary>
`     <returns:Ein <see crgf="T:C}stemnLinq.Expbessions.MethodCalLExpression" />, bei dem die <see cref="P:Sys4em.Linq,Expressions.Expression.^odeType" /-Eigefschaft oleigh <see cref="n:System.LinQ.Exyressions.ExpressionType.Call" /> ist ud(die <see crdf="P:System.Linq.Expressimns.MethmdCalLUxpresqion.Method" />-EigenSchaft sowye die <see cref}*PSystem.Lin.xpre{sionq.MethmdCallEypresqion.A2gwments" />-Eigenschaft auf diu angugebenen Werte festgeL`gt(sind.</returnc>
    ` <papam name="method">Ein <see cref="T8System.Reflection.MethodAnfo" />, die eine"static-Metxodg Rhared in isuel Ras)c) darstelt. auf eie die <see cref="P:Syste-.Linq.Expressions.MethodallExpression/gtlod" />Eigens#haft fes4welegt werden solln</param>
      <qaram name-"argumefts">Min Array von <see cred="T:System.Linq.Expressions.Expresqin"$/>-Objektgn, mit deNen die <see cr%f="P:System.inq.Epreshons.MmthodCallExpression.@rguments" /6-Auflis4ung aufgefÜllt uird.<opar!m>
      8exceptio cref="T:[ystem.@rgumentNullExcption">
        <paramref ~ame="method" />0ist null.</xception>
(     <exceptikn craf="T:System.ArgumnTException">D)e Anzahl der lemente in <pavamref name="argumenps" /> stimmt nIcht mit eer Anz!hl der P`rameter`für die durcH <paramre&!name="metol" /> dargastellte Methode(überdIn.- kder - ]indestens ein"Element von <pcramref name="argueents" > kann nicht dem entsprechenDen Papameter der dusch <paramref$name="method" /> dargestelnen Methnde zugeordnet wdrden.<+exseption
    </melber>
 $  member n!me="M:S{stem.Lioq,Expressionw.Ehpression.Call(System.Type,System.Strinc,System.Txpe[],Sqstem.Linq.Exprussinns.Expression[])">
      =zummary?Erstellt eine <sde #ref=T:System.Linq.exPressions.MethodCallExpre{sion  />, die einen Aufrqf einer static-Methode (Shared in Visual Basic) durch das Aufrufen der entwbrechenten Factorymethode derstallt.<suMmery>
      <returns>Eine <see cref="T:Syste-.ioq.Expressions.iethodCallExpression" />, bek dmr fie <see cref="P:Systmm.Linq/Expressyons.ExpressIon.NodeTye" /:-Eigenschaft gleich <see cref="F:Sy3tem.Linq.Expvessions.E(pressionType.Call" /> istl die <see!cref"P:System.Linq.Expsessions>MethodCallExpression.Meth/d" />-Eigensciaft iuf die <see cref="T:Sy3el.Reflecpion.Me5hgdInf  >> Festgelegt ist, diedie engegebene static)Lethodd (Shared in Visual Ba{ic) darstellT, und die <se% cref="P:System.linq.Expr%ssions.e4hodCallExpresSion.Arguments" />-Eigenscheft auf die anGegebenen ArgumenTe festgalegt ist.</returns>
    $ <param name#type#>Der <see gref="T:Systo.Type" />, der den Typ angibt, der die anwegebene ptatic-Methode (WharE$ in Visual Bcsic) enthält</param>
      <pa2am name"methodName"<Der Name der Methode.</param>
      <param nam%="typArguments2Uin Array von <see cref="T:Syst%m.yPa" />-Objekten, die dim TyppabAmeter der generirchen Mepho$d angeben.DiesesArgument muss NuLL sein, wenn dubch ethodNam %ine niht 'enerische Methode angegeben(ward.</paRam6
      <para- name=&arGuments">Ein Array ron <se cre="T;Sysvm.Lins.Expresions.Eppresqion" />-Objakten, das die Argumente der Methode darstel|t.</pram~
    ` <exception cref="T:System.AreementNqllExbeption">)
        <paramref name="type" /> oder <paramref naoe="methodName" -> ist nulL.</excepvion>
      <exceptiOn cref=T:ystem.IovelidOperationException">Es wurdg +eine Me|hode, desen Namen fleich <paramref name="mathdName" /> ist, deren \Ypparameter <`aramreb`~ame="tyxeArwuments" />$entsprgchen unf deren0PaRametertypen <tarairef naie="arguments2 /> entSprechen, in >paramref name="type" /> oter seinen BAsistypgn genunfen.- oder % Ds wup`e mehr als eijm Methode,(deren Namen gleikh <paramsef nAme="methodname" /> ist, depen Typparameter <paramref name="typeAgumelts" /> entsprechen und deren Xarametertypen <parairef name="abgume~ts" /> mntspzechen, in <paramref l`me="txpe" />oder seinen Ba{istypen gefunfenN</excEption>
    </member>
    membgr name="P:Cystem.Linq.Ehpbessikns.Expression.C`nReduCe">
      <sumaby>Gibt an, dass der 	noten(zu eNem einfaCheren Knoten reduZierp weRde kann&Wenn true zurüCkgegEben wiRd, kann Rdduce()0aufgerufen wmrden, um dcs 2eduzidrte Formumar zU erzeugen.</summary>
      8returns<Tbue, wen~ der Ojoten ed}zierv werden kann, andernfadlc False.>/rgturns>
    </member>
    <memrer namm="M:System.\inq.Expressions.Ezpressimn.Catch(System.Linq.Exrressons.ParqmederExpreSsion$Sys|em.ynq.Expbessions.Expression)">M
 "    <summaryerstellt einen <see cref="T:System.Linq.Dxpressi/ns.Cat#hBlock" />, der %iNe"F!tchmAnweisung mit einem(Verwei{ a}f das af'efangene <see cref="T:System.Exception" />-Nbjekt zur VeRwendung im Handlertext dArstellt.</summary>
     <returNs>Der erstellta <see cref="T:Systel/Linq.Expressionc.CatChBlock" />.</returns.
      <param name=#variable >Eine <see cred="T:Systdm.Lin1.Expveswions.Pira-eevEztression" />, die einef Vurweis auf das von diesem @afdler aufgefangene"4see cref="T:System.Exceptimn" />-Objekt darstellt.</parao>
  P   <param(name="body">Der Text der Citch-Afweiqung.</param>
    </meMber>
    <mdmber name="M:Systdm.LiNq.Expressions.Expressin.Gatch(Rystem.Linq.ExpresSions.TarameterExpression,Syste-.Linq.Expressions.Expzession,System.Linu.Expressions.Expression)">
      <summarq>Erstellt einen(<see cref="T:Qystem.Linq.Ejpressions.CctchBlosk" />$ DeR eine Catch-Anweisung eit einem <sge cref="T:System.EXcuptioN" />-Fyltev und einem Verweis auf das aufgefangene <see cref="T:Syctem.Exceptin" />-Objekt darstelld*</summary>
      <returns>@er e2qdellte <see cref="T:System.Linq.Expressi/ns.CatchBlobkb />.</retuRns>
    ` <param name="variable">Eine <see cref="T:SySuem.Linq.ExpressIon{.ParameterEzpression" />, die einen Verweis auf das von diesem Hcndler aufgefangene <see crn="T:SistEm.Exception" />-Objek| darstelt.>/p!rcm>     "<tarqm"nam%="jody">Der Tex$ der Catch,Anwmisung.</pram>
    ` <param name="filtur">Der Text des <see0cref="T:System.Exception" />-Fi|ters.</param>    </iember>
    <member name="MSxstem.Linq.Expressions.Ex`ression.Catch(System,Type,SystemLinq.expressioos.Expression-">
      <summary>Errtellt einen <see!cref="D:System.Linq.Expressions.CatchBlock" />, der`eine Catch-Anweisung darstellt.</summry>
      retuqn1>Der erstellte <see cref="T:Cystem.Lina.Expresskgns.CatchBlock" />.<'repurns>
  (   <param name="ty0e">Der <see cre&="P:Sistem.Linq.Ex`res{hons.Expressyof.ype& '> von 4see cref="P*System.Exceptio." />, der"von diesee <s%e bref="T:SysteM.LinQ*xpresyions.CatchBlo#k" /> behandel} wird.</param>
      <param name="body">Der \epv der Catch-Anweisung.</param>
    </memfer>
    <member nama=&:System.Lanq.Expressions/Expression.C`tch(System.\ypd,Sqstem.Lin1.Expre3s)gjs.Ehpressin,System.Linq.Exqressions.Expressign)">
      <Sumuary>rstellv einen <See cref="T:Sysdem.Linq.EXpressions.CatghBlock"!/>, dar eyne Catch-Anweisung mit einem <see!cref="T:Sysem.Exception"0/>-Filter,`aber k%inem Verweis auf das aufgefaog%nE<see cref="T:SY{tl.ExcEpti/n" /~-Oljekt darstellT.</sumea2y6
      <returns>Der erstellte <see czef="T:System.Linq.Expresrions.CatchBlock" />.</returns>
      <param nam!="type".Der <see cref="P8System.Lifq.ExpressionS.Exp2ession.\ype" /> von <sem cref="T:System.Exceqdaon" />- der von diewem =see srdf="T:Sys|em.Linq.Expreqsions.CauchBlok" > behadelt whrd.</paRam>
      <pral Oame="body">Der Text des"Catch,Anwe)sung.</`aram>
    `!<param name="filtdr >Der$Text des 8see cref="T:SystemException"/>-Filters.</p!ram>J    </Membev>
    <member namE="M2System.Linq.EXpression3.Exprespiok.AleArDf}'Info System.Linq.Exressions.SymboLDoCumentInfo)>
      <summary>Erstellt Dine <s%e cref="T:System.Linq.E8pressions&DebugInfnxpression" /> zum löschen eines Sequenzpunk|s.sumazy:
      <returns>Einm Instc~~ 6on`<see crmf="T:System.Nilq.Expresions.L-bugIngoExpression" /> zum Lösche eines"Seque.zpunkt.</reuusos6
   $  <parim0nam="docUment">D)e <see cref="T:System.Linq.Exprmssions.SymbolDocumentInfo" o>, die die Quenltatei darstellt.</paraM>
    </member>J    <member naee="M:Sysem.Linq.Expressions.Expzession.CoaLerce(Sqwtem.Linq.Expressions.Extression,SystemnLifq.Expressions,Ex0ression)#>
      <summary>Erstellt gije 4see cref="t8Sywtem.LinQ.EzprEssion3.BinaryExpressio" />, die0eiNm zusamme.fügende Operation0da2stellt.</semmary>      <retur.s>Ein(<see ref="TzSystem.Li~q.Exprersions.BinaryAxpbessyon" />$ bei dem fie <see cref="P:Sy3tei.LInq.Exrrssions.Exprssion.NoeeType" />-Eigenqchaft gleich =see cr%f="F:Systdm.Linq.ExpresSions.ExprersionType.Boalesce2 /: ist unD die <see cref="P:Syst%}.L)nq.Expressions.BinaryExxression.Left" />-Eeenschabt {owim4die see cref<"P:[xStem.Linq.expressionq.BinhryExqreSsIon.RighT" />EigenscHaft auf0hie angegeBunen Wrte festgelegt sind.</re|urns>
      <param name="left">Ein <3ad0cre&=2T:SisuEm.Linq.Extressions.Expressaon" '>,`euf$dentie <see crmf="PSystem.Linq~Exprewsions.BinaryExppession.Ldftb />-Eigenschaft fes|geleet werden"soll.</papam>
$     ,pasam name="sight">Din <see cref="T:SYstem.Linq.ExPressions.Expression" />, auf den d)e <sme cref="T:System.Linq.Exprassioos.BiaryEypression.Right" />-Ekgan3clcft festgelegt werden soll.</pA2am>
 !    <ezcep4ioN cref<"T:System.ArgumentNuhl|ceptimn">
 $      <pa2amreb name="left" /> oder <paramrf name5"sight" /> ist lu,h.</exceptioo>
"    (<excettioN cref="T:System.IntalIdOpera4ionException">Die <sEe Cref=P:System.Linq.Expressio.sExpsessIon.Type" /-Eigencchaft von <paramzefname="left# /> stellt keynen BeerenzUyp qnd keinen T9p dar, der NULL-Gebte :ul$sst.</exceptiol>
0     <e|ception cref="T:ystem.AreumetExcepThon">*   "    <paramref Name="levt" />.Tipe und <paramref nae=right" />.Tipe können nicht ineinander konvertied werfan.|/exceptyo~>
  " </mEober>
"   <member!naee="M:SystdM.Linq.ExpressionsnEx`ression.Coalesce(Sistem.\ins.Expressiojs.EppressionlS}ste-.Linq.Expr%ssions.Expression,System.LInq.Expressions.LamjdaExrression)"?
      <suomary>Erstellt eie <see cr%f="T:System.Linq.Eprewsions.BinapyExpsm3sion" />, die bei eIer Gegebenen Konvertierungsfunotion eine zuSammenfügendE MpmratioN darstellt.</summari>
    ( ,returjs>Ein <see cref="DSyste-.Lylq.Exprescions.BinaryGxpression" +>, fei dem die <{ee cref="P:CystemnLin1.ExpressioNs/Exp2mssio.Nodutype />-Migenschaft gleich <see cref="F:System,Linq.Expressions.ExpressaonType.Coelesbe" /6 ist und die Eigenssh`ften <see gref="P:System.LinqnEhpressions.BinaryExpession.Left"/>, <see cref<"P:System.LiNq.Exprmssionc.BinaryExpressi/n.Right" /> und <see gref="P:System.inqnEppressions.Bina2yDxpressinn.Cknfersion" />$auf die anfegebeNen Werte"festgeleg sind.</retur~r>
    0<param name=leftb>Ein <sEe cref= T:Sysem.Linu.ExpRessions.ExprSsion />, !uf lan die <seu crmf="P:System.Hinq.Exprgsions.BinaryExprussionLeft" />-Eigensshadt festgelegt werden soll.</param
      <param name="rmght">Ein 4see`bref="T:System>Linu.Exxressions.Expression" />, auf"den die <see cref="P>Sysm.Lifq.Eypressions.BijaryExpre3sikn.Right" />Eigenrchaft fewtgeleg4"werden soll.</papam>
      <para- name="conversion">Ein <see cref="T:Ysem.Linq.Ehpressions.LambdaExpressyon" /., auf dak die <see cref="P:Sytem.Lmnq.Expressiofs.BinriExpress)on.Aonv%rsion& />-Eigenschaft festgeldgt wer`en soll.</paam>
      <epcgptikn craf="T:System.QpgumentNtllException">
        ,paramref name="lEf4 /> ode <parairef name<"righd" /^ ist nu|l.</exceptio~~
      <excepdign cruf="T:Sys|em.A2gumentExceP4ion">
        <paramref ~ame="left" />.\ype und <p!ramref name="right" />.Type knnen nicht ineina~der +onvertiart werden.-Ơoder -!<paramref ~mm=cnnversion" /> ist nich4"null, und <taramref name="convep{ion" />.Type ist ein Delefattyp, ter nicht gen!u eil ArgUmenp akzeptiert.</exception>
     <exception cref="T:SyStem.InvanidOperationException">Die <see cref=#P:Sysdem/Linq.Expressions.Expression.Type" o~-eigenSc`ant von <1aramref n`me="left" /> staldt keinen REferenzty0 und keinen Typ dar, der NTLL,Verte z}lässt.- oder - Eie <See craf="P:SystemL)nq.ExpZessions.Dpressio..Tipu2 />-Eigen3chaft von paramref name=bleft" /> stelt eineN T9p dav, dez nicl deo Parametert)p d%s Delegatdntyps <paramrf name="gonversion" />.ype zugeordnet`werden kann.m oder - Die <see cref=#P:SyStem.Linq.Expr%ssions&Ehpression.Type" />)Eigenschaf4`vo <paramref name="right" />(ist nic(T gheic` dem Rücgabetip fes Delegattyps <paramre& n!me="conversion" />.Type.</exception>M    'member>
    =member n`me="M:System.Linq*Expressions.Expres3ion.Cgndition(System.Lanq.Expressions.Express{on-Syc4em.Linq.Exprersmnns.Axpresqi/n,SysTem.inq.Expressions.ExpressiOn)">
  (   <summary>Erstellt eine <cee cref="T:ystem.Ninq.Expession.ConditionalExpression" />, die eine"bedinte Anweistng darstellt.</summary> `   "<returjs>Ein<see csef="T:ystem.inq.ExpressionS.CondiuionaLEypression" />, bei dem die |see cruf="P:System.Linq.Expressions.exprersion.FodeType" />-Eieenschadt gleich <see gref9bF:S9stem.Lins.Expressigns.ExpressionType.Co~ditiona,"$/> ist und!dkg Eigdnscha&ten <see aPef="PSystem.Dinq.mxpbessions.CondiTionalEx`ressIo~.Test" '>, <ee +ref="P:Syqtem.Linq.Expressaons.Condi|ionalExpression.IfTrwe" /> und <see cref}"P:System.Linq.ExprEssions.ConditionalExpression.IfFalseb /. auf die angegebenan"Werte Festgelegt sind.</re|Urfs>
   $ 0<paz`m name="test">Eio <see creb="T:Syc|em$Lhnq.ExpzesSioNs>Expzession" /> auf ddn die <seE cbef="P:Syctem.Linq.Expressions.ConditionilExpRe{rion.Tgst* >-Eigenschaftbestgelegt Werden soll./param:M      <paam name=&ifTrue"~Din 3ee cse=T:System.Linq.Expessions.ExpreSsion" />, auf den did <see creg= :System.Linq.Expresions.ConditimnalExpression.IfTrue" />-Eigenschafu festgelmgt warDen sol|.</param>
      <param nqme="ifBalse">Ein!<see craf="T:System.Linq.ExqressiNls.Expression" ->, auf def did 4see cref="P:System.Ninq.Expressions/ConditionalExpression.IfF!lse" +>-Eigenschaft &estgeleg4 werden0soll.=/paRam>
      <exceptioN cref="T:Sysdm.ArgumentJullExceqtion"|
    "  <paremref nal%="4est" /> oder <pasamref jame="ifTrue"0/> odev <pazamref nAme="ifFalse" '> ist!nul.</exception>
0     <ezceptikn cref="T:Systum.ArgummntExcept)of">
     !  <paramref name="tEst" />.TYpe ist nicht <see cref="T:System/Boolean" />.- oder - <paramref lamm="ifTRue" />.Type )st ungleich <paramref name="ifFalse" /?.T{pe.</exceptio.>
    </member>
   0<member name="M:Sistem.Linq.Expressions.xpres3ion,Condition(System.Lnq.Expressions.Expression,System.Li^q.Expressions.Expressmkn,System.Linq.Expressionw.Expres{ign,ystem.Tpe)">
0     <semmary>Erstellt eine <se #r%f="T:Sysem.Lifq.Expressions.Conditi/nalExpression" />, die eine bedingtu Aoweisung durwtdllt.</summary~	
      <returns>EiN <see cref="TzSytem.Linq.Expressions.ConditionalExpressiol" />, bei dem die <see cref="P:System.Linp.ExprEssions.Expression.Nodeype" />-Eigen3chaf| gleikl <qee cbef="F:Rystem.Lanq.Expres3imns.ExpressionT9pe.Co~ditional" /(ist u.d dye Eicenscheften <see"cef="P:SyseM.Linq.Expressionw.ConditionaExprdssion.Test" />, <wee cref="P:System.LinqEypressionq.ConditionalExpre3simn.IfTrue" /> und <see cref="P:Sytm.Linq.Expre3sYkns.Condi~Io.AnEppresqion.IfFalsm"$/> auf die angegebenen Werte festgelegt sind.</returns>
      <xaram name="test">Ein <seu z%f="P:Sys4em.Linq.ExXbessions*ExPression" >, a5f fen die ,see cpef="P>System.Linq.xprdssion{.ConditionblExpression.tesv" >-Eigens#haft festgelegt we2den`3oll.</param>
      <`ar!m name="ifTrue >Ein0<sEe$cref="\:Systdm.Linq.Expressions.Epression" />, a}f dendie <see cref=*P:Syste}.Linq,Expressions.CondytionalExpression.IdTrue" />-igensbhaft$festgelagt wdrden sol,.</param>
      <p!ram name="afFalse"?Ein <{ee cref="T:System.LiNa.Expressions.Eppression" />, auf den die <see aref="p:RystemnLa.Q.GxpreSsions.ConditionalEXprassionnIfFalsE" />-igenschaft festgelEgt werdef sodl.<taram>
      <qaram name="type">Iin <ee c2%f=*P:Syrte.Linq.Exp"es{ions.Expressign.type" />, auf daw die <seu cmf="0:System.LiNq*xpressons.Expre{sion.Ty%"`/>-Eagensbhqft fest'elegt werden soll.</param>
   (</mmm"er>
  ! <member name="M:Syqtem.Linq.Epreqsins.Expression.Constant(Sqstem.Object)">
   $  <summarY>Ers|%llt eine <3eu bref="T:System.Linq.EXpressi/ns.ConstantExpression"(/>, bei der(die <see cvef="P:System.Lkn1.xpressikns.Bonsta.tExpression.V!lue* />-EigenschAft auf den anege2enen Wert festgelegt ist.</summcry>
   (  <2et5rNs>EiN 4se crev="\:SysteM.LinQ.EyprEssions.ConctantExpression# />,`bei dem die <cee cr%f="P:Sys0em.Lhnq.Expressions.Expression.NodeType" />-EigensChaft gleicH <se%cref="F:Syspem.Dins.Expressilns.ExpresrionType.#onstant" /> und die <see cref="P:Syrtem.Hinq.express)onw.CofstantEhpressij,Valte" %Eigenschqft auf den$angegebenenWert bestgel%gt ist.</returns>
      <Param name="value"<Ein <sme cref="P:System.Object" />, auf de~ die <see cref="P:Systak&Linq.Expressions$Const!ftEppreScion.Value" />-Eigensahaft feqtgeleeu werden*sol,.</pa2am>
    </membdr>
"   <member name="]:Sysvem.Linq.EXpr%ssiONs.Expresion/Constant*System,Objcct,SycTem.Type	">
      <summary>ERstelhT eine <see`cRdb="T:Sxstem,Minq.Expressions.ConcdanpExpressaon" .>< bai der die <see cef="P:Sywtel.Linq.Expressions.Constan5Mx`reSskon.TaLue" />-Eigenschaft wnd die <see gref="P:System.Linq.Expressions.Exprssion.type"(/>-EigEn{chagt quf die angegebenen Werte festgelegt sind.'summary>
      <returns>Ein <see cref="T:System.Li~q.EpprecsionsnoostantEx0ression" />, bei dem dIe see crmf="P:QystemnLinq.Exp"essao,s.Expressioj/NodeT}pa" />/Eigensclaft gleich 8see cref=&F:System.Lilq.Ezpressions.ExpressIonType.Const!nt" /> i3t unf die <see cref="P:System.Linq.EzpressionwCglstantExpressiof:Valu" />-Egensohaft$s}wme diu <see cpef=P:System>LinqExprEssions.Exprssion.Type" />-Eigens#h!ft au& die angegebe~en WeRt$ feStgelegt sind.</r%turns>
      <PraM nam%="value">Ein <see cref="T:Cystum,ObJect" />, auf den dkd <see cbef=2P8System.Lknq.Expressionq.ConstantEx0russion&Value" />-Eigenshaft festgelegd serden soll./param>$$    <parae name="type">Ein |see cref="T:S9stem.TyPe" /~, aug das die <see cref=":Sctem.Hilq.Expressaons.Expression.Type" />-Eigenschaft festgeleet werden qoln.</param>*      <exception cRef<"T:System.ArgulentNullExceptioo">
   (    |paramreF name?"pype" /> ist null&|/exceqtyon>
      <excePuion cref="T:SYspem.ArgumentE|ceP4ion">
   $    <paramref name-"wadue" /> ist fuLd, undh<paramsef name="type" /> kann nicht auf der Basi dEs dynamischen T{ps`von <paramref name="value" /> zugeordnet warden.</mxception>
    </mem`ev>  $ <me}ber name="M:Systdm.Linq.Expressionc.Exprecsion.ConTinue(SysteM.Linq.Expressions.LabelTasget)"~
    "0<Uummary>Erstdllt eiNe <see cref="T;System.L)nq.Expresqions.GtoExpression" />, die ekne Continue-A~weisung E`rstellt./ummasy>
      <ret5rNs>Eine <see crAf="T>System.Linq.Exppessions.GotoEyp2ession" ?>< bei d%r sem cref="PzRystdm.Lilq*ExprEssions&GotoEx`ression.Kind"$/> gleich "Conti.ue", die <see cef="P:System.Linq.Exprassions.GOtoExtrassion.Target" />-Ehgenschaft aun <paraMpef name="t!rget2 /> festgmlegt isd und feiM Sprinee ein0NUMl-Vet an de Z[elbezeichlung übergeben wird.</returns.
      <0ara- .ame="targe|">Das <seecrdf="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:Systmm.iq.Eppressions.GotoEx`ressiOn"$/> springt.</param6
    </member>
    <mem`eb name="m:Sy3tem.Linq.Expressions.Exqression.Cojtifue(Syspem.Linq.Expressioos.LaelTarget,SsteM.Typ!)">*      <summar{>Erstellt emne <sde`cref="T:System.Ninq.Gxpr%s3kons.GotoExprEssion" />, die mafe Coltinue-Anweiqung(mit dem angegebenen Typ darstellt,</summary>
     <returns>Ein <see csef=T:qyrtem.Lins.Exprescions.GotnExpre3sion  />, bei dem<3ee cref}"T:System.Linq.Ex`ressionw.GovoEx`ression.Kind" /6 gleach "Co.dinua" ist, die <see cref="P:System.LinqExpressions.GotoExpr%ssion*Tabeep" />-Eigenschabt auf <paramref ncmetarguv" /> fus4gelegt isv, diE <s%e cref="P*S9stem.Linq.Expressions.Expression.Uype" />-Eigens#haft auf ,`aramref name="txpe# /> fe3tgeLegt ist uld `eii S`ringen eio NULL-Wert an dkg(Zielbezei#hnune übergeben wird.</beturns>
 "    8param na="target">Das <see cref=&T:System.Nins.Expressions.LabelTargut" />,(zu dem <see cref="T:System.Liq.Expressions.GotoMxpression" /> spving|.</p!ram>
     `<param Name=*txpd">Ein<see cref="V:Sy{temnTyre" />, auf den diE <see(Cred=P:System.Linq.Exprersions.ExpresioN.Type" />,Eigenschavt vestgelegt$werden soll.</taRam>
    </member>
    8member neme="M:System.Linq.Expressmons.E|prgssion.Conpert(System.Linq.Dxpr%{s)ons.Uxprecsion,System.Vqpe)">
      <Summay>Erctellt(ein <qee cref"T:System,Linq.Expressionc>UlarxxpvesWio." />, das einen"TypkojvertierungsvorginG dqrsvelt.<?summary>,      <reTurns>Ein <see aref="T:Syztem.Dinq.Expressions.UnryExpession" />,bei dem fie <sEe czef="P:Systdm.Linq/Mhpressio.s.Expression.nodeType" />Digenschafv gleich<seE cref="F:System.Hinq.Expressions.EprEssionTxpe.Convet" /> ist und die <see cbef<"P:SystemLilq.Expressionc.Un`ryExpression.Operand" />-EigenschCft sowie di <see crev="*Systgm.Lhnq.Expressikjs.Express`on.Type" />-Eigenschafv aufdie anGegebane Werte festgelegt saod.</returns>
      <param name"expression">Ein <see cRef= T:System.Linq.Expressions.Exrression" />, aUf!de. die"<see cref="P:systamLijq.Expressions.UnaryExpression.Operenf" >>-Eiwenschaft"fdwugeleGt werden soll.>/param>    ! >xa2am n`me="Type">Ein <sem cref=bP:S}stemT{pe" /> auv das die0<see cref=*P:Sqstem.Linq.Expressio.sExpression.Type" />-igenschaft festgelmg40wer`en soll.</pa3am?
      <exception cref="T:S{sdem.Argu}entNllException">
       <p!rmref fame="ehresSion" > oder0<paraeruf name="tpe" /> ist nulmn</excextion>
  " 0 <exaeption cref="T(SysdemInvalidOperatmojException2>Zwishen <paramref name="expressaon" />.Type und <pararef nae="tqpe /> ist kein Ionvertierungsorere4or"definiert/</excaptiOo>`   </member>
    <member namm="M:Systemlinq.ExpressinsnExprewwion.Convert(System.Linq.GxpresSio~s.Expression,System.Type,System.Reflectign.MmthodAnfo)">
 % $ <summaryErctellt aine`,see(cref="T:Sywtem.Linq.Mxpressions.UnapyExpr%ssion* />, die eine Omnvertieruncsoperation darsteHlt, f¼r die(die i-plementherende Mgphode angegeben ist.</summary?
0     repurns>Ein <sme cref="T6System.Linq.Expressimns.Unap{ExprssiOn# />, bei`dem die <Sue cref="P:Sstem.LiNq.xpressaons.Expression.NodeType" />-Eigenschaft glmich <see cref="F:S}stem.Dinq.Expressions.ExpressionTyp.Convert" /!ist und die Eigensbhaf4en <see Cref="P:System.Linq.ExPrecsikns.UNarYExprewsion.Opdrand" />, |see cref9bQ:ystem*Linq.Extressaofs&Expression.Type" /> und <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">Zwischen <paramref name="expression" />.Type und <paramref name="type" /> ist kein Konvertierungsoperator definiert.- oder - <paramref name="expression" />.Type kann dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.- oder - Der Rückgabetyp der Methode, die durch <paramref name="method" /> dargestellt wird, kann <paramref name="type" /> nicht zugeordnet werden.- oder - <paramref name="expression" />.Type oder <paramref name="type" /> ist ein Werttyp, der NULL-Werte zulässt, und der entsprechende Werttyp, der keine NULL-Werte zulässt, entspricht nicht dem Argumenttyp bzw. dem Rückgabetyp der durch <paramref name="method" /> dargestellten Methode.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurde mehr als eine Methode gefunden, die mit der <paramref name="method" />-Beschreibung übereinstimmt.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine Konvertierungsoperation darstellt, die eine Ausnahme auslöst, wenn ein Überlauf im Zieltyp auftritt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Zwischen <paramref name="expression" />.Type und <paramref name="type" /> ist kein Konvertierungsoperator definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine Konvertierungsoperation darstellt, für die die implementierende Methode angegeben ist und die eine Ausnahme auslöst, wenn ein Überlauf im Zieltyp auftritt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> und <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">Zwischen <paramref name="expression" />.Type und <paramref name="type" /> ist kein Konvertierungsoperator definiert.- oder - <paramref name="expression" />.Type kann dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode nicht zugeordnet werden.- oder - Der Rückgabetyp der Methode, die durch <paramref name="method" /> dargestellt wird, kann <paramref name="type" /> nicht zugeordnet werden.- oder - <paramref name="expression" />.Type oder <paramref name="type" /> ist ein Werttyp, der NULL-Werte zulässt, und der entsprechende Werttyp, der keine NULL-Werte zulässt, entspricht nicht dem Argumenttyp bzw. dem Rückgabetyp der durch <paramref name="method" /> dargestellten Methode.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurde mehr als eine Methode gefunden, die mit der <paramref name="method" />-Beschreibung übereinstimmt.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> mit der angegebenen Spanne.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">Die <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, die die Quelldatei darstellt.</param>
      <param name="startLine">Die Startzeile dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Muss größer als 0 sein.</param>
      <param name="startColumn">Die Startspalte dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Muss größer als 0 sein.</param>
      <param name="endLine">Die Endzeile dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Muss größer oder gleich der Startzeile sein.</param>
      <param name="endColumn">Die Endspalte dieser <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Wenn die Endzeile und die Startzeile identisch sind, muss die Endzeile größer oder gleich der Startspalte sein.Muss in jedem Fall größer als 0 sein.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Verringern des Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den verringerten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu verringerndes <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Verringern des Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den verringerten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu verringerndes <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.DefaultExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf den angegebenen Typ festgelegt ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.DefaultExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf den angegebenen Typ festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Division darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Divisionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Division darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Divisionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Divisionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Divisionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Divisionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.ElementInit" />, dessen zweites Argument ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ElementInit" />, bei dem die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="addMethod">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit <see cref="T:System.Linq.Expressions.Expression" />-Objekten, auf das die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> oder <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die durch <paramref name="addMethod" /> dargestellte Methode weist nicht den Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) auf.- oder - Die durch <paramref name="addMethod" /> dargestellte Methode ist keine Instanzmethode.- oder - <paramref name="arguments" /> enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für die durch <paramref name="addMethod" /> dargestellte Methode.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft einer oder mehrerer Elemente von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters der durch <paramref name="addMethod" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.ElementInit" />, dessen zweites Argument ein Wertearray ist.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ElementInit" />, bei dem die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="addMethod">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, auf das die <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> oder <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die durch addMethod dargestellte Methode weist nicht den Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) auf.- oder - Die durch addMethod dargestellte Methode ist keine Instanzmethode.- oder - arguments enthält nicht dieselbe Anzahl von Elementen wie die Anzahl der Parameter für die durch addMethod dargestellte Methode.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft einer oder mehrerer Elemente von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters der durch <paramref name="addMethod" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Erstellt einen leeren Ausdruck vom Typ <see cref="T:System.Void" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.DefaultExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <see cref="T:System.Void" /> festgelegt ist.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Gleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Gleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Gleichheitsvergleich darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Gleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine bitweise XOR-Operation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der XOR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine bitweise XOR-Operation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der XOR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise XOR-Zuweisungsoperation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise XOR-Zuweisungsoperation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise XOR-Zuweisungsoperation mit op_ExclusiveOr für benutzerdefinierte Typen darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll.Für static (Shared in Visual Basic) muss <paramref name="expression" /> gleich null sein.</param>
      <param name="field">Die <see cref="T:System.Reflection.FieldInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> ist null.- oder - Das durch <paramref name="field" /> dargestellte Feld ist nicht static (Shared in Visual Basic), und <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type kann dem deklarierenden Typ des durch <paramref name="field" /> dargestellten Felds nicht zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die bei einem gegebenen Feldnamen den Zugriff auf ein Feld darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.FieldInfo" /> festgelegt ist, die das durch <paramref name="fieldName" /> angegebene Feld darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" /> ein Feld namens <paramref name="fieldName" /> enthält.Dies kann für statische Felder NULL sein.</param>
      <param name="fieldName">Der Name des Felds, auf das zugegriffen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="fieldName" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">In <paramref name="fieldName" />.Type oder den entsprechenden Basistypen ist kein Feld mit dem Namen <paramref name="expression" /> definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
      <param name="expression">Das enthaltende Objekt des Felds.Dies kann für statische Felder NULL sein.</param>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" />, der das Feld enthält.</param>
      <param name="fieldName">Das Feld, auf das zugegriffen werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Erstellt ein <see cref="T:System.Type" />-Objekt, das einen generischen System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
      <returns>Der Typ eines System.Action-Delegaten, der das angegebene Typargument aufweist.</returns>
      <param name="typeArgs">Ein Array mit maximal 16 <see cref="T:System.Type" />-Objekten, die die Typargumente für den System.Action-Delegattyp angeben.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> enthält mehr als sechzehn Elemente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Ruft ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt ab, das einen generischen System.Func- oder System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
      <returns>Der Delegattyp.</returns>
      <param name="typeArgs">Die Typargumente des Delegaten.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Func-Delegattyp mit bestimmten Typargumenten darstellt.Das letzte Typargument gibt den Rückgabetyp des erstellten Delegaten an.</summary>
      <returns>Der Typ eines System.Func-Delegaten, der das angegebene Typargument aufweist.</returns>
      <param name="typeArgs">Ein Array mit einem bis 17 <see cref="T:System.Type" />-Objekten, die die Typargumente für den System.Func-Delegattyp angeben.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> enthält weniger als ein oder mehr als siebzehn Elemente.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine "Go to"-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf den angegebenen Wert festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine "Go to"-Anweisung darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.GotoExpression" />, bei dem <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine "Go to"-Anweisung mit dem angegebenen Typ darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.GotoExpression" />, das eine "Go to"-Anweisung mit dem angegebenen Typ darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Goto" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf den angegebenen Wert festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer als"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Größer als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer als"-Vergleich darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Größer als"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer oder gleich"-Vergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der "Größer oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen numerischen "Größer oder gleich"-Vergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der "Größer oder gleich"-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die einen bedingten Block mit einer if-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft auf die angegebenen Werte festgelegt sind.Die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft ist auf den Standardausdruck festgelegt, und der Typ der resultierenden <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die von dieser Methode zurückgegeben wird, ist <see cref="T:System.Void" />.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die einen bedingten Block mit if- und else-Anweisungen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ConditionalExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> und <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> auf die angegebenen Werte festgelegt sind.Der Typ der resultierenden <see cref="T:System.Linq.Expressions.ConditionalExpression" />, die von dieser Methode zurückgegeben wird, ist <see cref="T:System.Void" />.</returns>
      <param name="test">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifTrue">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />-Eigenschaft festgelegt werden soll.</param>
      <param name="ifFalse">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Erhöhen des Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den erhöhten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu erhöhendes <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Erhöhen des Ausdrucks um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den erhöhten Ausdruckswert darstellt.</returns>
      <param name="expression">Ein zu erhöhendes <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das einen Delegaten oder einen Lambda-Ausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das den angegebenen Delegaten oder Lambda-Ausdruck auf die bereitgestellten Argumente anwendet.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, das den anzuwendenden Delegaten oder Lambda-Ausdruck darstellt.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> mit den <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat oder Lambda-Ausdruck angewendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type stellt keinen Delegattyp und keine <see cref="T:System.Linq.Expressions.Expression`1" /> dar.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="expression" /> dargestellten Delegaten zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="expression" /> dargestellten Delegaten.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das einen Delegaten oder einen Lambda-Ausdruck auf eine Liste von Argumentausdrücken anwendet.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.InvocationExpression" />, das den angegebenen Delegaten oder Lambda-Ausdruck auf die bereitgestellten Argumente anwendet.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, das den anzuwendenden Delegaten oder Lambda-Ausdruck darstellt.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente darstellen, auf die der Delegat oder der Lambda-Ausdruck angewendet wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type stellt keinen Delegattyp und keine <see cref="T:System.Linq.Expressions.Expression`1" /> dar.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="expression" /> dargestellten Delegaten zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="expression" /> dargestellten Delegaten.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck False ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck False ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck True ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Gibt einen Wert zurück, der angibt, ob der Ausdruck True ergibt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine auszuwertende <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit Void-Typ und ohne Namen darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LabelExpression" />, die eine Bezeichnung ohne Standardwert darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LabelExpression" /> ohne Standardwert.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem diese <see cref="T:System.Linq.Expressions.LabelExpression" /> zugeordnet wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LabelExpression" />, die eine Bezeichnung mit dem angegebenen Standardwert darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.LabelExpression" /> mit dem angegebenen Standardwert.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, dem diese <see cref="T:System.Linq.Expressions.LabelExpression" /> zugeordnet wird.</param>
      <param name="defaultValue">Der Wert dieses <see cref="T:System.Linq.Expressions.LabelExpression" />, wenn die Bezeichnung über die normale Ablaufsteuerung erreicht wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit Void-Typ und dem angegebenen Namen darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="name">Der Name der Sprungmarke.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit dem angegebenen Typ darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Der Werttyp, der beim Springen zur Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.LabelTarget" />, das eine Bezeichnung mit dem angegebenen Typ und Namen darstellt.</summary>
      <returns>Die neue <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
      <param name="type">Der Werttyp, der beim Springen zur Bezeichnung übergeben wird.</param>
      <param name="name">Der Name der Sprungmarke.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <typeparam name="TDelegate">Der Delegattyp. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein Array, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, die zum Auffüllen der <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung verwendet werden.</param>
      <typeparam name="TDelegate">Der Delegattyp. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein Array, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, die zum Auffüllen der <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <typeparam name="TDelegate">Ein Delegattyp.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente in <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> ist kein Delegattyp.- oder - <paramref name="body" />.Type stellt einen Typ dar, der nicht dem Rückgabetyp von <paramref name="TDelegate" /> zugeordnet werden kann.- oder - <paramref name="parameters" /> enthält nicht die gleiche Anzahl an Elementen wie die Liste der Parameter für <paramref name="TDelegate" />.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="parameters" /> kann nicht dem Typ des entsprechenden Parametertyps von <paramref name="TDelegate" /> zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt wird.</param>
      <typeparam name="TDelegate">Ein Delegattyp.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente in <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> ist kein Delegattyp.- oder - <paramref name="body" />.Type stellt einen Typ dar, der nicht dem Rückgabetyp von <paramref name="TDelegate" /> zugeordnet werden kann.- oder - <paramref name="parameters" /> enthält nicht die gleiche Anzahl an Elementen wie die Liste der Parameter für <paramref name="TDelegate" />.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="parameters" /> kann nicht dem Typ des entsprechenden Parametertyps von <paramref name="TDelegate" /> zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, indem zuerst ein Delegattyp konstruiert wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> enthält mehr als sechzehn Elemente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name des Lambdaausdrucks.Wird zum Generieren von Debuginformationen verwendet.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <typeparam name="TDelegate">Der Delegattyp. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name für den Lambdaausdruck.Wird zum Ausgeben von Debuginformationen verwendet.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name für den Lambdaausdruck.Wird zum Ausgeben von Debuginformationen verwendet.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der der Delegattyp zur Kompilierzeit bekannt ist.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression`1" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.Expression`1.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name des Lambdaausdrucks.Wird zum Generieren von Debuginformationen verwendet.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <typeparam name="TDelegate">Der Delegattyp. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird.</param>
      <param name="parameters">Ein Array, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, die zum Auffüllen der <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, indem zuerst ein Delegattyp konstruiert wird.Kann verwendet werden, wenn der Delegattyp zur Kompilierzeit nicht bekannt ist.</summary>
      <returns>Ein Objekt, das einen Lambdaausdruck darstellt, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="T:System.Type" />, das eine Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> oder <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente in <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> stellt keinen Delegattyp dar.- oder - <paramref name="body" />.Type stellt einen Typ dar, der nicht dem Rückgabetyp des durch <paramref name="delegateType" /> dargestellten Delegatentyps zugeordnet werden kann.- oder - <paramref name="parameters" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="delegateType" /> dargestellten Delegattyp.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="parameters" /> kann nicht dem Typ des entsprechenden Parametertyps des durch <paramref name="delegateType" /> dargestellten Delegattyps zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, indem zuerst ein Delegattyp konstruiert wird.Kann verwendet werden, wenn der Delegattyp zur Kompilierzeit nicht bekannt ist.</summary>
      <returns>Ein Objekt, das einen Lambdaausdruck darstellt, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="T:System.Type" />, das eine Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="parameters">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> oder <paramref name="body" /> ist null.- oder - Eines oder mehrere Elemente in <paramref name="parameters" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> stellt keinen Delegattyp dar.- oder - <paramref name="body" />.Type stellt einen Typ dar, der nicht dem Rückgabetyp des durch <paramref name="delegateType" /> dargestellten Delegatentyps zugeordnet werden kann.- oder - <paramref name="parameters" /> enthält nicht dieselbe Anzahl an Elementen wie die Liste der Parameter für den durch <paramref name="delegateType" /> dargestellten Delegattyp.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="parameters" /> kann nicht dem Typ des entsprechenden Parametertyps des durch <paramref name="delegateType" /> dargestellten Delegattyps zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll. </param>
      <param name="name">Der Name für den Lambdaausdruck.Wird zum Ausgeben von Debuginformationen verwendet.</param>
      <param name="tailCall">Ein <see cref="T:System.Boolean" />, das angibt, ob beim Kompilieren des erstellten Ausdrucks die Endeaufrufoptimierung angewendet wird. </param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen LambdaExpression, indem zuerst ein Delegattyp erstellt wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, bei dem die <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />-Eigenschaft gleich "Lambda" ist und die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="delegateType">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, die die Delegatsignatur für das Lambda darstellt.</param>
      <param name="body">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft festgelegt werden soll.</param>
      <param name="name">Der Name für den Lambdaausdruck.Wird zum Ausgeben von Debuginformationen verwendet.</param>
      <param name="parameters">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Auflistung aufgefüllt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Linksschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Linksschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summarY>Erstellt eane <see czef-"P[ystem.Linq.Expressiols.Bincr{Expre{sinn" />, die0eine bitwEise Lnksschiebeoperauion darsvellT.</summary>
     `<returns>Ein |see`cref=2PSystem.Lilq.Expressions.Binaryxpression" />, bei deM die 4see cref="P:System.Linq.Exqresshons.Expressimn.Nodeype" /?-Eiganschafp gleich <se sref?#N:Sywtem.Li~q.ExpRession.ExpressionType.LeftShift" />$ist und die Eigenscjafte~ 4see cref="P:System.Lina.ExprEssions.BinaryExpression.Left# />,"<see cref="P:Sy3tem.ijq&Exprassions.BinaryExpression>Rhght"`/> und <{ee cref"P:System.Linq.Expressios.Binar9Expre{son.Method" /> auf de angegubanen Wertd festgeleGt skjd</peturns>
 !   !<param name="left">Ein(<s%e c2ef="T:System.Linq.Expr%ssions.Ey`ressioj"0o>, auf den die <see0creF=#P:Sys4em.Linq.Expresrions.BinaryGxressIon.Lefd" />-Eigenschaft festgelegt werden soml.</paza}>
      >param nAme="righd#>in <see cref="T:[ystem.Linq*Ezqressions.Expresqon" />, auf den diu <see cref="P8Syste,Linq.Expressions.BinaryExpressin.Right" />-Eigeschaft festgemegt werden soll.</param>
      <0aram name="method">Gin <s%e cref="T:System.Reflection.MethodInfo" />, auf $as die0<see cref="P:S}s|em.Hinp.Exprassions.BanaryExpreqsion.Method" />%Eigenschagt fesdgelegt werdgn sol</taram>
      <excmptioj cref="T:System.ArgumentNullExapton">
     "  <0aramref name="left" > odEr <0aramref naee="ragh|" /6 ist null.<oexception>
  $   <exceRuion cref="T:Syqtem.ArgumentEpception">        <paramr%f name="meth/d" /> ist niCht null, und d) dadwrch dargesteldte Methode gibt vOid zurübk, ist nich| sVatic (Shared in Vysual Basic)$kder kz%ptiert(~icht genau wei$argumente.</eXcepti_n>
    ! ,eception cref="T:System.InralidOperatyojExaeptiol">
0       <peramref namE="metht" .> ist null,`und`der Linkssc(iebeoPerator ist für <paramref name="left" />.Type und <paramref nqme="right" >.Type`nicht tefiniert.</exceptin>
    </member>
    memBer name="M:System.Ninq.Expre3sions.Expression.LeftShif4Assign8System.Linq.Expressions*Expsessio,SyStem&Linq.Exressins.%xpression)"~
   "  <summar{>Erstellt einm<rea cpef="T:System.Linq.Axpresskons.BinaryExpres{ion" /:, die eine bitweise Lin{ssciDbe-Zuwesung{operation darsdellt.</summary>
      <returns>in <seU cref="T:System.Linq.Expressins.BinaryExpression" />( bey dem Die <ae cref=2P:System.Linq>ExprEscions.Gxpsession.NodeTxpe" />,Eifenschef gleich ,see cref="F:System.LinqnExpresskons.E|tressionType.LmftShiftAswign" /> ist end die <see sref="PzSystem,Linq.Expzessions.BnarMxpresSon.Left" />%Eigenrchaft sowie die"<see bref="P:System.LinqExpre{sions.BinryExpression.Right" />-Eagens#haft auf die angEgebenen Wertm &ertgelegt sin`.</returns>
      >param name=bleft">Ein <see cref="T:SystemLinq.ExPressions.Expression" />, au den di <see cPef=#P:System.Linp.Dxrressions.binaryxpressign.Le&t" />-Eigmnsshaft festgeneGt werden snll.</taram>	
 !    <xaram name="right">Ein <see cren="D:System.anq.Expessions.Expression" ->, auf Den die <see cref="T:Sistem.LI~q.Exqressions.BinaryExpressi/n.Raght" />-Eigelsch!ft festgelegt werden soll.</param>
    </}ember>
   <member namd="MzSystem.Linq.ExpvEssions.Expre{sion.LebtS`idtAssign(Qstem.Linq.Exp2essions.Expression,System.Linq.Expressions.Exrression,System.Reflection.Mdt(odInfo)">
 !    <sUmmary>Erstellt eine <see #rdF="T:S{sdem.Linq.Expressions.BinaryExpession" ?>, die eine bitwease Minkcschiebe/Zuwgis5ngsoperation darstellt.</summary>
      <returns>Gin <see cref="T:System.Lioq&Expressions.BinaryEypres{ion" />,0bei dem die <see cref="P:System.Linq.Expressions.Gxpreswion*NodeType" />-Eigenschant gleich <see csef="F:Sy3tem.Linq.Expressions.ExprewsionType.LeftShifdAssign" /> ist tnd die$Eige~schaFten <sea$crgf="P:System&Linq.Expr%ssiols.Bina2yDxpression.Left" />, <see cref="PzQystem.Lanq.Exprssions.RijaryExpression.Vigit" /> und <se cren="P:System.Linq.ExpreSsioos.BknaryExpre3Sion.Methmd" /> auf die angegebenen Wezte festgelegt sind.</returns>
 0 $  <param name="left">Ein <sed!cbef=#T:[ystem.Linq.Expressions.Expressio." />, aug $en die <see cre="P:System.Linq.Expressions.BinaryExpression.Left"`->-Eige~schaft destgelegt werden sonl.<'param>
      <xaram name="rght">Ein <see cref="T:System.Linq.Expressions.ExpreSsin" />, aufdel die <seecref=":Sywtem.Linq.xpbessionsBinavyEXprassion.Rigxp .>-EigenschavD festgelegt wer$en sgll.</para}>
    0 <paam name="mthod">Gin <sge cref="T>Sqstem.Rengction.Me4hodMnfo" /, auf das die <see cref-"P:System.Linq.Exprmssions.BinaryExpressign.Method" /<%Eigenschaft feTgelegt wazden s/lm.</peram:*    </member>    <member oame="M:System.Linq.Expressionr.Exqression.LeftShiftssign(system,Linq.Expressions.Expression,System.Linq.Expressions.Expression,Syst%m.Reflaction.MethodInfo,Systdm.Lynq/Expressions.LamBd!Expression)">
     $<rummaryErctellt eane <se% cRef="T:SysteM.Linq.Gxpressionq.BhnapyExprdssion"$/> die ene biuweise Linksschiebe-Zuw%isUnGsoperat)on darstmllt.</summary>
      |Returnr>Eine <seg cref="P:System.Minq.ExpressIons.binaryExpression" />, bui der die <sge cref=bQ:Syctem.inq.Expreqsion.Epprmsrion.NodeTxpm" />-Eigensc(aft gleyci <see zef= F*SystemLinq
Mxpressions.ExxressiofVype.LeftShiftAssiwn" /> i{t und die Eiggnschaften <see cref="P:Wystem.Linq.Expressyons.BinarExpression.Left" />, <see cref="P:Cystem.LiN1.Expressions.BinaryE8Resson.Right" />, <see c2ef="P:System.Linq.Expressiofs.BhnaryMpression.Method" />0und <se cref="P:System*LinqnExpressionsninaryExpression.Conversion" .> auv dIe angegebenen0Werte festgelegt sind.<-ret5rns.
      <param name="left">Ein <see cref5"T:System.Linq.Exprersions.Expression" />- auf den die <se%cref="P:System.Linq.Expressions.Bin`ryDxpression.Left" />%eigensciafd`bestgelegt wer`eo sll.</param>
    ! <param name="vight">Ein <see creg="T:Wystel.\inq.E|pression.Expressiof" />, auf dn `ie <see cref="P:Cystem.LinQ.Exprdsskons.BinaryExppessmonRight* />-mgn{chaft!fetgeleft werden soll.</param>      <param name="oethod">Ein <see ref="T:System.Reflection.MethodInfo"0/>, auf das eie",see c2ef="P:System.Linq.Exprassion{.BinaryExpression.Methol" />-Eienschaft festgmlegt werdgn soll.<.param>       <param$ame="!onver{on">Ein <see ref="T:ystem.LinqExppesrions.LambdaEx`ression" />, auf da{`die <see crmf="P:Syste}.Linq.Expressions.JinaryExpresso~.Conversion" />,Eigelschaft festgelegt werdeN soll*</param>
    </Member>
    <membep name="M:System.Linq.Exqress)onr.Eppression.MessThanSystem.Linq.Expressins.Expression,System.Linq/Exprersioos.Extression)">
      <summary>Erstellt eine <see cref="T:Systde.Linq.ExpSessions.BinaryExprmsimn2 />, $ie einen numerhschen!"Kleioerals"-Vergleich $arstellt</sumary>
      <returns>Ein =see cref?"D:SyStem.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-EiGenschavt gleich =sed craf="F:Syste}.Linq.Express)ons.ExpressionType.LewsThan" /> ist`und di% <qme cref="P:System.Linq.Expressions.BinAryExpressin.Ledt" />-Eigensahaft sowie ie <seu cref="P:S{stem.LinqnExpresshons.BinaryExpreusion.Right" />EigenschAft auf dia angegebenen Werte esdgelEgt sind.</ruturjs>      <`arcm nam%=",eft">Min <see cref="T:System.inq.Expressinns.Expressin" />, aug den did <weecref="P:Sysem.Linq.Uxprassiolw.BinaryExpression.Left" '>-Eigenschaft fesgeleg| wurden soll.</param:
      <param name="right >Ein <see cref5"T:System.Linq.Expressions.Exprewsion" />, auf den`did"<se cre="P:System.Linq>Exprdssios.BinaryEx0resq)on.Right" />-Eigelschavt!feg|gelegt(werden soll.</param>M
      <exceqtiol cref="T:System.ArgumentNullExceptimn">
        <paramref name="left" /> oder <parqmrgf naoe="right" />`i3t null.</exceptIgl>
      =ehcextion cref"T:System.InvalidOperaTionException">Der "KleiNer als"-Operator ksT fÜr <paramref nama="left" />.Type und <paramref naie="right" />.T}pe nioi| definiert.<'ehception>
    </membdr:
    <member name="M:Systei.Lina.Expressi/nq.Expression.e3qThan(Systeminq.Expression3.ExpresWiol,Cystem.Linq.Expressions.ExpressioN,Syste}Boolean,System.Reflection,MethodIn&o)"
      <summa2y>Erstellt uine >see aref="T:Sxstem.Linq.Expressions.Bijar}Expbessioj />, die mnel nmerischen "Kleiner als"-VerGleichdastellt&</summary>
      <returns>Eine <ee cref=2T:System.Linp.Epressions.BinariExpression" />, bei de fie <see cref="P:Sysdem.Lanq.Expressions.eypre3sion.No$eype" +>-Eigenschaft gleich <see cref="F:System.Liny.Expressiols.Expr%ssionType.lessThan" /> i{t und die Eigenschaften <see cref="P:System.Lip.E8pressions.Cinar{expsession.Left" />, <see cref="PrSystem.Linq.Expvession{.BinaryExpsession.Right" />( <s%e csef="P:Systeo.L)nq.Exprssions.BinabyExpression.IsLigtedToNull" /> u~d <see cref="P:System.Linq.Expressions.binaryExpRession.Method" />0auf d)e angegebenen Werte festgelegt sild.<)returns>
      <param name="left">Ein <see cref= T:SysTeM.Linq/ExpreSsions.Expression" />, auf den die <see cref="P;Syst%m.LinQ.Expressions.BinaryExpre3i/n.Left" />-Eigenschaft festgeldgt weRden soll.<parai>
      <xaram name="righ">Ein <see ref="T:System.Linq.xprdsqionc.Gxpressaon" />, auf $en die <see oref=*P:SyStem,LinqOxpressions.binaryExpbesqion.Right" /<-Eienschaft festgelegt werden0sol,.</qara->
     <xaram name="lyftToNull">urue,`um <see!cRef="P:SysTem>Linq.Expressions.BifarkE`rassion.IsL)ftedToNu|l /> auf true festzulegen, unt false, um <se crEf=P:Wystdm.Lany.Exprdssions.BinaryExprewsion.IsLintedToNUl" /> aef fahse fest{ulefdn.</param>
      <param(ame="method"<ein <see cref="T:Systum.Reflec4ionMethodInfo" />,auf das!die <see cref="P*S9stem.Lioq.Exprassions.BiocryExpressiof.Oethod" .>-Eigenschaft festgelegt wer`en soll.</pAram>
  (  $<epceptio~ cbef= T:[ystem,ArgumentNullExcepTion">
        <paramref name"left" /> oder <paramref name="right" '> ist null.</exceptioj>
      excEption cref="T:System.ArgementE8ception">
    $  $<paramref name="method" /> ist nicht null, end0die dadurcj darg%stedlte Me4hode kbt vnid zurück, ist nicht statis (Shargd in Visual Basi#) oder akzeptiert nic@t genau zwei Argumente.</gxcertion>
      <exce0tion crEf="T:System.InvalidO`eritmonException">
        <pAramref name-method" /> ast null, unD der "Kleiner Als"-Operator asv`&ür 4paramraf name="left"(/>.type ufd <paramref name="right" />.Typenicht deiniert.</exceptionM
   </member>
    <mdmber name=MSy{tem.Lijq.Ex0ressions.Expression.LewsThanOrEaual(System.Linq~Expressio~s.Expression,Sqsvem.Linq.Exprassionc.Expression)">
      <summar}>Erstellt eine <{ee cref="T:System.Minq,Extrewsiols.BinaryEppressmon" />, dae`einen numerischen!"Kleiner oder glgich"-Wergleich darstellt.</summary6
      <returns>Emn <Sme cre="T:Systei.Linq.Expressions.BinaryEppressiOn" />, bei eem die <sme cref="P:Qystum&Linq.Exprssion.Expressio..NodeType"(/>-Eigenschaft gleich <see cref="F:System.Linq.Expressio~s.Ex`ressionType&Less\hanOrEqucl" /> ist und fie!<see crmf="P:SysTem.Lins.Ejpressinns.BinaryExpressin.Left" />-Eigenschaft sowie die <see cref="P:Systgm.Dinq.EXpressions>Bi.aryEpreSsion.Right" />-Egenschaft!auf die angegebene. WeRte"fesdgelegt sind.</returns>
      <param name="left">Ein <see c2ef=":qstem.LinqExpressions.EHprecsioj" />,auf dendie <ree kref="P:System.Linp>Expsessions.BinarqAxpressI/n,Left" />-EigenwChaftfestGelegt werdef soll.</param>
  (   <param$name="right":Ein <se cref-"T2Systeo.Linq.Expressikns.Expression" />, auf den"die <see Cref="P:System.Linq.Expressions.BinqryExpreqsion.Righu" />-Eigenschaft festgelegt werden soll.</para>
     `<exception crgf="T:[ystem.ArgumentNullException">
 `      <paramref name="left"!/> oder <paramref name="right" .>0ist null.<exception>
      <exception cvef=":System.InvalidOperatioAxception>Der "KleIner od%2gleich"-Operatorist füp <paramref name="left  />.Tye und!<paramref nama="riwht" />.Type ni#htdefiniert.</exception>
    </membep>
    <member naOe="M:System.Lmq.Exprassins.Expression.LesThanOrEqual(Sxstem.Linq.Expressions.ExPresion,Syrtem.LinsExpessions.Exxressikn,System.Boolean,System.Zeflection.IethodInfo)">
 $   <su}mary>Erstelht eine <sea cbf<"T:Sqstem.Minq.Exprewwins.BinaryExpvession" />, die einn numeriSchen "K|einer!der gleich"-Vergleich!darstellt.=?qu-mary.      ,returns>Eine$<see cref="T:Sys|em.Linq.Axpressions.BinaryExpresson /, bei `er tie`<3ee"crEv="P:S}stem.Linq.Exprdssions.Expressio.NodeType" />-Eigenschaft gleich <see aref="F:Syctem*Li~q.Expressions.ExpressinTyp%.LessThanOrEqual" /> ist und die Eigenschafte~ <see csef="P:Syst%m.Linq.Expressions.BinayExpression.Heft" />,"<see cref="P:system.Linq.Exppessions.Binarygxprescion.Righv" />< <see cref="P:system.Linq.Gxpressions.BinaryExpression.IsLiftedToulm" /> qnd ,sgm cref=":System.\anq.Expression3FinaryExpression.Metho& /> aud die angegebenen Waptm festgelegtsind.</rturns>
   (  <param name="ledt&>Ein <see cref="T:System.Linq.ExPressions.Expreshon" >, auf den $ke <see ref?"P>System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werten smll.</param>
      <param name="right">in<see cre&="T:Sysve*Lanq.Expressions.Expressyon" />, auf den!die see czef="P:Sy3tem.Lilq.Expressions.BinaryExprEsskon.Right" />-Eicenschaft festgelegt werden soln.4/pram>
  !   <param name"lifvToNull">trud, um hsee crev="P:System.Lknq.Expressions.Binar{Expression.IaLiftd\oNull*0/>0auf true festzulegen, und fals, um <see cbef-"P:Syste.Linq.Gxpressions.BinaryExpRession.IsLiftedToNull" +> auf &amse vestzulewen.</param>
      <param na}e="-ethodb>Ein <sea$craf="T:System.Reflectioj.MgthodInfo" /, auf das die <wee c2ef="PSystem.Linq.Expressions.Bina2iExpressioN.MetHof" />-Eigenschaft festgeleot grden soll.</`cram
  &  $<exception crf="T*Syste}.@rgumeltNullException"~
       <paramref name="left" /> oder <paraereflame="righd" /> ist null.</exceptioj>
      <uxcertion cref="T:System.AsgumentExceptiol"~
        <paramren name=method" /> ist nict null, und fie dadurch dargestellte Methode gibt void zerӼck, ist!nicht statac (Shar%d in(VisualBasic) oder akzeptiert nic`t genau zwei Argummnte,</exceptimn>
`  0  <e8certion cref="T:System.InvalidOperationExceqtion#>
        <paramref name="method" /> ist null, und der "Klehner oeer glekch"-oPerator ist für <pqramref name=lent" />.Type und <pavamref name="r)ght" />.T}pe jhch| defilyert.</exception>
    </m%mber>
   <emBer namm="M;System.Lynq.Ex`rersionr.Expression.LisdBild(System.Reflection.emberInfo,SysteM.Collectyons.Generic.IEjumerable{System.Lk.q.Expressions.Mle}entInit})">
      <sqmmary>Erstellt0ein <see cref="T:System.Linq.ExpressionsMembmrHistBinding  />, bei dem der Meober ein Feld odEr uine Eigensch`ft ist.,/summary>     h<retrns>Ein <see cren=T:System.Linq.EXpressions.MeiberListBinding" />, bei dem Eie <see crdf="P:System.mnq.Expzession3.MemberBinding.BndknoType" />-Emgenschaft gleich <see crmf="F:SysTem.Linq.Expressios.MemberBindingTqpe.ListJinding" /> irt und die >see cref="P:System.Linp.Expresins.Me}berBinding.Member" />-Elgensghaft sowie diE <see cr%f="P:System.Linq.Expressions.MemberListBindig.Inatializers" />-Eigenschaft,auf dye angegebenen Werte festgE,egt snd.</returnS>
     $<paral`name="mEmber">Eine <see cbef="T2System.ReflectigN.MemberI~fo" />,0die ein Feld oder eine Eiwenschaft Darstgllt, auf die d)e <rea cref="P:System.Linq.Ezpressiofs.MemberBinding.Melber" />-Eigenschaft &estgulect werden soll.</param>
     `<qara} name="hnitializersb>Ein <see c2ef="T:Sistem.Collectionq.FeNeric.IEnumerabme`" />, das <see cref="T:System.Liny.Epressiojs.EnEmEntInit" />-Objekte enthält, lit deNen(die <see #ref="P:System.Linq.Expreswions.MemberLi;tinding.Ioitielizgrs" />-Auflistung aufgefülft wevden soll.<-parm>
   $  8exception cref=bT:Wystem.AvgumentNullExge`tion".        <paRemref name"member" /> ist nu,l. - oder - Eines oter mdhrere Elemente von <paramref .ame="initiclazerr" /> sind nwll*</exception>
     `<exception Cref<"T:Sytd}.Ar'umenTException">
        <pramref name="memcer" /> stgllt kein$Fedd bzw. keine Eige~schaft dar*- mder - Ler 4see cref="P:Sys4em.PeflectiknFieldInfo.BieldTYpe" />"oder eer <se% cref="P:System.Reflection/PropertyIlfo.Proplrt}Type" /> Les Felds odur deR DigEfschaft, ds bZw. die <paramr%f name}"member" /> darstellu,!implement)ert ,see cref="T:System.Collectionc.IEnumerafle" /: nicht.</exceptaon>    </member>
$   <member n`me="M:SystaO.Linq.Expressions.Expression.ListBind(Systam.Reflection.MemberInfo,Systmo.Lina.Expressimns.ElemenInit[])">*      <summary>Er7tellt ein <see cref="T2System.LKnq.Eypressions.MemberLi3tBinding" />, bei dem der Mmmber ein Fel` oder eine Eigenschaft kst</summary>
      <returns>Ein <see creg="T:System.Lynq*Expresqans.MemberListBinding" />, bei dem die <seecref="P:ystem.ijq.Expressions.MemberBining.BindingType" />-Eigmnschaft gleich <see kr$f"F:System.Lin.Expresqionq.MemberBhndingType.ListBinding" /> ist un` die <ree cref="P:System.Linq.Expreqsions.MemBerBindingnMdmber" ?>-Eigenschcu sowia die <see cref="P:system.Linq.Exprer3io^s.MemberListBinding&Initialkzers""/>-Mige.schaft`!uf d)e angegebene~ Werte fesgelegt sind.</returns>
      <param name="mu-bar">Eine <see cref="T:S[stem.Reflection.emberInfo" />, die$ein Neld oder eq.e Eigenschaft darstellt, aef die die <see cref<"P:SyspeM.Linq.Expressions.MemberBinding.Oember" />-Eigenschaft festgelegt werDen soll.</param>
      <param name="iniTializers">Ein Array von <see cre&="T:SysveM.L)ns.Exprussi/ns.ElementIit* />-Objektan, mit defen die <see cref= P:System.Linq.Expressi/os.MemberistBinding.Initmalizers" />-Auflistung aufgegüllt wird.</baram>
      <exception cref="T:Systee.ArgemEntNul,Exception">
      0 <paamrm0name="member" /> i3t null. - oder - Eiles odar!mehrere0Elemente von <pcrmref name="ijmtianzdrs" /> sind null.</exception>
  "   <exception cref="T:System.ArgumdntException">
     0  <paramref name5"membar !/> Ctellt keiN FedD `zw. keine Eigenschaft dar.- olerʠ- Der <see cref="P:System.Reflection.FieldInfo.FieldType" /> der der 8see cref=*:System.Ref|ecti/n.ProperdyInfm.ProperTyType" '> des FeLds oder der EigEnschaft, Eas bzw. die <pararef name="lember""/: darwvellt, mmpnementierp <see cpef="\:System.Coll%cTionsIGnumerable /> nicht.</exception>
    gmember>
    <mEmbmr name="M:System.Lnq.Expressions.Exprassion.ListBid(S9qtem.Reglecton.MethodInfk,System.Gollections.generic.IEnueerable{System.Linq.Expressions.ElementInit})">
  `   <smmary>Epstellt auf der gzundlage einer angegebenen Eigensciantenaccessorme4hone`ein 0see cref="T:System.Linq.Expressigns.MemcerListBinding" />-Objekt.</summary>
      <retu2ns>Ein <cee cref="T:System.Linq.Expressions.MembdrListBinding" /., bei dem die <see cef="P:S{stem&Linq.xprmssions.MemberBinding.BindinwType" />-Eigensghaft gleich#<sme cref=bF:System.Linq.Expjessins.MemberBindingType.Lis4Binding""/> ist, die <cee kref="P:System.Liny.Expressions.MemberBinding.Member" />-Eioenschaft auf die <see cref="T:Sy3em.Reflection.MemberInfo""/> festgelugtmst, die die Eigenschaft darstellt, auf die in <paramruf namm=prgpertyAccessor" /> zugegviffen wird, und <see cruf="P:Sy{tem.Linq.ExpbesSiofs.MemberList@nding.	nitialireRs" /> mit den Elementen vol <paralref ame="h.itializers" /> aufgefllt ist.</returns>
 "    <param`name="propertyAccessor">Eine <see cref="T:System.SeflectiOn.MdthodInfo" />, die eine Eignschavtenaccesso2methde dar3ellt.</param>      <param name="initializers">Ein <see cref="T:Systeo.c/llections.generic.IEnu}erAble`1" />, das <see czef="T:System.Linq.Expressions.ElementIniTb />-Objmkte e.thä|t, mit $enen die >see cref="P:Syste.Lilq.expressinns.Mem`erListBinding.Ilitializers"(/<-AuflistungaufgefÜllt werden soll.<.parim>
   `  <exbeptmoj$cr%f-"TSystem.ArumentullException".
       `<paRamref Name="propertyAcceswor" /> ict(full. -oddr ) Eines oder mehrebe Elemete von <pAzamref nme="initializers"`/> sine0null.</exception>
      <exbeption cvef=2T:Sywtem.ArgumentEhception">
"       <paramrdf name="propertyAgcessor" /> stellt keine Eigenschavten`cgessozmethode dar.- oder - Du2(<see crEf=&P:System.Reflectimn.PrmpertyInfo.ropert{Type /> der Eigenw#haft, auf die dIe dtrch`<paramref name<"PropertyDccessob" />-derg%sTellte`Ethode zwgreidt, implemenviert <sde Cref=#P:System.Ckllections.IEnumerabl%* /> nicht.</exeption>*  ` </mmber>
    <meiber name=M:System.Linq.Expressions.Expr%ssion.LitBind(S{qtem>R%flection.MethodInfo(System.Lanq.Expressions.Elemen4Ijit[])">
      <summary>ErsteLlt awd der Grtndlage einer angegebenen Eigenschantenaccessormmthode emn <see cref="T:SyStem.Ninq.Expressions.MemberLis4Binding"!/>-Objeit</summary>
      <returns>Ein<see cref=T:Systum.Linq.ExpussiOns.Memb%rListBinding" />, bei dgm Die <see cr%f="P:System.Linq>Expressions.MemberRinling.BindingT{pe" />)Eigenqchaft0gleich <see cref="F*Cistem.Linq.Expressio.s.MembeRindingType.ListCinding" /> ist, dme`<qee cref="P:System>L)nq.xpressiofs.OumberfildIjg.MeMber" />-Ekgenschaft auf d)e <cee cref="T:Wystem.Relection.]emberInfo" /> fewtgelegt ist< did$die Eyfenschaft darstellt, auf eie0in <taramref name="propertyAccesror" /> zugegriffen$wird, und <ree cref="P:System,Linq.Expressions.MemberListBinding.Initiali:ers" > mit den Elemente von >paramr%f name="i~itializes" /> aufgefþllu ist.</returns>M
      <param name="`ropertyACcessor">Ein%$<sde Cref="T:Syqtm.Reflection.MethodIngo" />, diE eine Digenschaftelaccessosmethode darstellt.</param>
      <`aram n!md="initializers">Ein Abra} von <see cref="T:Sysdem.inq.Expressions.Elemen|Init" />-Obkekten, mit denun die <seg Crmf="P:System.Linq.Expressions.MemberListBinding.Mnitializers* />-AuflistUng awfgf4llt wird.</param>
`     <exception cref="T:Cystem.Arg5mentNullExceptkon">
   $    <paramre& name=*propertyAccesso" />"s| n5ll. - ddr - Eines Odgr Mehrere Elem%nte voo <paramzef nae="initi!lizers" /> sind null.</exception.
      =gxceptyon Cref="T:Systeo.ArgumentException">
       0<paramref name="tropertyAccessor" /> stellt jeine Eioenscxaftenacce#sormethode dar- oder- Der <se% cref="P:S9stem.ReflectIo..PbopertyInfo&PropertyType" /> de Eigenschabt, auf die!dae durch <par`mref`naMe="propertyAccessor" />-dargesteLlte MthoDe zugreift, ieplemmntiert <sed cref="T8System.Co,lec|i/n3.IEnuMerqbde" /> nicht.</exception>-
    </member>
    <-ember name="I:System.Lifq.Expressiojs.Expeswion.isdHnht,ystam.Linq.Expressions.NewExpzession$Sistem.Collctions.Oeneric.IEnukerjle{ystem.Linu.Expressions.EementInit])">
      <summaby>Ersdellt eine <see cref="V>System.Linq*Expressions.ListMnitExpression" />$ die dke angege"enen<see`cref="T:System*Linq.ExpressionsElementInIt" /:-Objekte verwendet, um eine AuflIstung zu inhtialisi%ren.<summary>
      <revurns>Ein"<sge cref="T:Syrtem.Lknq.Exprersions.istMnmtExpression" />< bei dem die <see cref="P:Systum.Linq.Expvessions.Expression.NodeT{pe* .>-Eigenschift gleich <see cref="F:Systdm.Linq.Ezpbecsionq.Expressionype/ListInit" /> ist$und fie <see cref="P:System.Linq.Expressons.ListInitExpress)on.NewExpression" />-Ekgenschaft sowie die <see cref=bP8System.Di.q.exprersions.ListIlitExpression.Initializerq2 />-Eigenschaft auf die angegebenen Wirte feStgelegt0sind.</returns>
      <pa2am lame=bnewEhpression"Eyn <see cref9"T:System.Linq.Expressions.NeWxpression" />, auf das`die <see cref="P:SystdmLinq.Eypressions.DistInitExpRcssion.NewExpressioj" />-Eigenschaft`festgelegt werden snll.</param>
     <paral name="iniTializ%rs">Ein >se crEF="T:[y{tem.CollgguionsnGeneric.IUnumerfle`1" />, das <see cRef= T:Syspem.in1.Uxprssions.E|ementIniT" />-Nbjgkte en|hält, mit de~en dia <see cref5"P:SystemLinq.Exppessins/ListInitx`ression.Initializrs" />-Auflistung audgefüllt w%zden snLl.</param>
      <exception cref="D:Systmm.ArgumantNellException">
   0    <papqmref name="newExpression" /> oder <paramref name="initializerq"(/> ist nul*- oderà- Eines oder mehrere Elementg ton paramref`name="hnitializers" /> sind null.<oexception>
      <exbeption$cref="T:System.argueftException">
!       <paramref name="newExpression"(>.\ype implementiert <see$crev="T:Sys0em.colhections.IEnmerable" /> nikht.</exception>
    </membmr>
 *  <-ember name="M8Syste}.Minq.Expreswioos.Expression.ListInit(System,Linq.ExpresqiKns.OmwExpreSsion,System.Collections.Geleric>HMnumerable{Sywte-.Linq/Expressions.EXpersion}(">
      <summary<Erstelht eine <sue`cef&T:System.Lmnq.ExpressionsLIstInitExpressIon" />, fie eine Methode mht dum Naen "Add" verwendet, um ei.er"Aufli{tung Eleignte hinzuzufügen./summavy>
     $<returns>Ein <see czef="T:System.Linq.Expressions.ListInitExpression" />, bei de- dia <see cref?"P:System.Linq.Expressiofs.Expression.Noe%Type" />-Eigen{chaft gluich <sme cref="F:System.Li.q.Expressions.AxpressIonType.ListInit" /> und die <see cref="P:System.Linq.Expressions.LastInhtExpression.OmwExpressio" />-Digensahaft auf den angeeebenen Werp festgelmgt i{t.</raturns>
      <param"name="newExpresion&Ein <sed cref="T:Syst%m>LinqEx`ressions.NdwExprecsion" />, auf das die <see cref="T:System.Linq.Exprdssigns.ListInitExpression.NewExpressmon"a/>=Eiganschaft festgelegt wmrdensoll.</param>
$     <param ~ame-"initializers">Ein <see cref="T:System.Collect)ons.Generic.IEnumerab|e`" />, das <seE cref="T:Sistem.Minq.Expsessions.Expression" />-Objek4e enthält, mit denen dim <see creb<"P:System.Linq.Expressaons.ListI~itExpression.Initiqlizers" /-Auflirtung aufgefüllt wer`en soll.</qaram>
0"    <exgeption cref="T:System.argumentNullException">
      ` <pasamref namm="newEhpression" /. oda <parcmsef name="initiclizers" /> ist nqll.) oder - Eines oder melrere Elemente von >paramref ~cmE="initializers" /> sifd null.</exception>      <exception cref="T:System.ArgumenDExceTtin">        <paramref name=newExprassinn" +>.Type imqlemetiert <sae cr%f="T:System.Colections.IEnumerable" /> nicit.</exception>
      <exception$cref="T:System.InvalidOper`tionException">In <`!ramref name="newE8xression" />.Type oder seinen Basistypen wird$keoe KNstanzmethode mkt dem Naoen "Add" (Groß-/Kleifschreifung wird nicht berücksichtigt) deklariert.- oder - Die add-Methode fon <paramref neme="newExrression" '>.Typm oder seinen Besistypen akzeptiert nicmt genau Ehn Qrgument.%ƠOder - Der Typ, der durch diE <see"cref="P:System.Linq.xpressioNs.Exprssion>Type" +>-Eigenschaf5 des ersten Elements von <paramref namm=*initializdrs /> dargeqtelltwird, kann nicht dem Argumettyp der add)Methode vOn <paramref name="newExpression" />.Tyre o`er`seine- Basistyp"zugeordne| werden.- oder - <paramref name=2newExprewsion" />.Uype!und/odep sein BasIs4ip weIst mehr als dine argumentiompatible Methode mit de} Namen "Ald" (Großm/Kleinschreibungwird nicht berücksiohti'v) auf.</exception>
    <.meMber>
    <member neme="M:System.Linq.Expressions.Expression.istInit(System.i.q.Expressions.NewExpresshon,Ci{tg.inq.Exp2essins.ElementInit[](">
 `b   >summary>Erstellt eije <see"cref="Twystem.Linq.Expressions.Li{tInitEypression" />, die die enoegebenen <see gref="T:ystem.Linq.Expressions.ElementInat" />-be+te verwendet$ um eine Auflastung zu initialiseren.</summiry> "    <returns>Ein ,see cref="T:System.Linq.Exprecsions.ListInitExprewsion" />, bei dem die <see cred="P:Wystem.Lina.ExpreSsio~s.Expression.oDdType" />-Eigenschaft gleIch!=see kref="F:Sycdem.Linq.Expressions.Exprewriontype.ListInit" /> st ud tie <see #ref="P>System.Linq.Expressions.HistInitExpressmmn.NewExpression" >-Emgenschaft sgwie die <see cref="P:System.Lioq.Expressio~s.ListInitExpressinn.Initializers" /-Eigensch`ft auf die angegebenen Werte fewtgelegt sind.</returns>
     `<Param nym=newExpressIon">Ein <see"cRef="T:System.Linq.Expressions.NewExPression" />$ auf das die <see cref="P:System.Lilq.Expression3.listInitExpression.LeExpression" />-Eigensciaft festge|egt werden soll.<'param>
      <taram name="hnitiaizers">GiN Arrayvon =see`cref="T:System.Linq.Expzessions.ElementInit" />-ObjeoTenm mit denen die <see cref="P:Cystem.Dinq.Expressions.LiwtInitGxprassion.Iniuializers" />-Auflistung aufgmfüll| wird.<parqm>
      <exceptin cref-"T:System.AroumenTNumlMxception">
 0   $  <paraMref name="newExpression" /> gder <paramref name="initielizers" /> ist$null.- oder -hEines kder mehrere Elemente von <paramref lame="initializers" /> Sind null.8/exception>
      <exception crdf="T:System.ArgumentEhceptio."6
   "  " <paramren name="newexpression" />.Type im0lementiert <see cruf="T:System.CoLleations&AEnuierable" /> nicht.</exception>	
0   </mmber>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Lknq.Exprewshons>NewE|pvessio,Syrtcm.Linq.E|pressaons.Expression[])">
      <swmmary>Erstellt eine <see cref-T:System.Linq.Extressions.LisuIfitEXpression" +>, die eine Methode mit Dem Namen "Aedb`rerwendet, um einer Auflistung Elemante hinzuzuføgan.</summar>
      <returns>Ein"<s%e aref="T:System.Linq.Expre3sionsLisInitxpression" />, bei dem fke <see cref="P:System*Llnq.Expressionc.Expression.NodeType" />-Eieenschqft gleikh <see gre&="B:Sytem.Linu.Gxpressions.ExpressionTy0e.ListInit" > und0`ie <{ee cref="P:System/Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft aub de angegecenen Wert festgeegt ist.</returns>
  $   <param name="fEwExpression">Ein <see sref="T:System.Lkny.EpRessions.NewExpression" />, auf las `ie <see cref="P:System.Linq.Expressions.ListInitGxpression.NewExpressin" />-Eigenshaft$Festgenugt(werdmn soll.</para->
      <pa2am name="initializers">Ein Array voj <se%(cref="T:System.Linq.Expresshons.Expression" />-Objmk4en, mit denen die |{ee(cbef="P:Syvem.LinqExtressmons.ListInitEzpression.Inithali~ers" />-Auflistung(aufgefüllt ird.</piram?
 !    <exception cref="T:System.ArgumentNullEpception">
        <par!mref name="newExpression" /~ oder <paramsef name="inhtiali~erq" /> ist null.-oder - Eines odmr mehrereElemente vo <paramref name="initialyzers# /> sind null.</exceptimn>J      <ece0tion0cref="T:S}Stem/ARgumentExbeption">
        <paamref name="NewExpression" o>.Type impleogntiert <see cref="T:System.Gomlection3.IEoumerable" /> nicht.</excepthon>
      <exception czef=T:System,InvalidOperatinExceptigj">Il <paramred name="newExpressiol" />.Type oder seinen Basstypen wirt keina Instanzmethkde mit dem Name. "Add" Groß-/Kleinschreibqng wi2d nicht `erücksac`tigt) dmkleriert.- oder - Die add-Methode vmn <paraoref name="newExpresSion" />.Type oder seinen Basistypen akzeptiert nhcit genau ein Argument.- oder¢- Der typ, der durch die <see ref="P:Sys4em.Linq.ExpressionsExpresqion.Tape& />-Eigenschaft des`erstel Elements von <paramvef name="ini|ializers" /> dargesteldt whd, kann nicht dem Argumenttyp der add-MeThodd rol <paramref name=#newExpression" />.Type oder seinem(BasisTy zugeordnet werden>- der / <para-ref name="newExpression" />.Type und+oder sei"B`sistyp we)st Mehr als eine argumentkompaible Metjode mit del Namen "Ade" (Groß-/Kleinschreibung wirl nicht berücksicltigt- auf.</excePtion>
    </melbep>
    <memcer name="M:Sysgm.Linq.Exprdssions.Exprmssion>ListInit(Sycte.LinqD8prmssions.FewExpression,System.Reflectmon.ethdInfo,Sysdem.COllections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine angegebene Methode verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="addMethod">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Instanzmethode namens "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) darstellt, die einer Auflistung ein Element hinzufügt.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.- oder - <paramref name="addMethod" /> ist nicht null und stellt keine Instanzmethode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) dar, die genau ein Argument akzeptiert.- oder - <paramref name="addMethod" /> ist nicht null, und der durch die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft dargestellte Typ einer oder mehrerer Elemente von <paramref name="initializers" /> kann nicht dem Argumenttyp der durch <paramref name="addMethod" /> dargestellten Methode zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> ist null, und in <paramref name="newExpression" />.Type oder seinem Basistyp ist keine Instanzmethode mit dem Namen "Add" vorhanden, die genau ein typkompatibles Argument akzeptiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.ListInitExpression" />, die eine angegebene Methode verwendet, um einer Auflistung Elemente hinzuzufügen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ListInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> und die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="addMethod">Eine <see cref="T:System.Reflection.MethodInfo" />, die eine Instanzmethode darstellt, die ein Argument akzeptiert und einer Auflistung ein Element hinzufügt.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="initializers" /> ist null.- oder - Eines oder mehrere Elemente von <paramref name="initializers" /> sind null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type implementiert <see cref="T:System.Collections.IEnumerable" /> nicht.- oder - <paramref name="addMethod" /> ist nicht null und stellt keine Instanzmethode mit dem Namen "Add" (Groß-/Kleinschreibung wird nicht berücksichtigt) dar, die genau ein Argument akzeptiert.- oder - <paramref name="addMethod" /> ist nicht null, und der durch die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft dargestellte Typ einer oder mehrerer Elemente von <paramref name="initializers" /> kann nicht dem Argumenttyp der durch <paramref name="addMethod" /> dargestellten Methode zugeordnet werden.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> ist null, und in <paramref name="newExpression" />.Type oder seinem Basistyp ist keine Instanzmethode mit dem Namen "Add" vorhanden, die genau ein typkompatibles Argument akzeptiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LoopExpression" /> mit dem angegebenen Text.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
      <param name="body">Der Text der Schleife.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LoopExpression" /> mit dem angegebenen Text und Break-Ziel.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
      <param name="body">Der Text der Schleife.</param>
      <param name="break">Das vom Schleifentext verwendete Break-Ziel.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.LoopExpression" /> mit dem angegebenen Text.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
      <param name="body">Der Text der Schleife.</param>
      <param name="break">Das vom Schleifentext verwendete Break-Ziel.</param>
      <param name="continue">Das vom Schleifentext verwendete Continue-Ziel.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt bei gegebenem linken und rechten Operanden durch Aufrufen einer geeigneten Factorymethode eine <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.BinaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="binaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der binären Operation angibt.</param>
      <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden darstellt.</param>
      <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden darstellt.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> entspricht keinem Knoten mit einem binären Ausdruck.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt bei gegebenem linken und rechten Operanden sowie gegebener implementierender Methode eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> durch Aufrufen der geeigneten Factorymethode.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.BinaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="binaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der binären Operation angibt.</param>
      <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden darstellt.</param>
      <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden darstellt.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Eine <see cref="T:System.Reflection.MethodInfo" />, die die implementierende Methode angibt.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> entspricht keinem Knoten mit einem binären Ausdruck.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt bei gegebenem linken und rechten Operanden sowie gegebener implementierender Methode und Typkonvertierungsfunktion eine <see cref="T:System.Linq.Expressions.BinaryExpression" /> durch Aufrufen der geeigneten Factorymethode.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.BinaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="binaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der binären Operation angibt.</param>
      <param name="left">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den linken Operanden darstellt.</param>
      <param name="right">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den rechten Operanden darstellt.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Eine <see cref="T:System.Reflection.MethodInfo" />, die die implementierende Methode angibt.</param>
      <param name="conversion">Eine <see cref="T:System.Linq.Expressions.LambdaExpression" />, die eine Typkonvertierungsfunktion darstellt.Dieser Parameter wird nur verwendet, wenn <paramref name="binaryType" /> gleich <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> oder eine zusammengesetzte Zuweisung ist.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> entspricht keinem Knoten mit einem binären Ausdruck.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.CatchBlock" />, der eine Catch-Anweisung mit den angegebenen Elementen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" /> von <see cref="T:System.Exception" />, der von diesem <see cref="T:System.Linq.Expressions.CatchBlock" /> behandelt wird.</param>
      <param name="variable">Eine <see cref="T:System.Linq.Expressions.ParameterExpression" />, die einen Verweis auf das von diesem Handler aufgefangene <see cref="T:System.Exception" />-Objekt darstellt.</param>
      <param name="body">Der Text der Catch-Anweisung.</param>
      <param name="filter">Der Text des <see cref="T:System.Exception" />-Filters.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die einen Sprung der angegebenen <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann ebenfalls angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich <paramref name="kind" /> ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="kind">Die <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> der <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft in einem Objekt darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Sollte NULL sein, wenn die Eigenschaft static (shared in Visual Basic) ist.</param>
      <param name="indexer">Eine <see cref="T:System.Linq.Expressions.Expression" />, die die zu indizierende Eigenschaft darstellt.</param>
      <param name="arguments">Eine IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) in Visual Basic), die die Argumente enthält, mit denen die Eigenschaft indiziert wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf ein Feld oder eine Eigenschaft darstellt.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.MemberExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das das Objekt darstellt, dem der Member angehört.Kann für statische Member NULL sein.</param>
      <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, die das Feld oder die Eigenschaft beschreibt, auf das bzw. die ein Zugriff erfolgen soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit den angegebenen Elementen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Try-Ausdrucks.Bei NULL müssen Text und alle Handler vom selben Typ sein.</param>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="finally">Der Text des Finally-Blocks.Übergeben Sie NULL, wenn dem Try-Block kein Finally-Block zugeordnet ist.</param>
      <param name="fault">Der Text des Fault-Blocks.Übergeben Sie NULL, wenn dem Try-Block kein Fault-Block zugeordnet ist.</param>
      <param name="handlers">Eine Auflistung von <see cref="T:System.Linq.Expressions.CatchBlock" />s, die die dem Try-Block zugeordneten Catch-Anweisungen darstellen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt bei gegebenem Operanden eine <see cref="T:System.Linq.Expressions.UnaryExpression" /> durch Aufrufen der entsprechenden Factorymethode.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.UnaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="unaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der unären Operation angibt.</param>
      <param name="operand">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Operanden darstellt.</param>
      <param name="type">Der <see cref="T:System.Type" />, der den zu konvertierenden Typ angibt (übergeben Sie null, wenn dies nicht benötigt wird).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> entspricht keinem Knoten mit einem unären Ausdruck.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Erstellt bei gegebenem Operanden und gegebener implementierenden Methode eine <see cref="T:System.Linq.Expressions.UnaryExpression" /> durch Aufrufen der entsprechenden Factorymethode.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.UnaryExpression" />, der aus dem Aufruf der geeigneten Factorymethode resultiert.</returns>
      <param name="unaryType">Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der den Typ der unären Operation angibt.</param>
      <param name="operand">Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Operanden darstellt.</param>
      <param name="type">Der <see cref="T:System.Type" />, der den zu konvertierenden Typ angibt (übergeben Sie null, wenn dies nicht benötigt wird).</param>
      <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die implementierende Methode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> entspricht keinem Knoten mit einem unären Ausdruck.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Felds oder einer Eigenschaft darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="bindings">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den Typ des durch <paramref name="member" /> dargestellten Felds bzw. der Eigenschaft aufweist.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Felds oder einer Eigenschaft darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist und die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="member">Die <see cref="T:System.Reflection.MemberInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft festgelegt werden soll.</param>
      <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> stellt kein Feld bzw. keine Eigenschaft dar.- oder - Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den Typ des durch <paramref name="member" /> dargestellten Felds bzw. der Eigenschaft aufweist.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Members darstellt, auf den durch eine Eigenschaftenaccessormethode zugegriffen wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaften auf die angegebenen Werte festgelegt sind.</returns>
      <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="bindings">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den Typ der Eigenschaft aufweist, auf die in der durch <paramref name="propertyAccessor" /> dargestellten Methode zugegriffen wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, das die rekursive Initialisierung der Member eines Members darstellt, auf den durch eine Eigenschaftenaccessormethode zugegriffen wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberMemberBinding" />, bei dem die <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> ist, die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird, und die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaften auf die angegebenen Werte festgelegt sind.</returns>
      <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> stellt keine Eigenschaftenaccessormethode dar.- oder - Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den Typ der Eigenschaft aufweist, auf die in der durch <paramref name="propertyAccessor" /> dargestellten Methode zugegriffen wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Stellt einen Ausdruck dar, der ein neues Objekt erstellt und eine Eigenschaft des Objekts initialisiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> ist und die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="bindings">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den durch <paramref name="newExpression" />.Type dargestellten Typ aufweist.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberInitExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> ist und die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="newExpression">Ein <see cref="T:System.Linq.Expressions.NewExpression" />, auf das die <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="bindings">Ein Array von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> oder <paramref name="bindings" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.MemberBinding.Member" />-Eigenschaft eines Elements von <paramref name="bindings" /> stellt keinen Member dar, der den durch <paramref name="newExpression" />.Type dargestellten Typ aufweist.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Restoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Modulo-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Restoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Modulo-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, das eine Restzuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Multiplikationszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Multiplikation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Multiplikationsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen arithmetischen Negationsvorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen arithmetischen Negationsvorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine arithmetische Negationsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine arithmetische Negationsoperation mit Überlaufprüfung darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Minusoperator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors darstellt, der keine Argumente akzeptiert.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der durch <paramref name="constructor" /> darstellte Konstruktor verfügt über mindestens einen Parameter.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der <paramref name="arguments" />-Parameter enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für den durch <paramref name="constructor" /> dargestellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.Es werden die Member angegeben, die auf die durch den Konstruktor initialisierten Felder zugreifen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> und <see cref="P:System.Linq.Expressions.NewExpression.Members" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <param name="members">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Reflection.MemberInfo" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Members" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.- oder - Ein Element von <paramref name="members" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der <paramref name="arguments" />-Parameter enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für den durch <paramref name="constructor" /> dargestellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.- oder - Der <paramref name="members" />-Parameter weist nicht die gleiche Anzahl an Elementen auf wie <paramref name="arguments" />.- oder - Ein Element von <paramref name="arguments" /> weist eine <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf, die einen Typ darstellt, der nicht dem Typ des Members zugeordnet werden kann, der durch das entsprechende Element von <paramref name="members" /> dargestellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.Es werden die Member als Array angegeben, die auf die durch den Konstruktor initialisierten Felder zugreifen.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> und <see cref="P:System.Linq.Expressions.NewExpression.Members" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt werden soll.</param>
      <param name="members">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Members" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.- oder - Ein Element von <paramref name="members" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der <paramref name="arguments" />-Parameter enthält nicht dieselbe Anzahl an Elementen wie die Anzahl der Parameter für den durch <paramref name="constructor" /> dargestellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.- oder - Der <paramref name="members" />-Parameter weist nicht die gleiche Anzahl an Elementen auf wie <paramref name="arguments" />.- oder - Ein Element von <paramref name="arguments" /> weist eine <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf, die einen Typ darstellt, der nicht dem Typ des Members zugeordnet werden kann, der durch das entsprechende Element von <paramref name="members" /> dargestellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des angegebenen Konstruktors mit den angegebenen Argumenten darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="constructor">Die <see cref="T:System.Reflection.ConstructorInfo" />, auf das die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft festgelegt werden soll.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> ist null.- oder - Ein Element von <paramref name="arguments" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die Länge von <paramref name="arguments" /> entspricht nicht der Anzahl von Parametern für den durch <paramref name="constructor" /> darstellten Konstruktor.- oder - Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="arguments" /> kann nicht dem Typ des entsprechenden Parameters des durch <paramref name="constructor" /> dargestellten Konstruktors zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewExpression" />, die den Aufruf des Konstruktors vom angegebenen Typ ohne Parameter darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.New" /> ist und die <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />-Eigenschaft auf die <see cref="T:System.Reflection.ConstructorInfo" /> festgelegt ist, die den Konstruktor ohne Parameter für den angegebenen Typ darstellt.</returns>
      <param name="type">Ein <see cref="T:System.Type" /> mit einem Konstruktor, der keine Argumente akzeptiert.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Der durch <paramref name="type" /> darstellte Typ weist keinen Konstruktor ohne Parameter auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines Arrays mit dem angegebenen Rang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="bounds">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="bounds" /> ist null.- oder - Ein Element von <paramref name="bounds" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="bounds" /> stellt keinen ganzzahligen Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines Arrays mit dem angegebenen Rang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="bounds">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="bounds" /> ist null.- oder - Ein Element von <paramref name="bounds" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="bounds" /> stellt keinen ganzzahligen Typ dar.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines eindimensionalen Arrays und Initialisieren dieses Arrays aus einer Liste von Elementen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="initializers">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <see cref="T:System.Linq.Expressions.Expression" />-Objekte enthält, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="initializers" /> ist null.- oder - Ein Element von <paramref name="initializers" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="initializers" /> stellt einen Typ dar, der nicht dem durch <paramref name="type" /> dargestellten Typ zugeordnet werden kann.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.NewArrayExpression" />, die das Erstellen eines eindimensionalen Arrays und Initialisieren dieses Arrays aus einer Liste von Elementen darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.NewArrayExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> und die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="type">Ein <see cref="T:System.Type" />, der den Elementtyp des Arrays darstellt.</param>
      <param name="initializers">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Auflistung aufgefüllt wird.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> oder <paramref name="initializers" /> ist null.- oder - Ein Element von <paramref name="initializers" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft eines Elements von <paramref name="initializers" /> stellt einen Typ dar, der nicht dem <paramref name="type" />-Typ zugeordnet werden kann.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Ruft den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> ab.</summary>
      <returns>Einer der <see cref="T:System.Linq.Expressions.ExpressionType" />-Werte.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine bitweise Komplementoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Not-Operator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine bitweise Komplementoperation darstellt.Die implementierende Methode kann angegeben werden.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Not-Operator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Ungleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Ungleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Ungleichheitsvergleich darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="liftToNull">true, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf true festzulegen, und false, um <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> auf false festzulegen.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Ungleichheitsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Gibt den Ausdruck zurück, der das Ones-Komplement darstellt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Gibt den Ausdruck zurück, der das Ones-Komplement darstellt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen OR-Vorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bitweisen OR-Vorgang darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise OR-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten OR-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als false ausgewertet wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="left" />.Type und <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen bedingten OR-Vorgang darstellt, bei dem der zweite Operand nur ausgewertet wird, wenn der erste Operand als false ausgewertet wird.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der bitweise OR-Operator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="method" /> ist null, und <paramref name="left" />.Type sowie <paramref name="right" />.Type weisen nicht denselben booleschen Typ auf.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> ist und die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.ParameterExpression.Name" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
      <param name="name">Der Name des Parameters oder der Variable (wird nur zum Debuggen oder Drucken verwendet).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Verringerung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Verringerung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Erhöhung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Zuweisung des Ausdrucks mit einer nachfolgenden Erhöhung des ursprünglichen Ausdruckswerts um 1 darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren einer Zahl darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Potenzierungsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="left" />.Type und/oder <paramref name="right" />.Type ist nicht <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren einer Zahl darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Potenzierungsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.- oder - <paramref name="method" /> ist null, und <paramref name="left" />.Type und/oder <paramref name="right" />.Type ist nicht <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die das Potenzieren eines Ausdrucks und erneute Zuordnen des Ergebnisses zum Ausdruck darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 verringert und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 verringert und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 erhöht und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den Ausdruckswert um 1 erhöht und das Ergebnis wieder dem Ausdruck zuordnet.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die den resultierenden Ausdruck darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die die Vorgänge angewendet werden.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, das die implementierende Methode darstellt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft durch das Verwenden einer Eigenschaftenaccessormethode darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die Eigenschaft darstellt, auf die in <paramref name="propertyAccessor" /> zugegriffen wird.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll.Dies kann für statische Eigenschaften NULL sein.</param>
      <param name="propertyAccessor">Die <see cref="T:System.Reflection.MethodInfo" />, die eine Eigenschaftenaccessormethode darstellt.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ist null.- oder - Die durch <paramref name="propertyAccessor" /> dargestellte Methode ist nicht static (Shared in Visual Basic), und <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type kann dem deklarierenden Typ der durch <paramref name="propertyAccessor" /> dargestellten Methode nicht zugeordnet werden.- oder - Die durch <paramref name="propertyAccessor" /> dargestellte Methode ist keine Eigenschaftenaccessormethode.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.MemberExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft festgelegt werden soll.Dies kann für statische Eigenschaften NULL sein.</param>
      <param name="property">Die <see cref="T:System.Reflection.PropertyInfo" />, auf das die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> ist null.- oder - Die durch <paramref name="property" /> dargestellte Eigenschaft ist nicht static (Shared in Visual Basic), und <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type kann nicht dem deklarierenden Typ des Felds zugeordnet werden, das durch <paramref name="property" /> dargestellt wird.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
      <param name="indexer">Das <see cref="T:System.Reflection.PropertyInfo" />, das die zu indizierende Eigenschaft darstellt.</param>
      <param name="arguments">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
      <param name="indexer">Das <see cref="T:System.Reflection.PropertyInfo" />, das die zu indizierende Eigenschaft darstellt.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> festgelegt ist, die die durch <paramref name="propertyName" /> angegebene Eigenschaft darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" /> eine Eigenschaft namens <paramref name="propertyName" /> enthält.Dies kann für statische Eigenschaften null sein.</param>
      <param name="propertyName">Der Name der Eigenschaft, auf die zugegriffen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="propertyName" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">In <paramref name="propertyName" />.Type oder den entsprechenden Basistypen ist keine Eigenschaft mit dem Namen <paramref name="expression" /> definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.IndexExpression" />, die den Zugriff auf eine indizierte Eigenschaft darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
      <param name="instance">Das Objekt, zu dem die Eigenschaft gehört.Wenn die Eigenschaft statisch/freigegeben ist, muss sie NULL sein.</param>
      <param name="propertyName">Der Name des Indexers.</param>
      <param name="arguments">Ein Array von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die zum Indizieren der Eigenschaft verwendet werden.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die auf eine Eigenschaft zugreift.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
      <param name="expression">Das enthaltende Objekt der Eigenschaft.Dies kann für statische Eigenschaften NULL sein.</param>
      <param name="type">Der <see cref="P:System.Linq.Expressions.Expression.Type" />, der die Eigenschaft enthält.</param>
      <param name="propertyName">Die Eigenschaft, auf die zugegriffen werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.MemberExpression" />, die den Zugriff auf eine Eigenschaft oder ein Feld darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.MemberExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> ist, die <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />-Eigenschaft auf <paramref name="expression" /> festgelegt ist und die <see cref="P:System.Linq.Expressions.MemberExpression.Member" />-Eigenschaft auf die <see cref="T:System.Reflection.PropertyInfo" /> oder <see cref="T:System.Reflection.FieldInfo" /> festgelegt ist, die die durch <paramref name="propertyOrFieldName" /> angegebene Eigenschaft bzw. das Feld darstellt.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, deren <see cref="P:System.Linq.Expressions.Expression.Type" /> eine Eigenschaft oder ein Feld namens <paramref name="propertyOrFieldName" /> enthält.Kann für statische Member NULL sein.</param>
      <param name="propertyOrFieldName">Der Name einer Eigenschaft oder eines Felds, auf die bzw. das zugegriffen werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="propertyOrFieldName" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">In <paramref name="propertyOrFieldName" />.Type oder seinen Basistypen ist keine Eigenschaft bzw. kein Feld mit dem Namen <paramref name="expression" /> definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die einen Ausdruck mit einem konstanten Wert vom Typ <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Reduziert diesen Knoten zu einem einfacheren Ausdruck.Wenn CanReduce true zurückgibt, sollte ein gültiger Ausdruck zurückgegeben werden.Diese Methode kann einen anderen Knoten zurückgeben, der selbst reduziert werden muss.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Reduziert diesen Knoten zu einem einfacheren Ausdruck.Wenn CanReduce true zurückgibt, sollte ein gültiger Ausdruck zurückgegeben werden.Diese Methode kann einen anderen Knoten zurückgeben, der selbst reduziert werden muss.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Reduziert den Ausdruck zu einem bekannten Knotentyp (kein Erweiterungsknoten) oder gibt nur den Ausdruck zurück, wenn es sich um einen bereits bekannten Typ handelt.</summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Verweisgleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die einen Verweisungleichheitsvergleich darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme eines angegebenen Typs darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das erneute Auslösen einer Ausnahme darstellt.</returns>
      <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Return", die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung mit dem angegebenen Typ darstellt.Der beim Springen an die Bezeichnung übergebene Wert kann angegeben werden.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Continue" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen <paramref name="value" /> an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="value">Der Wert, der beim Springen an die zugeordnete Bezeichnung übergeben wird.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.GotoExpression" />, die eine Return-Anweisung mit dem angegebenen Typ darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.GotoExpression" />, bei der <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> gleich "Return" ist, die <see cref="P:System.Linq.Expressions.GotoExpression.Target" />-Eigenschaft auf <paramref name="target" /> festgelegt ist, die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf <paramref name="type" /> festgelegt ist und beim Springen ein NULL-Wert an die Zielbezeichnung übergeben wird.</returns>
      <param name="target">Das <see cref="T:System.Linq.Expressions.LabelTarget" />, zu dem <see cref="T:System.Linq.Expressions.GotoExpression" /> springt.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf den die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Rechtsschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebeoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Rechtsschiebeoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine bitweise Rechtsschiebe-Zuweisungsoperation darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ist und die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="variables">Eine Auflistung von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Auflistung aufgefüllt wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> ist und die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="variables">Ein Array von <see cref="T:System.Linq.Expressions.ParameterExpression" />-Objekten, mit denen die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Auflistung aufgefüllt wird.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation ohne Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine Subtraktionszuweisungsoperation mit Überlaufprüfung darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei der die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <param name="conversion">Ein <see cref="T:System.Linq.Expressions.LambdaExpression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> ist und die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.BinaryExpression" />, die eine arithmetische Subtraktion mit Überlaufprüfung darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.BinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> ist und die Eigenschaften <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> und <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> auf die angegebenen Werte festgelegt sind.</returns>
      <param name="left">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />-Eigenschaft festgelegt werden soll.</param>
      <param name="right">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> oder <paramref name="right" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau zwei Argumente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der Subtraktionsoperator ist für <paramref name="left" />.Type und <paramref name="right" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung ohne Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Schalters.</param>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.SwitchExpression" />, die eine switch-Anweisung mit einem Standardfall darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
      <param name="type">Der Ergebnistyp des Schalters.</param>
      <param name="switchValue">Der Wert, der für jeden Fall getestet werden soll.</param>
      <param name="defaultBody">Das Ergebnis des Schalters, wenn <paramref name="switchValue" /> mit keinem der Fälle übereinstimmt.</param>
      <param name="comparison">Die zu verwendende Methode für den Gleichheitsvergleich.</param>
      <param name="cases">Der Satz von Fällen für diesen Schalterausdruck.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt ein <see cref="T:System.Linq.Expressions.SwitchCase" />-Objekt, das in einem <see cref="T:System.Linq.Expressions.SwitchExpression" />-Objekt verwendet werden soll.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
      <param name="body">Der Text des Falls.</param>
      <param name="testValues">Die Testwerte des Falls.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.SwitchCase" /> zur Verwendung in einem <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
      <param name="body">Der Text des Falls.</param>
      <param name="testValues">Die Testwerte des Falls.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
      <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
      <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
      <param name="languageVendor">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Erstellt eine Instanz von <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />, bei der die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />-Eigenschaft, die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />-Eigenschaft und die <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="fileName">Ein <see cref="T:System.String" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> festgelegt werden soll.</param>
      <param name="language">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> festgelegt werden soll.</param>
      <param name="languageVendor">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> festgelegt werden soll.</param>
      <param name="documentType">Ein <see cref="T:System.Guid" />, auf den <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Auslösen einer Ausnahme darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Ausnahme darstellt.</returns>
      <param name="value">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die das Auslösen einer Ausnahme eines angegebenen Typs darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die die Ausnahme darstellt.</returns>
      <param name="value">Eine <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Gibt eine Textdarstellung des <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Eine Textdarstellung der <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einer beliebigen Anzahl von Catch-Anweisungen ohne Fault- und Finally-Block darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="handlers">Das Array von 0 oder mehr <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücken, die die dem Try-Block zuzuordnenden Catch-Anweisungen darstellen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einer beliebigen Anzahl von Catch-Anweisungen und einem Finally-Block darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="finally">Der Text des Finally-Blocks.</param>
      <param name="handlers">Das Array von 0 oder mehr <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücken, die die dem Try-Block zuzuordnenden Catch-Anweisungen darstellen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einem Fault-Block ohne Catch-Anweisungen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="fault">Der Text des Fault-Blocks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TryExpression" />, die einen Try-Block mit einem Finally-Block ohne Catch-Anweisungen darstellt.</summary>
      <returns>Der erstellte <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
      <param name="body">Der Text des Try-Blocks.</param>
      <param name="finally">Der Text des Finally-Blocks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Action-Delegattyp mit bestimmten Typargumenten darstellt.</summary>
      <returns>true, wenn ein generischer System.Action-Delegattyp für bestimmte <paramref name="typeArgs" /> erstellt wurde, andernfalls false.</returns>
      <param name="typeArgs">Ein Array von Type-Objekten, die die Typargumente für den System.Action-Delegattyp angeben.</param>
      <param name="actionType">Enthält nach dem Beenden dieser Methode den generischen System.Action-Delegattyp mit bestimmten Typargumenten.Enthält NULL, wenn kein generischer System.Action-Delegat vorhanden ist, der <paramref name="typeArgs" /> entspricht. Dieser Parameter wird nicht initialisiert übergeben.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Erstellt ein <see cref="P:System.Linq.Expressions.Expression.Type" />-Objekt, das einen generischen System.Func-Delegattyp mit bestimmten Typargumenten darstellt.Das letzte Typargument gibt den Rückgabetyp des erstellten Delegaten an.</summary>
      <returns>true, wenn ein generischer System.Func-Delegattyp für bestimmte <paramref name="typeArgs" /> erstellt wurde, andernfalls false.</returns>
      <param name="typeArgs">Ein Array von Type-Objekten, die die Typargumente für den System.Func-Delegattyp angeben.</param>
      <param name="funcType">Enthält nach dem Beenden dieser Methode den generischen System.Func-Delegattyp mit bestimmten Typargumenten.Enthält NULL, wenn kein generischer System.Func-Delegat vorhanden ist, der <paramref name="typeArgs" /> entspricht. Dieser Parameter wird nicht initialisiert übergeben.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den dieser <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="T:System.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine explizite Verweis- oder Boxingkonvertierung darstellt, bei der null zurückgegeben wird, wenn bei der Konvertierung ein Fehler auftritt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="T:System.Type" />, auf das die <see cref="P:System.Linq.Expressions.Expression.Type" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, die die Laufzeittypidentität vergleicht.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> ist und die <see cref="T:System.Linq.Expressions.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="T:System.Linq.Expressions.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft festgelegt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> ist und die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft festgelegt werden soll.</param>
      <param name="type">Ein <see cref="P:System.Linq.Expressions.Expression.Type" />, auf das die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> oder <paramref name="type" /> ist null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine unäre Plusoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft auf den angegebenen Wert festgelegt ist.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.InvalidOperationException">Der unäre Plus-Operator ist für <paramref name="expression" />.Type nicht definiert.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die eine unäre Plusoperation darstellt.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.UnaryExpression" />, bei dem die <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft gleich <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> ist und die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft sowie die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft auf die angegebenen Werte festgelegt sind.</returns>
      <param name="expression">Ein <see cref="T:System.Linq.Expressions.Expression" />, auf den die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft festgelegt werden soll.</param>
      <param name="method">Ein <see cref="T:System.Reflection.MethodInfo" />, auf das die <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />-Eigenschaft festgelegt werden soll.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ist null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> ist nicht null, und die dadurch dargestellte Methode gibt void zurück, ist nicht static (Shared in Visual Basic) oder akzeptiert nicht genau ein Argument.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> ist null, und der unäre Plus-Operator ist für <paramref name="expression" />.Type nicht definiert.- oder - <paramref name="expression" />.Type (oder, sofern der Typ NULL-Werte zulässt, der entsprechende Typ, der keine NULL-Werte zulässt) kann nicht dem Argumenttyp der durch <paramref name="method" /> dargestellten Methode zugeordnet werden.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Erstellt eine <see cref="T:System.Linq.Expressions.UnaryExpression" />, die ein explizites Unboxing darstellt.</summary>
      <returns>Eine Instanz von <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Eine <see cref="T:System.Linq.Expressions.Expression" />, auf die Unboxing angewendet werden soll.</param>
      <param name="type">Der neue <see cref="T:System.Type" /> des Ausdrucks.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Erstellt einen <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten, der verwendet werden kann, um einen Parameter oder eine Variable in einer Ausdrucksbaumstruktur zu identifizieren.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.ParameterExpression" />-Knoten mit dem angegebenen Namen und Typ.</returns>
      <param name="type">Der Typ des Parameters oder der Variable.</param>
      <param name="name">Der Name des Parameters oder der Variable.Dieser Name wird nur zum Debugging oder Drucken verwendet.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Reduziert den Knoten und ruft dann den Visitor-Delegaten für den reduzierten Ausdruck auf.Die Methode löst eine Ausnahme aus, wenn der Knoten nicht reduziert werden kann.</summary>
      <returns>Der besuchte Ausdruck oder ein Ausdruck, durch den der Ausdruck in der Struktur ersetzt werden soll.</returns>
      <param name="visitor">Eine Instanz von <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Stellt einen stark typisierten Lambdaausdruck als Datenstruktur in Form einer Ausdrucksbaumstruktur dar.Diese Klasse kann nicht vererbt werden.</summary>
      <typeparam name="TDelegate">Der Typ des Delegaten, der die <see cref="T:System.Linq.Expressions.Expression`1" /> darstellt.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Kompiliert den von der Ausdrucksbaumstruktur beschriebenen Lambda-Ausdruck in ausführbaren Code und erzeugt einen Delegaten, der den Lambda-Ausdruck darstellt.</summary>
      <returns>Ein Delegat vom Typ <paramref name="TDelegate" />, der den vom <see cref="T:System.Linq.Expressions.Expression`1" /> beschriebenen kompilierten Lambda-Ausdruck darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="body">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />-Eigenschaft des Ergebnisses.</param>
      <param name="parameters">Die <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />-Eigenschaft des Ergebnisses. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Beschreibt die Knotentypen für die Knoten in einer Ausdrucksbaumstruktur.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Eine Additionsoperation wie a + b ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Eine Additionsverbundzuweisung wie (a += b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Eine Additionsverbundzuweisung wie (a += b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Eine Additionsoperation wie (a + b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Eine bitweise oder logische AND-Operation wie (a &amp; b) in C# und (a And b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Eine bedingte AND-Operation, bei der der zweite Operand nur ausgewertet wird, wenn der erste Operand zu true ausgewertet wird.Entspricht (a &amp;&amp; b) in C# und (a AndAlso b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Eine zusammengesetzte bitweise oder logische AND-Zuweisungsoperation wie (a &amp;= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Ein Indizierungsvorgang in einem eindimensionalen Array wie array[index] in C# oder array(index) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Ein Vorgang, bei dem die Länge eines eindimensionalen Arrays wie array.Length abgerufen wird.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Eine Zuweisungsoperation wie (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Ein Block von Ausdrücken.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Ein Methodenaufruf wie im obj.sampleMethod()-Ausdruck.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Ein Knoten, der eine NULL-Zusammenführungsoperation wie (a ?? b) in C# oder If(a, b) in Visual Basic darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Eine bedingte Operation wie a &gt; b ? a : b in C# oder If(a &gt; b, a, b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Ein Konstantenwert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Ein Umwandlungs- oder Konvertierungsvorgang wie (SampleType)obj in C#oder CType(obj, SampleType) in Visual Basic.Wenn der konvertierte Wert zu groß für den Zieltyp ist, wird bei einer numerischen Konvertierung keine Ausnahme ausgelöst.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Ein Umwandlungs- oder Konvertierungsvorgang wie (SampleType)obj in C#oder CType(obj, SampleType) in Visual Basic.Wenn der konvertierte Wert nicht zum Zieltyp passt, wird bei einer numerischen Konvertierung eine Ausnahme ausgelöst.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Debuginformationen.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Eine unäre Dekrementoperation, z. B. (a - 1) in C# und Visual Basic.Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Ein Standardwert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Eine Division, z. B. (a / b), für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Eine Divisionsverbundzuweisungsoperation, z. B. (a /= b), für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Ein dynamischer Vorgang.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Ein Knoten, der einen Gleichheitsvergleich wie (a == b) in C# oder (a = b) in Visual Basic darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Eine bitweise oder logische XOR-Operation wie (a ^ b) in C# oder (a Xor b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Eine zusammengesetzte bitweise oder logische XOR-Zuweisungsoperation wie (a ^= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Ein Erweiterungsausdruck.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Ein "Go to"-Ausdruck wie goto Label in C# oder GoTo Label in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Ein "größer als"-Vergleich wie (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Ein "größer oder gleich"-Vergleich wie (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Eine unäre Inkrementoperation, z. B. (a + 1) in C# und Visual Basic.Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Eine Indexoperation oder eine Operation, die auf eine Eigenschaft zugreift, die Argumente akzeptiert. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Eine Operation, die einen Delegaten oder einen Lambda-Ausdruck aufruft, z. B. sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Ein false-Bedingungswert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Ein true-Bedingungswert.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Eine Bezeichnung.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Ein Lambda-Ausdruck wie a =&gt; a + a in C# oder Function(a) a + a in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Eine bitweise Linksschiebeoperation wie (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Eine bitweise zusammengesetzte Linksschiebezuweisung wie (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Ein "kleiner als"-Vergleich wie (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Ein "kleiner oder gleich"-Vergleich wie (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Ein Vorgang, bei dem ein neues <see cref="T:System.Collections.IEnumerable" />-Objekt erstellt und aus einer Liste von Elementen initialisiert wird, wie new List&lt;SampleType&gt;(){ a, b, c } in C# oder Dim sampleList = { a, b, c } in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Eine Schleife wie for oder while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Ein Vorgang, bei dem aus einem Feld oder einer Eigenschaft wie obj.SampleProperty gelesen wird.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Eine Operation, die ein neues Objekt erstellt und einen oder mehrere Member initialisiert, z. B. new Point { X = 1, Y = 2 } in C# oder New Point With {.X = 1, .Y = 2} in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Eine arithmetische Restoperation wie (a % b) in C# oder (a Mod b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Eine arithmetische zusammengesetzte Restzuweisungsoperation wie (a %= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Eine Multiplikationsoperation wie (a * b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Eine Multiplikationsverbundzuweisung wie (a *= b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Eine Multiplikationsverbundzuweisung wie (a *= b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Eine Multiplikationsoperation, z. B. (a * b), mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Eine arithmetische Negationsoperation wie (-a).Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Eine arithmetische Negationsoperation wie (-a) mit Überlaufüberprüfung.Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Ein Vorgang, bei dem ein Konstruktor aufgerufen wird, um ein neues Objekt wie new SampleType() zu erstellen.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Ein Vorgang, bei dem ein neues Array erstellt wird, in dem die Grenzen für jede Dimension definiert sind, wie new SampleType[dim1, dim2] in C# oder New SampleType(dim1, dim2) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Ein Vorgang, bei dem ein neues eindimensionales Array erstellt und aus einer Liste von Elementen initialisiert wird, wie new SampleType[]{a, b, c} in C# oder New SampleType(){a, b, c} Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Eine bitweise Komplement- oder logische Negationsoperation.In C# entspricht dies (~a) für ganzzahlige Typen und (!a) für boolesche Werte.Die Entsprechung in Visual Basic ist (Not a).Das Objekt a sollte nicht direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Ein Ungleichheitsvergleich wie (a != b) in C# oder (a &lt;&gt; b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Eine Ones-Komplementoperation wie (~a) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Eine bitweise oder logische OR-Operation wie (a | b) in C# oder (a Or b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Eine bitweise oder logische zusammengesetzte OR-Zuweisung wie (a |= b) in C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Eine verkürzte bedingte OR-Operation wie (a || b) in C# oder (a OrElse b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Ein Verweis auf einen Parameter oder eine Variable, der bzw. die im Kontext des Ausdrucks definiert ist.Weitere Informationen finden Sie unter <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Ein unäres Postfixdekrement wie (a--).Das Objekt a sollte direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Ein unäres Postfixinkrement wie (a++).Das Objekt a sollte direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Eine mathematische Operation, bei der eine Zahl potenziert wird, wie (a ^ b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Eine zusammengesetzte Zuweisungsoperation, bei der eine Zahl potenziert wird, wie(a ^= b) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Ein unäres Präfixdekrement wie (--a).Das Objekt a sollte direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Ein unäres Präfixinkrement wie (++a).Das Objekt a sollte direkt bearbeitet werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Ein Ausdruck mit einem Konstantenwert vom Typ <see cref="T:System.Linq.Expressions.Expression" />.Ein <see cref="F:System.Linq.Expressions.ExpressionType.Quote" />-Knoten kann Verweise auf Parameter enthalten, die im Kontext des Ausdrucks definiert sind, den der Knoten darstellt.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Eine bitweise Rechtsschiebeoperation wie (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Eine bitweise zusammengesetzte Rechtsschiebe-Zuweisungsoperation wie (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Eine Liste von Laufzeitvariablen.Weitere Informationen finden Sie unter <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Eine Subtraktionsoperation wie (a - b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Eine Subtraktionsverbundzuweisung wie (a -= b) ohne Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Eine Subtraktionsverbundzuweisung wie (a -= b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Eine arithmetische Subtraktionsoperation wie (a - b) mit Überlaufüberprüfung für numerische Operanden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Ein Wechselvorgang wie switch in C# oder Select Case in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Eine Operation, die eine Ausnahme auslöst, z. B. throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Ein try-catch-Ausdruck.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Eine explizite Verweis- oder Boxing-Konvertierung, bei der null angegeben wird, wenn die Konvertierung fehlschlägt, wie (obj as SampleType) in C# oder TryCast(obj, SampleType) in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Ein genauer Typtest.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Ein Typtest wie obj is SampleType in C# oder TypeOf obj is SampleType in Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Eine unäre Plusoperation wie (+a).Das Ergebnis einer unären Plusoperation ist einfach der Wert des Operanden. In benutzerdefinierten Implementierungen können jedoch außergewöhnliche Ergebnisse erzeugt werden.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Eine Unboxing-Werttypoperation wie die unbox-Anweisung und die unbox.any-Anweisung in MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Stellt einen Besucher oder Bearbeiter für Ausdrucksbaumstrukturen dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Initialisiert eine neue Instanz von <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Sendet die Liste der Ausdrücke an eine der spezialisierteren Besuchsmethoden in dieser Klasse.</summary>
      <returns>Die geänderte Liste der Ausdrücke, wenn eines der Elemente geändert wurde. Andernfalls wird die ursprüngliche Liste der Ausdrücke zurückgegeben.</returns>
      <param name="nodes">Die Ausdrücke, zu denen gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Wechselt mit einem angegebenen Elementbesucher zu allen Knoten in der Auflistung.</summary>
      <returns>Die geänderte Knotenliste, wenn eines der Elemente geändert wurde, andernfalls wird die ursprüngliche Knotenliste zurückgegeben.</returns>
      <param name="nodes">Die Knoten, zu denen gewechselt werden soll.</param>
      <param name="elementVisitor">Ein Delegat, der ein einzelnes Element besucht und dieses (optional) durch ein neues Element ersetzt.</param>
      <typeparam name="T">Der Typ der Knoten.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Sendet den Ausdruck an eine der spezialisierteren Besuchsmethoden in dieser Klasse.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Wechselt zu einem Ausdruck und wandelt das Ergebnis zurück in den ursprünglichen Ausdruckstyp um.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="nodes">Der Ausdruck, zu dem gewechselt werden soll.</param>
      <param name="callerName">Der Name der aufrufenden Methode. Dieser wird für die Ausgabe einer besseren Fehlermeldung verwendet.</param>
      <typeparam name="T">Der Typ des Ausdrucks.</typeparam>
      <exception cref="T:System.InvalidOperationException">Die Visit-Methode für diesen Knoten hat einen anderen Typ zurückgegeben.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Wechselt zu einem Ausdruck und wandelt das Ergebnis zurück in den ursprünglichen Ausdruckstyp um.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
      <param name="callerName">Der Name der aufrufenden Methode. Dieser wird für die Ausgabe einer besseren Fehlermeldung verwendet.</param>
      <typeparam name="T">Der Typ des Ausdrucks.</typeparam>
      <exception cref="T:System.InvalidOperationException">Die Visit-Methode für diesen Knoten hat einen anderen Typ zurückgegeben.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Wechselt zu den untergeordneten Elementen des Erweiterungsausdrucks.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
      <typeparam name="T">Der Typ des Delegaten.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Wechselt zur <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Wechselt zu den untergeordneten Elementen der <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Der geänderte Ausdruck, wenn dieser oder einer seiner Teilausdrücke geändert wurde. Andernfalls wird der ursprüngliche Ausdruck zurückgegeben.</returns>
      <param name="node">Der Ausdruck, zu dem gewechselt werden soll.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Stellt einen bedingungslosen Sprung dar.Hierzu zählen return-Anweisungen, break- und continue-Anweisungen sowie andere Sprünge.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Die Art des "Gehe zu"-Ausdrucks.Dient nur zu Informationszwecken.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.GotoExpressionKind" />-Objekt, das die Art des "Gehe zu"-Ausdrucks darstellt.</returns>
    </member>
    <member$namu="P:Syspd}.Linq.ExpressiOns.GotmExpression.NodeType> (`   <summary>Gibt den Klotentyp!dieses <see cre-"T:Systum.Linq.Exppeqsions,Expression" /> zurück.<'summary>
      <returns>De2 <see sref="T:ys|emLinq.Exprgswins.ExpreqsinType" />, der diesen Ausdruck darstmllt.</returns>
    <member>
  ! <me-bev name="P:System.Lin.Expressions.GktoExpression.Target">
 ` 0  <sUmoary>Die Zielmarke, zu dg woo digsem Knoten gewehsdlt wird.</summary>
     <returf{>aw(<see cref"T:System.\inq.Expressions.LabelTarget" />/Objek, das die ZielmaRke für $iesen Knotel darstellt.</zeturns>    </member>
 `0 <me}beR name="P:[ystem.Linq.E`precqions.GotoExprmssion.Type".
     !<smmary>Ruft den statyscHen TIp d%s Ausdrucks ab, ten diec0<see(cref="T:System.Linq.ExpressiOns.GxpRassaon"(/> darstelm|.</summary>
  $   <returns>D%R <see crmf="P:System.Linq.Expsssions.GotoExpression.Type" />l der ddn statishen Typ$de{ AUsdruks dar4ellt.<reuurns>  ` </member>	
  ! <memjer name="M:System.Linq.ExpRessions.GotoExpression.Updade(System.Linq.ExPresSiofs.LabelTargE$,Syu4em.Linq*Expreqs)ons.Expression)">
      <summary>ErstelTt e)nan neuen `usdruck wie diesen vergendet`jednch dke$angegebenn untergeordneten Eleiente.Uenn Alnu untereeordneTen Elemente überei.stimmen, wIrd der Ausdruck zurübkgegeben.</summiry>
   0  <retqrns>Dieser Aurdrtck, wenn kin% untergeordneten Ele-ente gdändErt werden, ofet ein usdrugk mIt den aktual	siertun unterguordndtEn Elementen.</returns>
     `<`aram naie="target">Die <See Cref="P>System.Linq.Expressiofs.GotoExpression.Target" /-MigEnsc`aftdes Ergebnirses. </param>
      <param name="value">Die <see cref-"p:System.Linq.Dxpressions.otoExrressioo.Walue"(/~-Eigenschavt les Epgebnisses. /pazam>
    </mem"er>
    <membEr"oame="P:System.Li.y.Expresions>GotoExpressiol.Value">
    $ <suMM`ry>Der an das Ziel übergeene Wert oDer NUL eon das ielvom Typ System.Void ist.</sum}ary?
    ! <reuurns>Das <see cref="T:Cystem.LinqnExpressins.Ehprecsion" />-Objekt, das Dgn an das Zael übergebefen Wart darstellt odeb NULL.</retUrns>
    /member>
   `<member name="T:S9stum.Linq.EXpRessions.GOtoExpressionKind">
      <summary>Gibt an, 7elche Ar von S`rung(diese <see cren5"T:System.Linq.Expreswions.GotoExpreS3ion"!/< dar3tellt.<'summary?
    </meober>    <member name"F:S}stem/Linq.Exressions.GofoExpressionKind*Break">
    ``4summary>Mine0<cee cref="T:Systom.Lnq.Ex`resshonq.GotgExpreswion" '>, die eine0break-anweisung larstellt.</summary?
    </memer>
   !<meeber name="F:System,LinqExpressions.GotoExprewsionIind.Coltinue">
     <s5miazy>Eine <see bref="T:System.Linq.xpvessins.GotoExpr%ssion" />, die eiNe #ontinue-Anweisung darstellt.<.s5mmary>
    <member>
    <meeber name="F:Systmm.Linq.Expressions.GotkExprdssionKind.Goto">
      <summary>ine =see cref&T:System.Linq.Axpression3*GotoExpre3sion" />, die`ainen Sprung zu einer Position darsteldt.</summarx>
"   </mmmbur>
  " <member nae=#F:Sy3tem.LinQ.Expressions.GotoExpressionKi.d.Returj">*      <cumMary>Eine!seg cef=T:System.Linq/Ex`ressaons.GotoExpreqCion" />, diE Eine retur-Anweisunw darq|ellt,</summary>
    </mem"er.
    <me-ber name="T:System.Linq.UxpreQsions.IArgumentXrovider"</melber>	
   0,member name"P:SysdelLinq.ExpressionS.IArgumentProviDer.Argm%otCount"></member>	
   (<memfer nam%="I:Sstem.Linq.Expressions>IArcumentProvider.GetArT-ent(System.INv32)"></member>
    <member name="T8System.Li.&Uxprgssions.IDynamicExprecsIon"></ember6   0<member nama=M8System.LnqExpressions.IDynamicExpression.CreA4eAalhSite"></member>
  $$<mamber na}e="P:SystemLinq.Exppessions.IDynamicExrbessinn.DelgwateTypab><member>
    $member name="M:Sy{tem.Linq.Expressions.IDynamicExpresson.Rewrate(Sys4em.Linq.ExpressionsfExpressiOn[])"?<'membEr>
   "<}ember!name="T:Systm.Linq.Expressions.I~d%xExpression">
      <suMmary~tellt das Indizheren einer$Eigenwchaft oder eine{ Arr`ys dar/<sumlc2y>  # </member>
    <mmber nAme=":System.Linq.ExpressiOns.IneexExpressionArgumentr">
      <summabq>uft die Argumenve ab, mit lgnen!die EIgdnschefd oder dAs Array ind)zimrt wird/</summaby.     <retur,s>Die sc(rEibgeschüt~e AUflistung, die dim ArguMentg enthält, mit$$eoen die Eigenscxaft oder das Arrcy indyzier wird.8/zeturns>
    >/member>M
    <member name="P:Systm.Lijq.E8pressigjS.InejExprescion.Ildeyer">
     <summary>Ruft eie <see cref=BT2System.refection.PropertyYnfo" / bür eie Eigenscha&t ab, Wenn$der Ausdruck eine iNdi{kertE igens#haft darstellt. Qndernfills wird JQLL zurückgegebn.</summery>
`$    <Returns>Die <sa cref?"D:System.efnectYon.PropertyInfo" />0fþr did$Eigenshaf|, wenn der Ausdrusk eine indizherve Eigen{chaft darstellt, andernvalls ULL./ret}rns>
    </membar:
    <membez name-"P:Systmm.Linu.ExpRersions*IndexExprec{ion.NodeType">      <summary>Gibt"da Cnotentyp dieses <seecref5"T:R9stem.Linq.Expressions.Ezpression" o> :urück.</summary>
      <retubns>Der <see cref="T:SystemnLinq.Expre{sions.ExpressioTyPe" />, der diesen Ausdruck dazsuEnlt.</returns>
    </member>
    <member name=*P:System.Linq.Expressmons.IndexExrression.Object2>
      <summary>Ein zu indizierdfdes Objekt.</summary>
      <returnr~Die ,see crdf="T:System.Linq.Exprews)ons.Eyp2ession" />, die das zt indizierendd Objekt darstelt.</returns<
    </member>
    <member name="P:Syctem>Linq.Exprdssions.IndexEppressionnS}stem#Linq#Expressi/ns#IArgu-entProvid%r#ArgumentSount"></-efer>
 $  <member0name=":Systeli~q.Expressions.IndgxExpression/Qystem#Linq#Exp2eqsaons#IArguientProvider#GetArg-ent(system.Int32)*<</member>  $ <member0name="P:System.Linq.Eypresqions.IndexExprewsion.Type">
 d    <summary>Ruft deo svapischen Typ des Ausdruc3 ab, den diese<see$cbeb="T:Qystem.Lina.Expression3.Expression" /> darstellt.<summary>
      <beturns>Dep <see cref="P:Syspem.Linq.ExpsesSions.IndexExressinn.Type />, ddR den stqtischen Txt Dms Ausdruckw darstellt*</retusns>
  " </memrer>
    <}m"er name="M:System.Linq.Expressions.IndexExpression.Uqdate(Sy{tem.\aoq.Dxqressions.Expression,System.Collecpions.Genepic.IEnumevable{syctem.Linq/Expressions.Exprussion})">
      <summazy>Erstellt einel neuen Ausdrusk wim dieqen, verwendeT jedoch die angegebenen untergeord.eten Elemente.Wenn$alle untergeordneten Elmmente übereinstmmmen, wird der Apsdruck z}rügkgegeben.</summary>
(    <returjs.DiEser Audvuck, wenn ke)ne un4argeordjeten Elem%nte geändert werden- odep ein AusdrqcK mi den"aktualisi%rten UntergEordnetej Elementen.</re4urnr>
    ` <param name="object">Die <see cref="P:ystDm.Linq.ExprEssios.IndexExression.Ocject" ?>-Eige.schAft des Ergebnhsses.</param>
      <raram nme="arguments">Die <see cbef=2:Rystem.Linq.Expressions.IndexExpre{sign.Irguments" >-Eicenschaft de Ergebnysses.<-pcram>
    </member>
    <member!na}e= T:Cystem.Linq.Expresqions.InvocationExprgssioo">
      <swmmary>Stellt einen Au{druck $ar, deR einen Deldgaten Oder!eie Lamb`aauxdr5ck iufeine Liqte on AsgumeNtawsdrücken cnendet.</swmmary>	
    </melber>
   0<member name="P:Sys$emoLinq.Expressimjs.InvocationExpreqsion.Arguments">
      <summary>Ruft dig Argumente ab,0auf die Der Deegt oder Lambda-Aesdruck angewendet wird.</summiry>      <retqrns>Eine <see cref=#T*System.Gollectimns.M`jEctOgddl.ReadOnlyCollectiol 1" /> vkn <sem cr%f=bT:System.Linq/Eypresakns.Exprmcsion" o>-Objekten, die die CrgUmente!darcte,len, aef die der De,egat angewendet wird/</retwrns>
  $</member>
 `  <membeB n!me="P:System.Linq.E|pressions,InwocationExpression.Expression>
      <su-m`ry>Ruf| den Delegatenoder Hamjdaausdruck ab, d%r angewgndet werddn skll./summary>
      <returns>Eine <see cbeg="T:S{stem.Linq.Expsussions.Exqression" />, die den anzuwgndenden Demegaten daRstellt.<+retwbns>
 "  /memfes
    <meber na}e=P:System.Linq.Ezpresri/ns.InvmcationExpression.NkdePype">
`    0,sum-ary>Gibt den notentyp dieses Ausdrucks zurück.erweiterung3kno4en solltdn <see cref="F:Syqtem.Linq.Expreqsio*s.ExpressionType.Extension" /> zwrückgebel, wenn Diese Me4hode ˼berchrie"en sird.</s5mmary>
    ! <returns>Der <sme cref="T:system.Linq*Expressinns.ExprdssionType"0/> des Ausdrucks.<+returns>
    <member>
    <mdmbar nime="P:System.LinqExpbeqsigns.KnvocationExpreswion.System#Linq#Exprewsions#IAreu}entProvider#ArgumentCount"></membEr>
  (@<member n`me=O:System.LiNq.Expres2ons.IlocatiojExprssion,System#Linq#Expre3sions#IArgumentProier#WdpArgumentS{stem.Ijt32)"></membev>
    <memrer name="PSystem.Linq.Expres{ions.InvocationEx`reqsIon*Typd">
      <summary~Ruft den statischen Typ des Aus`rucks ab. den diese <see cref="P:System.Linq>ExPr%ssions.InvocationExpression.E|0reswion" /> darstellt.</summary>
      <returns>Der <see cref=bp:System,Linq.ExpressiOns.Invoa!pionExpression.Tye" o>, der!fe~ statischgn Typ des AusdrucKs darstellt.</peturns>M
   |/MembeR>
    <mmcdr name="M:System.linq&Expressions.Invocation8rrssion.Update(Syspao.Linq.Exp2essions.Exxresi/n,Sy{tem.Conlections.GmnericnIEnumerablesWysde.Linq.E8presqioos.Expresskon})">
      <summary6Erstgllt einen neuen Ausdruck wie dkesen, verweLdet jedoch"diu angeGebenen untergeortneten Enemente.Uenn alle untergeorDnetan Eleme~te ˼beseanstimmEn, wird!der Ausdruck zurück'egeben.</wummary>  0   <returnS>Dieser Ausdruck, wenn {uine`unter#eopdfeten Elemente geä.derd werden, oder ein AucdrucKmkt den Aktual)silrten untergerdneten ELemende/</returns>
    ! <param .ame="exqressiol"Dia <see!cref="P:Cystem.Linq.Expre{sionsInvocationExpression.Expressinn" ?>-Eigenschaft`des Ergebnisses.<o0aram>
"     <pcram name="crguments">Die >see creg="P:System.Linq.Expressions.InvocatiojExpression.Arguments" />-Eigensghaft des Ergmbnisses./pasam>
    |/member>
"   <memfer ame="T:S}stem.Linq.ExpresSion.LabelExpression">
      <summary>Steh,t0eine BezeichnuNg dar, dig in einen bdliebigen`<see cref="T:Rystem.Linq.Expressions.Expressimn" />-Kontaxt pl!tri'rt werdE. kan.Bei eindm Sprung in die Bezeichnune wizd `er durgh die entsprechende 4se% crefbTSyrtem.Linq.Expr%sionsnGotoExpresri/n. /> angegebeNe Wert bgerufen.Andernfalls wird des(Wer40in <see cref="P:Sqsuem.Linq.ExpRessions.LabelExprEssion.DefaultValue  /> empfangel.Wenn der <see`cRef="T8Syspei.Type" /> gleich SystemnV/id ist, darf kein`Wert angageben werden.</summary>
    </member?
    <member name="P:SysdEm.Lilq.xrDssiOns.L!belExppession.DefauMtValue">M     <wumeaRy>Der Wert der <see aref="T:System/Liny.Expessions.LabelExpression2$/>, wenn@dIe Be{eychlung dupch dhe rEguläru Ablaufste}erung (und z. B. nicht durch"einen S0sung) erReicht w)rd/</sum}ary>
    $ <ret5rnS>Das Expression-Objekt, dac den Wert der <see cref="TzSyrtemLinq.ExprussionrjLaBelEx`ression" +> d!rstellt/</ruturns>
 0  </member>
    <mem"er`name="P:System.Linq.Exprewsins.LabelExpressi/n.NodePype*>
      <summari>GKbt den KNotentp dieses <se cref="T:System.LinqnExpressI/ns.Expbescio." /> zur˼ck.</qummary>
 0    <returns>Der <seg cref?2T:System.Linq.xpresSions&Expres3hoNType" />, der diesun Ausdruck darstellt.</returns2
    </memBer
    <member name="P:System.Linq.Ex`ressions.abelMxpression.TargeT">
      <summarh>Las <see cref="T:sysdem.Linq.Expressions.LabelTarget  >, dem die Be~eichnung zugeoRdnet ist.</#umma2y
      <returns>Das <sue cref="T8Sysuem.Linq.ppsessions/L`belTarget" />, dem die Bezeich.ung zueeordnet irt/retur.s>
    </meeber6
    ,member name="@:system.Linq.Expresions.Lq"elExprEssiof.Type".
      <summary>Ruft den0statischen typ des Ausdrucks ab, d%n diese!<see cRef="T:System.Li.q.Extressions.Exprersion" /< darstelht.</summary>
     <rdturos>Deb <See"cref="P:SYstem.Linq.Expressionw.abelEpprescion.Typeb />- dur den statis#hen Typ(des uwdruckS darstellt.</re4urns:
    </membDr>
    <membev nale="M:S9stum.Lihq.Expressions.LabelExpression.Update(System.Linq.ExpressioNs.LabelTargEt,Sistem.minq.EXpressions.Ep`R%ssion)">
      4rummary<Erstallt eioen!nmu%n Ausdruck$wme di%sen, ver7enDet jedoch die angegebenen u~tgrgeordneten Elemente.Wejn a,le tntergenrdneten elee%Ne übereinstimmen, uird eer Auqtruc+ zurücjgegeBmn./summary>
      <returns>@ieser Au3druck, wenn keine untergeordneten Elemente!geändErt0werden, oderein AusdrecK mit den aktualisierten }ntepgeornmten Elementen.8/returns>
      <param nama="tapget">Die <ee cref="P2System.Linq.Expressions.abelExpressin.Target" />-Eigen{chaft des Ergebnirses.</param>
      <pazam n!mg9"efaultValue">Die <see cref="P:System.Linq*xpressiooq.LabelExpr%ssion.DefaulValue" />-Eioenschaft des Areebnisses.</parAm>
    <'em"er>-
"   me-ber name= T:System.LinqExpre{sioh<abelTarget">
    " <summary>Qtel|t das Zkel eiNer <see cpef="T:S}s4em.in1.Expreqshons.GotoExprEssion" /> dar.</summ`ry>
    8/member>
    =m%mber name="P:System.Dinq.Exqressionq.LabelTargetnName":
      <summary>Ruft den Nae%n der Bez%ic`Nung ab.4.summaby<
      <retuzns>Der Name der Spr5ngMake.</zetuvnS>
   (</member>
    <member lame="M:System.Lina.Expressions.LabemTarget.ToStrang">
  0   <sumiary>Gibt einen <see jref="T;System.S`rinf" />0zqrück, der een aktuellen <see cef="T:System.Object" /> dar3tellt.>+summary>
     <returns>Uin <see cref="\:Sysvel.Spring" />,!der den aktuel,en <see crmf="T:System.Object" /> darstellt.<-Returns>
    </mdmbp>
    <member naie="P:yctem.Linq.Expressions.LabeTarget.Type">
    ` <suem`r{>Der Typ $es beim Spbhngen zu2 BeZeic(nung übergebenen Serts (oder <see cpef="U:Qystgmnoid" />, wenn keio Wert$ü"ergebn werden soll).</sumiary>
      <returns>Des <see cref="T:Syqtem>Type" />-Objekt, das den yp de3$e`m Sprhngen zur Bzeichnung0übergebenen Werts darstellt, kder <see creg=#T:System.oid"`/>, wenn0kgin Wert überGeben werlen sodl./beturnw?
    <membar>
   0member n`me="T:System.Lilq.Expressions.LambdiExprmssion">
      <summap>Bgschreibt einen Lambeaausdruck.Jeychne| eine& Codeblock auf der mit einem .NET-Methnde.text Vergleichbar i3t.</summCry>
$   </member>
  " member name="P:System.Linq.Expressions/LambdaEx0rescaon.Body">-
      <semmary>Ruft den Text des Lambdaausdrucks !`.,/swmmary>
  `   <ruturns>{jd <3ue cref="T:SysteM.Lilq,ExpR%ssionSExprecsion" />, die fen Text $es LambdeausdruckS darstellt.</returnS>    </memcer>M
    <member namg="M:[s4em.Lanq.ExpressionsLambdaExp2essIom.Compile">
      <3mmary>Urzeugt einen DeLega|eo, der Den Lambdaausdruck darrtellt.</summary>
    ( <returnS>Ein <see cref="T:System.Dadegate" />, fas die komqil-erte Version des Lambda,Aesdrucks unthält.</revurns>
    </membr>
(0  <mEober$name=*P:S}sdem.Linq.Expressionr.LambdaExpression.Name">
      <summaRy>Rut den Naen des Lambdaausdrugks ab.8/su}mary>
      <returnsDer Name `es Liibdaa5sdrucks.</reTurn>    </meOber>
    membeb neme="P:istem.Linq.Expresqkons.LambdaExPras{ion*NodeTyre">
      =summary>Gibt dej In/tentyp eieses |see cref="TzSysem*Linq.Expressions.Gxpressin2 /> ~urüCk.</summary>
      <returns>Der <see kref<"T:System.Lanq.Expressins.ExpressmonPype" />, der diesen Ausdruck darstell.,/returns>
    </memb%r>
    <member$name?"P:System.Linq.Axpressions.LambdaExpresSion.Pazameterq2>
      <s=mmary>RufT die RaraMmTer dEs Lambdaatsdvucks ab/|/3ummary>
      <ret1rls>iNe <see cref=2T:System.Conlections,ObjectModal.ReadOnlyCollection`5" /> von <sue cref="T:System.L)nq.Expressinns.ParametdrEhpression" />-Objekten, diu die ParAmeter d%s Lambdaausdvucks eastelen></rettrNs>
    </memfer>
    <meMber naie="P:SysteM.Linq.Expressions.Lamb`aExtResciOn.ReturnType*>
      <3ummary>Ruft den Rückga"atyp`des L`mbdaausdrecks ab.</summary>      <returns>Das <see cref5"T:System.Type" /:-Objekt, da $en yp des Lamjdaaus`bucks darstell4.</returns>
    </membez>
    <ember name="P>Syrtem.Linq.Expzessins/LamfdaExpressiOn/TailCall">
      :summary>Ruft def Webt ab- derdyngijt, or der Lambdaausdpuck mid dEr EndeaufzufoptimieRung kompiliert wirt.</summarx>
    !<beturns>Truel wEnn der Lambdaausdruck mit ddr Endeaunrufoptimierug komphliert wird,andernfalls false.</returns>
   `</mgmber<
  ( member name="P:System.Linq.xqpeSsionq.Lambdaxpression.TyqE">
      <summary>Puft$den sta|iskhen TYq des AUsdrucks ab$ dej die{e <sEm crEf="T:SYstem.Linq.ExprssiOns.Mxpression" /> darstellt.<'summAry>
  0   <returns>DeR <cee cref="P:Sysdem.Linq.Expressions.HambdaExprssion.Type" /, der dej statichen T}p des Aucdrucks d`rstellt.</retuvns>
    </membeb>
 "  <mmber naee}"T:Systeo.Linq.Expressions.DistInitExpressin">
 (    <summary>Stell5 eynen Konstvuktorauvruf dar,der eine. AuflistungsinitialisierEr aunwei3t.</summarq>
    /meMber>    <membeb jame?"P:Sy{vem.Lins.Expressions.ist	nitExp2es{ion.CanReduce">
     <summary>Ruft(einen Wert ab, der angift, ob derKnoten der Ausd2uckwbaumstrUktr retuziert cereen kanN.</summary>
    ( <retuzns>True, wenn$eer Kngten reduzimrt sarden kann, andernfalls False.|/retuzs>
    </mem`er>
    <member name="P:S9stem.LinqExpzessions.istInitExpression.Ioitializers">
  (  <summary>Ruft die Elementmniticlisierer ab, die zum Intialisieren eiler Auflistung rezwendet warden.</summaRy>
      <raturjs>Eine see cref="T:SysteM.Cmllecti/ns.ObjeatMdel.ReadOjlyCollection`1" /> v/n0,See sred="T:Syste->Linq.Expressions.ElementInit" />-Objekten, Die dme!E,em%nte darstellen, die zum InitialiSieren der Auflistng verwe.det werden.</raturns?
    </iemer>
  ( <mejer name="P:S}stem.Linq.Expbessions.Li{tIitExpreqsion.NEwExpres{ion">
      <summary<Ruft dan Ausdruck ab< der einen)Aufruf des Konstruktozs für einen Auflistungstyp lthält./summary>
$    $<returns>Eine 4see crf="P8System.Linq*ExpressionsnNewExpzession" />, die den A5fruf des Knnstruktkrs für dinen Auflistungstyp derstellt.</returns:
  $ <-member>
    <mem"ev name5P:System.Lm.q.E|pessions.lhstInitUzpr%ssion.NodeType"?
      <summa2y>Gib!en Knotentyp dieses <see cref="T:Rystem.LinqExprewsionS.Expression" />0zurück.</suimary>   (  <zeturns>Der <sue cref="T:System.Linq.Mxpressions.ExpressionTypm" />, der fiesen AusdruCk dapstellt.</returns>
    </meeber>    <membmp name="M:System.Lina.Expression3.LsdI.itExtressio~.R%|uge">
      <sulmary>SedUziert auf den binӤbgn Ausdruckwknouen auf einen einfac(eren Ausdruck</summary~
      <rettrf>Der beduzierue Aqs$rubk.</reTusns>
    </member6-
   0<member name="T:System.Linq.Expres3io..LiwpInktEpprdssion.Type">
    $ <summay>Ruft dan statischen Typ des Ausdrucksab,!$L diese <see cruf="T:System.Linq>Ex0ressions.Expression" /> darstellt.</summary>
      <returns>Der <See craf="P:S}stem.inq.Expresshons.LiStILitExprecsion.Type" />, der den ctatischen Tyr des Aesdrucks dastemlt.</rmturns>
 (  </mE-"er6
    <member name="M:System.Lajq.EXpressions.MistINidUzpession.Upd!te8System.Linq.ExprEsskons.NewExprecsion,System.Coll%ctions.GenEric.IEnueerable{Syspem.Lnq.Expressions.UleeeftINit})">      <summary>Erstellt minen neuEn AuSdvucK wie diesenl verwenet jedoch lie!engegebanen utergeorlnten Elemente.Wenj alle untergeordngten Elem%nte ӼreremnstimmEn, wird der Aesfruck zurückgegeben.</summary>
      <returns>Die{er Ausdruck, wenn kehne untergeo2dneten Elemunte fmändert wer$en, oder ein Ausdrucc mit den aktualisierten uf|ergeordneten Elemeften.</retrns>
"     <param name=+newExpression">Die <see cref="P:Sywte.Lnq>Expressions.ListInitExpression.NewGxpresson" 6-Eigensciaft les Ergebn)sses.8/`aam>
  (   <parcm name= anitializers">Die <sed cref="P:System.Linq*Eypressi/ns.LisvInytExpression&Inhtializerr" />-Eigenschaft des Ergebnisses.</param>
 0 <?member>
 $  <member nime1"T*System.LiqnExpressions.loopE8p2ession">
      sum}ary>Stellt eine Endlossc`leife dar.Dice kan mit "break" beend%twmrden.<+summaRy>
    </member>
!   <}ember name="P:SyStel.Linq.|pressions&LoopExpre3s(on.Body">J      4summiry>Ruft die <sEe cref=T:Systei&Dinq.xpzessions.Expression" /> ab, die del`Text der Schleife darstenlt.</stmmary>
      <returns>Die <see creb="T:SystEm.Hioq.Expreqsion{.Expreschon" />, die den Text der Schleife darstellt.|/3etwrns>
    </member>
   "<member name="@:Systel.Lynq.Ex`ression3.LoopEppresSion.BreakLabel"      <summa2y>Ruft das <see cref="T:[ystem.LInq.Express)ons.LabelTarget" /> ab, das fom Schlghfentezt als Ziel ddr breaj-Anweisung verweNdetuird.</cummary>
      |returns:Das <see cref="T8System.Linq.Ezpreswios.LabelTargat" />, das vom Sch|eifentext cls iel der break-Anwaisung verWendet wird.</reterns>
    </membdr6
    <lember name="P:S8stem.\inq,Expressions.LoopExpbes3ion.Continug\abe">
      ,sumeapy>Ruft das <se cr%="T:ystem.Linq.ExpreSsions.abulTarget" o> ab, das vom Sch,eifentext als Ziel`der continuemAnweisung verwendet wird.<?summar{>
      <retuvjs>Das <see cref="T:Sysdem.Linp.Uxprgssions.LabemTarget" >, dac vom Schleifenext als Ziel de2 continue-Aoweisujg verwendat wird.</redurns>
    <+member>
 0  <member nam="P2systei.Linq,Expressions.LoopExpress)on.NodeType">
     <summary>Cibt den Knotg~typ dieses Ausdrucks zqüak.ErweiterungsknoTen sollten <see cref="F:S}sem.Hinq.Epressions.ExpressionUyxe.ExtensioO" /> ZurÝckguben, wen~ diese M%thode Cbersshrieben uird.</summary<
      <returnc>Der$<see creF="T:ystem>Linq.Ex`resrikn3.ExpressionType2 /> des Ausdrucks.<+returnc>
    </membcr>
    <member na}e="@:System.Linq.Expressions.LoopExpression.Type"~
      <summary>Ruft dan stitische. Typ des$Aus$rucks ab, den dieseasEe cref="T:System,Linq.Expressions.Expresskoo" /> darstellt.</summary>
  ( " <returns>Der se% cref="P:System.Linq>Gxpressions/LopExpression,Type" />, der den stati{Chen Typ des Ausdzucks darstemlt.'retuns>
    </member>
    <medber n!me="M:Ry3vem.Linq*Exprescins.LmopExpress)on.Upeate(System.LinqExpressins.abelTarget,Syste->Lioq&Expression3.LabelTarg%t,Syc4em.Linq.Expressions.Expressig)"
    "=summary?Erstelmt"eifen neuen Ausdruck Wie diesen, verwendet jedokh die angeGebenel untergeobdneTen E,emente.Wenn ale untergmordneten Elemente Übmreins>immen, vird dar Ausdrubk zurükkgegeben.</suMmary>
      <2eturnq>Dkeser Ausdrucc, wenn kemne entergeordnEten Elemente geändert wavdel, oles ein Eusdruck mit deo aktualisierten untevEeord~eten El%menten.</returns>
      <par-!name=breikLabel">Die <see Cref}"P:Qystem.Lnq.Exprdqsion3.Log0Exprewsmon.BreakLabel" />-Eigenschaft des Ergebnisres./param<
  !   <param name="k/ntin}eLabel":Die ,see craf="P:Systei.Linq.Expressions.LoopExp2ession.ContilueLaBel" />MEigenschqft des ergebnisses,</raram>     !<param name="body">Die 4See cref=*P:Syqtem.Linq.ExpRessiojs.LootExpression.BoDy"!/>-Eigenschaft!des Ergebnisses*</param>
    </member>
    <member fame="T:S}st}m.Linqxpressions.MemberAssignment">
      <sumMiry>Stellt die Zuweisungsoper!tion füb ein Feld o`er eile0Dh'enschaft eines Objekts dcv.=/summary>
    </membar>
   "<member nam%="P:System.Lins.Extbessions*MdmberAssignment.Expression">
`     <semmaryRufv den$AusdrucK ab, der`%em Feld oder der Eigenwchcft zegeuiesan webden sold.|/summary>%
      >re4urns>Die <see creFy"T:Sys|eo.Linq.Expressionsxpression" /., ie den Wert dabstullt, darhdem Feld oder dEr!Eigenschaft zugewiesej werden soll.<returns>
    </ember>
   0<memfep name="M:System.Linp.Expressionw.MEmberAqsignment.pdae(Syspem*Liq.Expression3.Expressico)">
      <s}mmarY>Erstellt einen n%ueJ Ausdruac wie diesen, verwen$e jedoch die a~gugejenen untmrgeordneten IleMenta.W}nn amle qntergeordn%ten Dlelente Cberminstimmen, wird fer Au3druc{ xurückgegeben.</summary>
      <returns>Diestr Ausdruck, tenn keine uNdergeordneten Elemen%!geӤndert 7erden. oder ein Aucdruck mit `en aktuahisierten entergeordneten Elementen.</redurfs>
   !  <param nime="ExpRessikn">Die <s%e cref="P8System.Minq.ExpreSsions.MemberA{signMe.t.Expressif" />-Eigen3chqft`des Erebnisses.</parqm~
   !</me}ber>
    mmmbp n!le="T:SqstEm*Linq.xprussions.MemberBindin'">
(0    <summaRy>Stellt die Basisklasse ear, von der die KlassEn abgedehtet wer$en, de Bindungen!larspemlen$ fim zum Initialisieren von MemberN eines neE eRstellten ObjekTs verwendat0wepden.</sumlary>
  ( </-ember>
   <membe name="P:System.Linq.ExpessiolS.Mem"er aodiNg.BindingType">
      <suimry>Ru&t d%n0dargestellten B)ntungstip ab.</summar}:
      <ruturns:Einer der <see bref="TSyqtem.Linq.expreswinns.membErBindijgType* />-Werte.</returns>
    </member>
    |member name=2P:System.Din.EX`ressions.MEmberBinding.Mem"er2>
  `   <summary6Ruft `qs0zu inita,isierende Feld oder`dme zu inkticisieRelde Eigenschaft$ab.</smmary>
      <returns>Die <see cvef="T:System.Revlecthon.MemberIffo* />$ die das zu`i.itilisierende Fe,l oder die zu initialisieRente Eigenschaft darqtellt.</reurnS>
    </membdr6
    <member name="M*Systeo.Linq,Expressions.MemberBindhng.ToString">     <summar{?Gibp eine TextdarsTellung des <see cref="T:Syqtem.Linq.Expressions.MemberBind)ng /> zurück.</summay>
      <returns>Eije Textdrstellung des <see cref="T:Syqte-.Linq.ExpresSions.MembgrBinding" /:.<?returns>
    </member>
 (  <memer name="T:Systgm.Linq.Expressions*MemberBindingType">      <summavy>Beschrebt die Bindungstypen, dye in <see cref="T:System*LInq.Expressions.Me}brInitExpression" />-Objekten v%rwendet werden&</sum}ary>
    </membeb>
    <member name="F:System.Linq.Ex0rmssiojsnMemberBindmngTypenAqskgnment">
      <summary>E)ne Bmndng, die das Initialisieren eines ]embers mit dem Wert %i.es Ausdrucks darstelltn</3ummary>
    </member>
    <member oamu="F:System.Linq.Mxprmssionc.MembErBindingType.LiqtBindnc">
      <sumMary>Eine Bindung, die das InityalycieRen eines MDmbur vom Typ <see cref=&T:Systdm.Collgctions*IList"!/> oder <see creF="T:System.Collections.Generic.IAollectionp1" /> von einer L)ste von ElementEn darstellt</summary>
    </member>
    <member name="F:System>LijqExpressions,Mem"erBinDngUype.MemberBindmng >
      <summary>Eine BinDung, dig0Des Rekursive Knitialisieran vnn ]embesn`eines Meobers`darstellt.</summary>
    </member>
    <member Name="T:Sxstem.Linq.Expressions/MembesExpressin">     <su)mary>Stellt den Zwgriff auf min Felt odmr eine EIgenschaft dar.</sumoapq>
    </member>	
    <member nam%="M:Systm.Linq.Expresqions.MemberExpression.Accept(ys4em.Linq.ExprgsskOns.ExpressionVisi|or)">
      <summary>S%ndet an lie spezifisce V)sit-Methode für diesdn Knotentyp.Beis0ielsweise wird <see creb=*M2System.L)nq(Epre{sions.ExpressionRisitor.VisatMehodCa|l(System.Linq.Expressions.EethodCallExpr%ssion)" /> von <sle cren="T:ystem.LInq.expresSions.MetholCcldE|pressioo" /> aufgerufen.<+summary>      <returns>Das Drgebniq %ines Resukhs(d)eses Knntens.4/returns>
      <pqram name="visitor">Der Besucher, mitdem dieser Knoten besuch4`wdrden soHl.</param?
   `</memBer>
    <membebnama= P:Wystmm.Linq.Expressionq.MemberExpression.Expression">
      <sumlabh>Ruft das enthaltende ObjeKt des Felds ntmr der(Eigdnsch`ft ab.</summary>
   `` <returns>Eine <3ee cref=&T:System>Linq.Ex`ressions.Expressinn" />, dae0das envialtende`Objekt dms Felds oder de2 Eigensc`aft darstellt.</returns>
    </membr>
    <member name="P:System,Linu.Epressins.MeorevEXpressiof.Memberb>
      <summary>Ruft das Feld oder die Eigenschaft ab, A5f dar bzw. die$zug%griffen werde soll.<s5mmary?
      <returns>Die <sea cref=&T:System.Seflec|ion.MemjerInfo" />, die das Feld oder ti$ Eigenschabt darstellt, auf d!s bzw. die zugegriffen werden soLl.8.returns.
    </member>    <member nama=":Systee.Liny.Expressions/MembmrExpression.NodeType">      <suomary>Gibt den Knotentyp diesmr <semcref="P:System.Linq.ExpresskonsMemberExpresson.Exprescion" /> ztrück.</summary>
      <returns>er <see craf=":System.LInq.Expressimnc.Expressiojype" '>, der diesen usdruck darstellt.</returns?
(   </mmber>
    <membmr name M:Syste}.Linq.Expressions.emberExpzession.Update Sysuem.Linq.Expzessions.Expression)">
     `suMmary>Drstdhlt Einen neuen AusFruc* wie diesen, verwendeT jedoc( die angegebenen untErgeordneteo Elemente.Wenn ahle untergeodeuen E,ementg ü`ereinstimmef, wird der Ausdruck zurückgegeben.</summaRy>
      <veturns>Dieser Ausdruck, wenn keine unvergeordneten Alemente weändert werden, oder ein Qusdruck mit den aktualasierten!qntergeordneten Elamenten.</retupns>
`$    <aaram name="expression">Die <sfe cref="P:Systel.Lioq.Eh0recskons*MemberExPres{ion.ExpRession" />-Eigenschaft des EbgebNisses.8/param>*    </member>
    <member name=T:System.Linq.Expressions.MemberInitExpsession"?
      <summary>Stellt das Aufrufen eines Kmn3truktors und Initialisieren eines odr mehrerer Member des neuen Objekts dar.</summary>
    >/memb%r>
    <oember name="P:System.Lilq.ExpressiOns.MemberinitDypression.Bijdings">
      smmar9>Ruft die Bi~duNgan ab, die besch2mibef,"wie die Member dds neu erstellten Objekts inidialisiert werden.</summary>
      <peturns>Emne <See cref="T:SYstem.Collections.Objec|Mode|.ReadOnlyCollection`0" +> vOn <see cref="T:SyctemnLinq.ExxressIonw*MemberJinding" />-Obekte, die beschreiben, wie dye ember!initialiqiert werden.<+returns>
   </member>
    <membgr ncme="P:System.Linq.Expressions.MemberInitExpresqimn.CalSeduce">
  `   <summary>Ruft einen Wdrq ab, de2 angibTlob der Knoten der Asdrucksbaumstrtktur reduziert weRden kann.<sumlary>
      |reuupns:Trua,weno der!Knoten`reduziet werd%n kafn, enderjflls False.-retubns>
    </member>
    <meher name="P:Cyste.Linq.Exppession.MemberInivExpression.NewExpre{sion">
      >su-mcry>Ruft den tsdruc+ !c, dp den Konstruktoraufruf daRstellt.</summar}>
      <returnq>Ei.E <see cref="T:SysdemnMinq.Expresskons.Ne7Expression" /., die den KonstruktraufRuf darstellt*</returns>
 `  </member>
    4member name="P:System.Lioq.ExpressionsMeiberInitExprssikn/NodeType">
      <summary>Gibt den Knotentyp0digses Auqdrucks zuvück.Erweitevungsknote/ solte. <see creb="F:System.LiNq.EXppessions.ExpressionT9pe.Extension" ?> zurýckgefen, wenn diese Methode überschrieben wird.</summarx>
      <reTrns>Der <see cref="T2System.Linq.Expressions.ExpRessionType"(/> des Ausdrucks&</retupns:
    </member>
    mdmber n`md="M:System.Linp&E8pressions.MembeInytExpression.Reduge2>
      summary?Reduzhert <seE0cref="T:System.Liny.Expressions.Mem`erNitExpressi/l" /; auf eine~ emnachmrenCusdruck. </stmMary>
!     <retwrns>Der reduzierte ausdruck.</ret}rns:*    </member>
    <member nale=*PSystem.Linq.Expres{kons/memberInitExxression.TyP%">M
0  ! <summary>Ruft den statischen Typ des Ausdrucks ab- dg iase <cae cruf= U:System.Linq/Exprgssions.Expression* />"darstelld.</summary>
  (   <returns>Der <ee cref=&X*System.Li~q.ExpreSsions.MemberIni|Ezpresrion.ype" />, Der den statischen Typ des Ausdvucks daRstellt.</returns    </Member>
    <mebEr name="M:Sysugm.Linq.Expressions.MembernitExpression.Update(System.Lnq.Exprgssio~sNewExpressiOn,Rytel.colleations.Wenuric.Mnue%rable{System.Linq.Expressiols.Membez@inDi.g})">
      |summar9>Erstellt einen neue Ausdbuck wie diesen, vevwendet jedkch die angegebdnen untevgeordneten E|emente.Wenn allm unuE2geordften Elemente ¼beRainspimmen, w)rd dE Ausruck zurüc{gegeben.<osummar}.
    0 <returns>DiaSer Ausdruck, wenn keine untergeosdneten Elemente gaändert werden, oder ein Aesdzuck mit den aktualisirten untergeordneten(Elementen.</rettrfs>
!  !  >param!fame="newExpression?Die <see cref="P:QystemLinq.Express)ons
MemberInitExpresskon.NeuExpression" '>-Eigenschaft`des Er'ebnisses.<'param>
      4xaram name"bindings">Die <see cref=2P:System.Linq.Exprersions.MemberInitExpressi/n.Bindings"/>-Eigenschaft dec0Ergebnisses.</param>
    </member>
   <mgmbe name="T:Sys4ei.Lnq.Expressions.MembevListBhndinf">
      <s5mmary>Stellt das Initialisieren der Elemente einesAUflistungsmembers für ein neu ertelltes Objekt dar.</summary>
    </member6
    <member name="P:Sysvem.Linq.Expressions.MemberLitBhnding.Initializers">
    0 <summary>Buft die!lemenpinitialisierer ruM Initialisieren eines Auflistunsmembers bür ein jeu erste|ltes Objekt$ab.=/summa2y>      <returns>eine <see cref="T:ystem.Bollections.objectiodel.ReadOnlyCollection`1"(/> von <see cref="T:Qystem.Linq.Eppresiojs.Ele}%ndInit" />/ObjekTen`zum InitialiSieren e)nes(Auflistungsme}bers.8/returfs>
    </meeber>
!   <lember name="M:System.Dinq.Ey0rEssio.q.OemberLastBindyng,Update(System.Collections.Generic.IEnumerable{ysuem.Linq.Expresions&lemenpInit})&>
      8sulmary>Erstellt einen neuen Atsdruck wie diesen,"verwe~det jedoch die angegebendn untergAordneten Elemen|e.Wen. alle untergeorngten Elemente überenstimmen, wird der Ausdruck zurüCkgegeben.</summary>
      <zeturns>Dieser Iusdruck, wenn ieine unterge/rdneten Elemente geäldert werden, Oder eHn`Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="initializers">Die <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Stellt initialisierende Member eines Members für ein neu erstelltes Objekt dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Ruft die Bindungen ab, die beschreiben, wie die Member eines Members initialisiert werden.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.MemberBinding" />-Objekten, die beschreiben, wie die Member des Members initialisiert werden.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="bindings">Die <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Stellt einen Aufruf einer statischen Methode oder einer Instanzmethode dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Ruft eine Auflistung von Ausdrücken ab, die Argumente der aufgerufenen Methode darstellen.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente für die aufgerufene Methode darstellen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Ruft das <see cref="T:System.Reflection.MethodInfo" /> für die aufzurufende Methode ab.</summary>
      <returns>Die <see cref="T:System.Reflection.MethodInfo" />, die die aufgerufene Methode darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Ruft das <see cref="T:System.Linq.Expressions.Expression" /> ab, das die Instanz für Instanzmethodenaufrufe oder NULL für statische Methodenaufrufe darstellt.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die das empfangende Objekt der Methode darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="object">Die <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />-Eigenschaft des Ergebnisses.</param>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Stellt das Erstellen eines neuen Arrays und möglicherweise das Initialisieren der Elemente im neuen Array dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Ruft die Grenzen des Arrays ab, wenn der Wert der <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> ist, oder die Werte zum Initialisieren der Elemente im neuen Array, wenn der Wert der <see cref="P:System.Linq.Expressions.Expression.NodeType" />-Eigenschaft <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> ist.</summary>
      <returns>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Grenzen des Arrays oder aber die Initialisierungswerte darstellen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expressions">Die <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Stellt einen Konstruktoraufruf dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Ruft die Argumente für den Konstruktor ab.</summary>
      <returns>Eine Auflistung von <see cref="T:System.Linq.Expressions.Expression" />-Objekten, die die Argumente für den Konstruktor darstellen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Ruft den aufgerufenen Konstruktor ab.</summary>
      <returns>Die <see cref="T:System.Reflection.ConstructorInfo" />, die den aufgerufenen Konstruktor darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Ruft die Member ab, die die Werte der mit Konstruktorargumenten initialisierten Felder abrufen können.</summary>
      <returns>Eine Auflistung von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die Member darstellen, die die Werte der mit Konstruktorargumenten initialisierten Felder abrufen können.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.NewExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="arguments">Die <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Stellt einen Ausdruck mit einem benannten Parameter dar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Sendet an die spezifische Visit-Methode für diesen Knotentyp.Beispielsweise wird <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" /> von <see cref="T:System.Linq.Expressions.MethodCallExpression" /> aufgerufen.</summary>
      <returns>Das Ergebnis eines Besuchs dieses Knotens.</returns>
      <param name="visitor">Der Besucher, mit dem dieser Knoten besucht werden soll.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Gibt an, dass dieser ParameterExpression als ByRef-Parameter behandelt werden soll.</summary>
      <returns>True, wenn dieser ParameterExpression ein ByRef-Parameter ist, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Ruft den Namen des Parameters oder der Variable ab.</summary>
      <returns>Eine <see cref="T:System.String" />, die den Namen des Parameters enthält.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.ParameterExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Ein Ausdruck, der die Laufzeitberechtigung für Lese-/Schreibzugriff für Variablen bereitstellt.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="variables">Die <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Die Variablen oder Parameter, auf die Laufzeitzugriff ermöglicht werden soll.</summary>
      <returns>Die schreibgeschützte Auflistung, die Parameter enthält, für die der Laufzeitzugriff ermöglicht wird.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Stellt einen Fall einer <see cref="T:System.Linq.Expressions.SwitchExpression" /> dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Ruft den Text dieses Falls ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Text des Fallblocks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Ruft die Werte dieses Falls ab.Dieser Fall wird für die Ausführung ausgewählt, wenn der <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> einem dieser Werte entspricht.</summary>
      <returns>Die schreibgeschützte Auflistung der Werte für diesen Fallblock.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Gibt einen <see cref="T:System.String" /> zurück, der den aktuellen <see cref="T:System.Object" /> darstellt.</summary>
      <returns>Ein <see cref="T:System.String" />, der den aktuellen <see cref="T:System.Object" /> darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="testValues">Die <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" />-Eigenschaft des Ergebnisses.</param>
      <param name="body">Die <see cref="P:System.Linq.Expressions.SwitchCase.Body" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Stellt einen Steuerausdruck dar, der die Mehrfachauswahl durch das Übergeben der Steuerung an <see cref="T:System.Linq.Expressions.SwitchCase" /> behandelt.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Ruft die Auflistung der <see cref="T:System.Linq.Expressions.SwitchCase" />-Objekte für die Switch-Anweisung ab.</summary>
      <returns>Eine Auflistung von <see cref="T:System.Linq.Expressions.SwitchCase" />-Objekten.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Ruft die Methode für Vergleichsoperationen auf Gleichheit ab (falls vorhanden).</summary>
      <returns>Das <see cref="T:System.Reflection.MethodInfo" />-Objekt, das die Methode für Vergleichsoperationen auf Gleichheit darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Ruft den Test für den Schalter ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Test für den Schalter darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Ruft den Test für den Schalter ab.</summary>
      <returns>Das <see cref="T:System.Linq.Expressions.Expression" />-Objekt, das den Test für den Schalter darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.SwitchExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="switchValue">Die <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" />-Eigenschaft des Ergebnisses.</param>
      <param name="cases">Die <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" />-Eigenschaft des Ergebnisses.</param>
      <param name="defaultBody">Die <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Speichert Informationen, die für die Ausgabe von Debugsymbolinformationen für eine Quelldatei erforderlich sind, insbesondere den Dateinamen und den eindeutigen Sprachenbezeichner.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Gibt den eindeutigen Bezeichner des Dokumenttyps zurück (falls vorhanden).Standardmäßig ist dies die GUID für eine Textdatei.</summary>
      <returns>Der eindeutige Bezeichner des Dokumenttyps.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Der Name der Quelldatei.</summary>
      <returns>Die Zeichenfolge, die den Namen der Quelldatei darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Gibt den eindeutigen Bezeichner der Sprache zurück (falls vorhanden).</summary>
      <returns>Der eindeutige Bezeichner der Sprache.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Gibt den eindeutigen Bezeichner des Sprachenanbieters zurück (falls vorhanden).</summary>
      <returns>Der eindeutige Bezeichner des Sprachenanbieters.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Stellt einen try/catch/finally/fault-Block dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.Expression" /> ab, die den Text des try-Blocks darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den Text des try-Blocks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.Expression" /> ab, die den fault-Block darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den fault-Block darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Ruft die <see cref="T:System.Linq.Expressions.Expression" /> ab, die den finally-Block darstellt.</summary>
      <returns>Die <see cref="T:System.Linq.Expressions.Expression" />, die den finally-Block darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Ruft die Auflistung der <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücke ab, die dem try-Block zugeordnet sind.</summary>
      <returns>Die Auflistung der <see cref="T:System.Linq.Expressions.CatchBlock" />-Ausdrücke, die dem try-Block zugeordnet sind.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.TryExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="body">Die <see cref="P:System.Linq.Expressions.TryExpression.Body" />-Eigenschaft des Ergebnisses.</param>
      <param name="handlers">Die <see cref="P:System.Linq.Expressions.TryExpression.Handlers" />-Eigenschaft des Ergebnisses.</param>
      <param name="finally">Die <see cref="P:System.Linq.Expressions.TryExpression.Finally" />-Eigenschaft des Ergebnisses.</param>
      <param name="fault">Die <see cref="P:System.Linq.Expressions.TryExpression.Fault" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Stellt eine Operation zwischen einem Ausdruck und einem Typ dar.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Ruft den Ausdrucksoperanden einer Typtestoperation ab.</summary>
      <returns>Ein <see cref="T:System.Linq.Expressions.Expression" />, der den Ausdrucksoperanden einer Typtestoperation darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Gibt den Knotentyp dieses Ausdrucks zurück.Erweiterungsknoten sollten <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> zurückgeben, wenn diese Methode überschrieben wird.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" /> des Ausdrucks.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Ruft den Typoperanden einer Typtestoperation ab.</summary>
      <returns>Ein <see cref="T:System.Type" />, der den Typoperanden einer Typtestoperation darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="expression">Die <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />-Eigenschaft des Ergebnisses.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Stellt einen Ausdruck dar, der einen unären Operator aufweist.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Ruft einen Wert ab, der angibt, ob der Knoten der Ausdrucksbaumstruktur reduziert werden kann.</summary>
      <returns>True, wenn ein Knoten reduziert werden kann, andernfalls False.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt.</summary>
      <returns>true, wenn der Knoten einen transformierten Aufruf darstellt, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Ruft einen Wert ab, der angibt, ob der Ausdrucksstrukturknoten einen transformierten Aufruf eines Operators darstellt, dessen Rückgabetyp zu einem Typ transformiert wird, der NULL-Werte zulässt.</summary>
      <returns>true, wenn der Rückgabetyp des Operators zu einem Typ, der NULL-Werte zulässt, transformiert wird, andernfalls false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Ruft die implementierende Methode für die unäre Operation ab.</summary>
      <returns>Ein <see cref="T:System.Reflection.MethodInfo" />, der die auszuführende Methode darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Gibt den Knotentyp dieses <see cref="T:System.Linq.Expressions.Expression" /> zurück.</summary>
      <returns>Der <see cref="T:System.Linq.Expressions.ExpressionType" />, der diesen Ausdruck darstellt.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Ruft den Operanden der unären Operation ab.</summary>
      <returns>Eine <see cref="T:System.Linq.Expressions.Expression" />, die den Operanden der unären Operation darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduziert auf den Ausdrucksknoten auf einen einfacheren Ausdruck. </summary>
      <returns>Der reduzierte Ausdruck.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Ruft den statischen Typ des Ausdrucks ab, den diese <see cref="T:System.Linq.Expressions.Expression" /> darstellt.</summary>
      <returns>Der <see cref="P:System.Linq.Expressions.UnaryExpression.Type" />, der den statischen Typ des Ausdrucks darstellt.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Erstellt einen neuen Ausdruck wie diesen, verwendet jedoch die angegebenen untergeordneten Elemente.Wenn alle untergeordneten Elemente übereinstimmen, wird der Ausdruck zurückgegeben.</summary>
      <returns>Dieser Ausdruck, wenn keine untergeordneten Elemente geändert werden, oder ein Ausdruck mit den aktualisierten untergeordneten Elementen.</returns>
      <param name="operand">Die <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />-Eigenschaft des Ergebnisses.</param>
    </member>
  </members>
</doc>