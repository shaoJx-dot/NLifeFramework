<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Linq.Expressions</name>
  </assembly>
  <members>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Représente le résultat d'une opération de tri.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Représente le résultat d'une opération de tri.</summary>
      <typeparam name="T">Type du contenu de la source de données.Ce paramètre de type est covariant. Autrement dit, vous pouvez utiliser le type que vous avez spécifié ou tout type plus dérivé. Pour plus d'informations sur la covariance et la contravariance, consultez Covariance et contravariance dans les génériques.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données n'est pas défini.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtient le type des éléments retournés lors de l'exécution de l'arborescence d'expression associée à cette instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente le type des éléments retournés lorsque l'arborescence d'expression associé à cet objet est exécutée.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtient l'arborescence d'expression associée à l'instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Classe <see cref="T:System.Linq.Expressions.Expression" /> associée à cette instance de l'interface <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtient le fournisseur de requêtes associé à cette source de données.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryProvider" /> associé à cette source de données.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données est connu.</summary>
      <typeparam name="T">Type des données contenues dans la source de données.Ce paramètre de type est covariant. Autrement dit, vous pouvez utiliser le type que vous avez spécifié ou tout type plus dérivé. Pour plus d'informations sur la covariance et la contravariance, consultez Covariance et contravariance dans les génériques.</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Définit des méthodes destinées à créer et exécuter des requêtes décrites par un objet <see cref="T:System.Linq.IQueryable" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TElement">Type des éléments du <see cref="T:System.Linq.IQueryable`1" /> retourné.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête fortement typée représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
      <typeparam name="TResult">Type de la valeur qui résulte de l'exécution de la requête.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Valeur qui résulte de l'exécution de la requête spécifiée.</returns>
      <param name="expression">Arborescence d'expression qui représente une requête LINQ.</param>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Représente une expression qui comporte un opérateur binaire.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si le nœud d'arborescence de l'expression peut être réduit, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtient la fonction de conversion de type utilisée par une opération de fusion ou d'assignation composée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur.</summary>
      <returns>true si le nœud représente un appel levé ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns>true si le type de retour de l'opérateur est levé vers un type nullable ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtient l'opérande gauche de l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche de l'opération binaire.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtient la méthode d'implémentation pour l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Réduit le nœud d'expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtient l'opérande droit de l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit de l'opération binaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="left">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> du résultat. </param>
      <param name="conversion">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> du résultat.</param>
      <param name="right">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> du résultat. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Représente un bloc qui contient une séquence d'expressions où les variables peuvent être définies.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtient les expressions contenues dans ce bloc.</summary>
      <returns>Collection en lecture seule qui contient toutes les expressions contenues dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtient la dernière expression contenue dans ce bloc.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la dernière expression contenue dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> du résultat. </param>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> du résultat. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtient les variables définies dans ce bloc.</summary>
      <returns>Collection en lecture seule qui contient toutes les variables définies dans ce bloc.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Représente une instruction catch dans un bloc try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtient le corps du bloc catch.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtient le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtient le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Retourne un <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variable">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> du résultat.</param>
      <param name="filter">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> du résultat.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtient une référence pour l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Représente une expression qui comporte un opérateur conditionnel.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtient l'expression à exécuter si le test a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtient l'expression à exécuter si le test a la valeur true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'expression à exécuter si le test a la valeur true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtient le test de l'opération conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test de l'opération conditionnelle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="test">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> du résultat.</param>
      <param name="ifTrue">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> du résultat.</param>
      <param name="ifFalse">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Représente une expression qui a une valeur de constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtient la valeur de l'expression constante.</summary>
      <returns>
        <see cref="T:System.Object" /> égal à la valeur de l'expression représentée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Émet ou efface un point de séquence pour les informations de débogage.Cela permet au débogueur de mettre en surbrillance le code source correct lors du débogage.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtient la colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtient la ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtient la valeur qui indique si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence.</summary>
      <returns>True si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtient la colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtient la ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Représente la valeur par défaut d'un type ou une expression vide.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Représente un initialiseur pour un élément unique d'une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtient la méthode d'instance utilisée pour ajouter un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtient la collection d'arguments passés à une méthode qui ajoute un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments d'une méthode qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.ElementInit.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Retourne une représentation textuelle d'un objet <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Représentation textuelle de l'objet <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fournit la classe de base de laquelle sont dérivées les classes qui représentent des nœuds d'arborescence d'expression.Contient également des méthodes de fabrique static (Shared en Visual Basic) pour créer les divers types de nœuds.Il s'agit d'une classe abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation d'addition qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'addition arithmétique qui dispose d'une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'addition n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND au niveau du bit.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération AND conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits AND n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="method" /> est null et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau multidimensionnel.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="array">Expression qui représente le tableau multidimensionnel.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des expressions utilisées pour indexer le tableau.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="array">Expression qui représente le tableau à indexer.</param>
      <param name="indexes">Tableau qui contient des expressions utilisées pour indexer le tableau.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang supérieur à un.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.ouLe rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau de rang un.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="index">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="index" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.ou<paramref name="array" />.Type représente un type de tableau dont le rang n'est pas 1.ou<paramref name="index" />.Type ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente l'application d'un opérateur index de tableau à un tableau multidimensionnel.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="array">Tableau d'instances <see cref="T:System.Linq.Expressions.Expression" />, index pour l'opération d'index de tableau.</param>
      <param name="indexes">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.ouLe rang de <paramref name="array" />.Type ne correspond pas au nombre d'éléments dans <paramref name="indexes" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression permettant d'obtenir la longueur d'un tableau unidimensionnel.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> et la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> est égale à <paramref name="array" />.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égal à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> et dont <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLa propriété représentée par <paramref name="member" /> n'a pas d'accesseur set.ou<paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberAssignment" /> qui représente l'initialisation d'un membre à l'aide d'une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> a la valeur <paramref name="expression" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLa propriété accessible par <paramref name="propertyAccessor" /> n'a pas d'accesseur set.ou<paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient trois expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient quatre expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient deux expressions et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
      <param name="arg4">Cinquième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données et aucune variable.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="expressions">ExpressioNs contenues dans le bLok.</param>
 $  </member>
    <member name="M:Sytem.LinqnExprssions.Expression.Block(System.Type,System&Collections.Generic.IEnumerable{Syrtem.Linq.ExpressiOns.Expression})">
    ! <summary>Cre n <see cref="T:Syste-.Lilq.Expressions.BlockExrressikn" /> qui contient les expressions donnec, aucune varia"le et a un type de réstltat0spécifiaue.</summary>
     "<returns>Élment <s%e cred5"T:System.Linq.Expressioos.BlockExxression" '> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les variables et expressions données.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BlockExpression" /> qui contient les expressions données, aucune variable et a un type de résultat spécifique.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.BlockExpression" /> créé.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Break avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui ne prend aucun argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.ou<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d'instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale (passez null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.ou<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d'instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.ouLe nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.ouUn ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend deux arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance.(Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend trois arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel d'instance.(Passez la valeur Null pour une méthode statique (méthode partagée en Visual Basic.)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode qui prend des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> qui spécifie l'instance d'un appel de méthode d'instance (passez null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.ou<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d'instance.ou<paramref name="arguments" /> n'est pas null et un ou plusieurs de ses éléments sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.ouLe nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.ouUn ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> est égale à <paramref name="instance" />, dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'instance spécifiée, et dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> dont la valeur de propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> fera l'objet d'une recherche de méthode spécifique.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> ou <paramref name="methodName" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="instance" />.Type ou ses types de base.ouPlusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="instance" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique (méthode partagée en Visual Basic).</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode cible.</param>
      <param name="arguments">Collection de <see cref="T:System.Linq.Expressions.Expression" /> qui représente les arguments de l'appel.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode static (Shared en Visual Basic) qui prend un seul argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant deux arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant trois arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant quatre arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode statique prenant cinq arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le quatrième argument.</param>
      <param name="arg4">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le premier argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode static (Shared en Visual Basic) comportant des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode static (Shared en Visual Basic) à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le nombre d'éléments dans <paramref name="arguments" /> n'est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.ouUn ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MethodCallExpression" /> qui représente un appel à une méthode static (Shared en Visual Basic) en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode static (Shared en Visual Basic) spécifiée, et dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type contenant la méthode static (Shared en Visual Basic) spécifiée.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.Cet argument doit être null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="methodName" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n'est trouvée dans <paramref name="type" /> ou ses types de base.ouPlusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> sont trouvées dans <paramref name="type" /> ou ses types de base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indique que le nœud peut être réduit à un nœud plus simple.Si la valeur retournée est true, Reduce() peut être appelé pour produire la forme réduite.</summary>
      <returns>True si le nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec une référence à l'objet <see cref="T:System.Exception" /> intercepté pour une utilisation dans le corps du gestionnaire.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" /> et une référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body">Corps de l'instruction Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec un filtre <see cref="T:System.Exception" />, sans référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour la suppression d'un point de séquence.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour le nettoyage d'un point de séquence.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de fusion, à partir d'une fonction de conversion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.ou<paramref name="conversion" /> n'est pas null et <paramref name="conversion" />.Type est un type délégué qui ne prend pas exactement un argument.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> représente un type qui ne peut pas être assigné au type de paramètre du type délégué <paramref name="conversion" />.Type.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> n'est pas égale au type de retour du type délégué <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> ou <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type n'est pas <see cref="T:System.Boolean" />.ou<paramref name="ifTrue" />.Type n'est pas égal à <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente une instruction conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</returns>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> n'est pas null et <paramref name="type" /> ne peut pas être assigné à partir du type dynamique de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Continue avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion de type.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion pour laquelle la méthode d'implémentation est spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.ou<paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.ouLe type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.ou<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de conversion qui lève une exception en cas de dépassement du type cible et pour lequel la méthode d'implémentation est spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n'est défini entre <paramref name="expression" />.Type et <paramref name="type" />.ou<paramref name="expression" />.Type ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.ouLe type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.ou<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n'est pas égal au type d'argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> avec l'étendue spécifiée.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> qui représente le fichier source.</param>
      <param name="startLine">Ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure à 0.</param>
      <param name="startColumn">Colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure à 0.</param>
      <param name="endLine">Ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure ou égale à la ligne de début.</param>
      <param name="endColumn">Colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Si la ligne de fin est la même que la ligne de début, elle doit être supérieure ou égale à la colonne de début.Dans tous les cas, elle doit être supérieure à 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la décrémentation de l'expression par 1.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression décrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à affecter à la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de division arithmétique.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de division n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de division qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> comme deuxième argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par <paramref name="addMethod" /> n'est pas nommée "Add" (non respect de la casse).ouLa méthode représentée par <paramref name="addMethod" /> n'est pas une méthode d'instance.ou<paramref name="arguments" /> ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par <paramref name="addMethod" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un tableau de valeurs comme deuxième argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par addMethod n'est pas nommée "Add" (non respect de la casse).ouLa méthode représentée par addMethod n'est pas une méthode d'instance.ouarguments ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par addMethod.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crée une expression vide qui a le type <see cref="T:System.Void" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> est égale à <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'égalité n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur XOR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur XOR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Pour static (Shared en Visual Basic), <paramref name="expression" /> doit être null.</param>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> a la valeur null.ouLe champ représenté par <paramref name="field" /> n'est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration du champ représenté par <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ à partir du nom du champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.FieldInfo" /> qui représente le champ désigné par <paramref name="fieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient un champ nommé <paramref name="fieldName" />.Cette valeur peut être null pour les champs statiques.</param>
      <param name="fieldName">Nom d'un champ auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="fieldName" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Aucun champ nommé <paramref name="fieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
      <param name="expression">Objet conteneur du champ.Cette valeur peut être null pour les champs statiques.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient le champ.</param>
      <param name="fieldName">Champ auquel accéder.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crée un objet <see cref="T:System.Type" /> qui représente un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
      <returns>Type d'un délégué System.Action qui a les arguments de type spécifiés.</returns>
      <param name="typeArgs">Tableau contenant jusqu'à seize objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contient plus de seize éléments.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtient un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué générique System.Func ou System.Action comportant des arguments de type spécifiques.</summary>
      <returns>Type délégué.</returns>
      <param name="typeArgs">Arguments de type du délégué.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Func générique comportant des arguments de type spécifiques.Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <returns>Type d'un délégué System.Func qui a les arguments de type spécifiés.</returns>
      <param name="typeArgs">Tableau contenant entre un et dix-sept objets <see cref="T:System.Type" /> qui spécifient les arguments de type pour le type délégué System.Func.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contient moins d'un élément ou plus de dix sept éléments.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction GoTo avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur Null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur à ».La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "supérieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "supérieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « supérieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "supérieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ConditionalExpression" /> qui représente un bloc conditionnel avec une instruction if.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ont les valeurs spécifiées.Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ayant pour valeur l'expression par défaut et dont le type du <see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultant retourné par cette méthode est <see cref="T:System.Void" />.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
    </member>
    <membgr name="M:ystem.Lhnq.EzpressiOns.xpresion.IfThenElse(Syst%m.LifuExpressions.ExppesSion,system.linq.Expressols.Expression,System.Linp.Expressions.Expression)">      <summary>Crée un`<see cref=":Sysdem.Linq.ExP2es3ionr.CondiiofalExpression" /> qui représente u~ blkc conditionnal aves nes insVructions if et elsd.<-summary<
    $ <returns>        <see cref?"T:System.Li.q.Exresryons.ConditionalExprms{ion" /> dont la proprité <see cref="p:Syste.Linq.Expres3ions<Axpression.NofeType /> esp égale $<see aref="F:System.linq.ExpseqsyonsExprssionType.Conditional" /> t dont hes propriétés!<see creb="P:Sysuem.Liny.DxppessIons.Condi|iona|Expre3syon.TeSt" />, <seu cref9"P:System.Linq.Expressions.ConditionadEzpression.Ifrue" /> et <see cref="P:[y3vem.LInq.Exprewsions.CondiuionalExpreqion.IfFilse" /. ont les valeurs sqécifiées.Le ~pe`du =see cref="T:S9stem.Lioq.Expresshnns.ConditiooelEx`pessyon +> vCsultant retourné par cette méthode est <see cr%f=#T:System.Void" />.<+returns>
      <parao nime="test">
        <see cvef="T:S{Stem.Hinq.Expressions.Expression" /> auquel la pvopriété <see cref="P:Systdm.inq.Exprdssions.Condith/nalExpre{sin.Pest" /> doit âtre`égale.</param>
      <param nAMe}"idTru">
        <cee cref="P:System.Linq.Dxpre3sions.Expression* /> auquel$la prkpbiét <see kref=2PRystEmLinq.Expressions.ConditionalExtression.If\rue" /. doit être égale.</param>
   0  <parAm nam%="ifFamse">
  !     <eee cref="T:System.Linq.Expressions.Expressimn" .> aquel la 2ropriété <see cref"P:SystEmnLinp.Exprssions.ondipionalExpsession.IfFa|se" /> $oit tre Égale.<.xaram>
   "<+member>
h  0<member naoe="M:Rxstem.Linq.Expsessions.ExpesrionIncrement(System*Li.q.Expressions.Expressin)">
      <summary<Créeun(<sae cref="T:Systm.Li.a.ExpressiOnsUnabyExpsession" /> qui rep2ésen6e!l'yncpémentqtion de a Valeur de0'%Xpres{iOn par01.</summer}>	
   "  <returns>
        <{ee cref="T:System.Liq.Exxresqions.UneryExpres3ion" /> qui repr)sejte l'expression incrémen|ée.</returns>
    ( <param name="expresion">
        <see0cref="T:Sxstem.Linq>Expzeswions.Expression* .> ˠ incrémentez.</para-6
  ` </meobur>    <membernaMe5"M:System.Linq.Dx`reqsions.Expression.IncremenphSystem.Linq.Expression.Exxression.System.Reflccti/n.MethodI.fo)">
  0   =summar{>Crée un <{ee cref="T:System.nQ.Dxpr%ssions.Unar{Expression" /> qui représente$l'incséeentatkon de l'expRssion par 1.<+svmmary>
      <returns>
    "   <see cref="P:ystem,Linq.Exresions.UnaryExprmcsin" / qui reppөsente l'expression$incrémentåe.</retupns>
   "  <param name="expression">
        <see c2ef5"T8System.Dknq.Expressi/ns.Expressyon" /> à incvëmenPer.</parcm>
!     8para= nqme="method">
        <see cref="T:yrtem.ReflectioNlM%thoInfo" /> qui reprsnte la méthode d'implémg.tation.</para]>
(   </mem"er>
 $  <member name5"M:SysemnLinq.xpressiojs.EXpression.Invoke(System.Linq.Expressions.Uxpression,System.Collections.GeneviC.IEnumeradhe{Sys4em.Lioy.Mxpression3.ExpreSsion}-">
      <summary>Crée un <sEe!cref=T:System&Lkny.Expressions.nvocatiozE8pression"0O> qi appli1ue en$délégué ou uNe expre{sion lembda à une liste d'expres{ions d'crgumenfs.</summary>
      <retqns>M        <see cref="T:System.LiNq.Expressions.InvocAtionExpression" /> qui applique le délégué u l'ex0ression lam`da1spéciFiés aux arguments fgurnis.</returns<
      <param name="expression">
       !<see czef="T:System.Minq.Expressm/ns.xpreSsi/l" /. qui représente l'expression$d!mbda ou le Délégué auquel appliquer.</pram>
      <parim name="aRguments">Z`       <ee cef="T:System.CollectionsGeneric.IEnumerable`5" /<0pui condIent des objmts <see Crev="T:Qystem.Linq.Exqressions.Exrression" /> représen|ajt le3 qrgumens auxquans le délégué ou ,7exprEssion lamBda sont ap`lipuéS.</pavam>
   b` <exception kref="T:[ystem.ARgummntNullException">
        <paramref name="exp2gssion" '> a la valeur nll*</uxcepthon>
!   " <exaeption aref="T:Sy{tem.Argu-ndExce`tion">
        <paramref neme="expzEssiOn" /?.Uype ne repzésentg pas un tyPe délégué ou un <seecref="t:System.Linp.Expessions.Eypression`1`/>.ouLa propriétá <see cvef="P:[ysTem.i.q.Exprersiofs.Eppression,Type" /> d'un élme~t e <paramref name="arg}ments" .> ne pe}t pAs être(assignée au type du paramète corr%s0ondNt du délégué beqrésenté par <paramsef"name="gxpressimn" /6.</exception~
      ,Exception cref=&TSys4el.InvclidOperationException">
"       >parambef name="arg}ments" /> ne #ontient paq le múle nOMbre d'éléments(que la liste `e(paramètbes pour |` délégué beprésent© par <parmref naoe="exprersikn2 />.</exception>
    </}emjer>
   <member name="M:Systde.Linq.Expressions/Exprassion.Invoke*ystem.Linq.Expressions.Expression,ystem.Linq*Expressigls.Expressioj[])">
      <su}mqry>rée un <sEe cref<"T:Systel.Ni~q.ExpressiolS.InvocationEXtression"!/> qum!appliqe un délégué ou une exprgssion lambda ¢ une liSte `'eppressions d'Arguments.</summary6
      <retuvns>
       <see cref="T:SystEm.Linq.Exressions.InvocivionExprEssIon" +> qui applique le dèlégué nu l'expression lambda sp)cifiés a5x areuments fournis.</retu2ns~
 `    parae name="exression">
"  " $  <Seecrmf=":System.Linq/E8pressionq.Ezpruscion" /> sui bepbsente le dé\águé ou l'exprd{sion lambda à0appliqu%r.</param.
      <param name="arguments">Table5 d'obcets <see cref="T:System.Linq.ExpresIonc.Expreswion" /n qui représen4ent(les arguien4s auxqqe,s le délécué /u l'eztression lambda est applhs5ée.</param>
      <exception cref="TzSystem.A3gum%ntNuhhEceptio~">
  !(  (<paramref name="expressmon" /> a la vEleur null.</exception>
      <exception cref="T:Sy3pam.ArgumejtException":
       <paramref name="eppression" />.Type ne reprse.e qas un type félÉgwé$u wn(<see"cref="T:S{3tem.Linq.Expres{inc.Expre{sion`1" />.OuL propriété <se cref="P:System.Lijq&Exrrgss)kns.EXpresqion.T}pe" /> d'un ílémejt de <pqramref namm<"arguments" /? ne peut pas être aSsigne au type du parimètre correspondaNt du dlégué rEprqenté qer <param2er name=bexpression"/>.</excepTi/n>
)     <exceptio`cref<"U:System.InvilidOperationExcetion">
 0     `<pab!mref naMe="areumeNts" /> ne cmntienT pasle0même n/mfre d#élǩment{ que la histe!te paramètre{ 0our ,edélégué eprésenté paR <parairef n!}e="expression" />.</exception>
    </ieiber>    <mamber oame="M:Sy{tem.NinQ.Expressions.UxpressiOn.IsFalwe(System.inq.Expressions.Expresshon) >
      <summary>Indipee cy n'exppessiof"prend la valeur fale.</swmmary>
   `  <returns>nstance te <seu`cref="T:Sqstem.Linq.Expressions.UNaryExpressaon" />.</revurns>
      <raram name="dxpressimn">
0      `<see cref="T:System.LiP.AxpressIons.Ex|ression" > à évaluer.</param>-*    ,/memb%r>
    <mdmbAv naMe="M:Sys4em.Linq.Eypsessions.Dxpression.I{False(System.Linq.Expressions.Expressinn,System.Reflectign.MethodInfo)">
      <summary>In$ique sa l'expresson pzend ha valeuz fil{u.</qummary>
      <pettrNc>Instance de <s%e cref="T:Systei>Li~q.Expressions.UnaryE|presqion" '>n</returos>
      <param name="extression">
        <see cref=*T2System.LInq.Expressinns.E8reqsion" /> àívaluer.</param>
  !  "<pram name="meth+d">
`     ! <see sref=*T:System.Reflection.MethodInfo"$/> qui repr©sente la méthoDe d&implémenttion.</pa2am<
    <+memrer>
    <member name="M:System&Liny.Expressions.Expression*IsTrue(Wysdem.LInq.xp2essions.Mxpression)">
      <suomary>Indique 3i l'expression prend la valeur urt%.</sulmcry>
     0<re|uzns>Insuance `e <see #ef="TzSysem.LinqnExpression.Unariexpression" ->.</returns>
     <para- name="%xpression">
        <se czef="T:System.Linu.Expruss)gns.Exqvessioo" /> à évaluer.</param?
    <omember>   <member name="M:System.Lins.ExpressioNs.Expression.IsVrue(System.Lioq.Exprdsqikns.Expres3yon,System.REf,ection.MuthodInfg)">
      <summary>Kn`que si lexpression preod la valeur true.</summar9>      8reTurns>Instcnce de <see cref="T:Sistem.Linq.E8pressions.UnarExpress)/n" />.</reTurns>
      <Param nime="exprescion".
        =see cref}"T:Syspem.Linq.E|prgssiOfs.Ex`ression" /> à évaluer.</param>      <param!na}e="methmd">-J "      <see craf="T:Syqtem.Refldction.MephgdMjFo" /> qua représente la méthode d')mplөmentat)on./pirmm>
    </member>
    <memer name="zystem.Linq.Exprgssions.Expression.Label">
      <summary>Krée un <see cref="T:Syrtem.Linq.Expressions.LabelTarget" /> au) représgnte un étiquette avec le type void et aucun nom.<'summary>      <eturns~Nouvdlle <see$cref="T:Systam>Linq.Expresskmns.LabelTazget  />.</returns>
   !</meber>
  0 <Member name="M:Systtm.Lin.xpressions.Expre{sion*Labll(Sxstem.Linq.Expvessions.LabelTar'et)">	
  !  (<summary>Crée(sn!<see cref="T:S}stem.linq.Expressions.Labe,Expression" /> quireprésente une étiquette sanw valetr par dùfaut.</cummary>
      <returls>
   `    <see cref="T:Systum.Linq>MxpsEssi.s.LabelExpression" />$sans valeur!par défaut</ret5sls>      <param na}E="target":
        <see cref=bT:ystem.Linq.Exrressions.LabelTarget"0/>0aqquel <see cref-"T:Sqstem.Linq.Expreswions.LibglUxpression" /> sera associ.</parqm>
 !  <?member>
    <member naoe="M:System.Linq.EYpressions.Exprmsqion.Label(System.Linq.Expressions.LabelTarfet,Systeminp.Gx`re3siknr.Expression!">
 "    8suemary>Cr)e ]n <see cref="T:System.Linq/Expressions.LibelExppession" /> sui repBésefte qne étiquette avec la$aleer par défaup dmnnée.</summary>
     (<returns>
        <see cref?"T:[ystem.\i~q.Eh`ressigns.LabelExppession# /. avec la valer pqr défaut donnée.</returns>
      <pAram nae="target">
  0  (  <see cpef=T:System.Linq.Expressins.LabalTarget"!/> auquel <see cref=bT:S{stEm.Linq.Axpressions.LabelExpression" /> sera acrocié,</param>
   "  <param name="defaultValue">Valeur de ce <see kref="T:System.Linq.Expze3sionsLabelxppesion" /> lorsque l/étiquutte est atteine vma un flux de contrôle n/rmal.</param>
  <-mamber>
    <member neme"M:System,LinQ.Eprssions.Expression.Lqbel(System.Striog)">M     "<summary>Crée un <see cref="T:System.Hinq.Expressions>MabelTarget"0/> repréSentant tfe étiquette avec le type vohd dt le om donné.</summary.
   `  <returns>Fuvelle <see c2ef="T:System.Linq.Expressions.LarelTarget" .>.</returns>
      <param nama="jame">Nmm de l'étisuette.</param>
   "</meMbev>
 `  <mem`er0name9"M:System.Linq.ExpresSions/Expression.Label(System.Type)2>
("    <summary>Crée Wn$=see`ref="T:Sxstem.Linq.Expressi/ns&LabeLTarge|" /< représentant(5ne étiqu%ute aves le type doNné.</sum-ary>
     returfs>Nouvehle <see cref=*T:Sysvue.Linq&Mxpressions.MabelTarfet" />.</returns>
      <param name="4}pe">type de valeur paswée lors de l'accès à0l/étiquette.</rqram>
    </member>
    member naee="M:System.Linq.Expsessions.Expression.Labe,(System.Type,System-StrinG)">
$     <summary>Cre un <sea svef="T:System.LinqExpressions.LabelTarget" />`qui rdprésente une étiquette"arec$le type et l nnm donns.</summary>
      <returns>Nouvelle <qee crmf="T:System.Linq.Expressions.LabelTarget" />.</retUrns>
  0 ( <raram name="type">Dype de Vale5r assée lors de l'acbès à lgèuiquutte.</para->     `<pazam namu="oAme">Noo de l7étiquete.</pabam>
    </member>
    <membdr name="M*System.Linq.Axpres{ions.Expression.Lambd!(Sstem.Lin1.Expre{Sions.Exrss)on(Sqstem.Boolean,System.Collebtions.Generic.IEn}merable{System.Lynq.ExprescionsParaeeterExpresion})">
 $    <suMmary>Crée uo LalbdaExpression en commençant par contbuire unt{pe délégué.<?sqmmary> !   1<return>
      $<seE cref="T:SysteM.inq.%Xpresshons.La-bdaExxression" /> dont la`propriété <see cref="P:System.LiNq.Expressions&LambdaExpresionOodetype" />(est égala à Limbda et dont les xrotriétés <see cref<"P:S9stem.Lijq.Expressions.Daebd`Expressiof.Bmdy" o> eu <see cref/"P:istem.Lina.Expruscions.LaobdaExpre{sion.Parameters* /? ont les valeurs spécifiées/</returnS>N      <pabamnamu="body">
        <see cref="TzSyqte-*Linq.expre{sionr.xpression" / ausuel la propriété <see cref="p:Cystem,Linq.Expreswionp.LamjdaEpression.Body" /> doit!tre égale.</param>      $param oame="tailCq,l">
       $<see cref="TzSyc|em.BkOlea." /> qui indiq}e si l'oqtimisati/n 'appel tail sera appliquée pendant ,a com`ilation de l'dxpresshon créée.</qabam>
      <param name="pasameterr">
        <see cref="T:Sycte}.Collections>Generic.IGnuoerable`9" /> qui ckntie~t das objets`<sae cref="D:SyStem.Minq.Expressions.ParaMmTerExpression" /> à 5tiliserpour bemplir la cllection <see cRef="P:System.Hinq.Expresskons.LambdaGxpression.a2ameters" />.</pasam<
    |/membr>
  $ <member name="M:System.liny.EPPressions.Expression.Lalbda``1System.LiOq.Expressions.Expressikn,Syqtem.Bnolean,Sytem.Cohlections.Geoeric.Inumerable{Sywtee.Hinq.Expressions,ParameterExprecsio.})">     (<summary>Crée un <sme cref="T:Syst%m.Linq.Expressiofs.Expression`1" /> pour LgqueL lE type délégué est connu au momeNt dela comilatiob.</qummary>
  (   <returns>
        <see cref"T:System.Linq.Exprmssions.Expression`1" /> dont ha propriété 8see cref="PzSystem.Lioq.Expressions.Lambd!Expresqion.NodeTyp%" /> et égale à <see$cbef="D:Sysuem.linq.Exprecsions.Expr-ssio.Tpe.LaMbda" />$et dont les tropriété3 <see cref="P:System.Linq.Expressions.Lamb`Axpreswikn.Body" /> ev <see cvef="p:System.Linq>Exqrew3ions,LmbdaExprdssion.Tarameteps" /> ont les valeurs spécifiөes.|-raturns>
   "  <parAm sme92bod=">
       <see csef="T:System.Lin1.Expres{ions.Expression" /> cuquel la propriCté"<see cref="P:System.Linq.Expresyons.HambdaEypression.Body" /> doIt ê|re éwale.,/pabam>
      <param jam%="tailCall">
  (     <se cref="T*System.Boleal" /> qui indique sil'nptimisition d'appel!tayl sera appLiquée pendant la cnmpIlatign de l'expression créée.</param>
      <param name="qarameters">
        <see sre="T:System.Collactimns&Oengric.IEnumerable`1" /> qUi contient `es objets <see cref"\:Systee.Dinq.Expressions.ParameterExpres3yon" /> ¤(utiliser pour remplir lacmlection <see cref="P:System.Lin*Expressionc.LambdaExpression.Parameters" />.</param>J      <|yp%papai name="DDelegata">Typ% délégué. </typeparam>
    </meeber>J !  <member neme=bM:System.LInq.Axpressions.Expr%ssion.Lambda`1(System.Linq.AxPrdssionsnExpressio,System.Boolean,System.Lifq.Epressions.ParameterExpressio.[])">
      <summaryCrée`uf <ree cref="T:Sxstem.Linq.Axpressions.Expres{ion`1" /> pour leque< le tyt% dùl©gqè est connu au mkment de"l` c/mpi,a4ion.<summary>
(    <returns>        <see cref="T:System.Linq.Expressions.Expresrion`1" /> dont la prOpriété <see cref="P:Sxspe}.Linq.Expressions.Expresikn.NodmType"0/> est égale à <see cbef="F:Rystem.Linq.Expressions.ExpressimnType.Lambda" / et dont les propRi©tөS <see cref="P:Sysuem.Lilq.ExpressionsLaibdaExprEwsion.Bo$y" /> et <s%e0cref="P:Sytem.inq.Uxpressionw*LembdaExpression.araie4ezs" /> ont0leq valeurs spécIfiées.</returns;
(0    <`ara} name="bkdy">
        <see cref="T:Systm.Linq.Ehpresions.Expressi/o" /> auquel la propriété`<see cref":Wysuem.Linq.Expressions.LambdaExpressinn.Body" /> Doi4 Atre éwale.4/param>
      <parim oame=tailCall">
        <see(cref="TSystem.Boolean" /> qui i~dyqu% si l'opimisevion d'appel tqil sera appliquÈ% pendalt m! compilation de l'expression cré)e.</parqm>
(     <para name"parameters">Tablau qti cootient des objets"<seecreF="T:Sywtem.Linq.Expbessiols.ParameterE|ppession"$/> à utiliser aour rEmplir la aollection <see cref="P:System.Linq.ExpreSions*LaMbdaExpbession.Parameters" /:/</param>  !   <typeparam name="Eelegate"<Type délégmé. </typep!ral>
    </member>
    <membEr name=M:System.Linq$ExpressIons.Expression.Lam`dc(System.LinqnExpressionw&Expression,Rystem.Boolean,System.Minq.ExPressions.Parametgrx`ressioo[])">      <summary&Crée un La}bdaExpressio en commençant par cojtzuire un type déléué.</suMmary>
  0   <rturns>
        <see ref="T:System.Linq.Expressi/ns.LamrdaFzpresvhon" /> dont la propriété <se cref="@:Sstem.Linp.Expressions.LambdaExpression.JodeType" /> est éGaleä Lambda et(dont les proprkétés <see cref="P:Systdm.inq.Expsessions.LamBdaExpression.Body" /> et <seg cref="P:SysueM.Linq.Expre{sions.LcmbdaE|pression,Pirameters" /> ont les valeurs s0écifiëes.</returns>
      <param ncme="body">
        <see cbef="T:System.Linq.ExpvessiNnc.E8pression" o> auquel$la p2opzité"<sae cref="P:Sysd%m.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>      <param name="tailCall"~
        <sed crEf="T:SYstem.Booleen" /> qui indique si l'o`|imisaTion d'appeltail sera appliquée pendant |a kompili4ion de l'exprmssinn crëée.</Param>
      <param name="pArameters">Tablgau qui cOntient des ofjets <see cref<"T:System.Linq.Axpressions.Parame|erE|rression" .> Ӡ$utIliser pour remplir la co|lection <see cref="P:Systum,Lijq.EXpessions.LambdaxpvesSion.Parameters" /<.</pasam>
   $</member>
   <membez name="O:System.LInq.Expvessions&Expression.Lambda``1(System.Linq.expressions.Expresshon,SysTeM.Bohlections.Ganeric.IEnmerable{System.Linq.Exprm3sions.ParamederExpression})">
     0<summary>Crée un <see rgf<"T:Sqstem.LInq.Expressions.Expression`1" /> pour lequel le type délCgué esd onnu au }olent de la compilation.<summery>
      <retrn3>
        <see cpef="T:SystemLinq.Exprdscions.Expressaon`1" /? dont l! propriété <see!csaf=2P:Sqte-.linq.Expressimns&ExPresskon.NodeType" /> ewt égale à <see cref=2F:System.LnqnExpressions.AxpressioType.La-bda" / et dont les(pRoppiǩpés <see"crefm"P:System.Lilq.D8pressions.lamdaExpresiof.Body" /> dt <see cref="P:System.Linq.Uxpsessions.Lam"daExprescmon.Parameters" /:0ont les vqeurs"spécifiées.</returns>
      <param name}"body">
   $   `<see cref="T:System.Linq.ExpReSsio~s.Exxression" /> `uquel l` propriété <see cRef="P:SYstem.Lknq.xpressions.LambdaExpres3ion.Boly" /> doit être égal.</param>
$     <param name=#parameters"?
        <see cref="T*S}stem.Collections.Gengric.IEnwmerable`12!/> qUm contie.t des ofjets <see cref="T:G9s4em.Linq.Dxpvdssions.ParamaterExpression" /: à utilisgr pour remplir la collection <see cref="PSystei.Linq,Axpressins.Mambdaxpre{sionnParaeders" /></pa2am>
      <t9pdparam name="TTelegape&>Type délégUé.</Typeparam>
  $  (<e|Ception cref="T:Sysvem.ArgumentNu,lEcapti/n">
  0     <paramref name="bgdy" '> a la valeur0null.owUn ou plusieers élémentr dans <paramRef name="parameebs" o> sont null.4/exception>
 "    <exception cref="T:ysvel.ArgumentE8cepthon"<
       =paramref laie="TDelegaue" /> n'est pas un t9pe dé,gué.ou<paremref name=2body" />.ype représente un typa qui le peut pas être awsigné au type de r%toup le <paramre&$name="TDelegate" />.ou<parqmref name="parame4ers" /> ne contient ps le même nomjre d'ɩlémenTs que la liste de pqramèTrEs pour <paramref nme=*TDelegite" />.ouLa propriéTé <see cRev="P:System.Linq.Expressions.Expression.Typg" />d'un élément de <parampef ame=&parameters" /> ne peut pas CtRe assignée à partir du$type du,paramètre cobrespondant de <Paramred ncme="TDelegate" /~.</exceptmon>
    </memcer>
    <mmmber name="M:System.Linq.Expressions.Expressio.Lembda(Systum.\hnq.Expressions.Expbession,Systdm.Collectiojs.Generis.iEnumerabmeSysTmm.LinqnExpressioos.ParametevExp2mssion})">
   "  <sumear}>Crée un am"daExprassion en kommenç`nt par construire un type délégué.</summary>
      <veturns>
    !   <see cref=#T:Wystem.Linq.Expressioo3.LambdaExrersion" +>!dont la propziété <see$Cref="P;System.Lynp.Exprgsqions.LabdaExprdssion.NodeType" /> %st égale  Lambda et do.t les propbiéts <see cref="PSys4em.Linq&Expression.LambdaExpression.Bkdy*/>et 8see cref="P:System.ln.Expressioo{.LambdaExpression.Parametars" /> ont lms raleurs spécifiées.</returns>
      <paRam name="body">
        <see cref}"T:Sys|em.Mhnq.Expressions.Expzession" /> auquel`ha propraété <see cref="@Sytem.Lina.Expressions.LambdaEx0ressmo..Body" /> doit êtbd égale.</param>
      <paraM namm="parameters">
        8sed crev="t:System.COllectionc.GenericnYEnumer`ble`1" /> qui cootient des objetr <cee cref="T:S9stemLinq.Eppresshons.ParametarExpression" /> à"utimiser purremplir la collection 8s%e craf= P:SqsTem.Linq.Expressions,LambdaExpresqhnn.parameterc"0/>.</param>
    </member~
    <mdmber name="MzSystgm.LifqnEx|ressions.Dxpression.LbmjDa`1(Sys|em.Linq.Expsessions.Expression,SystEm.Lmnq/Exprassions.Para}evurExpression])">
      <summary>Crée qn <see cref="T:CystemLinq.Expres3ions.Exprmssin`1" /> pour lequel)le"uype déléguË est!connu qu mnment $e la compilation.</3ummary>
      <returnc>
 `      <see cref=2F:Sysvem.Linq.Expbes3ions.Exprersion`1" /> doj4 la propriété <see creF="P:System.Lin1.Expressions.Expresion.Noee]ype" /> %st ègahe à <see cref="F:System>Linq.Expressions.ExpRessionType.Lamda"!/> et dont`les$propriétés <see cref="P:rystem.Lnq.Expressions.LambdaExpre33ion.Body" /> et <see cref="P>Syctum.Linq.Dxpressi/ns.LambdaExpressynn>Parameters" /> onu les valeurs spCcifiées.</Ret]rns>
  $  <pAram name="body">
        <sEe cref="T:Sstem.Linq.Expbgssmons.Exres{kon" / auquel la prop2iátá su- creg=2PSystem.Linq.Expressions.LambdaEx|reswion.Bndy" /> doit être égale.</param>
   `  <param ame="parameters"T`bleeu d'objets <seE cref=#T:System.Linq.Ehp2eskons.ParemetgrExpreqSion"$/> à uti|iser po}r remplir la collection <sae cRef="Q:SyStemLinq>Axpressions.LambdaExpression.Parameters" />n</param>   $  <tyeparam name="Velegate">ype délègué.</pypeparam>
     `<exceptiOn cref="T:[ystem.ArgumEnTNullExcepdikn">
    `  (<paramref name="body" />a Ta valeur n}hlouUn ou(plusieurs ëlémentc dans <para-ref name}"parameters" /> soft oul,.</exception>
(  (  <exception cref="P:System.Argume.tExepthon2>
        <paramref`name="TEelegate" /> n'est ras u. tyPe félégué.ou<paramref name="boly" />.tqpe reppésente un"tYpe q}i ne pett pas êtse assiené au type `e retur de <paraoref(name="TDelegate" /..ou<qaramref name="par`meters" /: ne contie.t!pas le même nom"be d'élémentS que la lite0ed$paramdres pour <parqm2ef name="TDelegaue" />./uLa propriété <sme cref="P:Qystem.Linq.ExprEssion3.Expression.Type" /> d'un léont `e <papamref name="prameters" /> ne peut pas êtreasqignèe à partir0d% tipe du$paramtre"correspondant de <paramred0name="Telegate"/>.<'exce0tion>
   </member>
    <m%,ber name}"M:System.LinpnExpressions.Expression.Lambda(Systum.Lmnq.Expresskons.ExpressionSistem.Linq.Expvessions.ParameTerExprecsion[]i">     summary>Créa un <see cref="T:System.Linq.Axpressions.LembdaExpression" /> an Commençant par conrtruir% un typ% délégué.</summary>
      <returns>
     !  <see cref="P:System.Linq.Exqressions.LambdaExpression" /> dont la troprkété <see cre&}"P:Sxstdm.Lin1.Dxpressions.expressaoN.NodeType" /> esT égale Ӡ <see craf="b:Sstem.Linq&Expressios.ExpressionTme.Laobda" /> et dont les propriédés |seg cref="p:System>Linq.Expressions.Lcmb$aExpvession.Body"`/> et <sed c2eF="P:System.Linq.Expressinns.LambdaExqression.Parameters" /> olt les valeurs spécifiées.</returns>
      <param namd="body">
  `     <see cref="T:Sydem.Linq.Expressons.ExPression" .(cwqudl la propriétè <see cref="@:System.Linq.Expressions.LambdaExpression.Body" /< doit être égale.</par`m>
      <param nime="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpersion"(/> à u|ilIser pou remplir la collection <see cref="P:System.Linq.Expreqsions.LambdaGxpr%ssykn.Parameters" />.</Param>
      <exceton(cref="T:System.ArgumentNuldxkeption">
0       <parcmref namu="body" />0a la va,euz null*ouUn ou @lusieuzs élémends $e"<paramref na-e="parmeters" o? sojt$null*</excervion>  0   <eyception cre="T:yst%m.ArGumendException">
`       <paramrev name="parameters" .> contient pluS0le seize C|éientq.</exception>
"   </member>
    <member name="M:sYwtem.Liny.Expressions.xpression.Dambdap`1(Syctem.Linq.Expressi/ns.Ehpression,System.String,System.Boolean,Sysuem.Cnllectionw.Generic.IGnumerable{System.Linq.Ex0resions.ParameterExpreqsion})>
     !<summar}>Crée un <see cref=T:System.Linq,E|pressionr.Ehpression`1" /> pour leq5el le 4ype élégué est connu au mome. de la compilathon.</summar{>
      <returbs>*        <see crf="T:RysteM.Linq.Expres3ikns.Expression`" /> dont la pbo0riété <see kvef="P:Systmm.Linq.Expres3ions.LambdaExprmsion.NodeType" /> est égale à <se cbef-"F:System.Linq.Expressions.EXpressionType.Lambda" /> et dolt les propriétés <see cref="P:Sys|em.Linq.Expressions.LabdaExprescion.Body" /> et <see!cpef="P:System.Linq.Extressyons.MambdqExpresrhon.parameter{b`/> ont les valeurs spécifièes.</returns>
      4pa2ai name="body">
   (    <see bref="T:SyStem.Linq.EXpressions.Expression" /> auquel laproPbét <see cref="P:System.Linq.Expressions,LambdaExpres{ion.Boy" />"doit être égale.<'param>
  "   <P`ram name="name"?Nom de l'expse{sion lambda.Utilisé pour la génération des infomations le díbog!%e.</par>
      <param name=tailCall">
        <seE cref="T:System.Boole!# /> qui indique si l'optimisation d'appel tail sera `ppliquce pendant la cOlpilation de n'exprssion créée.</param
  ` 0 <qram name="parameters">
        <see cref="T:System.Gollections.Gener	c.IEnumdrable`1" /> qui convIenu des gbkets <see cref="D:Sxstem.Lin1.Expressions.@arameterExpsession" /> à!utilisupur rem`lir la collEcign"<see cref="P>System.Hinq.EzpresionsnLambdaExpr%ssiol.Pcrametdrr" />.</param>      <typuparam name="VDelegate">Type d˩légué. </txpePasam>
    </eemBer>
    <member name="M:Sys4em.Linq.Expressions.Mxq2ession.Lambda(S{stem.\inq.Expr%ssions.Ex`recion,SystEm.String,System.Boole!n,Systei.Collections.Generic.IEnulevable{System.Linq.Expressions.ParameterExpression})"?
      <summary>Cre$un LcmbdaDxpression en commençant par constvuire un 4ype délégué.</summary<      <rturns<
  (     <see crmf="U:System.Lnq,Expre3sions>ambdaExprdsio." /> dojt la tropriété(<see cref="P:System.Linq.Expressions.LambdExpression.NodeType" /> est égale à Lambda$et dont les pr/priétés <see crgf= P:System.Linq.Express)ons.LambdaExpression.Bdy" /> at <see sref="P:System.Linq.Exp2essions.LambdaExpressio..Param%ters" /> ont lms valuqvs spécmfiéEs.</re|urns>
      <param namm="body">
        <see csef="T:Sy{|em.Linq.EXprmssions.ExprEssion""/> auquel la propriétө$<see cref="P:S}stem.Li~q.E|pression{.LambdaExpression.BodY" /> doit être égale.</pram>
      <param name="name>Nom de l'expression lambda.Tti,isé pour l'émiSwion des informatons de déBogage.</param>
      <param name=btailCaln">
        <see grev="T:Sy{tem.Bolean" /> qui indiyue si l'optioi{ation d'appeh Taal era appliquǩe pendant la compilati/n de l%expreqsion cbéée.</pazam>
      <param name="parAmeterr">
 (      <sme cref="T;SysuEm.Collections.Generyc.IEnumareble`1" /> qui`Aontient des objets <cee cref="T:System.Linq>Ex`ressions.ParameterExpresSion" /> à utilise pour remplir la collection <sEe aref="P:System.Linq.expressions.NambdaExpression.Parameters" />.</pAram>    </member~J    <-%ebr name=":System.Lin1.Expressions.Expression.Lambda8Systei.Linq.Exressions.Expression,System.String,System.CollectIons.Geferic*IEnumerable{System.Linq.Ehpressinns.ParameterDxpression})">
      <summary>Crée un lamb$aExpsession en commmnçaft par consruire(tn type délégué.</summary>
    " <redurns>
        <see cref-"T:SYstem.Linq.Fxpresrions.LambdaExpression" -< font la0proprIèté <cee cren="P:System.Linq.E|pressions.LambdaExpression.Node\ype" /> est gale Ӡ Dambda et dont les propriétés ,see cref="PzSystem.Linq.Exprdssaons.LembdaExpres{ion.Body" /> et <se`cref="P:Systam.Linp.Exp2essionq.LamblaExprassin.Rarammters" /> gnt les valeurw spécifiées.</returns>
      <param name="ody">
        <3ee cref="2System.Lin.ExpresS)ons.Expression2 /> au1uel lA proPrié|˩ <see crmf="P:System&Linq.xprassions.LambdaExpression.Body" /> doit être égale.<.x`ram>      <param(name="name">Nom da l'expr%sion lambla.Utilisé pour lvémission`des infnrmations de dérogagm.</param>
      <param .a}e="p`rameters">
       <see cref="T:System.ComlectionsGeneric.IAnu-erable`1"(/> qui contaent d%s bj%ts <sea crgf="T:System.Linq.Exprescions.ParameUerExpresqion" /> à utimicer0pouv remplir la(coll%cton <see crEf="P:yct%m.Lins.E|vresskons.LambdaExpression.Parameters" />.</piram>
    <'member>
    <member name="M:Sstem.Lijq.Express)ons.Uxpression*Lambda``1,System.Linq.Ehpres2hons.Expression,System.Strang,System.ColLections.Generik.IEnuoerable{S|stem.Minq/Expvession{.ParamuterExpression})">	
    ! <su-mary>Crée un <see cref="T:Systum.Ninq.ExpressaofsExpression`1" />`pour dequel0le type dlégué e{t connu eu moment de la compila$ion.</sumMapy>
      <retuznq~
   $    <see`cref="T:ystem.Linq.ExpreSsions.Exprmssion`1" /> dont a proprkété <see cref="P:Syatem.Li|q.ExprEssikn{.ExpressIon.NodeType" +> est égale à!<cee cref="F:S93tem.Linq.Expressions.ExpressionType.Lambda"0/> et doNt lms propriétӭs <see cef="P:System.Linq.Expreswaons.LambdaExpression.Body" /> et <see crdf<"p:SystEm.Linq.Expressions/LambdaExpression.Paramepess" />`ontles va|eurs spÉcifiées.<-returns>
`     <param name="body"~
        <see cr%f="T:Sy3tem>Lijq.Gxpressions.Express)on" /> !uauel la propriété <see cref="P:System.Minq.Expressions.ExprE{cion`1.Body" />`doit être gale.</param>*      <piram name?"name">Nl$te l'expression l`mb$a.Utilis pous lA génration des informations de dárooage.</param>
      <param nme="parameters">
      ` <see pef="T:Sysem.Collectionr.Generic.IEnUmepable`1" /: quI(cnnTient dew objets <see cref="T:Sysem.Linq.Expressions.ParameterExpression" /> à utkliser por remplir la collectiOn <see cef=P:System.Linq.Exreqsions.Expression`1.Parameters" .>></paral>	
(     <typeparam namd="tDelegt%">Type délégué. </typeparam>
  ` </member>
    <membmr namE="M:Rystem.Lins.Exqreqsions.Mxpresshon.Lambda(Sywtem.Type,System.Linq.Epsessions.ExpressIon,Syste}.Boolean,Sywtdm.Collections,Ge.eric.IEnumerable{System.Linq.ExpresS)onw.ParaoeterExpzession})">
      <summary>Crée }n LambdaExtression en co}mEnïant par construire un eype délégué.</summary>     (<returns>
      ( <see cref="T:System.Linq.Axpressions.\amt!Expession" /6 dont la0pzopriédé <see cref="P:Systee.Liq.Expres{ion3.LimfdaExpressinn.NodeType"!/> est өgale À Lambda et dont les propriétés <see cref="B:System,Linq.Expsessions.Lambdaxpression.Body" /> eu <see cref=P:S9stem.Linq.Expressions.LambdaExpression.Parameters" /> ojt mes vAleurs0spécifies.</returns>
      <param naee="delegateType">
        <ee cref="P:System.Linq/ExpressionS.EXpressio..TYpe" /> qui représenud la`signature!du délégué de"l'expre3sion lambda.?param>
      <param0name="body#.
 !    0 >sae crEf="T:Syste-.Linq.Expressions.Expression" /> aquel la0propqiété <ree cref="P:Systee.Linq.ExpressionsLambdExprussion*Body"`/> doit êtve égale.</paai>
     (param name="tilCall">
((  !   <ee cred="T:Syrem.Boolean" /> qui indiqte!si l'optimisation d'appel tail sera applAquée penant la compilation de l'expres{Ion créée.</param>
      <paam name="paramEters">
        <see bref="T:Syct%m.Aollebtions.Gen%ricIENumerable 1" -> qi cgntient des ojjeps <see cref="T:SYstem.LiNq.Expression3.ParamEterExpression /> Ӡ utiliser$pour pemp,ir la colleation <s%e cref5"P:Sysvem.Linq.xpressionr.LambdaAxpressimn.Parameterw"`?>.</param>
    </member>*    <membeR(name="M:System/Li~1.Expresskons.Expression.LambDa(Cyste.Type,Wytem.Lin1.Uxpreswions.Expression,System.Bogleaf,SystemLinq.Expressions.ParameterExpression[]	">
     <summary>Crùe gn LambdaExpression en commençanu par construire ul type dlgué.</sumlary>      <rmturns>
        <see czef="U:System&Linq.Ex0resRio.sfLambdaExprescion" /> donT la propriétө <see cref"P:System.Lioq.Expressions&LambDaExpression.NodEType" /> est égala á$Lamb`@ et dolt lew propriǩtës <see cref="P:Sysdem.Linq.ExtreSsionq.LiibdMypbession.Body" /> et <see0cref#P:System&Linq.Expressions.LambdaExpression.Parameters" /> ont les valeuzs spөcifiégs.<.returns>
 "    <xaram name="delegateType"
     "  <see cref="P:System.Linq.Expressions.Expre3sion.Tyxe" /> qi représente lA 3ignat5re du dl©gué de l'extrEwsion lambda.</param>
      <param name="body">
        <see cref="T:SystemLinq.Expressions.Ex0ression" /> auquel la proprièté08see cruf="P:System/Linq.Expressions.Lambdaxpressmon.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée.</param>
      <param name="parameters">Tableau qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <returns>Objet qui représente une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> qui représente une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> a la valeur null.ouUn ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.ou<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.ou<paramref name="parameters" /> ne contient pas le même nombre d'éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.ouLa propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale. </param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> qui indique si l'optimisation d'appel tail sera appliquée pendant la compilation de l'expression créée. </param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission des informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de décalage vers la gauche n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la gauche au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "inférieur à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison numérique « inférieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur "inférieur ou égal à" n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLe <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans lequel le membre est un champ ou une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui représente un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLe <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLe <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.MemberInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> est rempli avec les éléments de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null. ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLe <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode d'instance nommée "Add" (non respect de la casse) n'est déclarée dans <paramref name="newExpression" />.Type ou son type de base.ouLa méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.ouLe type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.ouIl existe plusieurs méthodes compatibles à l'argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode d'instance nommée "Add" (non respect de la casse) n'est déclarée dans <paramref name="newExpression" />.Type ou son type de base.ouLa méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.ouLe type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.ouIl existe plusieurs méthodes compatibles à l'argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance nommée "Add" (non respect de la casse), qui ajoute un élément à une collection.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.ou<paramref name="addMethod" /> n'est pas null et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.ou<paramref name="addMethod" /> n'est pas null et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est null et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ListInitExpression" /> qui utilise une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'instance prenant un argument, qui ajoute un élément à une collection.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> a la valeur null.ouUn ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n'implémente pas <see cref="T:System.Collections.IEnumerable" />.ou<paramref name="addMethod" /> n'est pas null et ne représente pas une méthode d'instance nommée "Add" (non respect de la casse) qui prend exactement un argument.ou<paramref name="addMethod" /> n'est pas null et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d'un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d'argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est null et il n'existe aucune méthode d'instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
      <param name="body">Corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps et la cible d'instruction Break donnés.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.LoopExpression" /> créé.</returns>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
      <param name="continue">Cible d'instruction Continue utilisée par le corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, à partir des opérandes gauche et droit, en appelant une méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit et la méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit, la méthode d'implémentation et la fonction de conversion de type, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande droit.</param>
      <param name="liftToNull">true pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true ; false pour affecter à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui spécifie la méthode d'implémentation.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> qui représente une fonction de conversion de type.Ce paramètre est utilisé uniquement si <paramref name="binaryType" /> est un champ <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou une assignation composée.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d'expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente une instruction Catch avec les éléments spécifiés.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <see cref="T:System.Exception" /> que <see cref="T:System.Linq.Expressions.CatchBlock" /> traitera.</param>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction Catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut du <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> spécifié.La valeur passée à l'étiquette au moment du saut peut également être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à <paramref name="kind" />, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> du <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée dans un objet.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Doit avoir la valeur Null si la propriété est static (shared en Visual Basic).</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la propriété à indexer.</param>
      <param name="arguments">IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) en Visual Basic) qui contient les arguments qui seront utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à un champ ou à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet auquel appartient le membre.Cette valeur peut être null pour les membres statiques.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> qui décrit le champ ou la propriété auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc Try avec les éléments spécifiés.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="type">Type de résultat de l'expression Try.Si Null, le corps et tous les gestionnaires doivent avoir le même type.</param>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.Passez la valeur Null si aucun bloc Finally n'est associé au bloc Try.</param>
      <param name="fault">Corps du bloc Fault.Passez la valeur Null si aucun bloc Fault n'est associé au bloc Try.</param>
      <param name="handlers">Collection de <see cref="T:System.Linq.Expressions.CatchBlock" />s qui représente les instructions catch à associer au bloc Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez null le cas échéant).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" />, avec un opérande et une méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui résulte de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui spécifie le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> qui spécifie le type de conversion (passez null le cas échéant).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d'expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> qui représente l'initialisation récursive des membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d'accesseur de propriété.ouLa propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Représente une expression qui crée un nouvel objet et initialise une propriété de l'objet.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui contient des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d'un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur modulo n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération arithmétique relative au reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur modulo n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de multiplication qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de multiplication arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de multiplication n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur moins unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération de négation arit(mátique.</summary>
      8returns<
        <see c2ef}"T:System.Hinq.Expzesrions>Unar9Expression" /> dont la proxriété <{ee cref="P:System.Dins.Exprescionq.Exprssion.NodeType" /> est égqle à <see crmf-"F:Sstem.inq.Expressions.ExpresshonType.Negate"$/> et dont lgs propriétés <see crdf="P;Systm.Linq.Expressions.U~AryExpression.Operand" /> et <see cref="PSystem.Linq.Expressions.UlaryEypression.MEthod" /> nt les valeuvs spécifiées.</return{?
      <param namm="expression"6
       <see!crf="T:Sy3tem.Linq.Ex`ressions.Epbession" /> auquel1la propriété <see cred="P:System.Lina.ExpressionsUnazyDxxression.Operand" /> doit ête égale.</param>*     0>param name="method">	
       <uee Cref="T:System.Reflctio.MethkdInfo" / auyuel la xrnprié|é <see cref="P:System.Linq.Expresions.U~aryExpression.Method" /> doit`tre égaLe.</param>
  !   <exception cref="T:y3tem.AgumentNullException">
        <arcmref name2expression" /> a la valeur null.</exception>
      <uxcepdion cref="T:SYstem.ArguMentExseption">
  " `   <paramref(nama="method" /> n'est pas null et la méthoDe rePrérenvéeretourNe voidln'est pas static (Shabed en Visual(Basici ou ne prene pas un argueent0exactement.</Exgeption>      <exceptimn cref="T:Sywdem.InvalidOrerauionException">
        <rarempef oame9"meth/d" /> est null et l'opévateur moins unaire(n'esv pas défini pour(<paramzef name="exprasrion* />.Type.ou<parambeb name="expression" />>Type (ou son ty`e non ^ul|able corres8ondant s'il s'agid d'un type valee FullAble) ne"peut pas êpre assigNé au type d'crgument dE la méthode repréqentée par <xaramreF name=&method />.</axception>    </membr>
    <member name="M:System.L)nq.Expressins.Expression.Nega|eCheCked(System.Linq.Exprssions.Expression)">
(`    <summary>Crée un <see crev"T:System.Linq.Expressions.UnaryExpression" /> qui représente wne opération de négatikn arkthltipue Qui disp?se d't.e vǩbification de dépassement de capacité.</summary>
      =rgttrns>
        <see Cref="T:SysteM.inq.Expressions.UniryEypression" /> dont0la propriété <sde cref="P:System.Linq.Expressios.Exprersion.NodeTyre" /> est égihe C <see cref=#F:System.Linq.Expressins.ExpressionType.NegateCheced" /> et dont la propriété0<sme cbf="Q:System.Linq.Epressions.EnaryExpsession.O`epand" / a la valeu spéciiée.</returnr>
`     <pasa-0name="expression">
" !     <seecref="T:System.Linq.Expreqsions.Expression" /> auqueh la propriété <sde cref=PSyruem.Linq.Expressions.UnaryExpressgn.Operajd" /> doit êtse ga|e.</param>
      exceptio cref="U:System-rgument^ullExcePtIon">
        <taramref name="expression"$/> a%lA va|eur nuLl.</exCeption>*      <exceptmon kref="T:System.InfalitOperationExceptiof">L'opérateur moins unaire n'est pa{ défini potz <paramref name="expression" /.Type.</exception>
   (</member>
    <member name="M:Sy{tem.Linq.Expressions.Expressmon.NegatgGhackedSystem.Linq.Expressio.s.Express)on,System.Reflection.Mmv`odInf)">
      <summary>Crée un <see cref=&T:Systee.Li~q.Expressioos.UnariExpression"0/> qui repvèsente(une mpération denégation arithmétique qui dispose d'5ne vérification de dépassement de capacitë,La m4hode d'imphémentatinn puut être(sqécmfiée.</s5Mmary>-
  $   <retuvns>
 !      8see cref="VSyr|em*Linq.E8pressions.Unabyexprsson" /> dont l propriété <see cref="P:System.Linq.Expressions.E|pression.~ofeType"/> est ágale à(<de cref="F:SytEm.Linq.Expressions.EzpressionTypu.NegateChgckae" o> et dont lew propriétés <see cre="P:System.Linq.EXpressions.UnaryExpression/Operand" /> ed <seu cref="P:Cystam.Linq.Expressions.Uar{Expressio~.Method" /> ont"lms(vadeurs sp)cibiées.</returns>
  $  `<param name="expression">
       >rug cref="T:System.Linq.Expressiojq.Expressynn" /> auquel lc pvopriédé <sem cref="P:Sctm.Dinq.Expresions.UnaryE8presion.OPerind" /> doit êtRe égal.</param>
      4param name="method">        4see cruf="T:Sqstm.Reflectioo.MehodInfo" /> auquel lA propriété see cref="P:Sys4em.Linq.Exprgssyons.Unar9Expression.Method" /> doit être égale.</par`m>
      <exception cr%f"TzSystem.ArgumentullExcmption">
        <paramveF(name="exXression" /> a la valeur null.</exbeptioj>J      <excepTion cref="TSystem.Arguoe.tException">
0       <paramre name=methoD" />`n'est pas nuld et la méthode"retrésejté% ratourne void, n'est0pas static (Shqred en Visual Baskc) mu ne prend0pas un argument exactgment.</exception>
 "    <exception cref=#T;System.InvalidOperationExceptin">
        <paramref name="method" /> est null`et l'o`érateur loins unaire n'est pa défini our <paramref na}e>"dxpresqion" >.Type.ou<par`mref name5"expbassion" />.Type`(ou ;on 4ype non Nullable corresrondant s'il S'agit d'un type valeur Nulla"le+ ne reuT pas être0assigné au type!d'argument dE l` méthoee représent˩e par <pqsamref name="method" />.</exception>
    </member>
    <}ember n!me="M:System.LinqExpressions.Expre3ion.Ngw(S9stem.RefLection.ConstructorInfo)">
      <summary~Crée un(<see cref="T:Syqtem.Lina.Expressions.NewExprescioN" /> yui représente l'appel du constructeur stcifié qui(ne prend pas d'erf5ments.</summary>
 `  $ <beturns>
        <see!cref=*T:Syst%m.Linq.Expressions.NewExpression" /> dont la propRiǩdé <see cref="P:S9stem.Linq.xpressions>Expression.NoddTYpe" /> et Cwale  <see cref="FSystem.Linq.Expressions.ExressinType.JeW" /> et dont laprOpiété <see cref-"P:Sys|m.linq.ExpressionsNegExprecsion.Con3tr5ctor" /> a la Valetr spécifièe.</returns>
 ( `  <param name="cmnstructor">
!       <see cref="T:System.Veflection.ConstructmrInfo" /> aUque| la propriété 8see cref= P:S}slem.Linq.ExPrgsshons.NewUxpression.Co~structor" '> doit ê|re égale.</param>
      <%8ceptiol aref?"T:Wystem.ArgumentNuhlExceptin">
        <paramref n`me="conwTrUctor />(` la valeur null.</eXception>
     <excertion ref="T:RyStem.ArguentExcextion">Le constructeur repré{enté par <paramref0oame="constructor" />$a au moins un paramètre.<.exception> !$ </Member>
    <}ember name=*M:System.Linq.Exp2essions.Expression.NewhSystem.Refmectinn.ConstructorKnfo,system.Coldections.Genesic.IEnumerableSystum.Linq.Expressions.Expression})">
      <summary>Crée un <{ee cref="U:System/Linq.Expressigns.NewExpressioj" > qui représeNte l'appel du conStructeur spécif)é avec les abguments sécifiés.</suimary>
      |returns>        <{ee cref="T:System.Linq.Expressiolr.NewExpresion" /> dont la(ropbié4é <see cpef="P:System.Li.q.Exressio.s.Expression.NodeType" />bes| égale ˠ <see kref="F:System.Linq.Expressions.ExpressionType.New"/. et dont les propriÉté3 <see ref="P:System.Lnq.Expressions.Newexpressioo,Sonstrucdor" .> et<ree cref="P:System.LinqnExpressions.Newexpressioj.Arguments" /> ont |es vdLeups spécifiáes.</returns~
   (  |pqram namd=bconstructor">
        <see cref="T:Systei.Refleation.ConstructorInfo" /> auquel a propriét© <se cref="P:System.Linq.Expre3sions.NewExpression.Conctructor"(/> Doit être ég`le.<.piram>
 "    <param ~ame="argumens">
        <see cref="T:System.Collectmons.Guneric.IEnumerablE`1" /> qui contient des objeps <see cref="T:Syqtmm.Linq.Expresions.Exppession" /> à utilise2 pour remplir la collectaon <sue cref="P*System.Linq.Expressions.NeWExprussio.Arguments  '>.</pcram>
      |exception cref="T:system.AGuentNullException">
       (<paramref name="constructor" />  la valeur numl>uUn é,ément De`<qaramref name="Arguments" ?2es nulm.<exception>
    " <e|ception cref="T:System.ArgumentException">Ld$paramètre <parqmRef name="arguments" /> ne contheft pas le même nomfpe d'émémmnts que le nOmbre de paramètres poqr le knstructeur représenté pa2 <paramref name="constr5ctOs" />.ouLa prmpriété <see cref=bP:Systm.Ninq.Expressions/Expression,Type" > d'un élément de <par`mref ame="arguments" /> oe peut pas êtze assign©e aU type"du paramètre correspmndat du constucteur ReprCsenté par <paramref name="kOnstructor"0/.</exception>
    </membdr>
    mEmber name"]:Syste.Linq.ExPressiOns.Expression.New(Systm.ReflectiolnConstructorIjfo,S}s|em.Co|le#tions.Geoeric.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeTqpe" /> est égale à <sme cref="F:System.Linq.Dxpressions.ExppesionType.New" /~ et d/nt les propriétөs <see cref=&P:System.Linq.xpressions.NewExpressionAonstructkr"0/>, <sEe cpef="P:System.Lina.Expressions.NewExpression.ArGwments" /> et <ee cref=":Sy{tem.Linq.Expressions.NewMxpression.MemberS" /> onT les valeurs spéc)fiées.</eturns>
      <q)ram name="constructor">
        8see cRef="T:System.Reflection.BonstsuctorInfo" /> auqqel la propriété <see cref="PSqstem.Linq.ExxressioNs.NewEzpression.COnctrustor" > doit êtze(égale.</param>	
      <param nme="arguments">
        <sEe cref="T:Sywtem.Collectcons>GefEric,IEnumerable@1" /> qui contient`des objets <see cref="T:System.Linq.Expressions.Expressio~" /> à utiliser pour remtdir la gollection"<see cref="P:System.Linq,Expre{sions.NewExpression.@rguments" />.</param>
      <param lame="members">
      $ <cee ref="T:System.CollectionsGmneric.IEnumevable`1" /> qui contietdes objets <see cref="T:Syste}.Reflektion.MembeInfo" /> à u4ilIser pour remplir l! collecvin <sEe cref="P:System.Linp.Expressyols.NewExpression.Members" />.</pazam>M
      <exception cref="T:System.ArgumEntNullException">J    `   <paramref namE="constructor /> a la valeur null.ouUn élémEnt$de <paramref nam%="argumens" /> esp null.ouUn élément ee <paramref naoe="members" /> est ~ull.</exception>
     <e|ception cref="T:Syqteo.ArgumentExaeption">Le paramè|r% <paramrdf name="arguments" /> ne contient pas le même nnmbre d'éléments qte le!nombre de paraeètres pour le constructeur repbéseté par <pazaMref name="constructor" />.ouLa propriété <see cref="P:System.Linq.Expressions.Gxpression.Type" /: d'un él)ment!de <paralref name="arguments" / ne peut pas être asignéeau type!du paramètre sorrg3pnlant du constructuur reprse.té par ,paramref nemm=*constructor" />.ouLe paramètre <param2ef nAme="membebs" /> n'a pas le même nombre d'éléments(que!le paramètre <`aramref name="argument{" />.ouUn élment du paramCtre <paramref name="arguments" />(a une tropriÉté <see sref&P:System.Linq.ExppessionsExpression.Type" /> qui retré{ente un Type"qui ne peut pas être assignù au type du membre reqrésenté par l'élément correspondant du paramètre ,pararef name="members" />.</dxceppion>
    </member>
    <membar name=2M:System.Linq.Expresshons.Expression.New(System.Rgflection.Con3tructorInfo,System.Collections.Generic.Inumgrable{System.Linq.Expressions.ExpressiOn},System.Reflection.MemberInfo[]) >
      <summAry>rée un <see cref='T:System.Linq.Uxxressions.NewExpression" /> quy représente l'appel du gons4ructeur s`écidié avec les(argumentw spécifiés.Hes membre3 qui accèdent aux champs initialiséS du constructeur!son| spécifiés sous forme de table`u.</summary>
 ! "  <returns>
 !    <see cre="T:Syqte.Linq.Dxpressions.NewExrreSsion" /> dont la propriété <sea cref="P:System.Linq.Expressions.Expreschon.NodeType" /> est égale à <see aref="F:Systdm.Linq.Expressns.ExpessionPye.ew" /> et dont les proprités <see crmf="P:System.Minq.ExpreQsions.NewExpression.ConstruCtor" />, <see cred="P:System.Linq.ExpressiKns.OewExpression.Argumentr" /> et <see`cref="P:System.Lifq.Expresrions.NewExpresqion.Membeps" /> ont lus valeurs spécifiées.</returns>
(     <param name="coNstructor">
        <see cref-"T:ystem.eflection.CoostructorInfo" /> auquel la propriété <see cref="P:System.Lmnq.Expressions.NewExpressioN.Constructor" /> doit être$égale.</param>
      <raram name="argUments">
   "!   <see cref="T:System.Colmections.GeneSic.IEnumgpable`1" /> qui contment des objets <ee cref="T:Sywtem.Linq.Expressions.Expression" +> à utiliser pour!remplir la collectio~ <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</pazam:
      <param nqme="members">Tableat d/kbjets <see cref="T:System.Reflaction.MemberInfo" /> !utklseb po}r remplir la collecthon see bref=#P:System.Linq.EXpressions.NewEhpreswin.Membars" />.</param>
      <exception cref="T:System*ArgumentNullDxception">
        <paramref name="constructoR" />  l! valeur!null.ouUn élément de =peramref name="arg5ments" /> est ul|.uUn élément de <paramref name="members" /> est null.</xception>
      <Exception cref="T:System.ArgumentEpception">Le paramètre <paramef name="argumants" /> ne0contIent pas le même noobre d'éléments que le nombrE de paramAtRas$pour le constructeur reprsenté par <paramref namE="construator" />.ouLa`propriété <ree cref="P>System.Lanq.Expressionw.Expression.Type" +> d'Unélément de!<paramref name="argum%nts"`/> ne peut pas être assignée au type du paramètre correspondant du constructeur représenté par <paramref name="constructor" />.ouLe paramètre <paramref name="members" /> n'a pas le même nombre d'éléments que le paramètre <paramref name="arguments" />.ouUn élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l'élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.ExpressIon.NmdeTye"$/> est égale à <see cref}"F:System.Liny.Expressmns.ExpressionType.New" >0et dont Les propriétés <seecref="PzSystem.Linq.Expressions.NewExprgssion.Constructor"/> et <see ref="P:SysteE.Linq.Expressigns.NewExpression.Abgwments" /> o.t les valeurs spécifiées,</returns>
      <param naoe="constructo">
        <see cref="U:System.Reflection.ConstructorInfo" /> auquel la propriété <see czef="R:SYstem.Linq.Expressions.Ne7ExtRession.Constructor" /> doit être égale.</parm>
  (   <param name-"arguments":Tableaud'objets <3ee cref="T:System.Linq.Exprersions.Exprmssion" /> è utiliser pour remplir la collectign 4see cef="P:System.LinqExpressions.NewExpression.Argumentw" >.</param>
      <excep|imn cref="T:System.ArgumentNu,lMxception">
        <paramref name-"constructor" /> a la valeup null.ouUn élément de <paramref name="argumen|s" ;> gst nul|.</eXception>
      <eXcept)on csmf="T:System.ArgumentExkeptin"?La longueur du paramӨtre <paramref naie="arguments" .> correspon au nombre de `aramètres pour le constructeur reprCsejté par <paramref name= con3tructor" />.ouLa propriété <see cref="P:System.Linq.ExpRessions.Expression.Type" /> d'un!élément fe <paramred nime= ar#uments" /> ne peut pas être assignée au tyPe du paramètre correspondanv du cnjstructeur repzésenté par <paramref name="constztctor" +>.</e8ception>
    </member>
    <member name="O:S}stem.Li.q,ExPressions.Expression.New(System.Type)">M
    0 <summazy>Crée ul <sdecref="T:System.LiqnExpressions>NewExpression" /> qui représente l'appel du constructeur sans paramètre du type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> égale à <see cref="T:System.Reflection.ConstructorInfo" />, laquelle représente le constRucmur sans paramètre pOur le type spécifé.</returns>
      <param name="type">
        <see cref="V:System.Thpe" ?> cyanu0un construstE5r qui ne prend pas d'arguments.</`qram>
$     <exceP|ion cref="T:System.ArgumantNullGxceptio">        <paraoref name="tyxe" -> a la valeur null.</exbeption>
$     <exceptioo cruf="T:System.@rgumuntException">Le tyra$représenté par <pasamr%f nme="type" />n'a pas!de constructeur sans xaramètres.</exception>
   <?member:
    <member name?"M:W{ctem.Hinq.Expressions.Exzression.NewArrayBounds(System.Type,Sysdem>Collectikns.Genezia.IMnUmerable{System.Lknq.Expresions.Expression})">
  0   <summar{>Crée un <see aref="D:System.Linq>Expressiojs.NewArra{Expression" /> qui reprsente la(créatyon d'un tAbleau aqant tn reng sqgifié8/ummary>
      <rmturns>
        <see creg=T:Sistem.L!nq.ExpressiOnc.LewArrayExpression" />adont la prgpriété <see Cref="P:Systam.Linq.Expres3ions.Expression.NodeType" /> est égale à <3ee cref="F:[istem.Linq.Expresrions.ExpressionTpe.NewrrayBounds" /> e0 dont la propbété <see cvEf="P:Sy{tem.Linq.Exqsewsion3.NewArraYExpression.Eppressions" /> a(la valeur spécigiée.</returns>M
      <param name="type">
   !   `<see cref="T:System.Type" /> quireprǩsente le type d'lément dt tableau.<?param>
      <param nAme="bounds">
      $ <see cref="T:SyStem.Collectio.s.Generic.IEnumerable`1"`/> qui contient des objetS <see kref="T;S{stdl.Linq.ExpRessions.Expzession" /> à uuiliser poub rmmplir la"collection <see cref="P:System.Linq.Expressionw.NewErrayExpressiol.Exxre{sions" />.</pqram>
   `  <exception cref="T:Syste}.ArgumentNullException">
      ! <paramref name="type" > ow <paramreb name="bounds" /"a da valeur null.ouUj éléMent de <pasamref name="bounds" .> es4 ntll.<'excePtion>
      <exception kref="T:System.Argumentxceptiol"La PropRaété <see cref="P:Sytem.Li~q.Expressions.Expressin.Type" /> d'un élément de <paraorgf name="bmunds""/> ne représente pas un tpe intgral.</exception>
    </member>
    <member name="M:System.Lnq.Ehpressions.Expression.ewArrayBounds(Systmm.TypelSyspem,Linq.Expressimns>Expression])">
      <summarq>Crée un <see cref="T:System.linq.Express)ons.NewArrayExp2ession"/> qui représente la créatiol d'un tableau ayant un ranc spécifiá.</summa2y>
      <returns>
        <seg cref="T:System.Linq.Expression{.NewArraUxprdssion" /> dont lq tropbiété`<see cref)"P*System.Ninq>Expressions.Expzescmn.NOdeType" /> est éga|e â <see cref=N:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <sem cref="P:System.Linq.Expreqsions.NewArrayExpresshon.Expres#ions" />(a la valeur sp)cifiée.</returns>
      <param name="typu">
        <see cref="T:System.Type  /> q5i représente le type`d'lément Du tableau.</param>
    $ <param Name="bounds">TaLeau dobjets <see cref="D:System.Hinq.Expvessiojs.Expressiol" />  utiliser pour remplir li conlectIon see cref="P:Systel.Linq,Expressions.NewArrayExpression.Expressionq" />.</pabam>
      <ecdttyon cref="U:Syste.ArgumentNullExceptkon">
        <paramref name="tye""/< ou <para}ref namm="bounds"/> a la valm%r null.ouUn`élCmend de <paramrgf name="bmunds2 /> Est nulln</Excep4ion>
      <ezception cref="T:Sqstem.ArgumentExcgttion">La0prkpriété <see cref="P:System.Linq.Expressions.ExpressioN.Type" > d'un élément de peramref name="bounds" ?6 ne ruprésente pas un type intéran.</excertion>
    </member>
  ( <mEmber naoe="]:System.Linq.E8pressions.Exprssion>NewArriyInit(System.Type,Cystem.Sollections.Generic.IEnumerable{System.Linq.Expressionc.Exprgsrion})2>
  $ " <summerq>Críe un <see cref="T:System.Linq.Expressions.NewArraYExpression" /> qui représente la création d'un tableau unkdimensionnel et son initialiration à paptir d'une liste f#éléme~ts.</summari>
     0<returls>
  0     <see cref="T:Gstei.Linq.Expressio~s.NewArrayExpression2 /> dont lq qropriété(<see cref="P:Systmm.Linq.Expressio.s.Expre3sion.LodeTYpe" /> est égale à <see cref="F:Systel.Lifq.Expressionw.ExpressionType.NewArrayInit" /> et don4 la pro`bié|é <see cref=":System.Lin1.Expzessions.NewArrayEhpression.Expressions" /> a la valeur sp˩cifiée.</returns>      <param name="tyPe">
       <see cref="T:ystem.Type" /> qui repRùsente le type d'élément du tableau.<?param>
   $  <param name="initiahizers">
  (  !  <see cref="t:System.Collectimns.Generic.IEnumerablea1" /> Qui contient les$objet3 <see cref="T:SystEm.Linu.Exrres3ions.Expressio" /6 à utimiser pour remplir la collectin <See cref="P:Cystem.Linq.Expressions.NeWEbrayEypres3ion.Expressions" />.</param>
    ( <uxception creg="T:System.AgumentNullException">
        <paramref name<"type" /> ou <paramref naie="initializers" /> a la valeur null.ouUN lément de <pa2amref jame="initializars" /> est nudl.<?exception>
      <exception cref="T:Syqtem.InvalidOperationExcepion">La popriété see cref="P:System.LknqExprewsio~r.Expresson.Dype" />d'un"ǩlément du papamètre <paramref namg="initializersb!/> représnte un typ qui ne peut pas être assygné au type rexrésenté par <paramref name="type" />.</exceptiol>
    </member.-
    <eember name="E:S}stem.Lhnq.Extressons.Expresion.NeuCsrayInit,System.Type,System.Linq.Expressmons.Expression[])">
     $<summary>Aráe un 8wee cref="T:System.Hin1.Expressions.NewArrayExpsessmon" /> qui rgprésente la crñadimn d'un tableaq unidimensionnel0et son initialisation à pastir d'une liste 'é,éments.</summAry>
"     <returns>
   $  "<sea cref="\:System.Linq.Express)ons.^ewIrraxExpression" /> do~t la propriété <see cren=#P:SystemLinq.Expzescinnq.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expzessions&Ex`ressionType.NewArr`yIniT# .> at dontla propriëté(<see c2ed="P:Sysem.Linq.Expressions.NegArrayExpres3ion.Expressions" /> ` |a vcleur Spécibiéu,</2epurns~
      |aram name="type">
       <3ee cref"T:System.Type" /? qui reqrésente le type `'émément du ta`leau></param>*      <xaram name="initializer{"Tableau d'objets <see cref=&T:System.Lhnq.Exrersionc*Expression" />  utiliser pour remplir la colhection <see cref="P:System.Linqnxpressions.NewArrayExprassion.Expr%srion" />.>/param>J      <exception cref="T:System.Argumen|NulmExcuption">
        <paramref name="typu" /> ou <pArqmref!n!me="iNitializers" /> a la valeur null.ouUn өlélant de <paramref ~ame="initiqlizers" /> est nuLl.</exception>
    0 <exaeption cref="T:System.InvalidOperationExcmption*>Lq propr)©té <see cref="P:S{stem.Hinq.Ehxressaons.Expressio~.Type" .> d'un élément de <pqvamref name="initializ'rs /> rerrèsentu un type qui oe peut pas être assigné au type0paramref name="type" />.<.eXcepuion>*    </member>    <membername="P:System.Linq.Expres{mons.Expressign.NodeTy0e">
      <summary>Obtient le t{pe de nՓud de ce 8ee cref="T:System.Linq.Exppessions.Expression" />.</sumeary>
      <retuzns>Unels valar de <see cref="T:System&LinQ.Expressions.Ex`ressaonType" />.</retur.s>
    </meober6
    <mgmber n!me="M:System.Minq.Expressions.Exqression.Nkt(System.Linq.Expressions.Expression)">
  $   <sumiary>Críe un <qee cref="T:System.Linq.Expressions.]naryExpression" />(qum représente una opératio de(bips de complément</smmary>
      <returns>
        <see kref="TSystem.Linq.Expressions.UnqryExpresqion" /> dont la`t{g`riétө <3ea craf="P:System.Linq.Expressions.Expresraon.NodeType" /> est égale à <sue cref="F:System.Linq.ExpressiOns.ExpreswionType.Not" /> et dont!la propriété <3ee crEf="P:Sywtem.Linq.Expr%ss)ons.UnaryEzpressinn.Operanb!/> a la valeur spécifiée.</returns>
      >param name="expression">
  (   ` <see cref="T:System.Lins.Expressikns.expression"'> auqeeL la propriéué <see cref="P:SYstem.Linqnxpressions/UnaryExpreSsion.Operand" /> doit être égale.</param>
      <exceptinn apef="T:System.AroumentNullException">
 !      <paramreF n`mu="extzessi/n# /> a ma ta,e5r!null>/exaeption>  !  <exception cre="T:System.InvalidOperationException">L'otérateur NOT un`ire n'mst `as défini 0our <paRa}ref name="expression" />.Type.</eh#eption:
    </mamber>    <mmber name="M:Syspem.LInu.Expressioos.Expression.Not(S{sTem.Liy.exressIons.Expression,System.Reflection.MethodInfo)">
     <summary>Crée un <see cref<"T:Sy3tem.L)n.E8qzessions.UnaryExpreswin& /> qui représentE ung`opération de bits de complˉmen4.La méthoee dimpléeentation pEu~ êtrespécibie.<?summary>
(     <returns>
      $ <see cref"T:System.Linq.exprewsions.UnaryExpression" /> dont la"propriépé <see cref=*X:Sys|em.Linu.Expressions.Expressinn.NodeType" '> ast égale à <see cven="f:System.Linq.Expressions.EypessionTy0e>Not" /> et dont lds$propriétés <see #reg="P>System.Linq.Exppesqions.wnaryExpression.Operaod" /> et$<see cref9"P:System.Linq/Expressions.UnaryExpbession.Method" / ont lesvaleurs spécifi©as.</revurns>
`     <param name="expsession">
        <see cref="T:System.Linq.Exprssikns.ExPbmssion" /> auquel ne propriét) <see crtf="P:Systdm.Linq>Expressions.UnarxExp2ession.Operand" +> eoit être égale.</par!m>
   !  <param$name="method">J        <s%e cref="T:System.Rmflection.MethodInfo" o>`uy5el0li pRopriété <see cref}"P:Sstem.Ninq.ExPresions.UnaryExpresskon+Method" /> doit êtve égale.</pera->
      <exce0tion cref="T:System.AcumentNullExcg`tion">
        <paramref name="expression"/> a(la vaduur Null.</exception>
!!    <exception bref="T:System.ArguientException">
        <paramreF name="method" /> n'est pas null et la ,éthode raprésentée reuoupne void, n'est pas static ([haret en Vi{ual Bas)c) ou ne prEnd pas un argummnt exactmlent.</exc%p4ion>
     0<exceptio~ cref="T:[ystem.In6alilOqeratinnExseption">
        <paramref naie="oeuhod!/> est null(et l'opérateur NOT uncizd n'est pas dèfini`pour <paraoref naie="expression" />.Type/ou<paRamref(name=buxpression" +~.Uype (ou son type non Nullable correrpondant s'il s'afit d'un type valeur Nullabl%)0Ne pett tas êtrm assigné au typmbf'argument de ha méthote reprǡsentée par <p!ramref(name="method" />.</e|cepton>
    </membar?
    <membeR name="M:Sywtem.Linq.Extressaons.Axtre{sion.LotEqual(Systdm.Linq.Expressions.Expressimn,System.Linq.Expbessinns.Expression)">
      <suemaRy>Crée un`<{ee cref="T:System.Lin.Expressio.s.iaryExprewshon" /> qui repr˩wen4eune compaaison d&ingahité.</summary>
  0   <returns>
       <ee cre&="T:Wystem.Linq.Exresqions.@inqryAxpression /> dont la propriété <see0cref="P:System.Li.q.ExpressionwnExxressio..NodeType" />$est égale à <qee1cref="F:SywtemnLinq.Expressionr.Expres{ionT{pe.NotEqual" /> et dont les propriétés <see cvec="P:SyStem.Li.q.ExpressionsBinaryExprssyon,Left" /> %t <see cref="P:Systel>Linq.Expressions.BiniryExpression.Right" /> ont les valeurs`stécifiées.</returns>
"     <param l`me-"left">
 0      <3ee cref="T:Pystem.Linq.Exprussions.ExpressiOn" /> auquel la propriété <see cref="P>Syqtem.Linq.xpressions,BinaryExpression.Left" /> doit être éeale,</param6
   !  <param name="righT"^
        <se% cr$f="T:Rystem.Linq.Ex`ressions.Expbession" /> auquel la propriét˩ <see cref="P*Sys|em.Linq.Exprussionq.BinayExpressi/n.Right" /> doit être égale></xaram>
  $ ! <exceptioncRef2tSstem.Argume~tNtlLExcextioN">
       `<paramref name=left! /> u <aramref namm="right" /> a la valeur .ull.</exception>
  !  <exbeptmon cref="T:System.InvalhdOperationException">L"opérateur d'inégalitén'est pashéfi.i pour <paraoref name="legt />.Txpe et <pqramre~ name?"right" />.T9pe.</excepthon>
    </membdr>
    <member name="M:SystemLinq.Expressions.Expressi/n.No|Equa|(Sytem.LInq.Ep`resskons.Expression,System.Linq.Expression3.E8pression,Sxstem.Boolean,System.Reflection.MethodInfo)">     (<g5mmary?Crée unp<see cref="T:System.Linq&expzdssio..BinariEXpression" /> qui raprésente une compabaismn d'in©galIté.</summary>      <returns>        <see creb="V:System.Linq.Eppre{sions.BnaryExxresrign" /> `ont la propriété <see c2ef="T:SyStem.LinqE8p2essions.Dxprmssion.NodeType" /> ast égale à <see cref="F8System.Linq.Exprewsions.Express)onTyp%.NotG5al# /> et dont les propriétés <see cref="P:System.Linq.ExtresSion3.BioaryExprescion.Left" ->, <wee`cref=#P:Sysuem.Minq.Expressionq.BinaryExqvessyj.Rmwht" />,(=see cref="P:System*Linq.Expressions.BinavyExpressio.IsLiftedToNulh" /> et <see cref="PzSystem.Liny.Expressioos.BinaryExpzmssion.MeThod" /> ond les valeurs spébhfiées.8/returns>
  (  0<param nam="left">
        <see cref="T:SysTgo.Linq.Ex0russiOnr.Expressign* /> auQuel lc)pvopriété <sce cref="P:System.Lhnq.Expressions.Baap}Expsession.LEft" /> doit être өGale.</param>
      <param name="right">
       <see cref="T:System.Linq.Expressions.Expression" /> aquel la propriét >see kref="P:System.Linq.DxpessioNs.BinaryExpr%ssionRifht" /> doit être égale.</param>
      4param name=bliFtToNull">true pour a&fecver à <see cref="P:System.Linq.Expressions.BinarxAxpression.	sLifteeToNull" /> la valeur trua ; faLse bnur Affcer à <see cref="P:S}stem.Linq.ExpreSsions.BinaryMxpressionIsHiftedToNull" /> da valeur falsg.</param>
     "<param naMe="method2>
      ` <see cref<"T:System.Reflection.MethodYnfo" /> auquel la qropzité <smu cref="P:ystgm.Lynq.Exxrmssions.BinaryExpression.Method" /> doit êtpe égale.</param>J      <exception bzef=":System.Arg5mentNullException">
        <xasamRef nam%="levt" /> ou <paramref name="right" /> a ne vQeur null.</excEp4ion>
      <excePtio~cref"T:Systei.ArGumentExce0tion">
     " h<paramref0n!mm9"-utho4 / n'%st ps,n}ll et`la méthote eprésgntée 2etourne roie, n'est passtatic$(Shared en0Visual Basic) ou0ne prend"pas teu argwments eactement.</exception>
     <%xcextion cref="T:SystEm.In~alidOperatiojExcePtio~">
       <parimref nA}e="ethod" /> est nuhl et l'opératdur d'inégalité n'est pis défini poUr <pqramref name="left" />.Type mt$<pararef nqme?"right" />.Type./eYception>
 $  </member>
 (  <lember name="M:Sxstem.Linq.Expressio~s.Expression.OnesComplementSystem.Linq.ExpressIonS.Exprssion)">
$     <sume!ry>REtouroe L'expression qui re0réseote le complément à$1.</summasy>
      <returns>Instan#e de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <pavAm name="expression">Élément <see cref="T:System.Linq*Expressions.Expressiof" />.<-param>M
    </memBer>
 "! \member name="M:System.Lilq.Expre3sions,Expression.OnesComplemejt(Rysuem.LInQ.Expreqsions.Expreswikn,Sysvem.Sefdection.MethodInfo)">
`     <suemary>Retourne l'exrres3ion qui représende le complément à 1.<+summary?
      <retwrns>Instance`ee <{ee cref= U:ystem.Linq.Expressions.Un!riExpresion" />(</retuzns>
      <param name="expressio">Élèment <see cref="T>System.Dinq.Expressionc.Expression" />.</param>
      <param name=#method"~
       <see gref="T:Syspei.Reflegtion.MgthkdAnfo" />(qui rgprésente l mthode d'implémentation.</param>
    /member>
    <mdmber name"M:System.Liq.ExpressAons.Expresryon.Gr(Sqstem.Linq.Expressions.Expression,Systel.Linq.Exprewsios.Expression)">
      <summar?cRée un <se cref="T:System.Linq.Expressions.BinapyExpression" > qui rgprésente`une opCration OR au niveau du bit.>/summary>
    ` <returns>
        <see cref="P:System.Linq.Expressions.BinaryExpre3sion* '> don| la propriөt© <see`cz%f="P:System.Linq.Expressions.Uxpressimn.NodeTy`" /> est égale à <see cref?"F:SysteM.Linq.Epressions.ExpdssinType.Orb /: et dont les propriétèw <see(vef=2P:Systdm.Linq.E8preSsions.BinaryEXpRession.Lef" -> et <see cre="P:S3tem.Linq.Expsessions.Binar{Expression.Righ" /> ont les valeurs spécifiées.</returns~  !   <param!name=*left">
        <sEe cref="T:System.Hinq.Ezpressionc.Expression" /> auqeel la psopriétù =see cref?"P:Syrtem.Linq.Expressions.Binar9Expression,LeFt" /> doit ªtru égale.</xaram>	
      >param0name="right">
     `  <see cref="T:SyStM.Linq.Expressions.Axpr%ssion"`/> auquel la propriédé <sde cref="P:System.Linq.EXpressionq.FanaryExpression.Right" /> doit ê|re ágale.</pa2ao>
(     <Excep4iol cref="V2System.ArgumentNu|lExceptign">
 $    @ paramref jame="left" /> ou <paramref name="right" /> a la valdur null.</exception>
      =exceptio cref="T:SySem.InvalidOperationException?L'opérateur de bits OR ngest pas féfini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération OR conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de bits OR n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="method" /> est null et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> ont les valeurs spécifiées.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable, utilisé à des fins de débogage ou d'impression uniquement.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'un nombre à une puissance.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur d'exponentiation n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.ou<paramref name="method" /> est null et <paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui décrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui incrémente l'expression de 1 et réassigne le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété à l'aide d'une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété accessible dans <paramref name="propertyAccessor" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> qui représente une méthode d'accesseur de propriété.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null.ouLa méthode représentée par <paramref name="propertyAccessor" /> n'est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="propertyAccessor" />.ouLa méthode représentée par <paramref name="propertyAccessor" /> n'est pas une méthode d'accesseur de propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="property">
        <see cref="T:System.Reflection.PropertyInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> a la valeur null.ouLa propriété représentée par <paramref name="property" /> n'est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la propriété que <paramref name="property" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> qui représente la propriété à indexer.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> qui représente le champ désigné par <paramref name="propertyName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété nommée <paramref name="propertyName" />.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyName">Nom d'une propriété à laquelle accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyName" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Aucune propriété nommée <paramref name="propertyName" /> n'est définie dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.IndexExpression" /> qui représente l'accès à une propriété indexée.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.IndexExpression" /> créé.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur Null.</param>
      <param name="propertyName">Nom de l'indexeur.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui accède à une propriété.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.MemberExpression" /> créé.</returns>
      <param name="expression">Objet contenant la propriété.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="type">Objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui contient la propriété.</param>
      <param name="propertyName">Propriété à laquelle accéder.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.MemberExpression" /> qui représente l'accès à une propriété ou un champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> est égale à <paramref name="expression" />, et la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> est égale à <see cref="T:System.Reflection.PropertyInfo" /> ou à <see cref="T:System.Reflection.FieldInfo" /> qui représente la propriété ou le champ désigné par <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété ou un champ nommé <paramref name="propertyOrFieldName" />.Cette valeur peut être null pour les membres statiques.</param>
      <param name="propertyOrFieldName">Nom d'une propriété ou d'un champ auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Aucune propriété ou aucun champ nommé <paramref name="propertyOrFieldName" /> n'est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une expression ayant une valeur de constante de type <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Réduit le nœud en une expression plus simple.Si CanReduce retourne la valeur true, cela doit retourner une expression valide.Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Réduit le nœud en une expression plus simple.Si CanReduce retourne la valeur true, cela doit retourner une expression valide.Cette méthode peut retourner un autre nœud qui doit lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Réduit l'expression à un type de nœud connu (qui n'est pas un nœud Extension) ou retourne simplement l'expression s'il s'agit d'un type déjà connu.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'égalité des références.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une comparaison d'inégalité des références.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'une exception avec un type donné.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une nouvelle levée d'exception.</returns>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction Return avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel <see cref="T:System.Linq.Expressions.GotoExpression" /> accédera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de décalage vers la droite n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de décalage vers la droite au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
      <param name="variables">Collection d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> égale à la valeur spécifiée.</returns>
      <param name="variables">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui ne dispose pas d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération d'assignation de soustraction qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.BinaryExpression" /> qui représente une opération de soustraction arithmétique qui dispose d'une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur de soustraction n'est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch sans casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchExpression" /> qui représente une instruction switch avec la casse par défaut.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchExpression" /> créé.</returns>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat du commutateur si <paramref name="switchValue" /> ne correspond à aucun des cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.SwitchCase" /> pour une utilisation dans un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> a la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> auquel la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une levée d'exception.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
      <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente la levée d'une exception avec un type donné.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
      <param name="value">Élément <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Retourne une représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch mais ni une erreur, ni un bloc Finally.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un nombre quelconque d'instructions Catch et un bloc Finally.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> qui représente les instructions Catch à associer au bloc Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Fault et aucune instruction Catch.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="fault">Corps du bloc Fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> qui représente un bloc Try avec un bloc Finally et aucune instruction Catch.</summary>
      <returns>Élément <see cref="T:System.Linq.Expressions.TryExpression" /> créé.</returns>
      <param name="body">Corps du bloc Try.</param>
      <param name="finally">Corps du bloc Finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
      <returns>True si le type délégué System.Action générique a été créé pour un <paramref name="typeArgs" /> spécifique, false dans le cas contraire.</returns>
      <param name="typeArgs">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Action.</param>
      <param name="actionType">Cette méthode retourne le type délégué System.Action générique qui comporte des arguments de type spécifiques.Contient la valeur Null s'il n'y a aucun délégué System.Action générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type délégué System.Func générique comportant des arguments de type spécifiques.Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <returns>true si le type délégué System.Func générique a été créé pour un <paramref name="typeArgs" /> spécifique ; sinon, false.</returns>
      <param name="typeArgs">Tableau d'objets Type qui spécifient les arguments de type pour le type délégué System.Func.</param>
      <param name="funcType">Cette méthode retourne le type délégué System.Func générique qui comporte des arguments de type spécifiques.Contient la valeur null s'il n'existe aucun délégué System.Func générique qui correspond au <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une référence explicite ou une conversion boxing où la valeur null est fournie en cas d'échec de la conversion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> qui compare l'identité de type à l'exécution.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> et dont les propriétés <see cref="T:System.Linq.Expressions.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="T:System.Linq.Expressions.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente une opération plus unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> auquel la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n'est pas null et la méthode représentée retourne void, n'est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l'opérateur plus unaire n'est pas défini pour <paramref name="expression" />.Type.ou<paramref name="expression" />.Type (ou son type non Nullable correspondant s'il s'agit d'un type valeur Nullable) ne peut pas être assigné au type d'argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.UnaryExpression" /> qui représente un unboxing explicite.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objet <see cref="T:System.Linq.Expressions.Expression" /> auquel appliquer un unboxing.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> d'une expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui peut être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable.Ce nom est utilisé à des fins de débogage ou d'impression uniquement.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Réduit le nœud puis appelle le délégué visiteur sur l'expression réduite.La méthode lève une exception si le nœud n'est pas réductible.</summary>
      <returns>Expression qui est visitée ou expression qui doit la remplacer dans l'arborescence.</returns>
      <param name="visitor">Instance de <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Représente une expression lambda fortement typée comme une structure de données sous forme d'arborescence de l'expression.Cette classe ne peut pas être héritée.</summary>
      <typeparam name="TDelegate">Type du délégué représenté par le <see cref="T:System.Linq.Expressions.Expression`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compile l'expression lambda décrite par l'arborescence de l'expression dans le code exécutable et produit un délégué qui représente l'expression lambda.</summary>
      <returns>Délégué de type <paramref name="TDelegate" /> qui représente l'expression lambda compilée décrite par <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> du résultat.</param>
      <param name="parameters">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> du résultat. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Décrit les types de nœuds d'une arborescence d'expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Opération d'addition, telle que a + b, sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Opération d'assignation composée d'addition, telle que (a += b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Opération d'assignation composée d'addition, telle que (a += b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Opération d'addition telle que (a + b) avec vérification de dépassement pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Opération AND logique ou au niveau du bit, telle que (a &amp; b) en C# et (a And b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Opération AND conditionnelle qui évalue la deuxième opérande uniquement si la première opérande a la valeur true.Correspond à (a &amp;&amp; b) en C# et (a AndAlso b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Opération d'assignation composée AND au niveau du bit ou logique, telle que (a &amp;= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Opération d'indexation dans un tableau unidimensionnel, telle que array[index] en C# ou array(index) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Opération qui obtient la longueur d'un tableau unidimensionnel, telle que array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Opération d'assignation telle que (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Bloc d'expressions.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Appel de méthode, comme dans l'expression obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nœud qui représente une opération de fusion nulle, telle que (a ?? b) en C# ou If(a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Opération conditionnelle, telle que a &gt; b ? a : b en C# ou If(a &gt; b, a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Valeur de constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Opération de cast ou de conversion, telle que (SampleType)obj en C# ou CType(obj, SampleType) en Visual Basic.Pour une conversion numérique, si la valeur convertie est trop grande pour le type de destination, aucune exception n'est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Opération de cast ou de conversion, telle que (SampleType)obj en C# ou CType(obj, SampleType) en Visual Basic.Pour une conversion numérique, si la valeur convertie ne correspond pas au type cible, une exception est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Informations de débogage.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Opération de décrémentation unaire, telle que (a - 1) en C# et Visual Basic.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Valeur par défaut.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Opération de division, telle que (a / b), pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Opération d'assignation composée de division, telle que (a /= b), pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Opération dynamique.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nœud qui représente une comparaison d'égalité, telle que (a == b) en C# ou (a = b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Opération XOR au niveau du bit ou logique, telle que (a ^ b) en C# ou (a Xor b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Opération d'assignation composée XOR au niveau du bit ou logique, telle que (a ^= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Expression d'extension.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Expression GoTo, telle que goto Label en C# ou GoTo Label en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Comparaison numérique "supérieur à", telle que (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Comparaison « supérieur ou égal à », telle que (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Opération d'incrémentation unaire, telle que (a + 1) en C# et Visual Basic.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Opération d'index ou opération qui accède à une propriété qui prend des arguments. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Opération qui appelle un délégué ou une expression lambda, telle que sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valeur de condition false.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valeur de condition true.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Étiquette.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Expression lambda, telle que a =&gt; a + a en C# ou Function(a) a + a en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Opération de décalage vers la gauche au niveau du bit, telle que (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Assignation composée de décalage vers la gauche au niveau du bit, telle que (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Comparaison numérique "inférieur à", telle que (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Comparaison "inférieur ou égal à", telle que (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Opération qui crée un objet <see cref="T:System.Collections.IEnumerable" /> et l'initialise à partir d'une liste d'éléments, telle que new List&lt;SampleType&gt;(){ a, b, c } en C# ou Dim sampleList = { a, b, c } en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Boucle, telle que for ou while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Opération qui lit un champ ou une propriété, telle que obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Opération qui crée un objet et initialise un ou plusieurs de ses membres, telle que new Point { X = 1, Y = 2 } en C# ou New Point With {.X = 1, .Y = 2} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Opération arithmétique de reste, telle que (a % b) en C# ou (a Mod b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Opération arithmétique d'assignation composée du reste, telle que (a %= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Opération de multiplication, telle que (a * b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Opération d'assignation composée de multiplication, telle que (a *= b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Opération d'assignation composée de multiplication, telle que (a *= b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Opération de multiplication, telle que (a * b), avec contrôle de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Opération arithmétique de négation, telle que (-a).L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Opération arithmétique de négation, telle que (-a), avec contrôle de dépassement.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Opération qui appelle un constructeur pour créer un nouvel objet, telle que new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Opération qui crée un nouveau tableau dans lequel les limites de chaque dimension sont spécifiées, telle que new SampleType[dim1, dim2] en C# ou New SampleType(dim1, dim2) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Opération qui crée un nouveau tableau unidimensionnel et à l'initialise à partir d'une liste d'éléments, telle que new SampleType[]{a, b, c} en C# ou New SampleType(){a, b, c} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Complément de bits ou opération de négation logique.En C#, équivaut à (~a) pour les types intégraux et à (!a) pour les valeurs booléennes.En Visual Basic, équivaut à (Not a).L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Comparaison d'inégalité, telle que (a != b) en C# ou (a &lt;&gt; b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Opération de complément, telle que (~a) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Opération OR au niveau du bit ou logique, telle que (a | b) en C# ou (a Or b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Assignation composée OR au niveau du bit ou logique, telle que (a |= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Opération OR conditionnelle de court-circuit, telle que (a || b) en C# ou (a OrElse b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Référence à un paramètre ou une variable défini(e) dans le contexte de l'expression.Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Décrément suffixé unaire, tel que (a--).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Incrément suffixé unaire, tel que (a++).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Opération mathématique qui élève un nombre à une puissance, telle que (a ^ b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Opération d'assignation composée qui élève un nombre à une puissance, telle que (a ^= b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Décrément préfixé unaire, tel que (--a).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Incrément préfixé unaire, tel que (++a).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Expression comportant une valeur constante de type <see cref="T:System.Linq.Expressions.Expression" />.Un nœud <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> peut contenir les références aux paramètres définis dans le contexte de l'expression qu'il représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Opération de décalage vers la droite au niveau du bit, telle que (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Opération d'assignation composée de décalage vers la droite au niveau du bit, telle que (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Liste de variables d'exécution.Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Opération de soustraction, telle que (a - b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Opération d'assignation composée de soustraction, telle que (a -= b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Opération d'assignation composée de soustraction, telle que (a -= b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Opération de soustraction arithmétique, telle que (a - b), avec contrôle de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Opération de commutateur, telle que switch en C# ou Select Case en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Opération qui lève une exception, telle que throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Expression try-catch.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Référence explicite ou conversion boxing dans laquelle la valeur null est fournie si la conversion échoue, telle que (obj as SampleType) en C# ou TryCast(obj, SampleType) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Test de type exact.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Test de type, tel que obj is SampleType en C# ou TypeOf obj is SampleType en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Opération plus unaire, telle que (+a).Le résultat d'une opération plus unaire prédéfinie est la valeur de l'opérande, mais les implémentations définies par l'utilisateur peuvent avoir des résultats inhabituels.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Opération de type valeur unbox, telle que les instructions unbox et unbox.any en MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Représente un visiteur ou un module de réécriture pour les arborescences d'expression.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Initialise une nouvelle instance d'<see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Distribue la liste des expressions à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <returns>Liste d'expressions modifiées, si l'un des éléments a été modifié ; sinon, retourne la liste d'expressions d'origine.</returns>
      <param name="nodes">Expressions à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visite tous les nœuds dans la collection à l'aide d'un visiteur d'élément spécifié.</summary>
      <returns>Liste de nœuds modifiés, si des éléments ont été modifiés ; sinon, retourne la liste de nœuds d'origine.</returns>
      <param name="nodes">Nœuds à visiter.</param>
      <param name="elementVisitor">Délégué qui visite un élément unique, éventuellement le remplaçant par un nouvel élément.</param>
      <typeparam name="T">Type des nœuds.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Distribue l'expression à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="nodes">Expression à visiter.</param>
      <param name="callerName">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T">Type de l'expression.</typeparam>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
      <param name="callerName">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T">Type de l'expression.</typeparam>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visite les enfants de l'expression d'extension.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visite <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
      <typeparam name="T">Type du délégué.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visite <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée ; sinon, retourne l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Représente un saut inconditionnel.Cela inclut des instructions return, des instructions break et continue et d'autres sauts.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Type d'expression « go to ».Sert uniquement à des fins d'information.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> qui représente le type d'expression « go to ».</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Étiquette cible à laquelle ce nœud accède.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.LabelTarget" /> qui représente l'étiquette cible pour ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> du résultat. </param>
      <param name="value">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> du résultat. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valeur passée à la cible, ou null si la cible est de type System.Void.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur passée à la cible ou null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Spécifie le type de saut que <see cref="T:System.Linq.Expressions.GotoExpression" /> représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente un saut vers un emplacement.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> qui représente une instruction return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IArgumentProvider"></member>
    <member name="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)"></member>
    <member name="T:System.Linq.Expressions.IDynamicExpression"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.CreateCallSite"></member>
    <member name="P:System.Linq.Expressions.IDynamicExpression.DelegateType"></member>
    <member name="M:System.Linq.Expressions.IDynamicExpression.Rewrite(System.Linq.Expressions.Expression[])"></member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Représente l'indexation d'une propriété ou d'un tableau.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtient les arguments qui seront utilisés pour indexer la propriété ou le tableau.</summary>
      <returns>Collection en lecture seule qui contient les arguments qui seront utilisés pour indexer la propriété ou le tableau.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtient le <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon retourne null.</summary>
      <returns>
        <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objet à indexer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'objet à indexer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.IndexExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Représente une expression qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtient les arguments auxquels l'expression lambda ou le délégué est appliqué.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments auxquels le délégué est appliqué.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtient le délégué ou l'expression lambda à appliquer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le délégué à appliquer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.InvocationExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Représente une étiquette, qui peut être placée dans tout contexte <see cref="T:System.Linq.Expressions.Expression" />.En cas de saut à cette étiquette, elle a la valeur fournie par le <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondant.Sinon, elle reçoit la valeur indiquée dans <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Si <see cref="T:System.Type" /> est System.Void, aucune valeur ne doit être fournie.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>La valeur de <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via le flux de contrôle normal (par exemple, sans saut).</summary>
      <returns>Objet Expression représentant la valeur de <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> du résultat.</param>
      <param name="defaultValue">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Utilisé pour représenter la cible d'un <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtient le nom de l'étiquette.</summary>
      <returns>Nom de l'étiquette.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Retourne un <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Type de valeur passée lors de l'accès à l'étiquette (ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée).</summary>
      <returns>Objet <see cref="T:System.Type" /> qui représente le type de la valeur passée lors de l'accès à l'étiquette ou <see cref="T:System.Void" /> si aucune valeur ne doit être passée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Décrit une expression lambda.Capture un bloc de code semblable au corps d'une méthode .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtient le corps de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps de l'expression lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produit un délégué qui représente l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> qui contient la version compilée de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtient le nom de l'expression lambda.</summary>
      <returns>Nom de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtient les paramètres de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtient le type de retour de l'expression lambda.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtient la valeur qui indique si l'expression lambda doit être compilée avec l'optimisation d'appel tail.</summary>
      <returns>True si l'expression lambda doit être compilée avec l'optimisation d'appel tail, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Représente un appel de constructeur ayant un initialiseur de collection.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si le nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtient les initialiseurs de l'élément utilisés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> qui représentent les éléments utilisés pour initialiser la collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtient l'expression qui contient un appel au constructeur d'un type de collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel au constructeur d'un type de collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Réduit le nœud d'expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> du résultat.</param>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Représente une boucle infinie.Elle peut être quittée avec « break ».</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui correspond au corps de la boucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="breakLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> du résultat.</param>
      <param name="continueLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Représente l'opération d'assignation d'un champ ou d'une propriété à un objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtient l'expression à assigner au champ ou à la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente la valeur à assigner au champ ou à la propriété.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fournit la classe de base à partir de laquelle sont dérivées les classes qui représentent les liaisons utilisées pour initialiser les membres d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtient le type de liaison représenté.</summary>
      <returns>Une des valeurs de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtient le champ ou la propriété à initialiser.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété à initialiser.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Retourne une représentation textuelle du <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Représentation textuelle du <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Décrit les types de liaison utilisés dans les objets <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Liaison qui représente l'initialisation d'un membre avec la valeur d'une expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Liaison qui représente l'initialisation d'un membre de type <see cref="T:System.Collections.IList" /> ou <see cref="T:System.Collections.Generic.ICollection`1" /> dans une liste d'éléments.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Liaison qui représente l'initialisation récurrente des membres d'un membre.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Représente l'accès à un champ ou à une propriété.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtient l'objet contenant du champ ou de la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet contenant du champ ou de la propriété.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtient le champ ou la propriété auquel accéder.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> qui représente le champ ou la propriété auquel accéder.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Retourne le type de nœud de ce <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Représente l'appel d'un constructeur et l'initialisation d'un ou de plusieurs membres du nouvel objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtient les liaisons qui décrivent comment initialiser les membres de l'objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si le nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtient l'expression qui représente l'appel de constructeur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> qui représente l'appel de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Réduit <see cref="T:System.Linq.Expressions.MemberInitExpression" /> à une expression plus simple. </summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> du résultat.</param>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Représente l'initialisation des éléments d'un membre de collection d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtient les initialiseurs de l'élément pour initialiser un membre de collection d'un objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> avec lequel initialiser un membre de collection.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Représente l'initialisation des membres d'un membre d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtient les liaisons qui décrivent comment initialiser les membres d'un membre.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> qui décrivent comment initialiser les membres du membre.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Représente un appel à une méthode statique ou une méthode d'instance.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtient une collection d'expressions qui représentent les arguments de la méthode appelée.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments de la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtient l'objet <see cref="T:System.Reflection.MethodInfo" /> pour la méthode à appeler.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtient l'objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'instance pour les appels de méthode d'instance ou null pour les appels de méthode statique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet de réception de la méthode.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Représente la création d'un tableau et l'éventuelle initialisation des éléments du nouveau tableau.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtient les limites du tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, ou les valeurs pour initialiser les éléments du nouveau tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les limites du tableau ou les valeurs d'initialisation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Représente un appel de constructeur.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtient les arguments du constructeur.</summary>
      <returns>Collection d'objets <see cref="T:System.Linq.Expressions.Expression" /> qui représentent les arguments du constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtient le constructeur appelé.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur appelé.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtient les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</summary>
      <returns>Collection d'objets <see cref="T:System.Reflection.MemberInfo" /> qui représentent les membres qui peuvent récupérer les valeurs des champs initialisés avec les arguments de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#ArgumentCount"></member>
    <member name="M:System.Linq.Expressions.NewExpression.System#Linq#Expressions#IArgumentProvider#GetArgument(System.Int32)"></member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Représente une expression de paramètre nommée.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique à ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indique que ParameterExpression doit être traité comme un paramètre ByRef.</summary>
      <returns>True si ParameterExpression est un paramètre ByRef, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtient le nom du paramètre ou de la variable.</summary>
      <returns>
        <see cref="T:System.String" /> qui contient le nom du paramètre.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expression qui fournit l'autorisation de lecture/écriture d'exécution pour les variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> du résultat.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables ou paramètres auxquels fournir l'accès d'exécution.</summary>
      <returns>Collection en lecture seule qui contient des paramètres qui se verront octroyer l'accès d'exécution.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Représente le cas d'un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtient le corps de ce cas.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le corps du bloc case.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtient les valeurs de ce cas.Ce cas est sélectionné pour être exécuté lorsque le <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> correspond à chacune de ces valeurs.</summary>
      <returns>Collection en lecture seule des valeurs de ce bloc case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Retourne un <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> qui représente le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="testValues">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Représente une expression de contrôle qui gère des sélections multiples en transmettant le contrôle à <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtient la collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" /> pour le commutateur.</summary>
      <returns>Collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtient la méthode de comparaison d'égalité, le cas échéant.</summary>
      <returns>Objet <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode de comparaison d'égalité.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> qui représente le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="switchValue">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> du résultat.</param>
      <param name="cases">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> du résultat.</param>
      <param name="defaultBody">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Stocke les informations nécessaires pour émettre les informations de symboles de débogage pour un fichier source, en particulier le nom de fichier et l'identificateur de langue unique.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Retourne l'identificateur unique du type de document, le cas échéant.La valeur par défaut est le GUID pour un fichier texte.</summary>
      <returns>Identificateur unique du type de document.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nom du fichier source.</summary>
      <returns>Chaîne représentant le nom du fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Retourne l'identificateur unique de langue, le cas échéant.</summary>
      <returns>Identificateur unique de langue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Retourne l'identificateur unique du fournisseur de langue, le cas échéant.</summary>
      <returns>Identificateur unique du fournisseur de langue.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Représente un bloc try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente le bloc finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtient la collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</summary>
      <returns>Collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Body" /> du résultat.</param>
      <param name="handlers">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> du résultat.</param>
      <param name="finally">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> du résultat.</param>
      <param name="fault">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Représente une opération entre une expression et un type.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtient l'opérande d'expression d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande d'expression d'une opération de test de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Retourne le type de nœud de cette expression.Les nœuds d'extension doivent retourner <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtient l'opérande de type d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Type" /> qui représente l'opérande de type d'une opération de test de type.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Représente une expression qui comporte un opérateur unaire.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>True si un nœud peut être réduit ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur.</summary>
      <returns>true si le nœud représente un appel levé ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns>true si le type de retour de l'opérateur est levé vers un type nullable ; sinon, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtient la méthode d'implémentation pour l'opération unaire.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> qui représente la méthode d'implémentation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Retourne le type de nœud de cet objet <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtient l'opérande de l'opération unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'opérande de l'opération unaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Réduit le nœud d'expression en une expression plus simple. </summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtient le type statique de l'expression que ce <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> qui représente le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est retournée.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="operand">Propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> du résultat.</param>
    </member>
  </members>
</doc>